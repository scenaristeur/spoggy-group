!function(n){var t={};function e(I){if(t[I])return t[I].exports;var g=t[I]={i:I,l:!1,exports:{}};return n[I].call(g.exports,g,g.exports,e),g.l=!0,g.exports}e.m=n,e.c=t,e.d=function(n,t,I){e.o(n,t)||Object.defineProperty(n,t,{enumerable:!0,get:I})},e.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},e.t=function(n,t){if(1&t&&(n=e(n)),8&t)return n;if(4&t&&"object"==typeof n&&n&&n.__esModule)return n;var I=Object.create(null);if(e.r(I),Object.defineProperty(I,"default",{enumerable:!0,value:n}),2&t&&"string"!=typeof n)for(var g in n)e.d(I,g,function(t){return n[t]}.bind(null,g));return I},e.n=function(n){var t=n&&n.__esModule?function(){return n.default}:function(){return n};return e.d(t,"a",t),t},e.o=function(n,t){return Object.prototype.hasOwnProperty.call(n,t)},e.p="",e(e.s=107)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval("var RDF  = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    XSD  = 'http://www.w3.org/2001/XMLSchema#',\n    SWAP = 'http://www.w3.org/2000/10/swap/';\n\n/* harmony default export */ __webpack_exports__[\"a\"] = ({\n  xsd: {\n    decimal: XSD + 'decimal',\n    boolean: XSD + 'boolean',\n    double:  XSD + 'double',\n    integer: XSD + 'integer',\n    string:  XSD + 'string',\n  },\n  rdf: {\n    type:       RDF + 'type',\n    nil:        RDF + 'nil',\n    first:      RDF + 'first',\n    rest:       RDF + 'rest',\n    langString: RDF + 'langString',\n  },\n  owl: {\n    sameAs: 'http://www.w3.org/2002/07/owl#sameAs',\n  },\n  r: {\n    forSome: SWAP + 'reify#forSome',\n    forAll:  SWAP + 'reify#forAll',\n  },\n  log: {\n    implies: SWAP + 'log#implies',\n  },\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbjMvc3JjL0lSSXMuanM/ZmY1ZSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsQ0FBQyxFQUFDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgUkRGICA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjJyxcbiAgICBYU0QgID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hIycsXG4gICAgU1dBUCA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwLzEwL3N3YXAvJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICB4c2Q6IHtcbiAgICBkZWNpbWFsOiBYU0QgKyAnZGVjaW1hbCcsXG4gICAgYm9vbGVhbjogWFNEICsgJ2Jvb2xlYW4nLFxuICAgIGRvdWJsZTogIFhTRCArICdkb3VibGUnLFxuICAgIGludGVnZXI6IFhTRCArICdpbnRlZ2VyJyxcbiAgICBzdHJpbmc6ICBYU0QgKyAnc3RyaW5nJyxcbiAgfSxcbiAgcmRmOiB7XG4gICAgdHlwZTogICAgICAgUkRGICsgJ3R5cGUnLFxuICAgIG5pbDogICAgICAgIFJERiArICduaWwnLFxuICAgIGZpcnN0OiAgICAgIFJERiArICdmaXJzdCcsXG4gICAgcmVzdDogICAgICAgUkRGICsgJ3Jlc3QnLFxuICAgIGxhbmdTdHJpbmc6IFJERiArICdsYW5nU3RyaW5nJyxcbiAgfSxcbiAgb3dsOiB7XG4gICAgc2FtZUFzOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMi8wNy9vd2wjc2FtZUFzJyxcbiAgfSxcbiAgcjoge1xuICAgIGZvclNvbWU6IFNXQVAgKyAncmVpZnkjZm9yU29tZScsXG4gICAgZm9yQWxsOiAgU1dBUCArICdyZWlmeSNmb3JBbGwnLFxuICB9LFxuICBsb2c6IHtcbiAgICBpbXBsaWVzOiBTV0FQICsgJ2xvZyNpbXBsaWVzJyxcbiAgfSxcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n")},function(module,exports,__webpack_require__){eval("var store = __webpack_require__(21)('wks');\nvar uid = __webpack_require__(23);\nvar Symbol = __webpack_require__(2).Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL193a3MuanM/MmI0YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsRUFBVztBQUMvQixVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHN0b3JlID0gcmVxdWlyZSgnLi9fc2hhcmVkJykoJ3drcycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4vX3VpZCcpO1xudmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpLlN5bWJvbDtcbnZhciBVU0VfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PSAnZnVuY3Rpb24nO1xuXG52YXIgJGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBzdG9yZVtuYW1lXSB8fCAoc3RvcmVbbmFtZV0gPVxuICAgIFVTRV9TWU1CT0wgJiYgU3ltYm9sW25hbWVdIHx8IChVU0VfU1lNQk9MID8gU3ltYm9sIDogdWlkKSgnU3ltYm9sLicgKyBuYW1lKSk7XG59O1xuXG4kZXhwb3J0cy5zdG9yZSA9IHN0b3JlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n")},function(module,exports){eval("// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19nbG9iYWwuanM/NzcyNiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDIiwiZmlsZSI6IjIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvODYjaXNzdWVjb21tZW50LTExNTc1OTAyOFxudmFyIGdsb2JhbCA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PSBNYXRoXG4gID8gd2luZG93IDogdHlwZW9mIHNlbGYgIT0gJ3VuZGVmaW5lZCcgJiYgc2VsZi5NYXRoID09IE1hdGggPyBzZWxmXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICA6IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5pZiAodHlwZW9mIF9fZyA9PSAnbnVtYmVyJykgX19nID0gZ2xvYmFsOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///2\n")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(24);\nvar createDesc = __webpack_require__(38);\nmodule.exports = __webpack_require__(13) ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oaWRlLmpzPzMyZTkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLEVBQWM7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMsRUFBa0I7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsRUFBZ0I7QUFDekM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZFAgPSByZXF1aXJlKCcuL19vYmplY3QtZHAnKTtcbnZhciBjcmVhdGVEZXNjID0gcmVxdWlyZSgnLi9fcHJvcGVydHktZGVzYycpO1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZFAuZihvYmplY3QsIGtleSwgY3JlYXRlRGVzYygxLCB2YWx1ZSkpO1xufSA6IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///3\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(12);\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hbi1vYmplY3QuanM/Y2I3YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9faXMtb2JqZWN0Jyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkgdGhyb3cgVHlwZUVycm9yKGl0ICsgJyBpcyBub3QgYW4gb2JqZWN0IScpO1xuICByZXR1cm4gaXQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///4\n")},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(20);\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(10));\nutil.inherits = __webpack_require__(7);\n/*</replacement>*/\n\nvar Readable = __webpack_require__(52);\nvar Writable = __webpack_require__(34);\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanM/ZDZkZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxFQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxFQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLENBQVU7QUFDbEM7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLEVBQW9CO0FBQzNDLGVBQWUsbUJBQU8sQ0FBQyxFQUFvQjs7QUFFM0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJmaWxlIjoiNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///5\n")},function(module,exports){eval('var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function("return this")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === "object") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it\'s\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzP2NkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDIiwiZmlsZSI6IjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///6\n')},function(module,exports){eval("if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      ctor.prototype = Object.create(superCtor.prototype, {\n        constructor: {\n          value: ctor,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      })\n    }\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    if (superCtor) {\n      ctor.super_ = superCtor\n      var TempCtor = function () {}\n      TempCtor.prototype = superCtor.prototype\n      ctor.prototype = new TempCtor()\n      ctor.prototype.constructor = ctor\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcz8zZmI1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNy5qcyIsInNvdXJjZXNDb250ZW50IjpbImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///7\n")},function(module,exports){eval("module.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);\n // Export a singleton instance of SolidAuthClient\n\nconst auth = new _solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n/* harmony default export */ __webpack_exports__[\"default\"] = (auth); // Bind methods to instance, so they can be invoked as regular functions\n// (e.g., to pass around the fetch function)\n\nObject.getOwnPropertyNames(_solid_auth_client__WEBPACK_IMPORTED_MODULE_0__[\"default\"].prototype).forEach(property => {\n  const value = auth[property];\n\n  if (typeof value === 'function') {\n    auth[property] = value.bind(auth);\n  }\n}); // Expose window.SolidAuthClient for backward compatibility\n\nif (typeof window !== 'undefined') {\n  if ('SolidAuthClient' in window) {\n    console.warn('Caution: multiple versions of solid-auth-client active.');\n  } else {\n    let warned = false;\n    Object.defineProperty(window, 'SolidAuthClient', {\n      enumerable: true,\n      get: () => {\n        if (!warned) {\n          warned = true;\n          console.warn('window.SolidAuthClient has been deprecated.');\n          console.warn('Please use window.solid.auth instead.');\n        }\n\n        return auth;\n      }\n    });\n  }\n}\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SolidAuthClient; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _authn_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4);\n/* harmony import */ var _popup__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(81);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global fetch */\n\n\n\n\n\n\n // Store the global fetch, so the user is free to override it\n\nconst globalFetch = fetch;\nclass SolidAuthClient extends events__WEBPACK_IMPORTED_MODULE_1___default.a {\n  constructor() {\n    super(...arguments);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_pendingSession\", void 0);\n  }\n\n  fetch(input, options) {\n    this.emit('request', Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"toUrlString\"])(input));\n    return Object(_authn_fetch__WEBPACK_IMPORTED_MODULE_2__[\"authnFetch\"])(Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])(), globalFetch, input, options);\n  }\n\n  login(idp, options) {\n    options = _objectSpread({}, defaultLoginOptions(Object(_url_util__WEBPACK_IMPORTED_MODULE_6__[\"currentUrlNoParams\"])()), {}, options);\n    return _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"login\"](idp, options);\n  }\n\n  async popupLogin(options) {\n    options = _objectSpread({}, defaultLoginOptions(), {}, options);\n\n    if (!/https?:/.test(options.popupUri)) {\n      options.popupUri = new URL(options.popupUri || '/.well-known/solid/login', window.location).toString();\n    }\n\n    if (!options.callbackUri) {\n      options.callbackUri = options.popupUri;\n    }\n\n    const popup = Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"openIdpPopup\"])(options.popupUri);\n    const session = await Object(_popup__WEBPACK_IMPORTED_MODULE_3__[\"obtainSession\"])(options.storage, popup, options);\n    this.emit('login', session);\n    this.emit('session', session);\n    return session;\n  }\n\n  async currentSession() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    // Try to obtain a stored or pending session\n    let session = this._pendingSession || (await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage)); // If none found, attempt to create a new session\n\n    if (!session) {\n      // Try to create a new OIDC session from stored tokens\n      try {\n        this._pendingSession = _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"currentSession\"](storage);\n        session = await this._pendingSession;\n      } catch (err) {\n        console.error(err);\n      } // Save the new session and emit session events\n\n\n      if (session) {\n        await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"saveSession\"])(storage)(session);\n        this.emit('login', session);\n        this.emit('session', session);\n      }\n\n      delete this._pendingSession;\n    }\n\n    return session;\n  }\n\n  async trackSession(callback) {\n    /* eslint-disable standard/no-callback-literal */\n    callback((await this.currentSession()));\n    this.on('session', callback);\n  }\n\n  stopTrackSession(callback) {\n    this.removeListener('session', callback);\n  }\n\n  async logout() {\n    let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])();\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"getSession\"])(storage);\n\n    if (session) {\n      try {\n        await _webid_oidc__WEBPACK_IMPORTED_MODULE_7__[\"logout\"](storage, globalFetch);\n        this.emit('logout');\n        this.emit('session', null);\n      } catch (err) {\n        console.warn('Error logging out:');\n        console.error(err);\n      }\n\n      await Object(_session__WEBPACK_IMPORTED_MODULE_4__[\"clearSession\"])(storage);\n    }\n  }\n\n}\n\nfunction defaultLoginOptions(url) {\n  return {\n    callbackUri: url ? url.split('#')[0] : '',\n    popupUri: '',\n    storage: Object(_storage__WEBPACK_IMPORTED_MODULE_5__[\"defaultStorage\"])()\n  };\n}\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports) {\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"authnFetch\", function() { return authnFetch; });\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);\n/* harmony import */ var isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(isomorphic_fetch__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n/* harmony import */ var _host__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(7);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(8);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(11);\n\n\n\n\n\nasync function authnFetch(storage, fetch, input, options) {\n  // If not authenticated, perform a regular fetch\n  const session = await Object(_session__WEBPACK_IMPORTED_MODULE_3__[\"getSession\"])(storage);\n\n  if (!session) {\n    return fetch(input, options);\n  } // If we know the server expects credentials, send them\n\n\n  if (await shouldShareCredentials(storage, input)) {\n    return Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n  } // If we don't know for sure, try a regular fetch first\n\n\n  let resp = await fetch(input, options); // If the server then requests credentials, send them\n\n  if (resp.status === 401) {\n    await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"updateHostFromResponse\"])(storage)(resp);\n\n    if (await shouldShareCredentials(storage, input)) {\n      resp = Object(_webid_oidc__WEBPACK_IMPORTED_MODULE_4__[\"fetchWithCredentials\"])(session, fetch, input, options);\n    }\n  }\n\n  return resp;\n}\n\nasync function shouldShareCredentials(storage, input) {\n  const requestHost = await Object(_host__WEBPACK_IMPORTED_MODULE_2__[\"getHost\"])(storage)(Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"toUrlString\"])(input));\n  return requestHost != null && requestHost.requiresAuth;\n}\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"fetch\"]; }());\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrl\", function() { return currentUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentUrlNoParams\", function() { return currentUrlNoParams; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"navigateTo\", function() { return navigateTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"originOf\", function() { return originOf; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toUrlString\", function() { return toUrlString; });\n/* eslint-env browser */\nfunction getLocation() {\n  return typeof window !== 'undefined' ? window.location : {\n    href: 'https://example.org/',\n    pathname: '/',\n    origin: 'example.org'\n  };\n}\n\nconst currentUrl = () => getLocation().href;\nconst currentUrlNoParams = () => getLocation().origin + getLocation().pathname;\nconst navigateTo = url => {\n  getLocation().href = url;\n};\nconst originOf = url => new URL(url).origin;\nconst toUrlString = url => {\n  if (typeof url !== 'string') {\n    url = 'url' in url ? url.url : url.toString();\n  }\n\n  return new URL(url, currentUrl()).toString();\n};\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getHost\", function() { return getHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveHost\", function() { return saveHost; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateHostFromResponse\", function() { return updateHostFromResponse; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _session__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(8);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9);\n/* harmony import */ var _webid_oidc__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(11);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* globalRequest, Response, URL */\n\n\n\nfunction getHost(storage) {\n  return async url => {\n    const {\n      host\n    } = new URL(url);\n    const session = await Object(_session__WEBPACK_IMPORTED_MODULE_1__[\"getSession\"])(storage);\n\n    if (session && host === new URL(session.idp).host) {\n      return {\n        url: host,\n        requiresAuth: true\n      };\n    }\n\n    const {\n      hosts\n    } = await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"getData\"])(storage);\n    return hosts && hosts[host];\n  };\n}\nfunction saveHost(storage) {\n  return async (_ref) => {\n    let {\n      url,\n      requiresAuth\n    } = _ref;\n    await Object(_storage__WEBPACK_IMPORTED_MODULE_2__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      hosts: _objectSpread({}, data.hosts, {\n        [url]: {\n          requiresAuth\n        }\n      })\n    }));\n  };\n}\nfunction updateHostFromResponse(storage) {\n  return async resp => {\n    if (_webid_oidc__WEBPACK_IMPORTED_MODULE_3__[\"requiresAuth\"](resp)) {\n      const {\n        host\n      } = new URL(resp.url);\n      await saveHost(storage)({\n        url: host,\n        requiresAuth: true\n      });\n    }\n  };\n}\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSession\", function() { return getSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"saveSession\", function() { return saveSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clearSession\", function() { return clearSession; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\nasync function getSession(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"getData\"])(storage);\n  return data.session || null;\n}\nfunction saveSession(storage) {\n  return async session => {\n    const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n      session\n    }));\n    return data.session;\n  };\n}\nasync function clearSession(storage) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_1__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    session: null\n  }));\n}\n\n/***/ }),\n/* 9 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NAMESPACE\", function() { return NAMESPACE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"defaultStorage\", function() { return defaultStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getData\", function() { return getData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"updateStorage\", function() { return updateStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"asyncStorage\", function() { return asyncStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"memStorage\", function() { return memStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ipcStorage\", function() { return ipcStorage; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n\nconst NAMESPACE = 'solid-auth-client';\nconst defaultStorage = () => {\n  const hasLocalStorage = typeof window !== 'undefined' && 'localStorage' in window;\n  return asyncStorage(hasLocalStorage ? window.localStorage : memStorage());\n};\n/**\n * Gets the deserialized stored data\n */\n\nasync function getData(store) {\n  let serialized;\n  let data;\n\n  try {\n    serialized = await store.getItem(NAMESPACE);\n    data = JSON.parse(serialized || '{}');\n  } catch (e) {\n    console.warn('Could not deserialize data:', serialized);\n    console.error(e);\n    data = {};\n  }\n\n  return data;\n}\n/**\n * Updates a Storage object without mutating its intermediate representation.\n */\n\nasync function updateStorage(store, update) {\n  const currentData = await getData(store);\n  const newData = update(currentData);\n  await store.setItem(NAMESPACE, JSON.stringify(newData));\n  return newData;\n}\n/**\n * Takes a synchronous storage interface and wraps it with an async interface.\n */\n\nfunction asyncStorage(storage) {\n  return {\n    getItem: key => {\n      return Promise.resolve(storage.getItem(key));\n    },\n    setItem: (key, val) => {\n      return Promise.resolve(storage.setItem(key, val));\n    },\n    removeItem: key => {\n      return Promise.resolve(storage.removeItem(key));\n    }\n  };\n}\nconst memStorage = () => {\n  const store = {};\n  return {\n    getItem: key => {\n      if (typeof store[key] === 'undefined') return null;\n      return store[key];\n    },\n    setItem: (key, val) => {\n      store[key] = val;\n    },\n    removeItem: key => {\n      delete store[key];\n    }\n  };\n};\nfunction ipcStorage(client) {\n  return {\n    getItem: key => client.request('storage/getItem', key),\n    setItem: (key, val) => client.request('storage/setItem', key, val),\n    removeItem: key => client.request('storage/removeItem', key)\n  };\n}\n\n/***/ }),\n/* 10 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Server\", function() { return Server; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Client\", function() { return Client; });\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*\n  This module describes a simple IPC interface for communicating between browser windows.\n  window.postMessage() is the transport interface, and a request/response interface\n  is defined on top of it as follows:\n\n  const request = {\n    'solid-auth-client': {\n      id: 1234,\n      method: 'doSomethingPlease',\n      args: [ 'one', 'two', 'three' ]\n    }\n  }\n\n  const response = {\n    'solid-auth-client': {\n      id: 1234,\n      ret: 'the_value'\n    }\n  }\n*/\nconst NAMESPACE = 'solid-auth-client';\n/**\n * Receives and handles remote procedure calls.\n */\n\nclass Server {\n  constructor(clientWindow, clientOrigin, handle) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_clientOrigin\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_handler\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_messageListener\", void 0);\n\n    this._clientWindow = clientWindow;\n    this._clientOrigin = clientOrigin;\n    this._handler = handle;\n\n    this._messageListener = event => this._handleMessage(event);\n  }\n\n  async _handleMessage(_ref) {\n    let {\n      data,\n      origin\n    } = _ref;\n\n    // Ensure we can post to the origin\n    if (origin !== this._clientOrigin) {\n      console.warn(\"solid-auth-client is listening to \".concat(this._clientOrigin, \" \") + \"so ignored a message received from \".concat(origin, \".\"));\n      return;\n    } // Parse the request and send it to the handler\n\n\n    const req = data && data[NAMESPACE];\n\n    if (req && req.method) {\n      const {\n        id,\n        method,\n        args\n      } = req;\n      const ret = await this._handler(method, ...args);\n\n      this._clientWindow.postMessage({\n        [NAMESPACE]: {\n          id,\n          ret\n        }\n      }, this._clientOrigin);\n    }\n  }\n\n  start() {\n    window.addEventListener('message', this._messageListener);\n  }\n\n  stop() {\n    window.removeEventListener('message', this._messageListener);\n  }\n\n}\n/**\n * Makes remote procedure calls.\n */\n\nclass Client {\n  constructor(serverWindow, serverOrigin) {\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverWindow\", void 0);\n\n    _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(this, \"_serverOrigin\", void 0);\n\n    this._serverWindow = serverWindow;\n    this._serverOrigin = serverOrigin;\n  }\n\n  request(method) {\n    // Send the request as a message to the server window\n    const id = Math.random();\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    this._serverWindow.postMessage({\n      [NAMESPACE]: {\n        id,\n        method,\n        args\n      }\n    }, this._serverOrigin); // Create a promise that resolves to the request's return value\n\n\n    return new Promise((resolve, reject) => {\n      // Listen for responses to the request\n      window.addEventListener('message', responseListener); // Cancel if the response takes too long\n\n      const timeout = setTimeout(() => {\n        reject(new Error('Could not connect to main window.'));\n        window.removeEventListener('message', responseListener);\n      }, 2000); // Processes a possible response to the request\n\n      function responseListener(_ref2) {\n        let {\n          data\n        } = _ref2;\n        const resp = data && data[NAMESPACE];\n\n        if (resp && resp.id === id && resp.hasOwnProperty('ret')) {\n          resolve(resp.ret);\n          clearTimeout(timeout);\n          window.removeEventListener('message', responseListener);\n        }\n      }\n    });\n  }\n\n}\n\n/***/ }),\n/* 11 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"login\", function() { return login; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"currentSession\", function() { return currentSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"logout\", function() { return logout; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRegisteredRp\", function() { return getRegisteredRp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"requiresAuth\", function() { return requiresAuth; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fetchWithCredentials\", function() { return fetchWithCredentials; });\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12);\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2);\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14);\n/* harmony import */ var auth_header__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(auth_header__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(18);\n/* harmony import */ var _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(80);\n/* harmony import */ var _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);\n/* harmony import */ var _storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9);\n\n\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_1___default()(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/* global Response */\n\n\n\n\n\nasync function login(idp, options) {\n  try {\n    const rp = await getRegisteredRp(idp, options);\n    await saveAppHashFragment(options.storage);\n    return sendAuthRequest(rp, options);\n  } catch (err) {\n    console.warn('Error logging in with WebID-OIDC');\n    console.error(err);\n    return null;\n  }\n}\nasync function currentSession() {\n  let storage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"defaultStorage\"])();\n\n  try {\n    // Obtain the Relying Party\n    const rp = await getStoredRp(storage);\n\n    if (!rp) {\n      return null;\n    } // Obtain and clear the OIDC URL fragment\n\n\n    const url = Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"currentUrl\"])();\n\n    if (!/#(.*&)?access_token=/.test(url)) {\n      return null;\n    }\n\n    window.location.hash = '';\n    await restoreAppHashFragment(storage); // Obtain a session from the Relying Party\n\n    const storeData = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n    const session = await rp.validateResponse(url, storeData);\n\n    if (!session) {\n      return null;\n    }\n\n    return _objectSpread({}, session, {\n      webId: session.idClaims.sub,\n      idp: session.issuer\n    });\n  } catch (err) {\n    console.warn('Error finding a WebID-OIDC session');\n    console.error(err);\n    return null;\n  }\n}\nasync function logout(storage, fetch) {\n  const rp = await getStoredRp(storage);\n\n  if (rp) {\n    try {\n      // First log out from the IDP\n      await rp.logout(); // Then, log out from the RP\n\n      try {\n        await fetch('/.well-known/solid/logout', {\n          credentials: 'include'\n        });\n      } catch (e) {// Ignore errors for when we are not on a Solid pod\n      }\n    } catch (err) {\n      console.warn('Error logging out of the WebID-OIDC session');\n      console.error(err);\n    }\n  }\n}\nasync function getRegisteredRp(idp, options) {\n  // To reuse a possible previous RP,\n  // it be for the same IDP and redirect URI\n  let rp = await getStoredRp(options.storage);\n\n  if (!rp || rp.provider.url !== idp || !rp.registration.redirect_uris.includes(options.callbackUri)) {\n    // Register a new RP\n    rp = await registerRp(idp, options);\n    await storeRp(options.storage, idp, rp);\n  }\n\n  return rp;\n}\n\nasync function getStoredRp(storage) {\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const {\n    rpConfig\n  } = data;\n\n  if (rpConfig) {\n    rpConfig.store = storage;\n    return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.from(rpConfig);\n  } else {\n    return null;\n  }\n}\n\nasync function storeRp(storage, idp, rp) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, data => _objectSpread({}, data, {\n    rpConfig: rp\n  }));\n  return rp;\n}\n\nfunction registerRp(idp, opts) {\n  const {\n    storage,\n    callbackUri\n  } = opts;\n  const responseType = 'id_token token';\n  const clientNameI18n = {};\n  Object.entries(opts).filter((_ref) => {\n    let [key, _] = _ref;\n    return key.startsWith('clientName#');\n  }).forEach((_ref2) => {\n    let [key, value] = _ref2;\n    return clientNameI18n[key.replace('clientName#', 'client_name#')] = value;\n  });\n  const supplementaryOptions = {\n    logo_uri: opts.logoUri,\n    contacts: opts.contacts,\n    client_name: opts.clientName\n  };\n\n  const registration = _objectSpread({\n    issuer: idp,\n    grant_types: ['implicit'],\n    redirect_uris: [callbackUri],\n    response_types: [responseType],\n    scope: 'openid profile'\n  }, clientNameI18n, {}, supplementaryOptions);\n\n  const options = {\n    defaults: {\n      authenticate: {\n        redirect_uri: callbackUri,\n        response_type: responseType\n      }\n    },\n    store: storage\n  };\n  return _solid_oidc_rp__WEBPACK_IMPORTED_MODULE_3___default.a.register(idp, registration, options);\n}\n\nasync function sendAuthRequest(rp, _ref3) {\n  let {\n    callbackUri,\n    storage\n  } = _ref3;\n  const data = await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"getData\"])(storage);\n  const url = await rp.createRequest({\n    redirect_uri: callbackUri\n  }, data);\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(storage, () => data);\n  return Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"navigateTo\"])(url);\n}\n\nasync function saveAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, data => _objectSpread({}, data, {\n    appHashFragment: window.location.hash\n  }));\n}\n\nasync function restoreAppHashFragment(store) {\n  await Object(_storage__WEBPACK_IMPORTED_MODULE_6__[\"updateStorage\"])(store, (_ref4) => {\n    let {\n      appHashFragment = ''\n    } = _ref4,\n        data = _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0___default()(_ref4, [\"appHashFragment\"]);\n\n    window.location.hash = appHashFragment;\n    return data;\n  });\n}\n/**\n * Answers whether a HTTP response requires WebID-OIDC authentication.\n */\n\n\nfunction requiresAuth(resp) {\n  if (resp.status !== 401) {\n    return false;\n  }\n\n  const wwwAuthHeader = resp.headers.get('www-authenticate');\n\n  if (!wwwAuthHeader) {\n    return false;\n  }\n\n  const auth = auth_header__WEBPACK_IMPORTED_MODULE_2__[\"parse\"](wwwAuthHeader);\n  return auth.scheme === 'Bearer' && auth.params && auth.params.scope === 'openid webid';\n}\n/**\n * Fetches a resource, providing the WebID-OIDC ID Token as authentication.\n * Assumes that the resource has requested those tokens in a previous response.\n */\n\nasync function fetchWithCredentials(session, fetch, input, options) {\n  // Create a copy of the headers\n  const headers = {};\n  const origHeaders = options ? options.headers : input.headers;\n\n  if (origHeaders) {\n    const entries = typeof origHeaders.entries === 'function' ? origHeaders.entries() : Object.entries(origHeaders);\n\n    for (const [name, value] of entries) {\n      headers[name] = value;\n    }\n  } // Add Authorization header\n\n\n  const popToken = await _solid_oidc_rp_lib_PoPToken__WEBPACK_IMPORTED_MODULE_4___default.a.issueFor(Object(_url_util__WEBPACK_IMPORTED_MODULE_5__[\"toUrlString\"])(input), session);\n  headers.authorization = \"Bearer \".concat(popToken);\n  return fetch(input, _objectSpread({}, options, {\n    credentials: 'include',\n    headers\n  }));\n}\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar objectWithoutPropertiesLoose = __webpack_require__(13);\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties;\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose;\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"format\", {\n  enumerable: true,\n  get: function get() {\n    return _format.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function get() {\n    return _parse.default;\n  }\n});\n\nvar _format = _interopRequireDefault(__webpack_require__(15));\n\nvar _parse = _interopRequireDefault(__webpack_require__(17));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n//# sourceMappingURL=index.js.map\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar xxx = function xxx(key) {\n  return function (value) {\n    return `${key}=${value && !(0, _util.isToken)(value) ? (0, _util.quote)(value) : value}`;\n  };\n};\n\nvar build = function build(params) {\n  return params.reduce(function (prev, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        values = _ref2[1];\n\n    var transform = xxx(key);\n\n    if (!(0, _util.isToken)(key)) {\n      throw new TypeError();\n    }\n\n    if (Array.isArray(values)) {\n      return _toConsumableArray(prev).concat(_toConsumableArray(values.map(transform)));\n    }\n\n    return _toConsumableArray(prev).concat([transform(values)]);\n  }, []);\n};\n\nvar challenge = function challenge(params, options) {\n  if (Array.isArray(params)) {\n    return build(params);\n  } else if (typeof params === 'object') {\n    var entries = params;\n    return challenge(Object.keys(params).map(function (key) {\n      return [key, entries[key]];\n    }), options);\n  }\n\n  throw new TypeError();\n};\n\nvar _default = function _default(scheme, token, params) {\n  var obj = typeof scheme === 'string' ? {\n    scheme,\n    token,\n    params\n  } : scheme;\n\n  if (typeof obj !== 'object') {\n    throw new TypeError();\n  } else if (!(0, _util.isScheme)(obj.scheme)) {\n    throw new TypeError('Invalid scheme.');\n  }\n\n  return [obj.scheme].concat(_toConsumableArray(typeof obj.token !== 'undefined' ? [obj.token] : []), _toConsumableArray(typeof obj.params !== 'undefined' ? challenge(obj.params) : [])).join(' ');\n};\n\nexports.default = _default;\n//# sourceMappingURL=format.js.map\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unquote = exports.quote = exports.isScheme = exports.isToken = void 0;\nvar token = /^[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+$/;\n\nvar isToken = function isToken(str) {\n  return typeof str === 'string' && token.test(str);\n};\n\nexports.isToken = isToken;\nvar isScheme = isToken;\nexports.isScheme = isScheme;\n\nvar quote = function quote(str) {\n  return `\"${str.replace(/\"/g, '\\\\\"')}\"`;\n};\n\nexports.quote = quote;\n\nvar unquote = function unquote(str) {\n  return str.substr(1, str.length - 2).replace(/\\\\\"/g, '\"');\n};\n\nexports.unquote = unquote;\n//# sourceMappingURL=util.js.map\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _util = __webpack_require__(16);\n\n// lol dis\nvar body = /((?:[a-zA-Z0-9._~+\\/-]+=*(?:\\s+|$))|[^\\u0000-\\u001F\\u007F()<>@,;:\\\\\"/?={}\\[\\]\\u0020\\u0009]+)(?:=([^\\\\\"=\\s,]+|\"(?:[^\"\\\\]|\\\\.)*\"))?/g; // eslint-disable-line\n\nvar normalize = function normalize(prev, _cur) {\n  // Fixup quoted strings and tokens with spaces around them\n  var cur = _cur.charAt(0) === '\"' ? (0, _util.unquote)(_cur) : _cur.trim(); // Marshal\n\n  if (Array.isArray(prev)) {\n    return prev.concat(cur);\n  } else if (typeof prev === 'string') {\n    return [prev, cur];\n  }\n\n  return cur;\n};\n\nvar parseProperties = function parseProperties(scheme, string) {\n  var token = null;\n  var params = {}; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    var res = body.exec(string);\n\n    if (res === null) {\n      break;\n    }\n\n    if (res[2]) {\n      params[res[1]] = normalize(params[res[1]], res[2]);\n    } else {\n      token = normalize(token, res[1]);\n    }\n  }\n\n  return {\n    scheme,\n    params,\n    token\n  };\n};\n\nvar _default = function _default(str) {\n  if (typeof str !== 'string') {\n    throw new TypeError('Header value must be a string.');\n  }\n\n  var start = str.indexOf(' ');\n  var scheme = str.substr(0, start);\n\n  if (!(0, _util.isScheme)(scheme)) {\n    throw new TypeError(`Invalid scheme ${scheme}`);\n  }\n\n  return parseProperties(scheme, str.substr(start));\n};\n\nexports.default = _default;\n//# sourceMappingURL=parse.js.map\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = __webpack_require__(19);\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst fetch = __webpack_require__(5);\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst {\n  JSONDocument\n} = __webpack_require__(28);\n\nconst {\n  JWKSet\n} = __webpack_require__(37);\n\nconst AuthenticationRequest = __webpack_require__(68);\n\nconst AuthenticationResponse = __webpack_require__(70);\n\nconst RelyingPartySchema = __webpack_require__(79);\n\nconst onHttpError = __webpack_require__(74);\n\nconst FormUrlEncoded = __webpack_require__(69);\n/**\n * RelyingParty\n *\n * @class\n * Client interface for OpenID Connect Relying Party.\n *\n * @example\n *  let client = RelyingParty({\n *    provider: {\n *      name: 'Anvil Research, Inc.',\n *      url: 'https://forge.anvil.io'\n *      // configuration\n *      // jwks\n *    },\n *    defaults: {\n *      popToken: false,\n *      authenticate: {\n *        response_type: 'code',\n *        display: 'popup',\n *        scope: 'openid profile email'\n *      },\n *      register: {\n *        client_name: 'Example',\n *        client_uri: 'https://example.com',\n *        logo_uri: 'https://example.com/assets/logo.png',\n *        redirect_uris: ['https://app.example.com/callback'],\n *        response_types: ['code', 'code id_token token'],\n *        grant_types: ['authorization_code'],\n *        default_max_age: 7200,\n *        post_logout_redirect_uris: ['https://app.example.com']\n *      },\n *    },\n *    registration: {\n *      // if you have it saved somewhere\n *    },\n *    store: localStorage || req.session\n *  })\n *\n *  client.discover() => Promise\n *  client.jwks() => Promise\n *  client.authenticate()\n *  client.authenticateUri()\n *  client.validateResponse(uri) => Promise\n *  client.userinfo() => Promise\n *  client.logout()\n */\n\n\nclass RelyingParty extends JSONDocument {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return RelyingPartySchema;\n  }\n  /**\n   * from\n   *\n   * @description\n   * Create a RelyingParty instance from a previously registered client.\n   *\n   * @param {Object} data\n   * @returns {Promise<RelyingParty>}\n   */\n\n\n  static from(data) {\n    let rp = new RelyingParty(data);\n    let validation = rp.validate(); // schema validation\n\n    if (!validation.valid) {\n      return Promise.reject(new Error(JSON.stringify(validation)));\n    }\n\n    let jwks = rp.provider.jwks; // request the JWK Set if missing\n\n    if (!jwks) {\n      return rp.jwks().then(() => rp);\n    } // otherwise import the JWK Set to webcrypto\n\n\n    return JWKSet.importKeys(jwks).then(jwks => {\n      rp.provider.jwks = jwks;\n      return rp;\n    });\n  }\n  /**\n   * register\n   *\n   * @param issuer {string} Provider URL\n   * @param registration {Object} Client dynamic registration options\n   * @param options {Object}\n   * @param options.defaults\n   * @param [options.store] {Session|Storage}\n   * @returns {Promise<RelyingParty>} RelyingParty instance, registered.\n   */\n\n\n  static register(issuer, registration, options) {\n    let rp = new RelyingParty({\n      provider: {\n        url: issuer\n      },\n      defaults: Object.assign({}, options.defaults),\n      store: options.store\n    });\n    return Promise.resolve().then(() => rp.discover()).then(() => rp.jwks()).then(() => rp.register(registration)).then(() => rp);\n  }\n  /**\n   * Discover\n   *\n   * @description Fetches the issuer's OpenID Configuration.\n   * @returns {Promise<Object>} Resolves with the provider configuration response\n   */\n\n\n  discover() {\n    try {\n      let issuer = this.provider.url;\n      assert(issuer, 'RelyingParty provider must define \"url\"');\n      let url = new URL(issuer);\n      url.pathname = '.well-known/openid-configuration';\n      return fetch(url.toString()).then(onHttpError('Error fetching openid configuration')).then(response => {\n        return response.json().then(json => this.provider.configuration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * Register\n   *\n   * @description Register's a client with provider as a Relying Party\n   *\n   * @param options {Object}\n   * @returns {Promise<Object>} Resolves with the registration response object\n   */\n\n\n  register(options) {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.registration_endpoint, 'OpenID Configuration is missing registration_endpoint.');\n      let uri = configuration.registration_endpoint;\n      let method = 'post';\n      let headers = new Headers({\n        'Content-Type': 'application/json'\n      });\n      let params = this.defaults.register;\n      let body = JSON.stringify(Object.assign({}, params, options));\n      return fetch(uri, {\n        method,\n        headers,\n        body\n      }).then(onHttpError('Error registering client')).then(response => {\n        return response.json().then(json => this.registration = json);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n\n  serialize() {\n    return JSON.stringify(this);\n  }\n  /**\n   * jwks\n   *\n   * @description Promises the issuer's JWK Set.\n   * @returns {Promise}\n   */\n\n\n  jwks() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.jwks_uri, 'OpenID Configuration is missing jwks_uri.');\n      let uri = configuration.jwks_uri;\n      return fetch(uri).then(onHttpError('Error resolving provider keys')).then(response => {\n        return response.json().then(json => JWKSet.importKeys(json)).then(jwks => this.provider.jwks = jwks);\n      });\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * createRequest\n   *\n   * @param options {Object} Authn request options hashmap\n   * @param options.redirect_uri {string}\n   * @param options.response_type {string} e.g. 'code' or 'id_token token'\n   * @param session {Session|Storage} req.session or localStorage\n   * @returns {Promise<string>} Authn request URL\n   */\n\n\n  createRequest(options, session) {\n    return AuthenticationRequest.create(this, options, session || this.store);\n  }\n  /**\n   * Validate Response\n   *\n   * @param response {string} req.query or req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  validateResponse(response, session = this.store) {\n    let options;\n\n    if (response.match(/^http(s?):\\/\\//)) {\n      options = {\n        rp: this,\n        redirect: response,\n        session\n      };\n    } else {\n      options = {\n        rp: this,\n        body: response,\n        session\n      };\n    }\n\n    const authResponse = new AuthenticationResponse(options);\n    return AuthenticationResponse.validateResponse(authResponse);\n  }\n  /**\n   * userinfo\n   *\n   * @description Promises the authenticated user's claims.\n   * @returns {Promise}\n   */\n\n\n  userinfo() {\n    try {\n      let configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.userinfo_endpoint, 'OpenID Configuration is missing userinfo_endpoint.');\n      let uri = configuration.userinfo_endpoint;\n      let access_token = this.store.access_token;\n      assert(access_token, 'Missing access token.');\n      let headers = new Headers({\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${access_token}`\n      });\n      return fetch(uri, {\n        headers\n      }).then(onHttpError('Error fetching userinfo')).then(response => response.json());\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * logoutRequest\n   *\n   * Composes and returns the logout request URI, based on the OP's\n   * `end_session_endpoint`, with appropriate parameters.\n   *\n   * Note: Calling client code has the responsibility to clear the local\n   * session state (for example, by calling `rp.clearSession()`). In addition,\n   * some IdPs (such as Google) may not provide an `end_session_endpoint`,\n   * in which case, this method will return null.\n   *\n   * @see https://openid.net/specs/openid-connect-session-1_0.html#RPLogout\n   *\n   * @throws {Error} If provider config is not initialized\n   *\n   * @throws {Error} If `post_logout_redirect_uri` was provided without a\n   *   corresponding `id_token_hint`\n   *\n   * @param [options={}] {object}\n   *\n   * @param [options.id_token_hint] {string} RECOMMENDED.\n   *   Previously issued ID Token passed to the logout endpoint as\n   *   a hint about the End-User's current authenticated session with the\n   *   Client. This is used as an indication of the identity of the End-User\n   *   that the RP is requesting be logged out by the OP. The OP *need not* be\n   *   listed as an audience of the ID Token when it is used as an\n   *   `id_token_hint` value.\n   *\n   * @param [options.post_logout_redirect_uri] {string} OPTIONAL. URL to which\n   *   the RP is requesting that the End-User's User Agent be redirected after\n   *   a logout has been performed. The value MUST have been previously\n   *   registered with the OP, either using the `post_logout_redirect_uris`\n   *   Registration parameter or via another mechanism. If supplied, the OP\n   *   SHOULD honor this request following the logout.\n   *\n   *   Note: The requirement to validate the uri for previous registration means\n   *   that, in practice, the `id_token_hint` is REQUIRED if\n   *   `post_logout_redirect_uri` is used. Otherwise, the OP has no way to get\n   *   the `client_id` to load the saved client registration, to validate the\n   *   uri. The only way it can get it is by decoding the `id_token_hint`.\n   *\n   * @param [options.state] {string} OPTIONAL. Opaque value used by the RP to\n   *   maintain state between the logout request and the callback to the\n   *   endpoint specified by the `post_logout_redirect_uri` query parameter. If\n   *   included in the logout request, the OP passes this value back to the RP\n   *   using the `state` query parameter when redirecting the User Agent back to\n   *   the RP.\n   *\n   * TODO: In the future, consider adding `response_mode` param, for the OP to\n   *   determine how to return the `state` back the RP.\n   *   @see http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#ResponseModes\n   *\n   * TODO: Handle special cases for popular providers (Google, MSFT)\n   *\n   * @returns {string|null} Logout uri (or null if no end_session_endpoint was\n   *   provided in the IdP config)\n   */\n\n\n  logoutRequest(options = {}) {\n    const {\n      id_token_hint,\n      post_logout_redirect_uri,\n      state\n    } = options;\n    let configuration;\n    assert(this.provider, 'OpenID Configuration is not initialized');\n    configuration = this.provider.configuration;\n    assert(configuration, 'OpenID Configuration is not initialized');\n\n    if (!configuration.end_session_endpoint) {\n      console.log(`OpenId Configuration for ` + `${configuration.issuer} is missing end_session_endpoint`);\n      return null;\n    }\n\n    if (post_logout_redirect_uri && !id_token_hint) {\n      throw new Error('id_token_hint is required when using post_logout_redirect_uri');\n    }\n\n    const params = {};\n\n    if (id_token_hint) {\n      params.id_token_hint = id_token_hint;\n    }\n\n    if (post_logout_redirect_uri) {\n      params.post_logout_redirect_uri = post_logout_redirect_uri;\n    }\n\n    if (state) {\n      params.state = state;\n    }\n\n    const url = new URL(configuration.end_session_endpoint);\n    url.search = FormUrlEncoded.encode(params);\n    return url.href;\n  }\n  /**\n   * Logout\n   *\n   * @deprecated\n   *\n   * TODO: Add deprecation warnings, then remove. Client code should\n   *   use `logoutRequest()` instead\n   *\n   * @returns {Promise}\n   */\n\n\n  logout() {\n    let configuration;\n\n    try {\n      assert(this.provider, 'OpenID Configuration is not initialized.');\n      configuration = this.provider.configuration;\n      assert(configuration, 'OpenID Configuration is not initialized.');\n      assert(configuration.end_session_endpoint, 'OpenID Configuration is missing end_session_endpoint.');\n    } catch (error) {\n      return Promise.reject(error);\n    }\n\n    if (!configuration.end_session_endpoint) {\n      this.clearSession();\n      return Promise.resolve(undefined);\n    }\n\n    let uri = configuration.end_session_endpoint;\n    let method = 'get';\n    return fetch(uri, {\n      method,\n      credentials: 'include'\n    }).then(onHttpError('Error logging out')).then(() => this.clearSession()); // TODO: Validate `frontchannel_logout_uri` if necessary\n\n    /**\n     * frontchannel_logout_uri - OPTIONAL. RP URL that will cause the RP to log\n     * itself out when rendered in an iframe by the OP.\n     *\n     * An `iss` (issuer) query parameter and a `sid`\n     * (session ID) query parameter MAY be included by the OP to enable the RP\n     * to validate the request and to determine which of the potentially\n     * multiple sessions is to be logged out. If a sid (session ID) query\n     * parameter is included, an iss (issuer) query parameter MUST also be\n     * included.\n     * @see https://openid.net/specs/openid-connect-frontchannel-1_0.html#RPLogout\n     */\n  }\n\n  clearSession() {\n    let session = this.store;\n\n    if (!session) {\n      return;\n    }\n\n    delete session[SESSION_PRIVATE_KEY];\n  }\n  /**\n   * @param uri {string} Target Resource Server URI\n   * @param idToken {IDToken} ID Token to be embedded in the PoP token\n   *\n   * @returns {Promise<PoPToken>}\n   */\n\n\n  popTokenFor(uri, idToken) {\n    return PoPToken.issueFor(uri, idToken);\n  }\n\n}\n\nconst SESSION_PRIVATE_KEY = 'oidc.session.privateKey';\nRelyingParty.SESSION_PRIVATE_KEY = SESSION_PRIVATE_KEY;\nmodule.exports = RelyingParty;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar objectAssign = __webpack_require__(22);\n\n// compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js\n// original notice:\n\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nfunction compare(a, b) {\n  if (a === b) {\n    return 0;\n  }\n\n  var x = a.length;\n  var y = b.length;\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i];\n      y = b[i];\n      break;\n    }\n  }\n\n  if (x < y) {\n    return -1;\n  }\n  if (y < x) {\n    return 1;\n  }\n  return 0;\n}\nfunction isBuffer(b) {\n  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {\n    return global.Buffer.isBuffer(b);\n  }\n  return !!(b != null && b._isBuffer);\n}\n\n// based on node assert, original notice:\n// NB: The URL to the CommonJS spec is kept just for tradition.\n//     node-assert has evolved a lot since then, both in API and behavior.\n\n// http://wiki.commonjs.org/wiki/Unit_Testing/1.0\n//\n// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!\n//\n// Originally from narwhal.js (http://narwhaljs.org)\n// Copyright (c) 2009 Thomas Robinson <280north.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar util = __webpack_require__(23);\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar pSlice = Array.prototype.slice;\nvar functionsHaveNames = (function () {\n  return function foo() {}.name === 'foo';\n}());\nfunction pToString (obj) {\n  return Object.prototype.toString.call(obj);\n}\nfunction isView(arrbuf) {\n  if (isBuffer(arrbuf)) {\n    return false;\n  }\n  if (typeof global.ArrayBuffer !== 'function') {\n    return false;\n  }\n  if (typeof ArrayBuffer.isView === 'function') {\n    return ArrayBuffer.isView(arrbuf);\n  }\n  if (!arrbuf) {\n    return false;\n  }\n  if (arrbuf instanceof DataView) {\n    return true;\n  }\n  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {\n    return true;\n  }\n  return false;\n}\n// 1. The assert module provides functions that throw\n// AssertionError's when particular conditions are not met. The\n// assert module must conform to the following interface.\n\nvar assert = module.exports = ok;\n\n// 2. The AssertionError is defined in assert.\n// new assert.AssertionError({ message: message,\n//                             actual: actual,\n//                             expected: expected })\n\nvar regex = /\\s*function\\s+([^\\(\\s]*)\\s*/;\n// based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js\nfunction getName(func) {\n  if (!util.isFunction(func)) {\n    return;\n  }\n  if (functionsHaveNames) {\n    return func.name;\n  }\n  var str = func.toString();\n  var match = str.match(regex);\n  return match && match[1];\n}\nassert.AssertionError = function AssertionError(options) {\n  this.name = 'AssertionError';\n  this.actual = options.actual;\n  this.expected = options.expected;\n  this.operator = options.operator;\n  if (options.message) {\n    this.message = options.message;\n    this.generatedMessage = false;\n  } else {\n    this.message = getMessage(this);\n    this.generatedMessage = true;\n  }\n  var stackStartFunction = options.stackStartFunction || fail;\n  if (Error.captureStackTrace) {\n    Error.captureStackTrace(this, stackStartFunction);\n  } else {\n    // non v8 browsers so we can have a stacktrace\n    var err = new Error();\n    if (err.stack) {\n      var out = err.stack;\n\n      // try to strip useless frames\n      var fn_name = getName(stackStartFunction);\n      var idx = out.indexOf('\\n' + fn_name);\n      if (idx >= 0) {\n        // once we have located the function frame\n        // we need to strip out everything before it (and its line)\n        var next_line = out.indexOf('\\n', idx + 1);\n        out = out.substring(next_line + 1);\n      }\n\n      this.stack = out;\n    }\n  }\n};\n\n// assert.AssertionError instanceof Error\nutil.inherits(assert.AssertionError, Error);\n\nfunction truncate(s, n) {\n  if (typeof s === 'string') {\n    return s.length < n ? s : s.slice(0, n);\n  } else {\n    return s;\n  }\n}\nfunction inspect(something) {\n  if (functionsHaveNames || !util.isFunction(something)) {\n    return util.inspect(something);\n  }\n  var rawname = getName(something);\n  var name = rawname ? ': ' + rawname : '';\n  return '[Function' +  name + ']';\n}\nfunction getMessage(self) {\n  return truncate(inspect(self.actual), 128) + ' ' +\n         self.operator + ' ' +\n         truncate(inspect(self.expected), 128);\n}\n\n// At present only the three keys mentioned above are used and\n// understood by the spec. Implementations or sub modules can pass\n// other keys to the AssertionError's constructor - they will be\n// ignored.\n\n// 3. All of the following functions must throw an AssertionError\n// when a corresponding condition is not met, with a message that\n// may be undefined if not provided.  All assertion methods provide\n// both the actual and expected values to the assertion error for\n// display purposes.\n\nfunction fail(actual, expected, message, operator, stackStartFunction) {\n  throw new assert.AssertionError({\n    message: message,\n    actual: actual,\n    expected: expected,\n    operator: operator,\n    stackStartFunction: stackStartFunction\n  });\n}\n\n// EXTENSION! allows for well behaved errors defined elsewhere.\nassert.fail = fail;\n\n// 4. Pure assertion tests whether a value is truthy, as determined\n// by !!guard.\n// assert.ok(guard, message_opt);\n// This statement is equivalent to assert.equal(true, !!guard,\n// message_opt);. To test strictly for the value true, use\n// assert.strictEqual(true, guard, message_opt);.\n\nfunction ok(value, message) {\n  if (!value) fail(value, true, message, '==', assert.ok);\n}\nassert.ok = ok;\n\n// 5. The equality assertion tests shallow, coercive equality with\n// ==.\n// assert.equal(actual, expected, message_opt);\n\nassert.equal = function equal(actual, expected, message) {\n  if (actual != expected) fail(actual, expected, message, '==', assert.equal);\n};\n\n// 6. The non-equality assertion tests for whether two objects are not equal\n// with != assert.notEqual(actual, expected, message_opt);\n\nassert.notEqual = function notEqual(actual, expected, message) {\n  if (actual == expected) {\n    fail(actual, expected, message, '!=', assert.notEqual);\n  }\n};\n\n// 7. The equivalence assertion tests a deep equality relation.\n// assert.deepEqual(actual, expected, message_opt);\n\nassert.deepEqual = function deepEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'deepEqual', assert.deepEqual);\n  }\n};\n\nassert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {\n  if (!_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);\n  }\n};\n\nfunction _deepEqual(actual, expected, strict, memos) {\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n  } else if (isBuffer(actual) && isBuffer(expected)) {\n    return compare(actual, expected) === 0;\n\n  // 7.2. If the expected value is a Date object, the actual value is\n  // equivalent if it is also a Date object that refers to the same time.\n  } else if (util.isDate(actual) && util.isDate(expected)) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3 If the expected value is a RegExp object, the actual value is\n  // equivalent if it is also a RegExp object with the same source and\n  // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).\n  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {\n    return actual.source === expected.source &&\n           actual.global === expected.global &&\n           actual.multiline === expected.multiline &&\n           actual.lastIndex === expected.lastIndex &&\n           actual.ignoreCase === expected.ignoreCase;\n\n  // 7.4. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if ((actual === null || typeof actual !== 'object') &&\n             (expected === null || typeof expected !== 'object')) {\n    return strict ? actual === expected : actual == expected;\n\n  // If both values are instances of typed arrays, wrap their underlying\n  // ArrayBuffers in a Buffer each to increase performance\n  // This optimization requires the arrays to have the same type as checked by\n  // Object.prototype.toString (aka pToString). Never perform binary\n  // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their\n  // bit patterns are not identical.\n  } else if (isView(actual) && isView(expected) &&\n             pToString(actual) === pToString(expected) &&\n             !(actual instanceof Float32Array ||\n               actual instanceof Float64Array)) {\n    return compare(new Uint8Array(actual.buffer),\n                   new Uint8Array(expected.buffer)) === 0;\n\n  // 7.5 For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else if (isBuffer(actual) !== isBuffer(expected)) {\n    return false;\n  } else {\n    memos = memos || {actual: [], expected: []};\n\n    var actualIndex = memos.actual.indexOf(actual);\n    if (actualIndex !== -1) {\n      if (actualIndex === memos.expected.indexOf(expected)) {\n        return true;\n      }\n    }\n\n    memos.actual.push(actual);\n    memos.expected.push(expected);\n\n    return objEquiv(actual, expected, strict, memos);\n  }\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n}\n\nfunction objEquiv(a, b, strict, actualVisitedObjects) {\n  if (a === null || a === undefined || b === null || b === undefined)\n    return false;\n  // if one is a primitive, the other must be same\n  if (util.isPrimitive(a) || util.isPrimitive(b))\n    return a === b;\n  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b))\n    return false;\n  var aIsArgs = isArguments(a);\n  var bIsArgs = isArguments(b);\n  if ((aIsArgs && !bIsArgs) || (!aIsArgs && bIsArgs))\n    return false;\n  if (aIsArgs) {\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return _deepEqual(a, b, strict);\n  }\n  var ka = objectKeys(a);\n  var kb = objectKeys(b);\n  var key, i;\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length !== kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] !== kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects))\n      return false;\n  }\n  return true;\n}\n\n// 8. The non-equivalence assertion tests for any deep inequality.\n// assert.notDeepEqual(actual, expected, message_opt);\n\nassert.notDeepEqual = function notDeepEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, false)) {\n    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);\n  }\n};\n\nassert.notDeepStrictEqual = notDeepStrictEqual;\nfunction notDeepStrictEqual(actual, expected, message) {\n  if (_deepEqual(actual, expected, true)) {\n    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);\n  }\n}\n\n\n// 9. The strict equality assertion tests strict equality, as determined by ===.\n// assert.strictEqual(actual, expected, message_opt);\n\nassert.strictEqual = function strictEqual(actual, expected, message) {\n  if (actual !== expected) {\n    fail(actual, expected, message, '===', assert.strictEqual);\n  }\n};\n\n// 10. The strict non-equality assertion tests for strict inequality, as\n// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);\n\nassert.notStrictEqual = function notStrictEqual(actual, expected, message) {\n  if (actual === expected) {\n    fail(actual, expected, message, '!==', assert.notStrictEqual);\n  }\n};\n\nfunction expectedException(actual, expected) {\n  if (!actual || !expected) {\n    return false;\n  }\n\n  if (Object.prototype.toString.call(expected) == '[object RegExp]') {\n    return expected.test(actual);\n  }\n\n  try {\n    if (actual instanceof expected) {\n      return true;\n    }\n  } catch (e) {\n    // Ignore.  The instanceof check doesn't work for arrow functions.\n  }\n\n  if (Error.isPrototypeOf(expected)) {\n    return false;\n  }\n\n  return expected.call({}, actual) === true;\n}\n\nfunction _tryBlock(block) {\n  var error;\n  try {\n    block();\n  } catch (e) {\n    error = e;\n  }\n  return error;\n}\n\nfunction _throws(shouldThrow, block, expected, message) {\n  var actual;\n\n  if (typeof block !== 'function') {\n    throw new TypeError('\"block\" argument must be a function');\n  }\n\n  if (typeof expected === 'string') {\n    message = expected;\n    expected = null;\n  }\n\n  actual = _tryBlock(block);\n\n  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') +\n            (message ? ' ' + message : '.');\n\n  if (shouldThrow && !actual) {\n    fail(actual, expected, 'Missing expected exception' + message);\n  }\n\n  var userProvidedMessage = typeof message === 'string';\n  var isUnwantedException = !shouldThrow && util.isError(actual);\n  var isUnexpectedException = !shouldThrow && actual && !expected;\n\n  if ((isUnwantedException &&\n      userProvidedMessage &&\n      expectedException(actual, expected)) ||\n      isUnexpectedException) {\n    fail(actual, expected, 'Got unwanted exception' + message);\n  }\n\n  if ((shouldThrow && actual && expected &&\n      !expectedException(actual, expected)) || (!shouldThrow && actual)) {\n    throw actual;\n  }\n}\n\n// 11. Expected to throw an error:\n// assert.throws(block, Error_opt, message_opt);\n\nassert.throws = function(block, /*optional*/error, /*optional*/message) {\n  _throws(true, block, error, message);\n};\n\n// EXTENSION! This is annoying to write outside this module.\nassert.doesNotThrow = function(block, /*optional*/error, /*optional*/message) {\n  _throws(false, block, error, message);\n};\n\nassert.ifError = function(err) { if (err) throw err; };\n\n// Expose a strict only variant of assert\nfunction strict(value, message) {\n  if (!value) fail(value, true, message, '==', strict);\n}\nassert.strict = objectAssign(strict, assert, {\n  equal: assert.strictEqual,\n  deepEqual: assert.deepStrictEqual,\n  notEqual: assert.notStrictEqual,\n  notDeepEqual: assert.notDeepStrictEqual\n});\nassert.strict.strict = assert.strict;\n\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (hasOwn.call(obj, key)) keys.push(key);\n  }\n  return keys;\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||\n  function getOwnPropertyDescriptors(obj) {\n    var keys = Object.keys(obj);\n    var descriptors = {};\n    for (var i = 0; i < keys.length; i++) {\n      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);\n    }\n    return descriptors;\n  };\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  if (typeof process !== 'undefined' && process.noDeprecation === true) {\n    return fn;\n  }\n\n  // Allow for deprecating things in the process of starting up.\n  if (typeof process === 'undefined') {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = __webpack_require__(25);\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = __webpack_require__(26);\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nvar kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;\n\nexports.promisify = function promisify(original) {\n  if (typeof original !== 'function')\n    throw new TypeError('The \"original\" argument must be of type Function');\n\n  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {\n    var fn = original[kCustomPromisifiedSymbol];\n    if (typeof fn !== 'function') {\n      throw new TypeError('The \"util.promisify.custom\" argument must be of type Function');\n    }\n    Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n      value: fn, enumerable: false, writable: false, configurable: true\n    });\n    return fn;\n  }\n\n  function fn() {\n    var promiseResolve, promiseReject;\n    var promise = new Promise(function (resolve, reject) {\n      promiseResolve = resolve;\n      promiseReject = reject;\n    });\n\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n    args.push(function (err, value) {\n      if (err) {\n        promiseReject(err);\n      } else {\n        promiseResolve(value);\n      }\n    });\n\n    try {\n      original.apply(this, args);\n    } catch (err) {\n      promiseReject(err);\n    }\n\n    return promise;\n  }\n\n  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));\n\n  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {\n    value: fn, enumerable: false, writable: false, configurable: true\n  });\n  return Object.defineProperties(\n    fn,\n    getOwnPropertyDescriptors(original)\n  );\n}\n\nexports.promisify.custom = kCustomPromisifiedSymbol\n\nfunction callbackifyOnRejected(reason, cb) {\n  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).\n  // Because `null` is a special error value in callbacks which means \"no error\n  // occurred\", we error-wrap so the callback consumer can distinguish between\n  // \"the promise rejected with null\" or \"the promise fulfilled with undefined\".\n  if (!reason) {\n    var newReason = new Error('Promise was rejected with a falsy value');\n    newReason.reason = reason;\n    reason = newReason;\n  }\n  return cb(reason);\n}\n\nfunction callbackify(original) {\n  if (typeof original !== 'function') {\n    throw new TypeError('The \"original\" argument must be of type Function');\n  }\n\n  // We DO NOT return the promise as it gives the user a false sense that\n  // the promise is actually somehow related to the callback's execution\n  // and that the callback throwing will reject the promise.\n  function callbackified() {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args.push(arguments[i]);\n    }\n\n    var maybeCb = args.pop();\n    if (typeof maybeCb !== 'function') {\n      throw new TypeError('The last argument must be of type Function');\n    }\n    var self = this;\n    var cb = function() {\n      return maybeCb.apply(self, arguments);\n    };\n    // In true node style we process the callback on `nextTick` with all the\n    // implications (stack, `uncaughtException`, `async_hooks`)\n    original.apply(this, args)\n      .then(function(ret) { process.nextTick(cb, null, ret) },\n            function(rej) { process.nextTick(callbackifyOnRejected, rej, cb) });\n  }\n\n  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));\n  Object.defineProperties(callbackified,\n                          getOwnPropertyDescriptors(original));\n  return callbackified;\n}\nexports.callbackify = callbackify;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(24)))\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports) {\n\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports) {\n\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports) {\n\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"window\"]; }());\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  Formats: __webpack_require__(29),\n  Initializer: __webpack_require__(30),\n  JSONDocument: __webpack_require__(31),\n  JSONMapping: __webpack_require__(34),\n  JSONPatch: __webpack_require__(32),\n  JSONPointer: __webpack_require__(33),\n  JSONSchema: __webpack_require__(35),\n  Validator: __webpack_require__(36)\n};\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * JSON Schema Formats\n *\n * TODO\n * Is there a good way to express these over multiple lines with comments\n * for easier debugging and auditing?\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar DATETIME_REGEXP = /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)$/i;\nvar URI_REGEXP = /^(?:[a-z][a-z0-9+-.]*)?(?:\\:|\\/)\\/?[^\\s]*$/i;\nvar EMAIL_REGEXP = /^[a-z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i;\nvar IPV4_REGEXP = /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/;\nvar IPV6_REGEXP = /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i;\nvar HOSTNAME_REGEXP = /^[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\\.[a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;\n\n/**\n * Formats\n */\n\nvar Formats = function () {\n  function Formats() {\n    _classCallCheck(this, Formats);\n  }\n\n  _createClass(Formats, [{\n    key: 'register',\n\n\n    /**\n     * Register\n     *\n     * @description\n     * Register a new mapping from named format to RegExp instance\n     *\n     * TODO\n     * We can do some extra validation of the RegExp to\n     * ensure it's the acceptable subset of RegExps allowed\n     * by JSON Schema.\n     *\n     * @param {string} name\n     * @param {RegExp} pattern\n     * @returns {RegExp}\n     */\n    value: function register(name, pattern) {\n      // verify name is a string\n      if (typeof name !== 'string') {\n        throw new Error('Format name must be a string');\n      }\n\n      // cast a string to RegExp\n      if (typeof pattern === 'string') {\n        pattern = new RegExp(pattern);\n      }\n\n      return this[name] = pattern;\n    }\n\n    /**\n     * Resolve\n     *\n     * @description\n     * Given a format name, return the corresponding registered validation. In the\n     * event a format is not registered, throw an error.\n     *\n     * @param {string} name\n     * @returns {RegExp}\n     */\n\n  }, {\n    key: 'resolve',\n    value: function resolve(name) {\n      var format = this[name];\n\n      if (!format) {\n        throw new Error('Unknown JSON Schema format.');\n      }\n\n      return format;\n    }\n\n    /**\n     * Test\n     *\n     * @description\n     * Test that a value conforms to a format.\n     *\n     * @param {string} name\n     * @param {string} value\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'test',\n    value: function test(name, value) {\n      var format = this.resolve(name);\n      return format.test(value);\n    }\n  }], [{\n    key: 'initialize',\n\n\n    /**\n     * Initialize\n     *\n     * @description\n     * Create a new Formats instance and register default formats\n     *\n     * @returns {Formats}\n     */\n    value: function initialize() {\n      var formats = new Formats();\n      formats.register('date-time', DATETIME_REGEXP);\n      formats.register('uri', URI_REGEXP);\n      formats.register('email', EMAIL_REGEXP);\n      formats.register('ipv4', IPV4_REGEXP);\n      formats.register('ipv6', IPV6_REGEXP);\n      formats.register('hostname', HOSTNAME_REGEXP);\n      return formats;\n    }\n  }]);\n\n  return Formats;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Formats.initialize();\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Initializer\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = function () {\n\n  /**\n   * constructor\n   */\n  function Initializer(schema, options) {\n    _classCallCheck(this, Initializer);\n\n    Object.assign(this, options || {});\n    this.root = this.root || this;\n\n    this.root.depth = this.root.depth || 1;\n\n    if (this.level > this.root.depth) {\n      this.root.depth = this.level;\n    }\n\n    this.level = this.level || 0;\n    this.schema = schema;\n  }\n\n  /**\n   * compile (static)\n   */\n\n\n  _createClass(Initializer, [{\n    key: 'compile',\n\n\n    /**\n     * compile\n     */\n    value: function compile() {\n      var root = this.root,\n          depth = this.depth,\n          level = this.level;\n\n      var declarations = '';\n      var body = '';\n\n      // traverse the schema and generate code\n      body += this.default();\n      body += this.properties();\n      //body += this.additionalProperties()\n      body += this.items();\n      //body += this.additionalItems()\n\n\n      // value\n      body += this.member();\n      body += this.item();\n\n      // after traversing the schema\n      // generate the variable declarations\n      if (root === this) {\n        for (var i = 1; i <= this.root.depth; i++) {\n          declarations += this.declaration(i);\n        }\n\n        return '\\n        options = options || {}\\n\\n        if (options.filter === false) {\\n          Object.assign(target, JSON.parse(JSON.stringify(source)))\\n        }\\n\\n        ' + declarations + '\\n        ' + body + '\\n      ';\n      }\n\n      return body;\n    }\n\n    /**\n     * declaration\n     */\n\n  }, {\n    key: 'declaration',\n    value: function declaration(level) {\n      return '\\n      var target' + level + '\\n      var source' + level + '\\n      var count' + level + '\\n    ';\n    }\n\n    /**\n     * default\n     */\n\n  }, {\n    key: 'default',\n    value: function _default() {\n      var schema = this.schema,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var value = schema.default; // rename default to value because it's a keyword and syntax highlighter breaks\n\n      var block = '';\n\n      if (schema.hasOwnProperty('default')) {\n\n        if (key) {\n          block += '\\n          target' + level + '[\\'' + key + '\\'] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (index) {\n          block += '\\n          target' + level + '[' + index + '] = ' + JSON.stringify(value) + '\\n        ';\n        }\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (options.defaults !== false) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * member\n     */\n\n  }, {\n    key: 'member',\n    value: function member() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      // `key` tells us to treat this subschema as an object member vs an array item\n      // and the absence of the other values here indicates we are dealing with a\n      // primitive value\n      if (key && !properties && !additionalProperties && !items && !additionalItems) {\n\n        // first generate the assignment statement\n        block += '\\n        target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n      ';\n\n        // for nested container objects, add the counter incrementing statement\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        // wrap the foregoing in a check for presence on the source\n        block = '\\n        if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * item\n     */\n\n  }, {\n    key: 'item',\n    value: function item() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          index = this.index;\n      var properties = schema.properties,\n          additionalProperties = schema.additionalProperties,\n          items = schema.items,\n          additionalItems = schema.additionalItems;\n\n      var block = '';\n\n      if (index && !properties && !additionalProperties && !items && !additionalItems) {\n\n        block += '\\n        target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n      ';\n\n        if (level > 1) {\n          block += '\\n          count' + level + '++\\n        ';\n        }\n\n        block = '\\n        if (' + index + ' < len) {\\n          ' + block + '\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var properties = schema.properties;\n\n      var block = '';\n\n      if (properties) {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var initializer = new Initializer(subschema, { key: key, root: root, level: level + 1 });\n\n          block += initializer.compile();\n        });\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (typeof source === \\'object\\' && source !== null && !Array.isArray(source)) {\\n            if (typeof target !== \\'object\\') {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n            count1 = 0\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n\n          if (index) {\n            block = '\\n            if (' + index + ' < source' + level + '.length || typeof source' + level + '[' + index + '] === \\'object\\') {\\n\\n              source' + (level + 1) + ' = source' + level + '[' + index + '] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (' + index + ' < target' + level + '.length || typeof target' + level + '[' + index + '] !== \\'object\\') {\\n                target' + (level + 1) + ' = {}\\n                if (' + index + ' < source' + level + '.length) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[' + index + ']\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[' + index + '] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[' + index + '] = source' + level + '[' + index + ']\\n              count' + level + '++\\n            }\\n          ';\n          }\n\n          if (key) {\n            block = '\\n            if ((typeof source' + level + '[\\'' + key + '\\'] === \\'object\\'\\n                  && source' + level + '[\\'' + key + '\\'] !== null\\n                  && !Array.isArray(source' + level + '[\\'' + key + '\\']))\\n                || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n              source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || {}\\n              count' + (level + 1) + ' = 0\\n\\n              if (!target' + level + '.hasOwnProperty(\\'' + key + '\\')\\n                  || typeof target' + level + '[\\'' + key + '\\'] !== \\'object\\'\\n                  || target' + level + '[\\'' + key + '\\'] === null\\n                  || Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n                target' + (level + 1) + ' = {}\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n              } else {\\n                target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n                count' + (level + 1) + '++\\n              }\\n\\n              ' + block + '\\n\\n              if (count' + (level + 1) + ' > 0) {\\n                target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n                count' + level + '++\\n              }\\n\\n            } else {\\n              target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n              count' + level + '++\\n            }\\n          ';\n          }\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {}\n\n    /**\n     * items\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var schema = this.schema,\n          root = this.root,\n          level = this.level,\n          key = this.key,\n          index = this.index;\n      var items = schema.items;\n\n      var block = '';\n\n      if (items) {\n\n        if (Array.isArray(items)) {\n          // TODO\n          //\n          //\n          //\n          //\n          //\n          // ...\n\n        } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n          var _index = 'i' + (level + 1);\n          var initializer = new Initializer(items, { index: _index, root: root, level: level + 1 });\n\n          block += '\\n          var sLen = source' + (level + 1) + '.length || 0\\n          var tLen = target' + (level + 1) + '.length || 0\\n          var len = 0\\n\\n          if (sLen > len) { len = sLen }\\n          // THIS IS WRONG, CAUSED SIMPLE ARRAY INIT TO FAIL (OVERWRITE\\n          // EXISTING TARGET VALUES WITH UNDEFINED WHEN SOURCE IS SHORTER THAN\\n          // TARGET). LEAVING HERE UNTIL WE FINISH TESTING AND SEE WHY IT MIGHT\\n          // HAVE BEEN HERE IN THE FIRST PLACE.\\n          //\\n          // if (tLen > len) { len = tLen }\\n\\n          for (var ' + _index + ' = 0; ' + _index + ' < len; ' + _index + '++) {\\n            ' + initializer.compile() + '\\n          }\\n        ';\n        }\n\n        // root-level properties boilerplate\n        if (root === this) {\n          block = '\\n          if (Array.isArray(source)) {\\n            if (!Array.isArray(target)) {\\n              throw new Error(\\'?\\')\\n            }\\n\\n            source1 = source\\n            target1 = target\\n\\n            ' + block + '\\n          }\\n        ';\n\n          // nested properties boilerplate\n        } else {\n          block = '\\n          if (Array.isArray(source' + level + '[\\'' + key + '\\']) || !source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n\\n            source' + (level + 1) + ' = source' + level + '[\\'' + key + '\\'] || []\\n            count' + (level + 1) + ' = 0\\n\\n            if (!target' + level + '.hasOwnProperty(\\'' + key + '\\') || !Array.isArray(target' + level + '[\\'' + key + '\\'])) {\\n              target' + (level + 1) + ' = []\\n                if (source' + level + '.hasOwnProperty(\\'' + key + '\\')) {\\n                  count' + (level + 1) + '++\\n                }\\n\\n            } else {\\n              target' + (level + 1) + ' = target' + level + '[\\'' + key + '\\']\\n              count' + (level + 1) + '++\\n            }\\n\\n            ' + block + '\\n\\n            if (count' + (level + 1) + ' > 0) {\\n              target' + level + '[\\'' + key + '\\'] = target' + (level + 1) + '\\n              count' + level + '++\\n            }\\n\\n          } else {\\n            target' + level + '[\\'' + key + '\\'] = source' + level + '[\\'' + key + '\\']\\n            count' + level + '++\\n          }\\n        ';\n        }\n      }\n\n      return block;\n    }\n\n    /**\n     *\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {}\n  }], [{\n    key: 'compile',\n    value: function compile(schema) {\n      var initializer = new Initializer(schema);\n      var block = initializer.compile();\n\n      //console.log(beautify(block))\n      try {\n        return new Function('target', 'source', 'options', block);\n      } catch (e) {\n        console.log(e, e.stack);\n      }\n    }\n  }]);\n\n  return Initializer;\n}();\n\nmodule.exports = Initializer;\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPatch = __webpack_require__(32);\n\n/**\n * JSONDocument\n *\n * @class\n * JSONDocument is a high level interface that binds together all other features of\n * this package and provides the principle method of data modeling.\n */\n\nvar JSONDocument = function () {\n  _createClass(JSONDocument, null, [{\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      throw new Error('Schema must be defined by classes extending JSONDocument');\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} data\n     * @param {Object} options\n     */\n\n  }]);\n\n  function JSONDocument() {\n    var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, JSONDocument);\n\n    this.initialize(data, options);\n  }\n\n  /**\n   * Initialize\n   *\n   * @param {Object} data\n   * @param {Object} options\n   */\n\n\n  _createClass(JSONDocument, [{\n    key: 'initialize',\n    value: function initialize() {\n      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = this.constructor.schema;\n\n      schema.initialize(this, data, options);\n    }\n\n    /**\n     * Validate\n     *\n     * @param {JSONSchema} alternate - OPTIONAL alternate schema\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(alternate) {\n      var schema = this.constructor.schema;\n\n      return (alternate || schema).validate(this);\n    }\n\n    /**\n     * Patch\n     *\n     * @param {Array} ops\n     */\n\n  }, {\n    key: 'patch',\n    value: function patch(ops) {\n      var patch = new JSONPatch(ops);\n      patch.apply(this);\n    }\n\n    /**\n     * Select\n     */\n\n  }, {\n    key: 'select',\n    value: function select() {}\n\n    /**\n     * Project\n     *\n     * @description\n     * Given a mapping, return an object projected from the current instance.\n     *\n     * @example\n     * let schema = new JSONSchema({\n     *   properties: {\n     *     foo: { type: 'Array' }\n     *   }\n     * })\n     *\n     * let mapping = new JSONMapping({\n     *   '/foo/0': '/bar/baz'\n     * })\n     *\n     * class FooTracker extends JSONDocument {\n     *   static get schema () { return schema }\n     * }\n     *\n     * let instance = new FooTracker({ foo: ['qux'] })\n     * instance.project(mapping)\n     * // => { bar: { baz: 'qux' } }\n     *\n     * @param {JSONMapping} mapping\n     * @return {Object}\n     */\n\n  }, {\n    key: 'project',\n    value: function project(mapping) {\n      return mapping.project(this);\n    }\n\n    /**\n     * Serialize\n     *\n     * @param {Object} object\n     * @returns {string}\n     */\n\n  }], [{\n    key: 'serialize',\n    value: function serialize(object) {\n      return JSON.stringify(object);\n    }\n\n    /**\n     * Deserialize\n     *\n     * @param {string} data\n     * @return {*}\n     */\n\n  }, {\n    key: 'deserialize',\n    value: function deserialize(data) {\n      try {\n        return JSON.parse(data);\n      } catch (e) {\n        throw new Error('Failed to parse JSON');\n      }\n    }\n  }]);\n\n  return JSONDocument;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONDocument;\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * Modes\n */\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * Operations list\n */\nvar OPERATIONS = ['add', 'remove', 'replace', 'move', 'copy', 'test'];\n\n/**\n * Patch\n *\n * @class\n * Implements RFC 6902: JavaScript Object Notation (JSON) Patch\n * https://tools.ietf.org/html/rfc6902\n */\n\nvar JSONPatch = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Array} ops\n   */\n  function JSONPatch(ops) {\n    _classCallCheck(this, JSONPatch);\n\n    this.ops = ops || [];\n  }\n\n  /**\n   * Apply\n   *\n   * @todo handle errors/roll back\n   * @todo protect properties that are private in the schema\n   * @todo map JSON Pointers real property names\n   *\n   * @param {Object} target\n   */\n\n\n  _createClass(JSONPatch, [{\n    key: 'apply',\n    value: function apply(target) {\n      var _this = this;\n\n      this.ops.forEach(function (operation) {\n        var op = operation.op;\n\n        if (!op) {\n          throw new Error('Missing \"op\" in JSON Patch operation');\n        }\n\n        if (OPERATIONS.indexOf(op) === -1) {\n          throw new Error('Invalid \"op\" in JSON Patch operation');\n        }\n\n        if (!operation.path) {\n          throw new Error('Missing \"path\" in JSON Patch operation');\n        }\n\n        _this[op](operation, target);\n      });\n    }\n\n    /**\n     * Add\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'add',\n    value: function add(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch add operation');\n      }\n\n      var pointer = new JSONPointer(op.path, SILENT);\n      pointer.add(target, op.value);\n    }\n\n    /**\n     * Remove\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(op, target) {\n      var pointer = new JSONPointer(op.path);\n      pointer.remove(target);\n    }\n\n    /**\n     * Replace\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch replace operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      pointer.replace(target, op.value);\n    }\n\n    /**\n     * Move\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'move',\n    value: function move(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch move operation');\n      }\n\n      if (op.path.match(new RegExp('^' + op.from))) {\n        throw new Error('Invalid \"from\" in JSON Patch move operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      from.remove(target);\n      pointer.add(target, value);\n    }\n\n    /**\n     * Copy\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy(op, target) {\n      if (op.from === undefined) {\n        throw new Error('Missing \"from\" in JSON Patch copy operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var from = new JSONPointer(op.from);\n      var value = from.get(target);\n\n      pointer.add(target, value);\n    }\n\n    /**\n     * Test\n     *\n     * @param {Object} op\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'test',\n    value: function test(op, target) {\n      if (op.value === undefined) {\n        throw new Error('Missing \"value\" in JSON Patch test operation');\n      }\n\n      var pointer = new JSONPointer(op.path);\n      var value = pointer.get(target);\n\n      switch (_typeof(op.value)) {\n        //case 'string':\n        //case 'number':\n        //case 'boolean':\n        //  if (value !== op.value) {\n        //    throw new Error('Mismatching JSON Patch test value')\n        //  }\n        default:\n          if (value !== op.value) {\n            throw new Error('Mismatching JSON Patch test value');\n          }\n      }\n    }\n  }]);\n\n  return JSONPatch;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPatch;\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Mode enumeration\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar THROW = 0;\nvar RECOVER = 1;\nvar SILENT = 2;\n\n/**\n * JSONPointer\n *\n * @class\n * Implements RFC 6901: JavaScript Object Notation (JSON) Pointer\n * https://tools.ietf.org/html/rfc6901\n */\n\nvar JSONPointer = function () {\n\n  /**\n   * Constructor\n   */\n  function JSONPointer(expr, mode) {\n    _classCallCheck(this, JSONPointer);\n\n    this.expr = expr;\n    this.mode = mode || THROW;\n    this.tokens = expr && expr.charAt(0) === '#' ? this.parseURIFragmentIdentifier(expr) : this.parseJSONString(expr);\n  }\n\n  /**\n   * Escape\n   */\n\n\n  _createClass(JSONPointer, [{\n    key: 'escape',\n    value: function escape(expr) {\n      return expr.replace(/~/g, '~0').replace(/\\//g, '~1');\n    }\n\n    /**\n     * Unescape\n     */\n\n  }, {\n    key: 'unescape',\n    value: function unescape(expr) {\n      return expr.replace(/~1/g, '/').replace(/~0/g, '~');\n    }\n\n    /**\n     * Parse\n     */\n\n  }, {\n    key: 'parseJSONString',\n\n\n    /**\n     * Parse JSON String\n     *\n     * @description Parse an expression into a list of tokens\n     * @param {string} expr\n     * @returns {Array}\n     */\n    value: function parseJSONString(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr === '') {\n        return [];\n      }\n\n      if (expr.charAt(0) !== '/') {\n        throw new Error('Invalid JSON Pointer');\n      }\n\n      if (expr === '/') {\n        return [''];\n      }\n\n      return expr.substr(1).split('/').map(this.unescape);\n    }\n\n    /**\n     * To JSON String\n     *\n     * @description Render a JSON string representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toJSONString',\n    value: function toJSONString() {\n      return '/' + this.tokens.map(this.escape).join('/');\n    }\n\n    /**\n     * Parse URI Fragment Identifer\n     */\n\n  }, {\n    key: 'parseURIFragmentIdentifier',\n    value: function parseURIFragmentIdentifier(expr) {\n      if (typeof expr !== 'string') {\n        throw new Error('JSON Pointer must be a string');\n      }\n\n      if (expr.charAt(0) !== '#') {\n        throw new Error('Invalid JSON Pointer URI Fragment Identifier');\n      }\n\n      return this.parseJSONString(decodeURIComponent(expr.substr(1)));\n    }\n\n    /**\n     * To URI Fragment Identifier\n     *\n     * @description Render a URI Fragment Identifier representation of a pointer\n     * @returns {string}\n     */\n\n  }, {\n    key: 'toURIFragmentIdentifier',\n    value: function toURIFragmentIdentifier() {\n      var _this = this;\n\n      var value = this.tokens.map(function (token) {\n        return encodeURIComponent(_this.escape(token));\n      }).join('/');\n\n      return '#/' + value;\n    }\n\n    /**\n     * Get\n     *\n     * @description Get a value from the source object referenced by the pointer\n     * @param {Object} source\n     * @returns {*}\n     */\n\n  }, {\n    key: 'get',\n    value: function get(source) {\n      var current = source;\n      var tokens = this.tokens;\n\n      for (var i = 0; i < tokens.length; i++) {\n        if (!current || current[tokens[i]] === undefined) {\n          if (this.mode !== THROW) {\n            return undefined;\n          } else {\n            throw new Error('Invalid JSON Pointer reference');\n          }\n        }\n\n        current = current[tokens[i]];\n      }\n\n      return current;\n    }\n\n    /**\n     * Add\n     *\n     * @description Set a value on a target object referenced by the pointer. Put\n     * will insert an array element. To change an existing array elemnent, use\n     * `pointer.set()`\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'add',\n    value: function add(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      // iterate through the tokens\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        // set the property on the target location\n        if (i === tokens.length - 1) {\n          if (token === '-') {\n            current.push(value);\n          } else if (Array.isArray(current)) {\n            current.splice(token, 0, value);\n          } else if (value !== undefined) {\n            current[token] = value;\n          }\n\n          // handle missing target location based on \"mode\"\n        } else if (!current[token]) {\n          switch (this.mode) {\n            case THROW:\n              throw new Error('Invalid JSON Pointer reference');\n\n            case RECOVER:\n              current = current[token] = parseInt(token) ? [] : {};\n              break;\n\n            case SILENT:\n              return;\n\n            default:\n              throw new Error('Invalid pointer mode');\n          }\n\n          // reference the next object in the path\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Replace\n     *\n     * @description Set a value on a target object referenced by the pointer. Set will\n     * overwrite an existing array element at the target location.\n     * @param {Object} target\n     * @param {*} value\n     */\n\n  }, {\n    key: 'replace',\n    value: function replace(target, value) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (i === tokens.length - 1) {\n          current[token] = value;\n        } else if (!current[token]) {\n          current = current[token] = parseInt(token) ? [] : {};\n        } else {\n          current = current[token];\n        }\n      }\n    }\n\n    /**\n     * Del\n     *\n     * - if this is an array it should splice the value out\n     */\n\n  }, {\n    key: 'remove',\n    value: function remove(target) {\n      var tokens = this.tokens;\n      var current = target;\n\n      for (var i = 0; i < tokens.length; i++) {\n        var token = tokens[i];\n\n        if (current === undefined || current[token] === undefined) {\n          return undefined;\n        } else if (Array.isArray(current)) {\n          current.splice(token, 1);\n          return undefined;\n        } else if (i === tokens.length - 1) {\n          delete current[token];\n        }\n\n        current = current[token];\n      }\n\n      // delete from the target\n    }\n  }], [{\n    key: 'parse',\n    value: function parse(expr) {\n      return new JSONPointer(expr);\n    }\n  }]);\n\n  return JSONPointer;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONPointer;\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar JSONPointer = __webpack_require__(33);\n\n/**\n * JSONPointer mode\n */\nvar RECOVER = 1;\n\n/**\n * JSONMapping\n *\n * @class\n * Defines a means to declaratively translate between object\n * representations using JSON Pointer syntax.\n */\n\nvar JSONMapping = function () {\n\n  /**\n   * Constructor\n   *\n   * @description Translate pointers from JSON Strings into Pointer objects\n   * @param {Object} mapping\n   */\n  function JSONMapping(mapping) {\n    var _this = this;\n\n    _classCallCheck(this, JSONMapping);\n\n    Object.defineProperty(this, 'mapping', {\n      enumerable: false,\n      value: new Map()\n    });\n\n    Object.keys(mapping).forEach(function (key) {\n      var value = mapping[key];\n      _this.mapping.set(new JSONPointer(key, RECOVER), new JSONPointer(value, RECOVER));\n    });\n  }\n\n  /**\n   * Map\n   *\n   * @description Assign values from source to target by reading the mapping\n   * from right to left.\n   * @param {Object} target\n   * @param {Object} source\n   */\n\n\n  _createClass(JSONMapping, [{\n    key: 'map',\n    value: function map(target, source) {\n      this.mapping.forEach(function (right, left) {\n        left.add(target, right.get(source));\n      });\n    }\n\n    /**\n     * Project\n     *\n     * @description Assign values from source to target by reading the mapping\n     * from left to right.\n     * @param {Object} source\n     * @param {Object} target\n     */\n\n  }, {\n    key: 'project',\n    value: function project(source, target) {\n      this.mapping.forEach(function (right, left) {\n        right.add(target, left.get(source));\n      });\n    }\n  }]);\n\n  return JSONMapping;\n}();\n\n/**\n * Exports\n */\n\n\nmodule.exports = JSONMapping;\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Initializer = __webpack_require__(30);\nvar Validator = __webpack_require__(36);\n\n/**\n * JSONSchema\n *\n * @class\n * Compiles JSON Schema documents to an object with object initialization\n * and validation methods.\n */\n\nvar JSONSchema = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {Object} schema\n   */\n  function JSONSchema(schema) {\n    _classCallCheck(this, JSONSchema);\n\n    // TODO: optionally parse JSON string?\n    Object.assign(this, schema);\n\n    // add schema-derived initialize and validate methods\n    Object.defineProperties(this, {\n      initialize: {\n        enumerable: false,\n        writeable: false,\n        value: Initializer.compile(schema)\n      },\n      validate: {\n        enumerable: false,\n        writeable: false,\n        value: Validator.compile(schema)\n      }\n    });\n  }\n\n  /**\n   * Extend\n   *\n   * @description\n   * ...\n   * Dear future,\n   *\n   * This function was meticulously plagiarized from some curious amalgam of\n   * stackoverflow posts whilst dozing off at my keyboard, too deprived of REM-\n   * sleep to recurse unassisted. If it sucks, you have only yourself to blame.\n   *\n   * Goodnight.\n   *\n   * @param {Object} schema\n   * @returns {JSONSchema}\n   */\n\n\n  _createClass(JSONSchema, [{\n    key: 'extend',\n    value: function extend(schema) {\n      function isObject(data) {\n        return data && (typeof data === 'undefined' ? 'undefined' : _typeof(data)) === 'object' && data !== null && !Array.isArray(data);\n      }\n\n      function extender(target, source) {\n        var result = Object.assign({}, target);\n        if (isObject(target) && isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isObject(source[key])) {\n              if (!(key in target)) {\n                Object.assign(result, _defineProperty({}, key, source[key]));\n              } else {\n                result[key] = extender(target[key], source[key]);\n              }\n            } else {\n              Object.assign(result, _defineProperty({}, key, source[key]));\n            }\n          });\n        }\n        return result;\n      }\n\n      var descriptor = extender(this, schema);\n      return new JSONSchema(descriptor);\n    }\n  }]);\n\n  return JSONSchema;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JSONSchema;\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Module dependencies\n * @ignore\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar formats = __webpack_require__(29);\n\n/**\n * For variable iterator counter\n *\n * @type {number}\n */\nvar indexCount = 0;\n\n/**\n * Validator\n *\n * Compile an object describing a JSON Schema into a validation function.\n */\n\nvar Validator = function () {\n  _createClass(Validator, null, [{\n    key: 'compile',\n\n\n    /**\n     * Compile (static)\n     *\n     * @description\n     * Compile an object describing a JSON Schema into a validation function.\n     *\n     * @param {Object} schema\n     * @returns {Function}\n     */\n    value: function compile(schema) {\n      var validator = new Validator(schema);\n\n      var body = '\\n      // \"cursor\"\\n      let value = data\\n      let container\\n      let stack = []\\n      let top = -1\\n\\n      // error state\\n      let valid = true\\n      let errors = []\\n\\n      // complex schema state\\n      let initialValidity\\n      let anyValid\\n      let notValid\\n      let countOfValid\\n      let initialErrorCount\\n      let accumulatedErrorCount\\n\\n      // validation code\\n      ' + validator.compile() + '\\n\\n      // validation result\\n      return {\\n        valid,\\n        errors\\n      }\\n    ';\n\n      return new Function('data', body);\n    }\n\n    /**\n     * Return current iterator index counter and increase value\n     *\n     * @returns {number}\n     */\n\n  }, {\n    key: 'counter',\n    get: function get() {\n      return indexCount++;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param {Object} schema - object representation of a schema\n     * @param {string} options - compilation options\n     */\n\n  }]);\n\n  function Validator(schema) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Validator);\n\n    // assign schema to this\n    this.schema = schema;\n\n    // assign all options to this\n    Object.assign(this, options);\n\n    // ensure address is defined\n    if (!this.address) {\n      this.address = '';\n    }\n\n    // ensure require is boolean\n    if (this.require !== true) {\n      this.require = false;\n    }\n  }\n\n  /**\n   * Compile\n   *\n   * @description\n   * The instance compile method is \"dumb\". It only sequences invocation of\n   * more specific compilation methods. It generates code to\n   *\n   *  - read a value from input\n   *  - validate type(s) of input\n   *  - validate constraints described by various schema keywords\n   *\n   * Conditional logic related to code generation is pushed downsteam to\n   * type-specific methods.\n   */\n\n\n  _createClass(Validator, [{\n    key: 'compile',\n    value: function compile() {\n      var block = '';\n\n      if (this.require) {\n        block += this.required();\n      }\n\n      // type validation\n      block += this.type();\n\n      // type specific validation generators\n      // null and boolean are covered by this.type()\n      // integer should be covered by number and this.type()\n      block += this.array();\n      block += this.number();\n      block += this.object();\n      block += this.string();\n\n      // non-type-specific validation generators\n      block += this.enum();\n      block += this.anyOf();\n      block += this.allOf();\n      block += this.not();\n      block += this.oneOf();\n\n      return block;\n    }\n\n    /**\n     * push\n     */\n\n  }, {\n    key: 'push',\n    value: function push() {\n      return '\\n      stack.push(value)\\n      container = value\\n      top++\\n    ';\n    }\n\n    /**\n     * pop\n     */\n\n  }, {\n    key: 'pop',\n    value: function pop() {\n      return '\\n      if (stack.length > 1) {\\n        top--\\n        stack.pop()\\n      }\\n\\n      value = container = stack[top]\\n    ';\n    }\n\n    /**\n     * type\n     *\n     * @description\n     * > An instance matches successfully if its primitive type is one of the\n     * > types defined by keyword. Recall: \"number\" includes \"integer\".\n     * > JSON Schema Validation Section 5.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'type',\n    value: function type() {\n      var type = this.schema.type,\n          address = this.address;\n\n      var block = '';\n\n      if (type) {\n        var types = Array.isArray(type) ? type : [type];\n        var conditions = types.map(function (type) {\n          // TODO: can we make a mapping object for this to clean it up?\n          if (type === 'array') return '!Array.isArray(value)';\n          if (type === 'boolean') return 'typeof value !== \\'boolean\\'';\n          if (type === 'integer') return '!Number.isInteger(value)';\n          if (type === 'null') return 'value !== null';\n          if (type === 'number') return 'typeof value !== \\'number\\'';\n          if (type === 'object') return '(typeof value !== \\'object\\' || Array.isArray(value) || value === null)';\n          if (type === 'string') return 'typeof value !== \\'string\\'';\n        }).join(' && ');\n\n        block += '\\n      // ' + address + ' type checking\\n      if (value !== undefined && ' + conditions + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'type\\',\\n          message: \\'invalid type\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Type-specific validations\n     *\n     * Type checking is optional in JSON Schema, and a schema can allow\n     * multiple types. Generated code needs to apply type-specific validations\n     * only to appropriate values, and ignore everything else. Type validation\n     * itself is handled separately from other validation keywords.\n     *\n     * The methods `array`, `number`, `object`, `string` generate type-specific\n     * validation code blocks, wrapped in a conditional such that they will\n     * only be applied to values of that type.\n     *\n     * For example, the `number` method, given the schema\n     *\n     *     { minimum: 3 }\n     *\n     * will generate\n     *\n     *     if (typeof value === 'number') {\n     *       if (value < 3) {\n     *         valid = false\n     *         errors.push({ message: '...' })\n     *       }\n     *     }\n     *\n     * Integer values are also numbers, and are validated the same as numbers\n     * other than the type validation itself. Therefore no `integer` method is\n     * needed.\n     */\n\n    /**\n     * array\n     *\n     * @description\n     * Invoke methods for array-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to array values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'array',\n    value: function array() {\n      var keywords = ['additionalItems', 'items', 'minItems', 'maxItems', 'uniqueItems'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Array validations\\n       */\\n      if (Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * number\n     *\n     * @description\n     * Invoke methods for number-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to number values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'number',\n    value: function number() {\n      var keywords = ['minimum', 'maximum', 'multipleOf'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Number validations\\n       */\\n      if (typeof value === \\'number\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * object\n     *\n     * @description\n     * Invoke methods for object-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to object values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'object',\n    value: function object() {\n      var keywords = ['maxProperties', 'minProperties', 'additionalProperties', 'properties', 'patternProperties', 'dependencies', 'schemaDependencies', 'propertyDependencies'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * Object validations\\n       */\\n      if (typeof value === \\'object\\' && value !== null && !Array.isArray(value)) {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * string\n     *\n     * @description\n     * Invoke methods for string-specific keywords and wrap resulting code in\n     * type-checking conditional so that any resulting validations are only\n     * applied to string values.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'string',\n    value: function string() {\n      var keywords = ['maxLength', 'minLength', 'pattern', 'format'];\n      var validations = this.validations(keywords);\n      var block = '';\n\n      if (validations.length > 0) {\n        block += '\\n      /**\\n       * String validations\\n       */\\n      if (typeof value === \\'string\\') {\\n      ' + validations + '\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * validations\n     *\n     * @description\n     * Iterate over an array of keywords and invoke code generator methods\n     * for each. Concatenate the results together and return. Used by \"type\"\n     * methods such as this.array() and this.string()\n     *\n     * @param {Array} keywords\n     * @returns {string}\n     */\n\n  }, {\n    key: 'validations',\n    value: function validations(keywords) {\n      var _this = this;\n\n      var schema = this.schema;\n\n      var block = '';\n\n      var constraints = Object.keys(schema).filter(function (key) {\n        return keywords.indexOf(key) !== -1;\n      });\n\n      constraints.forEach(function (keyword) {\n        block += _this[keyword]();\n      });\n\n      return block;\n    }\n\n    /**\n     * enum\n     *\n     * @description\n     * > An instance validates successfully against this keyword if its value\n     * > is equal to one of the elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.5.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'enum',\n    value: function _enum() {\n      var enumerated = this.schema.enum,\n          address = this.address;\n\n      var conditions = ['value !== undefined'];\n      var block = '';\n\n      if (enumerated) {\n        enumerated.forEach(function (value) {\n          switch (typeof value === 'undefined' ? 'undefined' : _typeof(value)) {\n            case 'boolean':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'number':\n              conditions.push('value !== ' + value);\n              break;\n\n            case 'string':\n              conditions.push('value !== \"' + value + '\"');\n              break;\n\n            case 'object':\n              if (value === null) {\n                conditions.push('value !== null');\n              } else {\n                conditions.push('\\'' + JSON.stringify(value) + '\\' !== JSON.stringify(value)');\n              }\n              break;\n\n            default:\n              throw new Error('Things are not well in the land of enum');\n\n          }\n        });\n\n        block += '\\n      /**\\n       * Validate \"' + address + '\" enum\\n       */\\n      if (' + conditions.join(' && ') + ') {\\n        valid = false\\n        errors.push({\\n          keyword: \\'enum\\',\\n          message: JSON.stringify(value) + \\' is not an enumerated value\\'\\n        })\\n      }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * anyOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against at least one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.4\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'anyOf',\n    value: function anyOf() {\n      var anyOf = this.schema.anyOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(anyOf)) {\n        block += '\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        anyValid = false\\n      ';\n\n        anyOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          anyValid = true\\n        }\\n        ';\n        });\n\n        block += '\\n          if (anyValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * allOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against all schemas defined by this keyword's\n     * > value.\n     * > JSON Schema Validation Section 5.5.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'allOf',\n    value: function allOf() {\n      var allOf = this.schema.allOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(allOf)) {\n        allOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        ' + validator.compile() + '\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * oneOf\n     *\n     * @description\n     * > An instance validates successfully against this keyword if it\n     * > validates successfully against exactly one schema defined by this\n     * > keyword's value.\n     * > JSON Schema Validation Section 5.5.5\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'oneOf',\n    value: function oneOf() {\n      var oneOf = this.schema.oneOf,\n          address = this.address;\n\n      var block = '';\n\n      if (Array.isArray(oneOf)) {\n        block += '\\n        /**\\n         * Validate ' + address + ' oneOf\\n         */\\n        initialValidity = valid\\n        initialErrorCount = errors.length\\n        countOfValid = 0\\n      ';\n\n        oneOf.forEach(function (subschema) {\n          var validator = new Validator(subschema, { address: address });\n          block += '\\n        accumulatedErrorCount = errors.length\\n        ' + validator.compile() + '\\n        if (accumulatedErrorCount === errors.length) {\\n          countOfValid += 1\\n        }\\n        ';\n        });\n\n        block += '\\n          if (countOfValid === 1) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors.push({\\n              keyword: \\'oneOf\\',\\n              message: \\'what is a reasonable error message for this case?\\'\\n            })\\n          }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * not\n     *\n     * @description\n     * > An instance is valid against this keyword if it fails to validate\n     * > successfully against the schema defined by this keyword.\n     * > JSON Schema Validation Section 5.5.6\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'not',\n    value: function not() {\n      var not = this.schema.not,\n          address = this.address;\n\n      var block = '';\n\n      if ((typeof not === 'undefined' ? 'undefined' : _typeof(not)) === 'object' && not !== null && !Array.isArray(not)) {\n        var subschema = not;\n        var validator = new Validator(subschema, { address: address });\n\n        block += '\\n        /**\\n         * NOT\\n         */\\n        if (value !== undefined) {\\n          initialValidity = valid\\n          initialErrorCount = errors.length\\n          notValid = true\\n\\n          accumulatedErrorCount = errors.length\\n\\n          ' + validator.compile() + '\\n\\n          if (accumulatedErrorCount === errors.length) {\\n            notValid = false\\n          }\\n\\n          if (notValid === true) {\\n            valid = initialValidity\\n            errors = errors.slice(0, initialErrorCount)\\n          } else {\\n            valid = false\\n            errors = errors.slice(0, initialErrorCount)\\n            errors.push({\\n              keyword: \\'not\\',\\n              message: \\'hmm...\\'\\n            })\\n          }\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * properties\n     *\n     * @description\n     * Iterate over the `properties` schema property if it is an object. For each\n     * key, initialize a new Validator for the subschema represented by the property\n     * value and invoke compile. Append the result of compiling each subschema to\n     * the block of code being generated.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'properties',\n    value: function properties() {\n      var schema = this.schema,\n          address = this.address;\n      var properties = schema.properties,\n          required = schema.required;\n\n      var block = this.push();\n\n      // ensure the value of \"required\" schema property is an array\n      required = Array.isArray(required) ? required : [];\n\n      if ((typeof properties === 'undefined' ? 'undefined' : _typeof(properties)) === 'object') {\n        Object.keys(properties).forEach(function (key) {\n          var subschema = properties[key];\n          var isRequired = required.indexOf(key) !== -1;\n          // TODO\n          // how should we be calculating these things? should be json pointer?\n          // needs a separate function\n          var pointer = [address, key].filter(function (segment) {\n            return !!segment;\n          }).join('.');\n          var validation = new Validator(subschema, { address: pointer, require: isRequired });\n\n          // read the value\n          block += '\\n        value = container[\\'' + key + '\\']\\n        ';\n\n          block += validation.compile();\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Other Properties\n     *\n     * @description\n     * This method is not for a keyword. It wraps validations for\n     * patternProperties and additionalProperties in a single iteration over\n     * an object-type value's properties.\n     *\n     * It should only be invoked once for a given subschema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'otherProperties',\n    value: function otherProperties() {\n      return '\\n      /**\\n       * Validate Other Properties\\n       */\\n      ' + this.push() + '\\n\\n      for (let key in container) {\\n        value = container[key]\\n        matched = false\\n\\n        ' + this.patternValidations() + '\\n        ' + this.additionalValidations() + '\\n      }\\n\\n      ' + this.pop() + '\\n    ';\n    }\n\n    /**\n     * Pattern Validations\n     *\n     * @description\n     * Generate validation code from a subschema for properties matching a\n     * regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternValidations',\n    value: function patternValidations() {\n      var patternProperties = this.schema.patternProperties;\n\n      var block = '';\n\n      if ((typeof patternProperties === 'undefined' ? 'undefined' : _typeof(patternProperties)) === 'object') {\n        Object.keys(patternProperties).forEach(function (pattern) {\n          var subschema = patternProperties[pattern];\n          var validator = new Validator(subschema);\n          block += '\\n          if (key.match(\\'' + pattern + '\\')) {\\n            matched = true\\n            ' + validator.compile() + '\\n          }\\n        ';\n        });\n      }\n\n      return block;\n    }\n\n    /**\n     * Additional Validations\n     *\n     * @description\n     * Generate validation code, either from a subschema for properties not\n     * defined in the schema, or to disallow properties not defined in the\n     * schema.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalValidations',\n    value: function additionalValidations() {\n      var _schema = this.schema,\n          properties = _schema.properties,\n          additionalProperties = _schema.additionalProperties,\n          address = this.address;\n\n      var validations = '';\n      var block = '';\n\n      // catch additional unmatched properties\n      var conditions = ['matched !== true'];\n\n      // ignore defined properties\n      Object.keys(properties || {}).forEach(function (key) {\n        conditions.push('key !== \\'' + key + '\\'');\n      });\n\n      // validate additional properties\n      if ((typeof additionalProperties === 'undefined' ? 'undefined' : _typeof(additionalProperties)) === 'object') {\n        var subschema = additionalProperties;\n        var validator = new Validator(subschema, { address: address + '[APKey]' });\n        block += '\\n        // validate additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          ' + validator.compile() + '\\n        }\\n      ';\n      }\n\n      // error for additional properties\n      if (additionalProperties === false) {\n        block += '\\n        // validate non-presence of additional properties\\n        if (' + conditions.join(' && ') + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalProperties\\',\\n            message: key + \\' is not a defined property\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * patternProperties\n     *\n     * @description\n     * Generate validation code for properties matching a pattern\n     * defined by the property name (key), which must be a string\n     * representing a valid regular expression.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'patternProperties',\n    value: function patternProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * additionalProperties\n     *\n     * @description\n     * Generate validation code for additional properties not defined\n     * in the schema, or disallow additional properties if the value of\n     * `additionalProperties` in the schema is `false`.\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalProperties',\n    value: function additionalProperties() {\n      var block = '';\n\n      if (!this.otherPropertiesCalled) {\n        this.otherPropertiesCalled = true;\n        block += this.otherProperties();\n      }\n\n      return block;\n    }\n\n    /**\n     * minProperties\n     *\n     * @description\n     * > An object instance is valid against \"minProperties\" if its number of\n     * > properties is greater than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minProperties',\n    value: function minProperties() {\n      var minProperties = this.schema.minProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min properties\\n        if (Object.keys(value).length < ' + minProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minProperties\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxProperties\n     *\n     * @description\n     * > An object instance is valid against \"maxProperties\" if its number of\n     * > properties is less than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.4.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxProperties',\n    value: function maxProperties() {\n      var maxProperties = this.schema.maxProperties,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max properties\\n        if (Object.keys(value).length > ' + maxProperties + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxProperties\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Dependencies\n     *\n     * @description\n     * > For all (name, schema) pair of schema dependencies, if the instance has\n     * > a property by this name, then it must also validate successfully against\n     * > the schema.\n     * >\n     * > Note that this is the instance itself which must validate successfully,\n     * > not the value associated with the property name.\n     * >\n     * > For each (name, propertyset) pair of property dependencies, if the\n     * > instance has a property by this name, then it must also have properties\n     * > with the same names as propertyset.\n     * > JSON Schema Validation Section 5.4.5.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'dependencies',\n    value: function dependencies() {\n      var dependencies = this.schema.dependencies,\n          address = this.address;\n\n\n      var block = this.push();\n\n      if ((typeof dependencies === 'undefined' ? 'undefined' : _typeof(dependencies)) === 'object') {\n        Object.keys(dependencies).forEach(function (key) {\n          var dependency = dependencies[key];\n          var conditions = [];\n\n          if (Array.isArray(dependency)) {\n            dependency.forEach(function (item) {\n              conditions.push('container[\\'' + item + '\\'] === undefined');\n            });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined && (' + conditions.join(' || ') + ')) {\\n              valid = false\\n              errors.push({\\n                keyword: \\'dependencies\\',\\n                message: \\'unmet dependencies\\'\\n              })\\n            }\\n          ';\n          } else if ((typeof dependency === 'undefined' ? 'undefined' : _typeof(dependency)) === 'object') {\n            var subschema = dependency;\n            var validator = new Validator(subschema, { address: address });\n\n            block += '\\n            if (container[\\'' + key + '\\'] !== undefined) {\\n              ' + validator.compile() + '\\n            }\\n          ';\n          }\n        });\n      }\n\n      block += this.pop();\n\n      return block;\n    }\n\n    /**\n     * Required\n     *\n     * @description\n     * > An object instance is valid against this keyword if its property set\n     * > contains all elements in this keyword's array value.\n     * > JSON Schema Validation Section 5.4.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'required',\n    value: function required() {\n      var properties = this.schema.properties,\n          address = this.address;\n\n      var block = '';\n\n      block += '\\n      // validate ' + address + ' presence\\n      if (value === undefined) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'required\\',\\n          message: \\'is required\\'\\n        })\\n      }\\n    ';\n\n      return block;\n    }\n\n    /**\n     * additionalItems\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'additionalItems',\n    value: function additionalItems() {\n      var _schema2 = this.schema,\n          items = _schema2.items,\n          additionalItems = _schema2.additionalItems,\n          address = this.address;\n\n      var block = '';\n\n      if (additionalItems === false && Array.isArray(items)) {\n        block += '\\n        // don\\'t allow additional items\\n        if (value.length > ' + items.length + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'additionalItems\\',\\n            message: \\'additional items not allowed\\'\\n          })\\n        }\\n      ';\n      }\n\n      if ((typeof additionalItems === 'undefined' ? 'undefined' : _typeof(additionalItems)) === 'object' && additionalItems !== null && Array.isArray(items)) {\n        var subschema = additionalItems;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // additional items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = ' + items.length + '; i' + counter + ' <= container.length; i' + counter + '++) {\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * Items\n     *\n     * @description\n     * > Successful validation of an array instance with regards to these two\n     * > keywords is determined as follows: if \"items\" is not present, or its\n     * > value is an object, validation of the instance always succeeds,\n     * > regardless of the value of \"additionalItems\"; if the value of\n     * > \"additionalItems\" is boolean value true or an object, validation of\n     * > the instance always succeeds; if the value of \"additionalItems\" is\n     * > boolean value false and the value of \"items\" is an array, the\n     * > instance is valid if its size is less than, or equal to, the size\n     * > of \"items\".\n     * > JSON Schema Validation Section 5.3.1\n     *\n     * Code to generate\n     *\n     *     // this outer conditional is generated by this.array()\n     *     if (Array.isArray(value) {\n     *       let parent = value\n     *       for (let i = 0; i < parent.length; i++) {\n     *         value = parent[i]\n     *         // other validation code depending on value here\n     *       }\n     *       value = parent\n     *     }\n     *\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'items',\n    value: function items() {\n      var items = this.schema.items,\n          address = this.address;\n\n      var block = '';\n\n      // if items is an array\n      if (Array.isArray(items)) {\n        block += this.push();\n\n        items.forEach(function (item, index) {\n          var subschema = item;\n          var validator = new Validator(subschema, { address: address + '[' + index + ']' });\n\n          block += '\\n          // item #' + index + '\\n          value = container[' + index + ']\\n          ' + validator.compile() + '\\n        ';\n        });\n\n        block += this.pop();\n\n        // if items is an object\n      } else if ((typeof items === 'undefined' ? 'undefined' : _typeof(items)) === 'object' && items !== null) {\n        var subschema = items;\n        var validator = new Validator(subschema);\n        var counter = Validator.counter;\n\n        block += '\\n        // items\\n        ' + this.push() + '\\n\\n        for (var i' + counter + ' = 0; i' + counter + ' < container.length; i' + counter + '++) {\\n          // read array element\\n          value = container[i' + counter + ']\\n          ' + validator.compile() + '\\n        }\\n\\n        ' + this.pop() + '\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minItems\n     *\n     * @description\n     * > An array instance is valid against \"minItems\" if its size is greater\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minItems',\n    value: function minItems() {\n      var minItems = this.schema.minItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' min items\\n        if (value.length < ' + minItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minItems\\',\\n            message: \\'too few properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxItems\n     *\n     * @description\n     * > An array instance is valid against \"maxItems\" if its size is less\n     * > than, or equal to, the value of this keyword.\n     * > JSON Schema Validation Section 5.3.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxItems',\n    value: function maxItems() {\n      var maxItems = this.schema.maxItems,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' max items\\n        if (value.length > ' + maxItems + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxItems\\',\\n            message: \\'too many properties\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * uniqueItems\n     *\n     * @description\n     * > If this keyword has boolean value false, the instance validates\n     * > successfully. If it has boolean value true, the instance validates\n     * > successfully if all of its elements are unique.\n     * > JSON Schema Validation Section 5.3.4\n     *\n     * TODO\n     * optimize\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'uniqueItems',\n    value: function uniqueItems() {\n      var uniqueItems = this.schema.uniqueItems,\n          address = this.address;\n\n      var block = '';\n\n      if (uniqueItems === true) {\n        block += '\\n        // validate ' + address + ' unique items\\n        let values = value.map(v => JSON.stringify(v)) // TODO: optimize\\n        let set = new Set(values)\\n        if (values.length !== set.size) {\\n          valid = false\\n          errors.push({\\n            keyword: \\'uniqueItems\\',\\n            message: \\'items must be unique\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n\n    /**\n     * minLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is\n     * > greater than, or equal to, the value of this keyword. The length of\n     * > a string instance is defined as the number of its characters as\n     * > defined by RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minLength',\n    value: function minLength() {\n      var minLength = this.schema.minLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate minLength\\n        if (Array.from(value).length < ' + minLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minLength\\',\\n            message: \\'too short\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * maxLength\n     *\n     * @description\n     * > A string instance is valid against this keyword if its length is less\n     * > than, or equal to, the value of this keyword. The length of a string\n     * > instance is defined as the number of its characters as defined by\n     * > RFC 4627 [RFC4627].\n     * > JSON Schema Validation Section 5.2.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maxLength',\n    value: function maxLength() {\n      var maxLength = this.schema.maxLength,\n          address = this.address;\n\n\n      return '\\n        // ' + address + ' validate maxLength\\n        if (Array.from(value).length > ' + maxLength + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maxLength\\',\\n            message: \\'too long\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Pattern\n     *\n     * @description\n     * > A string instance is considered valid if the regular expression\n     * > matches the instance successfully.\n     * > JSON Schema Validation Section 5.2.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'pattern',\n    value: function pattern() {\n      var pattern = this.schema.pattern,\n          address = this.address;\n\n\n      if (pattern) {\n        return '\\n          // ' + address + ' validate pattern\\n          if (!value.match(new RegExp(\\'' + pattern + '\\'))) {\\n            valid = false\\n            errors.push({\\n              keyword: \\'pattern\\',\\n              message: \\'does not match the required pattern\\'\\n            })\\n          }\\n      ';\n      }\n    }\n\n    /**\n     * Format\n     *\n     * @description\n     * > Structural validation alone may be insufficient to validate that\n     * > an instance meets all the requirements of an application. The\n     * > \"format\" keyword is defined to allow interoperable semantic\n     * > validation for a fixed subset of values which are accurately\n     * > described by authoritative resources, be they RFCs or other\n     * > external specifications.\n     * > JSON Schema Validation Section 7.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'format',\n    value: function format() {\n      var format = this.schema.format,\n          address = this.address;\n\n      var matcher = formats.resolve(format);\n\n      if (matcher) {\n        return '\\n      // ' + address + ' validate format\\n      if (!value.match(' + matcher + ')) {\\n        valid = false\\n        errors.push({\\n          keyword: \\'format\\',\\n          message: \\'is not \"' + format + '\" format\\'\\n        })\\n      }\\n      ';\n      }\n    }\n\n    /**\n     * Minimum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMinimum\": if \"exclusiveMinimum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is greater\n     * > than, or equal to, the value of \"minimum\"; if \"exclusiveMinimum\" is\n     * > present and has boolean value true, the instance is valid if it is\n     * > strictly greater than the value of \"minimum\".\n     * > JSON Schema Validation Section 5.1.3\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'minimum',\n    value: function minimum() {\n      var _schema3 = this.schema,\n          minimum = _schema3.minimum,\n          exclusiveMinimum = _schema3.exclusiveMinimum,\n          address = this.address;\n\n      var operator = exclusiveMinimum === true ? '<=' : '<';\n\n      return '\\n        // ' + address + ' validate minimum\\n        if (value ' + operator + ' ' + minimum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'minimum\\',\\n            message: \\'too small\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * Maximum\n     *\n     * @description\n     * > Successful validation depends on the presence and value of\n     * > \"exclusiveMaximum\": if \"exclusiveMaximum\" is not present, or has\n     * > boolean value false, then the instance is valid if it is lower than,\n     * > or equal to, the value of \"maximum\"; if \"exclusiveMaximum\" has\n     * > boolean value true, the instance is valid if it is strictly lower\n     * > than the value of \"maximum\".\n     * > JSON Schema Validation Section 5.1.2\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'maximum',\n    value: function maximum() {\n      var _schema4 = this.schema,\n          maximum = _schema4.maximum,\n          exclusiveMaximum = _schema4.exclusiveMaximum,\n          address = this.address;\n\n      var operator = exclusiveMaximum === true ? '>=' : '>';\n\n      return '\\n        // ' + address + ' validate maximum\\n        if (value ' + operator + ' ' + maximum + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'maximum\\',\\n            message: \\'too large\\'\\n          })\\n        }\\n    ';\n    }\n\n    /**\n     * multipleOf\n     *\n     * @description\n     * > A numeric instance is valid against \"multipleOf\" if the result of\n     * > the division of the instance by this keyword's value is an integer.\n     * > JSON Schema Validation Section 5.1.1\n     *\n     * @returns {string}\n     */\n\n  }, {\n    key: 'multipleOf',\n    value: function multipleOf() {\n      var multipleOf = this.schema.multipleOf;\n\n      var block = '';\n\n      if (typeof multipleOf === 'number') {\n        var length = multipleOf.toString().length;\n        var decimals = length - multipleOf.toFixed(0).length - 1;\n        var pow = decimals > 0 ? Math.pow(10, decimals) : 1;\n        var condition = void 0;\n\n        if (decimals > 0) {\n          condition = '(value * ' + pow + ') % ' + multipleOf * pow + ' !== 0';\n        } else {\n          condition = 'value % ' + multipleOf + ' !== 0';\n        }\n\n        block += '\\n        if (' + condition + ') {\\n          valid = false\\n          errors.push({\\n            keyword: \\'multipleOf\\',\\n            message: \\'must be a multiple of ' + multipleOf + '\\'\\n          })\\n        }\\n      ';\n      }\n\n      return block;\n    }\n  }]);\n\n  return Validator;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = Validator;\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * @module JSON Object Signing and Encryption (JOSE)\n */\nvar JWA = __webpack_require__(38);\nvar JWK = __webpack_require__(57);\nvar JWKSet = __webpack_require__(60);\nvar JWT = __webpack_require__(62);\nvar JWS = __webpack_require__(67);\nvar Base64URLSchema = __webpack_require__(64);\nvar JOSEHeaderSchema = __webpack_require__(66);\nvar JWKSchema = __webpack_require__(58);\nvar JWKSetSchema = __webpack_require__(61);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JWTSchema = __webpack_require__(63);\n\n/**\n * Export\n */\nmodule.exports = {\n  JWA: JWA,\n  JWK: JWK,\n  JWKSet: JWKSet,\n  JWT: JWT,\n  JWS: JWS,\n  Base64URLSchema: Base64URLSchema,\n  JOSEHeaderSchema: JOSEHeaderSchema,\n  JWKSchema: JWKSchema,\n  JWKSetSchema: JWKSetSchema,\n  JWTClaimsSetSchema: JWTClaimsSetSchema,\n  JWTSchema: JWTSchema\n};\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n *\n * TODO\n * - switch between Node.js webcrypto package and browser implementation\n */\nvar base64url = __webpack_require__(39);\nvar supportedAlgorithms = __webpack_require__(46);\n\nvar _require = __webpack_require__(55),\n    NotSupportedError = _require.NotSupportedError;\n\n/**\n * JWA\n * https://tools.ietf.org/html/rfc7518\n */\n\n\nvar JWA = function () {\n  function JWA() {\n    _classCallCheck(this, JWA);\n  }\n\n  _createClass(JWA, null, [{\n    key: 'sign',\n\n\n    /**\n     * Sign\n     *\n     * @description\n     * Create a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} key\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n    value: function sign(alg, key, data) {\n      // normalize the algorithm\n      var normalizedAlgorithm = supportedAlgorithms.normalize('sign', alg);\n\n      // validate algorithm is supported\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // validate type of key\n      // TODO\n      //  - is the key suitable for the algorithm?\n      //  - does that get validated in webcrypto?\n      //if (key instanceof CryptoKey) {\n      //  return Promise.reject(new InvalidKeyError())\n      //}\n\n      // sign the data\n      return normalizedAlgorithm.sign(key, data);\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature.\n     *\n     * @param {string} alg\n     * @param {CryptoKey} privateKey\n     * @param {string|Buffer} signature\n     * @param {string|Buffer} data\n     *\n     * @return {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(alg, key, signature, data) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('verify', alg);\n\n      if (normalizedAlgorithm instanceof Error) {\n        return Promise.reject(new NotSupportedError(alg));\n      }\n\n      // TODO\n      // validate publicKey\n\n      // verify the signature\n      return normalizedAlgorithm.verify(key, signature, data);\n    }\n\n    /**\n     * Encrypt\n     */\n\n    /**\n     * Decrypt\n     */\n\n    /**\n     * Import\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var normalizedAlgorithm = supportedAlgorithms.normalize('importKey', key.alg);\n      return normalizedAlgorithm.importKey(key);\n    }\n  }]);\n\n  return JWA;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWA;\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(40).default;\nmodule.exports.default = module.exports;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = __webpack_require__(45);\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(42)\nvar ieee754 = __webpack_require__(43)\nvar isArray = __webpack_require__(44)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Local dependencies\n */\nvar None = __webpack_require__(47);\nvar HMAC = __webpack_require__(48);\nvar RSASSA_PKCS1_v1_5 = __webpack_require__(52);\nvar SupportedAlgorithms = __webpack_require__(53);\n\n/**\n * Register Supported Algorithms\n */\nvar supportedAlgorithms = new SupportedAlgorithms();\n\n/**\n * Sign\n */\nsupportedAlgorithms.define('HS256', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'sign', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'sign', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'sign', {})\n//supportedAlgorithms.define('ES384', 'sign', {})\n//supportedAlgorithms.define('ES512', 'sign', {})\n//supportedAlgorithms.define('PS256', 'sign', {})\n//supportedAlgorithms.define('PS384', 'sign', {})\n//supportedAlgorithms.define('PS512', 'sign', {})\n\nsupportedAlgorithms.define('none', 'sign', new None({\n  // nothing goes here\n}));\n\n/**\n * Verify\n */\nsupportedAlgorithms.define('HS256', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('HS384', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('HS512', 'verify', new HMAC({\n  name: 'HMAC',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\nsupportedAlgorithms.define('RS256', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'verify', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n//supportedAlgorithms.define('ES256', 'verify', {})\n//supportedAlgorithms.define('ES384', 'verify', {})\n//supportedAlgorithms.define('ES512', 'verify', {})\n//supportedAlgorithms.define('PS256', 'verify', {})\n//supportedAlgorithms.define('PS384', 'verify', {})\n//supportedAlgorithms.define('PS512', 'verify', {})\n\nsupportedAlgorithms.define('none', 'verify', new None({\n  // nothing goes here\n}));\n\nsupportedAlgorithms.define('RS256', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-256'\n  }\n}));\n\nsupportedAlgorithms.define('RS384', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-384'\n  }\n}));\n\nsupportedAlgorithms.define('RS512', 'importKey', new RSASSA_PKCS1_v1_5({\n  name: 'RSASSA-PKCS1-v1_5',\n  hash: {\n    name: 'SHA-512'\n  }\n}));\n\n/**\n * Export\n */\nmodule.exports = supportedAlgorithms;\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * None\n */\nvar None = function () {\n  function None() {\n    _classCallCheck(this, None);\n  }\n\n  _createClass(None, [{\n    key: 'sign',\n\n    /**\n     * sign\n     */\n    value: function sign() {\n      return Promise.resolve('');\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      // this will never get called. but you looked.\n    }\n  }]);\n\n  return None;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = None;\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * HMAC with SHA-2 Functions\n */\n\nvar HMAC = function () {\n\n  /**\n   * Constructor\n   *\n   * @param {string} bitlength\n   */\n  function HMAC(params) {\n    _classCallCheck(this, HMAC);\n\n    this.params = params;\n  }\n\n  /**\n   * Sign\n   *\n   * @description\n   * Generate a hash-based message authentication code for a\n   * given input and key. Enforce the key length is equal to\n   * or greater than the bitlength.\n   *\n   * @param {CryptoKey} key\n   * @param {string} data\n   *\n   * @returns {string}\n   */\n\n\n  _createClass(HMAC, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO: validate key length\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * Verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {string} signature\n     * @param {string} data\n     *\n     * @returns {Boolean}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * Assert Sufficient Key Length\n     *\n     * @description Assert that the key length is sufficient\n     * @param {string} key\n     */\n\n  }, {\n    key: 'assertSufficientKeyLength',\n    value: function assertSufficientKeyLength(key) {\n      if (key.length < this.bitlength) {\n        throw new Error('The key is too short.');\n      }\n    }\n  }]);\n\n  return HMAC;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = HMAC;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"crypto\"]; }());\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar TextEncoder = global.TextEncoder ? global.TextEncoder // browser\n: __webpack_require__(51).TextEncoder; // node shim\nmodule.exports = TextEncoder;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20)))\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports) {\n\n(function() { module.exports = window[\"TextEncoder\"]; }());\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(Buffer) {\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar base64url = __webpack_require__(39);\nvar crypto = __webpack_require__(49);\nvar TextEncoder = __webpack_require__(50);\n\n/**\n * RSASSA-PKCS1-v1_5\n */\n\nvar RSASSA_PKCS1_v1_5 = function () {\n\n  /**\n   * constructor\n   *\n   * @param {string} bitlength\n   */\n  function RSASSA_PKCS1_v1_5(params) {\n    _classCallCheck(this, RSASSA_PKCS1_v1_5);\n\n    this.params = params;\n  }\n\n  /**\n   * sign\n   *\n   * @description\n   * Generate a digital signature for a given input and private key.\n   *\n   * @param {CryptoKey} key\n   * @param {BufferSource} data\n   *\n   * @returns {Promise}\n   */\n\n\n  _createClass(RSASSA_PKCS1_v1_5, [{\n    key: 'sign',\n    value: function sign(key, data) {\n      var algorithm = this.params;\n\n      // TODO\n      //if (!this.sufficientKeySize()) {\n      //  return Promise.reject(\n      //    new Error(\n      //      'A key size of 2048 bits or larger must be used with RSASSA-PKCS1-v1_5'\n      //    )\n      //  )\n      //}\n\n      data = new TextEncoder().encode(data);\n\n      return crypto.subtle.sign(algorithm, key, data).then(function (signature) {\n        return base64url(Buffer.from(signature));\n      });\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a digital signature for a given input and private key.\n     *\n     * @param {CryptoKey} key\n     * @param {BufferSource} signature\n     * @param {BufferSource} data\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, signature, data) {\n      var algorithm = this.params;\n\n      if (typeof signature === 'string') {\n        signature = Uint8Array.from(base64url.toBuffer(signature));\n      }\n\n      if (typeof data === 'string') {\n        data = new TextEncoder().encode(data);\n      }\n      // ...\n\n      return crypto.subtle.verify(algorithm, key, signature, data);\n    }\n\n    /**\n     * importKey\n     *\n     * @param {JWK} key\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'importKey',\n    value: function importKey(key) {\n      var jwk = Object.assign({}, key);\n      var algorithm = this.params;\n      var usages = key['key_ops'] || [];\n\n      if (key.use === 'sig') {\n        usages.push('verify');\n      }\n\n      if (key.use === 'enc') {\n        // TODO: handle encryption keys\n        return Promise.resolve(key);\n      }\n\n      if (key.key_ops) {\n        usages = key.key_ops;\n      }\n\n      return crypto.subtle.importKey('jwk', jwk, algorithm, true, usages).then(function (cryptoKey) {\n        Object.defineProperty(jwk, 'cryptoKey', {\n          enumerable: false,\n          value: cryptoKey\n        });\n\n        return jwk;\n      });\n    }\n  }]);\n\n  return RSASSA_PKCS1_v1_5;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = RSASSA_PKCS1_v1_5;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar NotSupportedError = __webpack_require__(54);\n\n/**\n * Operations\n */\nvar operations = ['sign', 'verify', 'encrypt', 'decrypt', 'importKey'];\n\n/**\n * SupportedAlgorithms\n */\n\nvar SupportedAlgorithms = function () {\n\n  /**\n   * constructor\n   */\n  function SupportedAlgorithms() {\n    var _this = this;\n\n    _classCallCheck(this, SupportedAlgorithms);\n\n    operations.forEach(function (op) {\n      _this[op] = {};\n    });\n  }\n\n  /**\n   * Supported Operations\n   */\n\n\n  _createClass(SupportedAlgorithms, [{\n    key: 'define',\n\n\n    /**\n     * define\n     *\n     * @description\n     * Register Web Crypto API algorithm parameter for an algorithm\n     * and operation.\n     *\n     * @param {string} alg\n     * @param {string} op\n     * @param {Object} argument\n     */\n    value: function define(alg, op, argument) {\n      var registeredAlgorithms = this[op];\n      registeredAlgorithms[alg] = argument;\n    }\n\n    /**\n     * normalize\n     *\n     * @description\n     * Map JWA alg name to Web Crypto API algorithm parameter\n     *\n     * @param {string} op\n     * @param {Object} alg\n     *\n     * @returns {Object}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(op, alg) {\n      var registeredAlgorithms = this[op];\n\n      if (!registeredAlgorithms) {\n        return new SyntaxError(); // what kind of error should this be?\n      }\n\n      var argument = registeredAlgorithms[alg];\n\n      if (!argument) {\n        return new NotSupportedError(alg);\n      }\n\n      return argument;\n    }\n  }], [{\n    key: 'operations',\n    get: function get() {\n      return operations;\n    }\n  }]);\n\n  return SupportedAlgorithms;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = SupportedAlgorithms;\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * NotSupportedError\n */\nvar NotSupportedError = function (_Error) {\n  _inherits(NotSupportedError, _Error);\n\n  function NotSupportedError(alg) {\n    _classCallCheck(this, NotSupportedError);\n\n    var _this = _possibleConstructorReturn(this, (NotSupportedError.__proto__ || Object.getPrototypeOf(NotSupportedError)).call(this));\n\n    _this.message = alg + \" is not a supported algorithm\";\n    return _this;\n  }\n\n  return NotSupportedError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = NotSupportedError;\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = {\n  DataError: __webpack_require__(56),\n  NotSupportedError: __webpack_require__(54)\n};\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * DataError\n */\nvar DataError = function (_Error) {\n  _inherits(DataError, _Error);\n\n  function DataError(message) {\n    _classCallCheck(this, DataError);\n\n    return _possibleConstructorReturn(this, (DataError.__proto__ || Object.getPrototypeOf(DataError)).call(this, message));\n  }\n\n  return DataError;\n}(Error);\n\n/**\n * Export\n */\n\n\nmodule.exports = DataError;\n\n/***/ }),\n/* 57 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSchema = __webpack_require__(58);\nvar JWA = __webpack_require__(38);\n\n/**\n * JWK Class\n */\n\nvar JWK = function (_JSONDocument) {\n  _inherits(JWK, _JSONDocument);\n\n  function JWK() {\n    _classCallCheck(this, JWK);\n\n    return _possibleConstructorReturn(this, (JWK.__proto__ || Object.getPrototypeOf(JWK)).apply(this, arguments));\n  }\n\n  _createClass(JWK, null, [{\n    key: 'importKey',\n\n\n    /**\n     * importKey\n     *\n     * TODO:\n     * - should this be on JWA?\n     */\n    value: function importKey(jwk) {\n      return JWA.importKey(jwk);\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * Schema\n     */\n    get: function get() {\n      return JWKSchema;\n    }\n  }]);\n\n  return JWK;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWK;\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n * @ignore\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar _require2 = __webpack_require__(59),\n    BASE64_REGEXP = _require2.BASE64_REGEXP;\n\n/**\n * JWK Schema\n */\n\n\nvar JWKSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    kty: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['RSA', 'EC', 'oct'] // other values MAY be used\n    },\n\n    use: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['sig', 'enc'] // other values MAY be used\n    },\n\n    key_ops: {\n      type: 'array',\n      //format: 'case-sensitive',\n      items: {\n        enum: ['sign', 'verify', 'encrypt', 'decrypt', 'wrapKey', 'unwrapKey', 'deriveKey', 'deriveBits'] // other values MAY be used\n      }\n    },\n\n    alg: {\n      type: 'string',\n      //format: 'case-sensitive',\n      enum: ['HS256', 'HS384', 'HS512', 'RS256', 'RS384', 'RS512', 'ES256', 'ES384', 'ES512', 'PS256', 'PS384', 'PS512', 'none'] // other values MAY be used\n    },\n\n    kid: {\n      type: 'string'\n    },\n\n    x5u: {\n      type: 'string'\n      //format: 'url'\n    },\n\n    x5c: {\n      type: 'array'\n      //format: BASE64_REGEXP\n    },\n\n    x5t: {\n      type: 'string'\n      //format: BASE64_REGEXP\n    }\n\n    //'x5t#S256': {\n    //  type: 'string',\n    //  //format: BASE64_REGEXP\n    //}\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSchema;\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Package dependencies\n */\nvar _require = __webpack_require__(28),\n    Formats = _require.Formats;\n\n/**\n * Format extensions\n */\n\n\nFormats.register('StringOrURI', new RegExp());\nFormats.register('NumericDate', new RegExp());\nFormats.register('URI', new RegExp());\nFormats.register('url', new RegExp());\nFormats.register('base64', new RegExp());\nFormats.register('base64url', new RegExp());\nFormats.register('MediaType', new RegExp());\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWKSetSchema = __webpack_require__(61);\nvar JWK = __webpack_require__(57);\n\n/**\n * JWKSet\n *\n * @class\n * JWKSet represents a JSON Web Key Set as described in Section 5 of RFC 7517:\n * https://tools.ietf.org/html/rfc7517#section-5\n */\n\nvar JWKSet = function (_JSONDocument) {\n  _inherits(JWKSet, _JSONDocument);\n\n  function JWKSet() {\n    _classCallCheck(this, JWKSet);\n\n    return _possibleConstructorReturn(this, (JWKSet.__proto__ || Object.getPrototypeOf(JWKSet)).apply(this, arguments));\n  }\n\n  _createClass(JWKSet, null, [{\n    key: 'importKeys',\n\n\n    /**\n     * importKeys\n     */\n    value: function importKeys(jwks) {\n      var validation = this.schema.validate(jwks);\n\n      if (!validation.valid) {\n        return Promise.reject(new Error('Invalid JWKSet: ' + JSON.stringify(validation, null, 2)));\n      }\n\n      if (!jwks.keys) {\n        return Promise.reject(new Error('Cannot import JWKSet: keys property is empty'));\n      }\n\n      var imported = void 0,\n          importing = void 0;\n\n      try {\n        imported = new JWKSet(jwks);\n        importing = jwks.keys.map(function (key) {\n          return JWK.importKey(key);\n        });\n      } catch (err) {\n        return Promise.reject(err);\n      }\n\n      return Promise.all(importing).then(function (keys) {\n        imported.keys = keys;\n        return imported;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWKSetSchema;\n    }\n  }]);\n\n  return JWKSet;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWKSet;\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\nvar JWKSchema = __webpack_require__(58);\n\n/**\n * JWKSetSchema\n */\nvar JWKSetSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    keys: {\n      type: 'array',\n      items: JWKSchema\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWKSetSchema;\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\n\nvar _require = __webpack_require__(28),\n    JSONDocument = _require.JSONDocument;\n\nvar JWTSchema = __webpack_require__(63);\nvar JWS = __webpack_require__(67);\nvar DataError = __webpack_require__(56);\n\n/**\n * JWT\n */\n\nvar JWT = function (_JSONDocument) {\n  _inherits(JWT, _JSONDocument);\n\n  function JWT() {\n    _classCallCheck(this, JWT);\n\n    return _possibleConstructorReturn(this, (JWT.__proto__ || Object.getPrototypeOf(JWT)).apply(this, arguments));\n  }\n\n  _createClass(JWT, [{\n    key: 'isJWE',\n\n\n    /**\n     * isJWE\n     */\n    value: function isJWE() {\n      return !!this.header.enc;\n    }\n\n    /**\n     * resolveKeys\n     */\n\n  }, {\n    key: 'resolveKeys',\n    value: function resolveKeys(jwks) {\n      var kid = this.header.kid;\n      var keys = void 0,\n          match = void 0;\n\n      // treat an array as the \"keys\" property of a JWK Set\n      if (Array.isArray(jwks)) {\n        keys = jwks;\n      }\n\n      // presence of keys indicates object is a JWK Set\n      if (jwks.keys) {\n        keys = jwks.keys;\n      }\n\n      // wrap a plain object they is not a JWK Set in Array\n      if (!jwks.keys && (typeof jwks === 'undefined' ? 'undefined' : _typeof(jwks)) === 'object') {\n        keys = [jwks];\n      }\n\n      // ensure there are keys to search\n      if (!keys) {\n        throw new DataError('Invalid JWK argument');\n      }\n\n      // match by \"kid\" or \"use\" header\n      if (kid) {\n        match = keys.find(function (jwk) {\n          return jwk.kid === kid;\n        });\n      } else {\n        match = keys.find(function (jwk) {\n          return jwk.use === 'sig';\n        });\n      }\n\n      // assign matching key to JWT and return a boolean\n      if (match) {\n        this.key = match.cryptoKey;\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode() {\n      // validate\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      var token = this;\n\n      if (this.isJWE()) {\n        return JWE.encrypt(token);\n      } else {\n        return JWS.sign(token);\n      }\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     * Verify a decoded JWT instance\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify() {\n      var validation = this.validate();\n\n      if (!validation.valid) {\n        return Promise.reject(validation);\n      }\n\n      return JWS.verify(this);\n    }\n  }], [{\n    key: 'decode',\n\n\n    /**\n     * decode\n     *\n     * @description\n     * Decode a JSON Web Token\n     *\n     * @param {string} data\n     * @returns {JWT}\n     */\n    value: function decode(data) {\n      var ExtendedJWT = this;\n      var jwt = void 0;\n\n      if (typeof data !== 'string') {\n        throw new DataError('JWT must be a string');\n      }\n\n      // JSON of Flattened JSON Serialization\n      if (data.startsWith('{')) {\n        try {\n          data = JSON.parse(data, function () {});\n        } catch (error) {\n          throw new DataError('Invalid JWT serialization');\n        }\n\n        if (data.signatures || data.recipients) {\n          data.serialization = 'json';\n        } else {\n          data.serialization = 'flattened';\n        }\n\n        jwt = new ExtendedJWT(data, { filter: false });\n\n        // Compact Serialization\n      } else {\n        try {\n          var serialization = 'compact';\n          var segments = data.split('.');\n          var length = segments.length;\n\n          if (length !== 3 && length !== 5) {\n            throw new Error('Malformed JWT');\n          }\n\n          var header = JSON.parse(base64url.decode(segments[0]));\n\n          // JSON Web Signature\n          if (length === 3) {\n            var type = 'JWS';\n            var payload = JSON.parse(base64url.decode(segments[1]));\n            var signature = segments[2];\n\n            jwt = new ExtendedJWT({ type: type, segments: segments, header: header, payload: payload, signature: signature, serialization: serialization }, { filter: false });\n          }\n\n          // JSON Web Encryption\n          if (length === 5) {\n            //let type = 'JWE'\n            //let [protected, encryption_key, iv, ciphertext, tag] = segments\n\n            //jwt = new ExtendedJWT({\n            //  type,\n            //  protected: base64url.decode(JSON.parse(protected)),\n            //  encryption_key,\n            //  iv,\n            //  ciphertext,\n            //  tag,\n            //  serialization\n            //})\n          }\n        } catch (error) {\n          throw new DataError('Invalid JWT compact serialization');\n        }\n      }\n\n      return jwt;\n    }\n\n    /**\n     * encode\n     *\n     * @description\n     * Encode a JSON Web Token\n     *\n     * @param {Object} header\n     * @param {Object} payload\n     * @param {CryptoKey} key\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'encode',\n    value: function encode(header, payload, key) {\n      var jwt = new JWT(header, payload);\n      return jwt.encode(key);\n    }\n\n    /**\n     * verify\n     *\n     * @description\n     *\n     * @param {CryptoKey} key\n     * @param {string} token\n     *\n     * @returns {Promise}\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(key, token) {\n      var jwt = JWT.decode(token);\n      jwt.key = key;\n      return jwt.verify().then(function (verified) {\n        return jwt;\n      });\n    }\n  }, {\n    key: 'schema',\n\n\n    /**\n     * schema\n     */\n    get: function get() {\n      return JWTSchema;\n    }\n  }]);\n\n  return JWT;\n}(JSONDocument);\n\n/**\n * Export\n */\n\n\nmodule.exports = JWT;\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar Base64URLSchema = __webpack_require__(64);\nvar JWTClaimsSetSchema = __webpack_require__(65);\nvar JOSEHeaderSchema = __webpack_require__(66);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTSchema\n *\n * @description\n * This schema represents all the things a deserialized JWT can be, i.e.,\n * either a JWS or JWE, and any serialization of them. Validation of well-\n * formedness for a given serialization is accomplished at the time of\n * encoding.\n */\n\n\nvar JWTSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * type\n     */\n    type: {\n      type: 'string',\n      enum: ['JWS', 'JWE']\n    },\n\n    /**\n     * segments\n     */\n    segments: {\n      type: 'array'\n    },\n\n    /**\n     * header\n     */\n    header: JOSEHeaderSchema,\n\n    /**\n     * protected\n     */\n    protected: JOSEHeaderSchema,\n\n    /**\n     * unprotected\n     */\n    unprotected: JOSEHeaderSchema,\n\n    /**\n     * iv\n     */\n    iv: Base64URLSchema,\n\n    /**\n     * aad\n     */\n    aad: Base64URLSchema,\n\n    /**\n     * ciphertext\n     */\n    ciphertext: Base64URLSchema,\n\n    /**\n     * tag\n     */\n    tag: Base64URLSchema,\n\n    /**\n     * recipients\n     */\n    recipients: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          header: JOSEHeaderSchema,\n          encrypted_key: Base64URLSchema\n        }\n      }\n    },\n\n    /**\n     * payload\n     */\n    payload: JWTClaimsSetSchema,\n\n    /**\n     * signatures\n     */\n    signatures: {\n      type: 'array',\n      items: {\n        type: 'object',\n        properties: {\n          protected: JOSEHeaderSchema,\n          header: JOSEHeaderSchema,\n          signature: Base64URLSchema,\n          key: { type: 'object' }\n        }\n      }\n    },\n\n    /**\n     * signature\n     */\n    signature: Base64URLSchema,\n\n    /**\n     * verified\n     */\n    verified: {\n      type: 'boolean',\n      default: false\n    },\n\n    /**\n     * key\n     */\n    key: {\n      type: 'object'\n    },\n\n    /**\n     * serialization\n     */\n    serialization: {\n      type: 'string',\n      enum: ['compact', 'json', 'flattened'],\n      default: 'compact'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTSchema;\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * Base64URLSchema\n */\n\n\nvar Base64URLSchema = new JSONSchema({\n  type: 'string',\n  format: 'base64url'\n});\n\n/**\n * Export\n */\nmodule.exports = Base64URLSchema;\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JWTClaimsSetSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-4\n *\n * 4.  JWT Claims\n *\n *   The JWT Claims Set represents a JSON object whose members are the\n *   claims conveyed by the JWT.  The Claim Names within a JWT Claims Set\n *   MUST be unique; JWT parsers MUST either reject JWTs with duplicate\n *   Claim Names or use a JSON parser that returns only the lexically last\n *   duplicate member name, as specified in Section 15.12 (\"The JSON\n *   Object\") of ECMAScript 5.1 [ECMAScript].\n *\n *   The set of claims that a JWT must contain to be considered valid is\n *   context dependent and is outside the scope of this specification.\n *   Specific applications of JWTs will require implementations to\n *   understand and process some claims in particular ways.  However, in\n *   the absence of such requirements, all claims that are not understood\n *   by implementations MUST be ignored.\n *\n *   There are three classes of JWT Claim Names: Registered Claim Names,\n *   Public Claim Names, and Private Claim Names.\n */\n\n\nvar JWTClaimsSetSchema = new JSONSchema({\n  properties: {\n\n    /**\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1\n     *\n     * 4.1.  Registered Claim Names\n     *\n     *   The following Claim Names are registered in the IANA \"JSON Web Token\n     *   Claims\" registry established by Section 10.1.  None of the claims\n     *   defined below are intended to be mandatory to use or implement in all\n     *   cases, but rather they provide a starting point for a set of useful,\n     *   interoperable claims.  Applications using JWTs should define which\n     *   specific claims they use and when they are required or optional.  All\n     *   the names are short because a core goal of JWTs is for the\n     *   representation to be compact.\n     */\n\n    /**\n     * iss\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.1\n     *\n     * 4.1.1.  \"iss\" (Issuer) Claim\n     *\n     *   The \"iss\" (issuer) claim identifies the principal that issued the\n     *   JWT.  The processing of this claim is generally application specific.\n     *   The \"iss\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    iss: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * sub\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.2\n     *\n     * 4.1.2.  \"sub\" (Subject) Claim\n     *\n     *   The \"sub\" (subject) claim identifies the principal that is the\n     *   subject of the JWT.  The claims in a JWT are normally statements\n     *   about the subject.  The subject value MUST either be scoped to be\n     *   locally unique in the context of the issuer or be globally unique.\n     *   The processing of this claim is generally application specific.  The\n     *   \"sub\" value is a case-sensitive string containing a StringOrURI\n     *   value.  Use of this claim is OPTIONAL.\n     */\n    sub: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * aud\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.3\n     *\n     * 4.1.3.  \"aud\" (Audience) Claim\n     *\n     *   The \"aud\" (audience) claim identifies the recipients that the JWT is\n     *   intended for.  Each principal intended to process the JWT MUST\n     *   identify itself with a value in the audience claim.  If the principal\n     *   processing the claim does not identify itself with a value in the\n     *   \"aud\" claim when this claim is present, then the JWT MUST be\n     *   rejected.  In the general case, the \"aud\" value is an array of case-\n     *   sensitive strings, each containing a StringOrURI value.  In the\n     *   special case when the JWT has one audience, the \"aud\" value MAY be a\n     *   single case-sensitive string containing a StringOrURI value.  The\n     *   interpretation of audience values is generally application specific.\n     *   Use of this claim is OPTIONAL.\n     */\n    aud: {\n      type: ['array', 'string'],\n      format: 'StringOrURI',\n      items: {\n        format: 'StringOrURI'\n      }\n    },\n\n    /**\n     * exp\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.4\n     *\n     * 4.1.4.  \"exp\" (Expiration Time) Claim\n     *\n     *   The \"exp\" (expiration time) claim identifies the expiration time on\n     *   or after which the JWT MUST NOT be accepted for processing.  The\n     *   processing of the \"exp\" claim requires that the current date/time\n     *   MUST be before the expiration date/time listed in the \"exp\" claim.\n     *\n     *   Implementers MAY provide for some small leeway, usually no more than\n     *   a few minutes, to account for clock skew.  Its value MUST be a number\n     *   containing a NumericDate value.  Use of this claim is OPTIONAL.\n     *\n     */\n    exp: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * nbf\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.5\n     *\n     * 4.1.5.  \"nbf\" (Not Before) Claim\n     *\n     *   The \"nbf\" (not before) claim identifies the time before which the JWT\n     *   MUST NOT be accepted for processing.  The processing of the \"nbf\"\n     *   claim requires that the current date/time MUST be after or equal to\n     *   the not-before date/time listed in the \"nbf\" claim.  Implementers MAY\n     *   provide for some small leeway, usually no more than a few minutes, to\n     *   account for clock skew.  Its value MUST be a number containing a\n     *   NumericDate value.  Use of this claim is OPTIONAL.\n     */\n    nbf: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * iat\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.6\n     *\n     * 4.1.6.  \"iat\" (Issued At) Claim\n     *\n     *   The \"iat\" (issued at) claim identifies the time at which the JWT was\n     *   issued.  This claim can be used to determine the age of the JWT.  Its\n     *   value MUST be a number containing a NumericDate value.  Use of this\n     *   claim is OPTIONAL.\n     */\n    iat: {\n      type: 'number',\n      format: 'NumericDate'\n    },\n\n    /**\n     * jti\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-4.1.7\n     *\n     * 4.1.7.  \"jti\" (JWT ID) Claim\n     *\n     *   The \"jti\" (JWT ID) claim provides a unique identifier for the JWT.\n     *   The identifier value MUST be assigned in a manner that ensures that\n     *   there is a negligible probability that the same value will be\n     *   accidentally assigned to a different data object; if the application\n     *   uses multiple issuers, collisions MUST be prevented among values\n     *   produced by different issuers as well.  The \"jti\" claim can be used\n     *   to prevent the JWT from being replayed.  The \"jti\" value is a case-\n     *   sensitive string.  Use of this claim is OPTIONAL.\n     */\n    jti: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JWTClaimsSetSchema;\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/**\n * Dependencies\n */\nvar JWKSchema = __webpack_require__(58);\n\nvar _require = __webpack_require__(28),\n    JSONSchema = _require.JSONSchema;\n\n/**\n * JOSEHeaderSchema\n *\n * JSON Web Token (JWT)\n * https://tools.ietf.org/html/rfc7519#section-5\n *\n * 5.  JOSE Header\n *\n *   For a JWT object, the members of the JSON object represented by the\n *   JOSE Header describe the cryptographic operations applied to the JWT\n *   and optionally, additional properties of the JWT.  Depending upon\n *   whether the JWT is a JWS or JWE, the corresponding rules for the JOSE\n *   Header values apply.\n */\n\n\nvar JOSEHeaderSchema = new JSONSchema({\n  type: 'object',\n  properties: {\n\n    /**\n     * typ\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.1\n     *\n     * 5.1.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter defined by [JWS] and [JWE] is used\n     *   by JWT applications to declare the media type [IANA.MediaTypes] of\n     *   this complete JWT.  This is intended for use by the JWT application\n     *   when values that are not JWTs could also be present in an application\n     *   data structure that can contain a JWT object; the application can use\n     *   this value to disambiguate among the different kinds of objects that\n     *   might be present.  It will typically not be used by applications when\n     *   it is already known that the object is a JWT.  This parameter is\n     *   ignored by JWT implementations; any processing of this parameter is\n     *   performed by the JWT application.  If present, it is RECOMMENDED that\n     *   its value be \"JWT\" to indicate that this object is a JWT.  While\n     *   media type names are not case sensitive, it is RECOMMENDED that \"JWT\"\n     *   always be spelled using uppercase characters for compatibility with\n     *   legacy implementations.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.9\n     *\n     * 4.1.9.  \"typ\" (Type) Header Parameter\n     *\n     *   The \"typ\" (type) Header Parameter is used by JWS applications to\n     *   declare the media type [IANA.MediaTypes] of this complete JWS.  This\n     *   is intended for use by the application when more than one kind of\n     *   object could be present in an application data structure that can\n     *   contain a JWS; the application can use this value to disambiguate\n     *   among the different kinds of objects that might be present.  It will\n     *   typically not be used by applications when the kind of object is\n     *   already known.  This parameter is ignored by JWS implementations; any\n     *   processing of this parameter is performed by the JWS application.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"typ\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"typ\" value not containing a\n     *   '/'.  For instance, a \"typ\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     *   The \"typ\" value \"JOSE\" can be used by applications to indicate that\n     *   this object is a JWS or JWE using the JWS Compact Serialization or\n     *   the JWE Compact Serialization.  The \"typ\" value \"JOSE+JSON\" can be\n     *   used by applications to indicate that this object is a JWS or JWE\n     *   using the JWS JSON Serialization or the JWE JSON Serialization.\n     *   Other type values can also be used by applications.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.11\n     *\n     * 4.1.11.  \"typ\" (Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"typ\" Header Parameter defined in Section 4.1.9 of [JWS], except\n     *   that the type is that of this complete JWE.\n     */\n    typ: {\n      type: 'string'\n    },\n\n    /**\n     * cty\n     *\n     * JSON Web Token (JWT)\n     * https://tools.ietf.org/html/rfc7519#section-5.2\n     *\n     * 5.2.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter defined by [JWS] and [JWE]\n     *   is used by this specification to convey structural information about\n     *   the JWT.\n     *\n     *   In the normal case in which nested signing or encryption operations\n     *   are not employed, the use of this Header Parameter is NOT\n     *   RECOMMENDED.  In the case that nested signing or encryption is\n     *   employed, this Header Parameter MUST be present; in this case, the\n     *   value MUST be \"JWT\", to indicate that a Nested JWT is carried in this\n     *   JWT.  While media type names are not case sensitive, it is\n     *   RECOMMENDED that \"JWT\" always be spelled using uppercase characters\n     *   for compatibility with legacy implementations.  See Appendix A.2 for\n     *   an example of a Nested JWT.\n     *\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.10\n     *\n     * 4.1.10.  \"cty\" (Content Type) Header Parameter\n     *\n     *   The \"cty\" (content type) Header Parameter is used by JWS applications\n     *   to declare the media type [IANA.MediaTypes] of the secured content\n     *   (the payload).  This is intended for use by the application when more\n     *   than one kind of object could be present in the JWS Payload; the\n     *   application can use this value to disambiguate among the different\n     *   kinds of objects that might be present.  It will typically not be\n     *   used by applications when the kind of object is already known.  This\n     *   parameter is ignored by JWS implementations; any processing of this\n     *   parameter is performed by the JWS application.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     *   Per RFC 2045 [RFC2045], all media type values, subtype values, and\n     *   parameter names are case insensitive.  However, parameter values are\n     *   case sensitive unless otherwise specified for the specific parameter.\n     *\n     *   To keep messages compact in common situations, it is RECOMMENDED that\n     *   producers omit an \"application/\" prefix of a media type value in a\n     *   \"cty\" Header Parameter when no other '/' appears in the media type\n     *   value.  A recipient using the media type value MUST treat it as if\n     *   \"application/\" were prepended to any \"cty\" value not containing a\n     *   '/'.  For instance, a \"cty\" value of \"example\" SHOULD be used to\n     *   represent the \"application/example\" media type, whereas the media\n     *   type \"application/example;part=\"1/2\"\" cannot be shortened to\n     *   \"example;part=\"1/2\"\".\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.12\n     *\n     * 4.1.12.  \"cty\" (Content Type) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"cty\" Header Parameter defined in Section 4.1.10 of [JWS], except\n     *   that the type is that of the secured content (the plaintext).\n     */\n    cty: {\n      type: 'string',\n      enum: ['JWT']\n    },\n\n    /**\n     * alg\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   The \"alg\" (algorithm) Header Parameter identifies the cryptographic\n     *   algorithm used to secure the JWS.  The JWS Signature value is not\n     *   valid if the \"alg\" value does not represent a supported algorithm or\n     *   if there is not a key for use with that algorithm associated with the\n     *   party that digitally signed or MACed the content.  \"alg\" values\n     *   should either be registered in the IANA \"JSON Web Signature and\n     *   Encryption Algorithms\" registry established by [JWA] or be a value\n     *   that contains a Collision-Resistant Name.  The \"alg\" value is a case-\n     *   sensitive ASCII string containing a StringOrURI value.  This Header\n     *   Parameter MUST be present and MUST be understood and processed by\n     *   implementations.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 3.1 of [JWA].\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.1\n     *\n     * 4.1.1.  \"alg\" (Algorithm) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"alg\" Header Parameter defined in Section 4.1.1 of [JWS], except\n     *   that the Header Parameter identifies the cryptographic algorithm used\n     *   to encrypt or determine the value of the CEK.  The encrypted content\n     *   is not usable if the \"alg\" value does not represent a supported\n     *   algorithm, or if the recipient does not have a key that can be used\n     *   with that algorithm.\n     *\n     *   A list of defined \"alg\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 4.1 of [JWA].\n     */\n    alg: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * jku\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.2\n     *\n     * 4.1.2.  \"jku\" (JWK Set URL) Header Parameter (JWS)\n     *\n     *   The \"jku\" (JWK Set URL) Header Parameter is a URI [RFC3986] that\n     *   refers to a resource for a set of JSON-encoded public keys, one of\n     *   which corresponds to the key used to digitally sign the JWS.  The\n     *   keys MUST be encoded as a JWK Set [JWK].  The protocol used to\n     *   acquire the resource MUST provide integrity protection; an HTTP GET\n     *   request to retrieve the JWK Set MUST use Transport Layer Security\n     *   (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n     *   validated, as per Section 6 of RFC 6125 [RFC6125].  Also, see\n     *   Section 8 on TLS requirements.  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.4\n     *\n     * 4.1.4.  \"jku\" (JWK Set URL) Header Parameter (JWE)\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jku\" Header Parameter defined in Section 4.1.2 of [JWS], except\n     *   that the JWK Set resource contains the public key to which the JWE\n     *   was encrypted; this can be used to determine the private key needed\n     *   to decrypt the JWE.\n     */\n    jku: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * jwk\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.3\n     *\n     * 4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   The \"jwk\" (JSON Web Key) Header Parameter is the public key that\n     *   corresponds to the key used to digitally sign the JWS.  This key is\n     *   represented as a JSON Web Key [JWK].  Use of this Header Parameter is\n     *   OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.5\n     *\n     * 4.1.5.  \"jwk\" (JSON Web Key) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"jwk\" Header Parameter defined in Section 4.1.3 of [JWS], except\n     *   that the key is the public key to which the JWE was encrypted; this\n     *   can be used to determine the private key needed to decrypt the JWE.\n     */\n    //jwk: JWKSchema,\n\n    /**\n     * kid\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.4\n     *\n     * 4.1.4.  \"kid\" (Key ID) Header Parameter\n     *\n     *   The \"kid\" (key ID) Header Parameter is a hint indicating which key\n     *   was used to secure the JWS.  This parameter allows originators to\n     *   explicitly signal a change of key to recipients.  The structure of\n     *   the \"kid\" value is unspecified.  Its value MUST be a case-sensitive\n     *   string.  Use of this Header Parameter is OPTIONAL.\n     *\n     *   When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n     *   parameter value.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.6\n     *\n     * 4.1.6.  \"kid\" (Key ID) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"kid\" Header Parameter defined in Section 4.1.4 of [JWS], except\n     *   that the key hint references the public key to which the JWE was\n     *   encrypted; this can be used to determine the private key needed to\n     *   decrypt the JWE.  This parameter allows originators to explicitly\n     *   signal a change of key to JWE recipients.\n     */\n    kid: {\n      type: 'string'\n    },\n\n    /**\n     * x5u\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.5\n     *\n     * 4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   The \"x5u\" (X.509 URL) Header Parameter is a URI [RFC3986] that refers\n     *   to a resource for the X.509 public key certificate or certificate\n     *   chain [RFC5280] corresponding to the key used to digitally sign the\n     *   JWS.  The identified resource MUST provide a representation of the\n     *   certificate or certificate chain that conforms to RFC 5280 [RFC5280]\n     *   in PEM-encoded form, with each certificate delimited as specified in\n     *   Section 6.1 of RFC 4945 [RFC4945].  The certificate containing the\n     *   public key corresponding to the key used to digitally sign the JWS\n     *   MUST be the first certificate.  This MAY be followed by additional\n     *   certificates, with each subsequent certificate being the one used to\n     *   certify the previous one.  The protocol used to acquire the resource\n     *   MUST provide integrity protection; an HTTP GET request to retrieve\n     *   the certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n     *   the server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n     *   Also, see Section 8 on TLS requirements.  Use of this Header\n     *   Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.7\n     *\n     * 4.1.7.  \"x5u\" (X.509 URL) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5u\" Header Parameter defined in Section 4.1.5 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5u: {\n      type: 'string',\n      format: 'URI'\n    },\n\n    /**\n     * x5c\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.6\n     *\n     * 4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   The \"x5c\" (X.509 certificate chain) Header Parameter contains the\n     *   X.509 public key certificate or certificate chain [RFC5280]\n     *   corresponding to the key used to digitally sign the JWS.  The\n     *   certificate or certificate chain is represented as a JSON array of\n     *   certificate value strings.  Each string in the array is a\n     *   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded) DER\n     *   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n     *   the public key corresponding to the key used to digitally sign the\n     *   JWS MUST be the first certificate.  This MAY be followed by\n     *   additional certificates, with each subsequent certificate being the\n     *   one used to certify the previous one.  The recipient MUST validate\n     *   the certificate chain according to RFC 5280 [RFC5280] and consider\n     *   the certificate or certificate chain to be invalid if any validation\n     *   failure occurs.  Use of this Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.8\n     *\n     * 4.1.8.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5c\" Header Parameter defined in Section 4.1.6 of [JWS], except\n     *   that the X.509 public key certificate or certificate chain [RFC5280]\n     *   contains the public key to which the JWE was encrypted; this can be\n     *   used to determine the private key needed to decrypt the JWE.\n     */\n    x5c: {\n      type: 'array',\n      items: {\n        type: 'string',\n        format: 'base64'\n      }\n    },\n\n    /**\n     * x5t\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.7\n     *\n     * 4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   The \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n     *   base64url-encoded SHA-1 thumbprint (a.k.a. digest) of the DER\n     *   encoding of the X.509 certificate [RFC5280] corresponding to the key\n     *   used to digitally sign the JWS.  Note that certificate thumbprints\n     *   are also sometimes known as certificate fingerprints.  Use of this\n     *   Header Parameter is OPTIONAL.\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.9\n     *\n     * 4.1.9.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t\" Header Parameter defined in Section 4.1.7 of [JWS], except\n     *   that the certificate referenced by the thumbprint contains the public\n     *   key to which the JWE was encrypted; this can be used to determine the\n     *   private key needed to decrypt the JWE.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     */\n    x5t: {\n      type: 'string',\n      format: 'base64url'\n    },\n\n    /**\n     * x5t#S256\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.8\n     *\n     * 4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *         Parameter\n     *\n     *   The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n     *   Parameter is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n     *   of the DER encoding of the X.509 certificate [RFC5280] corresponding\n     *   to the key used to digitally sign the JWS.  Note that certificate\n     *   thumbprints are also sometimes known as certificate fingerprints.\n     *   Use of this Header Parameter is OPTIONAL.\n     *\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.10\n     *\n     * 4.1.10.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n     *          Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"x5t#S256\" Header Parameter defined in Section 4.1.8 of [JWS],\n     *   except that the certificate referenced by the thumbprint contains the\n     *   public key to which the JWE was encrypted; this can be used to\n     *   determine the private key needed to decrypt the JWE.  Note that\n     *   certificate thumbprints are also sometimes known as certificate\n     *   fingerprints.\n     */\n    //'x5t#S256': {\n    //  type: 'string',\n    //  format: 'base64url'\n    //},\n\n    /**\n     * crit\n     *\n     * JSON Web Signature (JWS)\n     * https://tools.ietf.org/html/rfc7515#section-4.1.11\n     *\n     * 4.1.11.  \"crit\" (Critical) Header Parameter\n     *\n     *   The \"crit\" (critical) Header Parameter indicates that extensions to\n     *   this specification and/or [JWA] are being used that MUST be\n     *   understood and processed.  Its value is an array listing the Header\n     *   Parameter names present in the JOSE Header that use those extensions.\n     *   If any of the listed extension Header Parameters are not understood\n     *   and supported by the recipient, then the JWS is invalid.  Producers\n     *   MUST NOT include Header Parameter names defined by this specification\n     *   or [JWA] for use with JWS, duplicate names, or names that do not\n     *   occur as Header Parameter names within the JOSE Header in the \"crit\"\n     *   list.  Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n     *   value.  Recipients MAY consider the JWS to be invalid if the critical\n     *   list contains any Header Parameter names defined by this\n     *   specification or [JWA] for use with JWS or if any other constraints\n     *   on its use are violated.  When used, this Header Parameter MUST be\n     *   integrity protected; therefore, it MUST occur only within the JWS\n     *   Protected Header.  Use of this Header Parameter is OPTIONAL.  This\n     *   Header Parameter MUST be understood and processed by implementations.\n     *\n     *   An example use, along with a hypothetical \"exp\" (expiration time)\n     *   field is:\n     *\n     *     {\"alg\":\"ES256\",\n     *     \"crit\":[\"exp\"],\n     *     \"exp\":1363284000\n     *     }\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.13\n     *\n     *   4.1.13.  \"crit\" (Critical) Header Parameter\n     *\n     *   This parameter has the same meaning, syntax, and processing rules as\n     *   the \"crit\" Header Parameter defined in Section 4.1.11 of [JWS],\n     *   except that Header Parameters for a JWE are being referred to, rather\n     *   than Header Parameters for a JWS.\n     */\n    crit: {\n      type: 'array',\n      items: {\n        type: 'string'\n      },\n      minItems: 1\n    },\n\n    /**\n     * enc\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.2\n     *\n     * 4.1.2.  \"enc\" (Encryption Algorithm) Header Parameter\n     *\n     *   The \"enc\" (encryption algorithm) Header Parameter identifies the\n     *   content encryption algorithm used to perform authenticated encryption\n     *   on the plaintext to produce the ciphertext and the Authentication\n     *   Tag.  This algorithm MUST be an AEAD algorithm with a specified key\n     *   length.  The encrypted content is not usable if the \"enc\" value does\n     *   not represent a supported algorithm.  \"enc\" values should either be\n     *   registered in the IANA \"JSON Web Signature and Encryption Algorithms\"\n     *   registry established by [JWA] or be a value that contains a\n     *   Collision-Resistant Name.  The \"enc\" value is a case-sensitive ASCII\n     *   string containing a StringOrURI value.  This Header Parameter MUST be\n     *   present and MUST be understood and processed by implementations.\n     *\n     *   A list of defined \"enc\" values for this use can be found in the IANA\n     *   \"JSON Web Signature and Encryption Algorithms\" registry established\n     *   by [JWA]; the initial contents of this registry are the values\n     *   defined in Section 5.1 of [JWA].\n     */\n    enc: {\n      type: 'string',\n      format: 'StringOrURI'\n    },\n\n    /**\n     * zip\n     *\n     * JSON Web Encryption (JWE)\n     * https://tools.ietf.org/html/rfc7516#section-4.1.3\n     *\n     * 4.1.3.  \"zip\" (Compression Algorithm) Header Parameter\n     *\n     *   The \"zip\" (compression algorithm) applied to the plaintext before\n     *   encryption, if any.  The \"zip\" value defined by this specification\n     *   is:\n     *\n     *   o  \"DEF\" - Compression with the DEFLATE [RFC1951] algorithm\n     *\n     *   Other values MAY be used.  Compression algorithm values can be\n     *   registered in the IANA \"JSON Web Encryption Compression Algorithms\"\n     *   registry established by [JWA].  The \"zip\" value is a case-sensitive\n     *   string.  If no \"zip\" parameter is present, no compression is applied\n     *   to the plaintext before encryption.  When used, this Header Parameter\n     *   MUST be integrity protected; therefore, it MUST occur only within the\n     *   JWE Protected Header.  Use of this Header Parameter is OPTIONAL.\n     *   This Header Parameter MUST be understood and processed by\n     *   implementations.\n     */\n    zip: {\n      type: 'string'\n    }\n  }\n});\n\n/**\n * Export\n */\nmodule.exports = JOSEHeaderSchema;\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/**\n * Dependencies\n */\nvar base64url = __webpack_require__(39);\nvar JWA = __webpack_require__(38);\n\nvar _require = __webpack_require__(55),\n    DataError = _require.DataError;\n\n/**\n * JWS\n */\n\n\nvar JWS = function () {\n  function JWS() {\n    _classCallCheck(this, JWS);\n  }\n\n  _createClass(JWS, null, [{\n    key: 'sign',\n\n\n    /**\n     * sign\n     *\n     * @description\n     * Encode a JWT instance\n     *\n     * @param {Object} token\n     * @returns {Promise}\n     */\n    value: function sign(token) {\n      var payload = base64url(JSON.stringify(token.payload));\n\n      // compact serialization\n      if (token.serialization === 'compact') {\n        var key = token.key,\n            alg = token.header.alg;\n\n        var header = base64url(JSON.stringify(token.header));\n        var data = header + '.' + payload;\n\n        return JWA.sign(alg, key, data).then(function (signature) {\n          return data + '.' + signature;\n        });\n      }\n\n      // JSON serialization\n      if (token.serialization === 'json') {}\n\n      // Flattened serialization\n      if (token.serialization === 'flattened') {}\n\n      return Promise.reject(new DataError('Unsupported serialization'));\n    }\n\n    /**\n     * verify\n     */\n\n  }, {\n    key: 'verify',\n    value: function verify(jwt) {\n      // multiple signatures\n      if (jwt.signatures) {\n        // ...\n      }\n\n      var key = jwt.key,\n          signature = jwt.signature,\n          alg = jwt.header.alg;\n\n      // one signature\n\n      if (jwt.signature) {\n        var _jwt$segments = _slicedToArray(jwt.segments, 2),\n            header = _jwt$segments[0],\n            payload = _jwt$segments[1];\n\n        var data = header + '.' + payload;\n\n        if (alg === 'none') {\n          return Promise.reject(new DataError('Signature provided to verify with alg: none'));\n        }\n\n        return JWA.verify(alg, key, signature, data).then(function (verified) {\n          jwt.verified = verified;\n          return verified;\n        });\n      }\n\n      if (alg === 'none') {\n        if (!key && !signature) {\n          jwt.verified = true;\n\n          return Promise.resolve(true);\n        }\n\n        if (key) {\n          return Promise.reject(new DataError('Key provided to verify signature with alg: none'));\n        }\n      }\n\n      // no signatures to verify\n      return Promise.reject(new DataError('Missing signature(s)'));\n    }\n  }]);\n\n  return JWS;\n}();\n\n/**\n * Export\n */\n\n\nmodule.exports = JWS;\n\n/***/ }),\n/* 68 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Buffer) {/**\n * Dependencies\n */\nconst assert = __webpack_require__(21);\n\nconst base64url = __webpack_require__(39);\n\nconst crypto = __webpack_require__(49);\n\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst {\n  URL\n} = __webpack_require__(27);\n/**\n * Authentication Request\n */\n\n\nclass AuthenticationRequest {\n  /**\n   * create\n   *\n   * @description\n   * Create a new authentication request with generated state and nonce,\n   * validate presence of required parameters, serialize the request data and\n   * persist it to the session, and return a promise for an authentication\n   * request URI.\n   *\n   * @param {RelyingParty} rp – instance of RelyingParty\n   * @param {Object} options - optional request parameters\n   * @param {Object} session – reference to localStorage or other session object\n   *\n   * @returns {Promise}\n   */\n  static create(rp, options, session) {\n    const {\n      provider,\n      defaults,\n      registration\n    } = rp;\n    let issuer, endpoint, client, params;\n    return Promise.resolve().then(() => {\n      // validate presence of OP configuration, RP client registration,\n      // and default parameters\n      assert(provider.configuration, 'RelyingParty provider OpenID Configuration is missing');\n      assert(defaults.authenticate, 'RelyingParty default authentication parameters are missing');\n      assert(registration, 'RelyingParty client registration is missing'); // define basic elements of the request\n\n      issuer = provider.configuration.issuer;\n      endpoint = provider.configuration.authorization_endpoint;\n      client = {\n        client_id: registration.client_id\n      };\n      params = Object.assign(defaults.authenticate, client, options); // validate presence of required configuration and parameters\n\n      assert(issuer, 'Missing issuer in provider OpenID Configuration');\n      assert(endpoint, 'Missing authorization_endpoint in provider OpenID Configuration');\n      assert(params.scope, 'Missing scope parameter in authentication request');\n      assert(params.response_type, 'Missing response_type parameter in authentication request');\n      assert(params.client_id, 'Missing client_id parameter in authentication request');\n      assert(params.redirect_uri, 'Missing redirect_uri parameter in authentication request'); // generate state and nonce random octets\n\n      params.state = Array.from(crypto.getRandomValues(new Uint8Array(16)));\n      params.nonce = Array.from(crypto.getRandomValues(new Uint8Array(16))); // hash the state and nonce parameter values\n\n      return Promise.all([crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.state)), crypto.subtle.digest({\n        name: 'SHA-256'\n      }, new Uint8Array(params.nonce))]);\n    }) // serialize the request with original values, store in session by\n    // encoded state param, and replace state/nonce octets with encoded\n    // digests\n    .then(digests => {\n      let state = base64url(Buffer.from(digests[0]));\n      let nonce = base64url(Buffer.from(digests[1]));\n      let key = `${issuer}/requestHistory/${state}`; // store the request params for response validation\n      // with serialized octet values for state and nonce\n\n      session[key] = JSON.stringify(params); // replace state and nonce octets with base64url encoded digests\n\n      params.state = state;\n      params.nonce = nonce;\n    }).then(() => AuthenticationRequest.generateSessionKeys()).then(sessionKeys => {\n      AuthenticationRequest.storeSessionKeys(sessionKeys, params, session);\n    }) // optionally encode a JWT with the request parameters\n    // and replace params with `{ request: <jwt> }\n    .then(() => {\n      if (provider.configuration.request_parameter_supported) {\n        return AuthenticationRequest.encodeRequestParams(params).then(encodedParams => {\n          params = encodedParams;\n        });\n      }\n    }) // render the request URI and terminate the algorithm\n    .then(() => {\n      let url = new URL(endpoint);\n      url.search = FormUrlEncoded.encode(params);\n      return url.href;\n    });\n  }\n\n  static generateSessionKeys() {\n    return crypto.subtle.generateKey({\n      name: \"RSASSA-PKCS1-v1_5\",\n      modulusLength: 2048,\n      publicExponent: new Uint8Array([0x01, 0x00, 0x01]),\n      hash: {\n        name: \"SHA-256\"\n      }\n    }, true, [\"sign\", \"verify\"]).then(keyPair => {\n      // returns a keypair object\n      return Promise.all([crypto.subtle.exportKey('jwk', keyPair.publicKey), crypto.subtle.exportKey('jwk', keyPair.privateKey)]);\n    }).then(jwkPair => {\n      let [publicJwk, privateJwk] = jwkPair;\n      return {\n        public: publicJwk,\n        private: privateJwk\n      };\n    });\n  }\n\n  static storeSessionKeys(sessionKeys, params, session) {\n    // store the private one in session, public one goes into params\n    session['oidc.session.privateKey'] = JSON.stringify(sessionKeys.private);\n    params.key = sessionKeys.public;\n  }\n\n  static encodeRequestParams(params) {\n    const excludeParams = ['scope', 'client_id', 'response_type', 'state'];\n    const keysToEncode = Object.keys(params).filter(key => !excludeParams.includes(key));\n    let payload = {};\n    keysToEncode.forEach(key => {\n      payload[key] = params[key];\n    });\n    let requestParamJwt = new JWT({\n      header: {\n        alg: 'none'\n      },\n      payload\n    }, {\n      filter: false\n    });\n    return requestParamJwt.encode().then(requestParamCompact => {\n      let newParams = {\n        scope: params['scope'],\n        client_id: params['client_id'],\n        response_type: params['response_type'],\n        request: requestParamCompact,\n        state: params['state']\n      };\n      return newParams;\n    });\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationRequest;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 69 */\n/***/ (function(module, exports) {\n\n/**\n * Dependencies\n */\n\n/**\n * FormUrlEncoded\n */\nclass FormUrlEncoded {\n  /**\n   * Encode\n   *\n   * @description\n   * Represent an object as x-www-form-urlencoded string.\n   *\n   * @param {Object} data\n   * @returns {string}\n   */\n  static encode(data) {\n    let pairs = [];\n    Object.keys(data).forEach(function (key) {\n      pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(data[key]));\n    });\n    return pairs.join('&');\n  }\n  /**\n   * Decode\n   *\n   * @description\n   * Parse a x-www-form-urlencoded into an object.\n   *\n   * @param {string} data\n   * @returns {Object}\n   */\n\n\n  static decode(data) {\n    let obj = {};\n    data.split('&').forEach(function (property) {\n      let pair = property.split('=');\n      let key = decodeURIComponent(pair[0]);\n      let val = decodeURIComponent(pair[1]);\n      obj[key] = val;\n    });\n    return obj;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = FormUrlEncoded;\n\n/***/ }),\n/* 70 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(global, Buffer) {/**\n * Dependencies\n */\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst assert = __webpack_require__(21);\n\nconst crypto = __webpack_require__(49);\n\nconst base64url = __webpack_require__(39);\n\nconst fetch = __webpack_require__(5);\n\nconst Headers = fetch.Headers ? fetch.Headers : global.Headers;\n\nconst FormUrlEncoded = __webpack_require__(69);\n\nconst IDToken = __webpack_require__(71);\n\nconst Session = __webpack_require__(73);\n\nconst onHttpError = __webpack_require__(74);\n\nconst HttpError = __webpack_require__(76);\n/**\n * AuthenticationResponse\n */\n\n\nclass AuthenticationResponse {\n  /**\n   * @param rp {RelyingParty}\n   * @param [redirect] {string} req.query\n   * @param [body] {string} req.body.text\n   * @param session {Session|Storage} req.session or localStorage or similar\n   * @param params {object} hashmap\n   * @param mode {string} 'query'/'fragment'/'form_post',\n   *   determined in `parseResponse()`\n   */\n  constructor({\n    rp,\n    redirect,\n    body,\n    session,\n    mode,\n    params = {}\n  }) {\n    this.rp = rp;\n    this.redirect = redirect;\n    this.body = body;\n    this.session = session;\n    this.mode = mode;\n    this.params = params;\n  }\n  /**\n   * validateResponse\n   *\n   * @description\n   * Authentication response validation.\n   *\n   * @param {string|Object} response\n   *\n   * @returns {Promise<Session>}\n   */\n\n\n  static validateResponse(response) {\n    return Promise.resolve(response).then(this.parseResponse).then(this.errorResponse).then(this.matchRequest).then(this.validateStateParam).then(this.validateResponseMode).then(this.validateResponseParams).then(this.exchangeAuthorizationCode).then(this.validateIDToken).then(Session.fromAuthResponse);\n  }\n  /**\n   * parseResponse\n   *\n   * @param {object} response\n   *\n   * @returns {object}\n   */\n\n\n  static parseResponse(response) {\n    let {\n      redirect,\n      body\n    } = response; // response must be either a redirect uri or request body, but not both\n\n    if (redirect && body || !redirect && !body) {\n      throw new HttpError(400, 'Invalid response mode');\n    } // parse redirect uri\n\n\n    if (redirect) {\n      let url = new URL(redirect);\n      let {\n        search,\n        hash\n      } = url;\n\n      if (search && hash || !search && !hash) {\n        throw new HttpError(400, 'Invalid response mode');\n      }\n\n      if (search) {\n        response.params = FormUrlEncoded.decode(search.substring(1));\n        response.mode = 'query';\n      }\n\n      if (hash) {\n        response.params = FormUrlEncoded.decode(hash.substring(1));\n        response.mode = 'fragment';\n      }\n    } // parse request form body\n\n\n    if (body) {\n      response.params = FormUrlEncoded.decode(body);\n      response.mode = 'form_post';\n    }\n\n    return response;\n  }\n  /**\n   * errorResponse\n   *\n   * @param {AuthenticationResponse} response\n   *\n   * @throws {Error} If response params include the OAuth2 'error' param,\n   *   throws an error based on it.\n   *\n   * @returns {AuthenticationResponse} Chainable\n   *\n   * @todo Figure out HTTP status code (typically 400, 401 or 403)\n   *   based on the OAuth2/OIDC `error` code, probably using an external library\n   */\n\n\n  static errorResponse(response) {\n    const errorCode = response.params.error;\n\n    if (errorCode) {\n      const errorParams = {};\n      errorParams['error'] = errorCode;\n      errorParams['error_description'] = response.params['error_description'];\n      errorParams['error_uri'] = response.params['error_uri'];\n      errorParams['state'] = response.params['state'];\n      const error = new Error(`AuthenticationResponse error: ${errorCode}`);\n      error.info = errorParams;\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * matchRequest\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static matchRequest(response) {\n    let {\n      rp,\n      params,\n      session\n    } = response;\n    let state = params.state;\n    let issuer = rp.provider.configuration.issuer;\n\n    if (!state) {\n      throw new Error('Missing state parameter in authentication response');\n    }\n\n    let key = `${issuer}/requestHistory/${state}`;\n    let request = session[key];\n\n    if (!request) {\n      throw new Error('Mismatching state parameter in authentication response');\n    }\n\n    response.request = JSON.parse(request);\n    return response;\n  }\n  /**\n   * validateStateParam\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateStateParam(response) {\n    let octets = new Uint8Array(response.request.state);\n    let encoded = response.params.state;\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (encoded !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching state parameter in authentication response');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateResponseMode\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseMode(response) {\n    if (response.request.response_type !== 'code' && response.mode === 'query') {\n      throw new Error('Invalid response mode');\n    }\n\n    return response;\n  }\n  /**\n   * validateResponseParams\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateResponseParams(response) {\n    let {\n      request,\n      params\n    } = response;\n    let expectedParams = request.response_type.split(' ');\n\n    if (expectedParams.includes('code')) {\n      assert(params.code, 'Missing authorization code in authentication response'); // TODO assert novelty of code\n    }\n\n    if (expectedParams.includes('id_token')) {\n      assert(params.id_token, 'Missing id_token in authentication response');\n    }\n\n    if (expectedParams.includes('token')) {\n      assert(params.access_token, 'Missing access_token in authentication response');\n      assert(params.token_type, 'Missing token_type in authentication response');\n    }\n\n    return response;\n  }\n  /**\n   * exchangeAuthorizationCode\n   *\n   * @param {Object} response\n   * @returns {Promise} response object\n   */\n\n\n  static exchangeAuthorizationCode(response) {\n    let {\n      rp,\n      params,\n      request\n    } = response;\n    let code = params.code; // only exchange the authorization code when the response type is \"code\"\n\n    if (!code || request['response_type'] !== 'code') {\n      return Promise.resolve(response);\n    }\n\n    let {\n      provider,\n      registration\n    } = rp;\n    let id = registration['client_id'];\n    let secret = registration['client_secret']; // verify the client is not public\n\n    if (!secret) {\n      return Promise.reject(new Error('Client cannot exchange authorization code because ' + 'it is not a confidential client'));\n    } // initialize token request arguments\n\n\n    let endpoint = provider.configuration.token_endpoint;\n    let method = 'POST'; // initialize headers\n\n    let headers = new Headers({\n      'Content-Type': 'application/x-www-form-urlencoded'\n    }); // initialize the token request parameters\n\n    let bodyContents = {\n      'grant_type': 'authorization_code',\n      'code': code,\n      'redirect_uri': request['redirect_uri'] // determine client authentication method\n\n    };\n    let authMethod = registration['token_endpoint_auth_method'] || 'client_secret_basic'; // client secret basic authentication\n\n    if (authMethod === 'client_secret_basic') {\n      let credentials = new Buffer(`${id}:${secret}`).toString('base64');\n      headers.set('Authorization', `Basic ${credentials}`);\n    } // client secret post authentication\n\n\n    if (authMethod === 'client_secret_post') {\n      bodyContents['client_id'] = id;\n      bodyContents['client_secret'] = secret;\n    }\n\n    let body = FormUrlEncoded.encode(bodyContents); // TODO\n    // client_secret_jwt authentication\n    // private_key_jwt\n    // make the token request\n\n    return fetch(endpoint, {\n      method,\n      headers,\n      body\n    }).then(onHttpError('Error exchanging authorization code')).then(tokenResponse => tokenResponse.json()).then(tokenResponse => {\n      assert(tokenResponse['access_token'], 'Missing access_token in token response');\n      assert(tokenResponse['token_type'], 'Missing token_type in token response');\n      assert(tokenResponse['id_token'], 'Missing id_token in token response'); // anything else?\n      // IS THIS THE RIGHT THING TO DO HERE?\n\n      response.params = Object.assign(response.params, tokenResponse);\n      return response;\n    });\n  }\n  /**\n   * validateIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIDToken(response) {\n    // only validate the ID Token if present in the response\n    if (!response.params.id_token) {\n      return Promise.resolve(response);\n    }\n\n    return Promise.resolve(response).then(AuthenticationResponse.decryptIDToken).then(AuthenticationResponse.decodeIDToken).then(AuthenticationResponse.validateIssuer).then(AuthenticationResponse.validateAudience).then(AuthenticationResponse.resolveKeys).then(AuthenticationResponse.verifySignature).then(AuthenticationResponse.validateExpires).then(AuthenticationResponse.verifyNonce).then(AuthenticationResponse.validateAcr).then(AuthenticationResponse.validateAuthTime).then(AuthenticationResponse.validateAccessTokenHash).then(AuthenticationResponse.validateAuthorizationCodeHash);\n  }\n  /**\n   * decryptIDToken\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static decryptIDToken(response) {\n    // TODO\n    return Promise.resolve(response);\n  }\n  /**\n   * decodeIDToken\n   *\n   * Note: If the `id_token` is not present in params, this method does not\n   * get called (short-circuited in `validateIDToken()`).\n   *\n   * @param response {AuthenticationResponse}\n   * @param response.params {object}\n   * @param [response.params.id_token] {string} IDToken encoded as a JWT\n   *\n   * @returns {AuthenticationResponse} Chainable\n   */\n\n\n  static decodeIDToken(response) {\n    let jwt = response.params.id_token;\n\n    try {\n      response.decoded = IDToken.decode(jwt);\n    } catch (decodeError) {\n      const error = new HttpError(400, 'Error decoding ID Token');\n      error.cause = decodeError;\n      error.info = {\n        id_token: jwt\n      };\n      throw error;\n    }\n\n    return response;\n  }\n  /**\n   * validateIssuer\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateIssuer(response) {\n    let configuration = response.rp.provider.configuration;\n    let payload = response.decoded.payload; // validate issuer of token matches this relying party's provider\n\n    if (payload.iss !== configuration.issuer) {\n      throw new Error('Mismatching issuer in ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * validateAudience\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAudience(response) {\n    let registration = response.rp.registration;\n    let {\n      aud,\n      azp\n    } = response.decoded.payload; // validate audience includes this relying party\n\n    if (typeof aud === 'string' && aud !== registration['client_id']) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate audience includes this relying party\n\n\n    if (Array.isArray(aud) && !aud.includes(registration['client_id'])) {\n      throw new Error('Mismatching audience in id_token');\n    } // validate authorized party is present if required\n\n\n    if (Array.isArray(aud) && !azp) {\n      throw new Error('Missing azp claim in id_token');\n    } // validate authorized party is this relying party\n\n\n    if (azp && azp !== registration['client_id']) {\n      throw new Error('Mismatching azp claim in id_token');\n    }\n\n    return response;\n  }\n  /**\n   * resolveKeys\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static resolveKeys(response) {\n    let rp = response.rp;\n    let provider = rp.provider;\n    let decoded = response.decoded;\n    return Promise.resolve(provider.jwks).then(jwks => jwks ? jwks : rp.jwks()).then(jwks => {\n      if (decoded.resolveKeys(jwks)) {\n        return Promise.resolve(response);\n      } else {\n        throw new Error('Cannot resolve signing key for ID Token');\n      }\n    });\n  }\n  /**\n   * verifySignature\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifySignature(response) {\n    let alg = response.decoded.header.alg;\n    let registration = response.rp.registration;\n    let expectedAlgorithm = registration['id_token_signed_response_alg'] || 'RS256'; // validate signing algorithm matches expectation\n\n    if (alg !== expectedAlgorithm) {\n      throw new Error(`Expected ID Token to be signed with ${expectedAlgorithm}`);\n    }\n\n    return response.decoded.verify().then(verified => {\n      if (!verified) {\n        throw new Error('Invalid ID Token signature');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateExpires\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateExpires(response) {\n    let exp = response.decoded.payload.exp; // validate expiration of token\n\n    if (exp <= Math.floor(Date.now() / 1000)) {\n      throw new Error('Expired ID Token');\n    }\n\n    return response;\n  }\n  /**\n   * verifyNonce\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static verifyNonce(response) {\n    let octets = new Uint8Array(response.request.nonce);\n    let nonce = response.decoded.payload.nonce;\n\n    if (!nonce) {\n      throw new Error('Missing nonce in ID Token');\n    }\n\n    return crypto.subtle.digest({\n      name: 'SHA-256'\n    }, octets).then(digest => {\n      if (nonce !== base64url(Buffer.from(digest))) {\n        throw new Error('Mismatching nonce in ID Token');\n      }\n\n      return response;\n    });\n  }\n  /**\n   * validateAcr\n   *\n   * @param {Object} response\n   * @returns {Object}\n   */\n\n\n  static validateAcr(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthTime\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthTime(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAccessTokenHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAccessTokenHash(response) {\n    // TODO\n    return response;\n  }\n  /**\n   * validateAuthorizationCodeHash\n   *\n   * @param {Object} response\n   * @returns {Promise}\n   */\n\n\n  static validateAuthorizationCodeHash(response) {\n    // TODO\n    return response;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = AuthenticationResponse;\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(20), __webpack_require__(41).Buffer))\n\n/***/ }),\n/* 71 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWT\n} = __webpack_require__(37);\n\nconst IDTokenSchema = __webpack_require__(72);\n/**\n * IDToken\n */\n\n\nclass IDToken extends JWT {\n  /**\n   * Schema\n   */\n  static get schema() {\n    return IDTokenSchema;\n  }\n\n}\n/**\n * Export\n */\n\n\nmodule.exports = IDToken;\n\n/***/ }),\n/* 72 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Local dependencies\n */\nconst {\n  JWTSchema\n} = __webpack_require__(37);\n/**\n * IDToken Schema\n */\n\n\nconst IDTokenSchema = JWTSchema.extend({\n  properties: {\n    /**\n     * header\n     * http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n     * ID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header\n     * Parameter fields. Instead, references to keys used are communicated in\n     * advance using Discovery and Registration parameters, per Section 10.\n     */\n    header: {//not: { required: ['x5u', 'x5c', 'jku', 'jwk'] }\n    },\n\n    /**\n     * payload\n     */\n    payload: {\n      properties: {\n        /**\n         * iss\n         *\n         * REQUIRED. Issuer Identifier for the Issuer of the response.\n         * The iss value is a case sensitive URL using the https scheme\n         * that contains scheme, host, and optionally, port number and\n         * path components and no query or fragment components.\n         */\n        iss: {\n          type: 'string',\n          format: 'url'\n        },\n\n        /**\n         * sub\n         *\n         * REQUIRED. Subject Identifier. A locally unique and never\n         * reassigned identifier within the Issuer for the End-User, which\n         * is intended to be consumed by the Client, e.g., 24400320 or\n         * AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255\n         * ASCII characters in length. The sub value is a case sensitive\n         * string.\n         */\n        sub: {\n          type: 'string',\n          maxLength: 255\n        },\n\n        /**\n         * aud\n         *\n         * REQUIRED. Audience(s) that this ID Token is intended for. It\n         * MUST contain the OAuth 2.0 client_id of the Relying Party as an\n         * audience value. It MAY also contain identifiers for other audiences.\n         * In the general case, the aud value is an array of case sensitive\n         * strings. In the common special case when there is one audience,\n         * the aud value MAY be a single case sensitive string.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * exp\n         *\n         * REQUIRED. Expiration time on or after which the ID Token MUST NOT\n         * be accepted for processing. The processing of this parameter\n         * requires that the current date/time MUST be before the expiration\n         * date/time listed in the value. Implementers MAY provide for some\n         * small leeway, usually no more than a few minutes, to account for\n         * clock skew. Its value is a JSON number representing the number of\n         * seconds from 1970-01-01T0:0:0Z as measured in UTC until the\n         * date/time. See RFC 3339 [RFC3339] for details regarding date/times\n         * in general and UTC in particular.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * iat\n         *\n         * REQUIRED. Time at which the JWT was issued. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time.\n         */\n        // inherited from JWTClaimsSetSchema\n\n        /**\n         * auth_time\n         *\n         * Time when the End-User authentication occurred. Its value is a\n         * JSON number representing the number of seconds from\n         * 1970-01-01T0:0:0Z as measured in UTC until the date/time. When a\n         * max_age request is made or when auth_time is requested as an\n         * Essential Claim, then this Claim is REQUIRED; otherwise, its\n         * inclusion is OPTIONAL. (The auth_time Claim semantically\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] auth_time\n         * response parameter.)\n         */\n        auth_time: {\n          type: 'integer',\n          format: 'NumericDate'\n        },\n\n        /**\n         * nonce\n         *\n         * String value used to associate a Client session with an ID Token,\n         * and to mitigate replay attacks. The value is passed through\n         * unmodified from the Authentication Request to the ID Token. If\n         * present in the ID Token, Clients MUST verify that the nonce Claim\n         * Value is equal to the value of the nonce parameter sent in the\n         * Authentication Request. If present in the Authentication Request,\n         * Authorization Servers MUST include a nonce Claim in the ID Token\n         * with the Claim Value being the nonce value sent in the\n         * Authentication Request. Authorization Servers SHOULD perform no\n         * other processing on nonce values used. The nonce value is a case\n         * sensitive string.\n         */\n        nonce: {\n          type: 'string'\n        },\n\n        /**\n         * acr\n         *\n         * OPTIONAL. Authentication Context Class Reference. String\n         * specifying an Authentication Context Class Reference value that\n         * identifies the Authentication Context Class that the authentication\n         * performed satisfied. The value \"0\" indicates the End-User\n         * authentication did not meet the requirements of ISO/IEC 29115\n         * [ISO29115] level 1. Authentication using a long-lived browser\n         * cookie, for instance, is one example where the use of \"level 0\" is\n         * appropriate. Authentications with level 0 SHOULD NOT be used to\n         * authorize access to any resource of any monetary value. (This\n         * corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] nist_auth_level\n         * 0.) An absolute URI or an RFC 6711 [RFC6711] registered name\n         * SHOULD be used as the acr value; registered names MUST NOT be used\n         * with a different meaning than that which is registered. Parties\n         * using this claim will need to agree upon the meanings of the\n         * values used, which may be context-specific. The acr value is a\n         * case sensitive string.\n         */\n        acr: {\n          type: 'string'\n        },\n\n        /**\n         * amr\n         * OPTIONAL. Authentication Methods References. JSON array of strings\n         * that are identifiers for authentication methods used in the\n         * authentication. For instance, values might indicate that both\n         * password and OTP authentication methods were used. The definition\n         * of particular values to be used in the amr Claim is beyond the\n         * scope of this specification. Parties using this claim will need to\n         * agree upon the meanings of the values used, which may be context-\n         * specific. The amr value is an array of case sensitive strings.\n         */\n        amr: {\n          type: 'array',\n          items: {\n            type: 'string'\n          }\n        },\n\n        /**\n         * azp\n         * OPTIONAL. Authorized party - the party to which the ID Token was\n         * issued. If present, it MUST contain the OAuth 2.0 Client ID of this\n         * party. This Claim is only needed when the ID Token has a single\n         * audience value and that audience is different than the authorized\n         * party. It MAY be included even when the authorized party is the\n         * same as the sole audience. The azp value is a case sensitive string\n         * containing a StringOrURI value.\n         */\n        azp: {\n          type: 'string',\n          format: 'StringOrURI'\n        }\n      },\n\n      /**\n       * Required Claims\n       */\n      required: ['iss', 'sub', 'aud', 'exp', 'iat']\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = IDTokenSchema;\n\n/***/ }),\n/* 73 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst fetch = __webpack_require__(5);\n\nconst onHttpError = __webpack_require__(74);\n\nconst PoPToken = __webpack_require__(75);\n\nclass Session {\n  /**\n   * @param options {Object}\n   *\n   * @param options.credentialType {string} 'access_token' or 'pop_token'\n   *\n   * @param options.issuer {string} Identity provider (issuer of ID/Access Token)\n   *\n   * @param options.authorization {object}\n   * @param options.authorization.client_id {string} OIDC/OAuth2 client id\n   * @param [options.authorization.id_token] {string} Compact-serialized id_token param\n   * @param [options.authorization.access_token] {string} Compact-serialized access_token param\n   * @param [options.authorization.refresh_token] {string} Compact-serialized refresh_token\n   *\n   * @param [options.sessionKey] {string} Serialized client session key generated\n   *   during the Authentication Request, used to issue PoPTokens\n   *\n   * @param [options.idClaims] {object} Decoded/verified ID Token JWT payload\n   *\n   * @param [options.accessClaims] {object} Decoded/verified Access Token JWT payload\n   */\n  constructor(options) {\n    this.credentialType = options.credentialType || 'access_token';\n    this.issuer = options.issuer;\n    this.authorization = options.authorization || {};\n    this.sessionKey = options.sessionKey;\n    this.idClaims = options.idClaims;\n    this.accessClaims = options.accessClaims;\n  }\n\n  static from(options) {\n    return new Session(options);\n  }\n  /**\n   * @param response {AuthenticationResponse}\n   *\n   * @returns {Session} RelyingParty Session object\n   */\n\n\n  static fromAuthResponse(response) {\n    const RelyingParty = __webpack_require__(19); // import here due to circular dep\n\n\n    let idClaims = response.decoded && response.decoded.payload || {};\n    let {\n      rp\n    } = response;\n    let registration = rp.registration;\n    let rpAuthOptions = rp.defaults.authenticate || {};\n    let credentialType = rpAuthOptions['credential_type'] || rp.defaults.popToken ? 'pop_token' : 'access_token';\n    let sessionKey = response.session[RelyingParty.SESSION_PRIVATE_KEY];\n    let options = {\n      credentialType,\n      sessionKey,\n      issuer: idClaims.iss,\n      idClaims,\n      authorization: {\n        client_id: registration['client_id'],\n        access_token: response.params['access_token'],\n        id_token: response.params['id_token'],\n        refresh_token: response.params['refresh_token']\n      }\n    };\n    return Session.from(options);\n  }\n  /**\n   * Authenticated fetch() getter\n   *\n   * @returns {function}\n   */\n\n\n  get fetch() {\n    /**\n     * fetch() function signature\n     *\n     * @param url {RequestInfo|string}\n     * @param options {object}\n     *\n     * @returns {Function<Promise<Response>>}\n     */\n    return (url, options) => {\n      return Promise.resolve().then(() => {\n        if (this.hasCredentials()) {\n          return this.fetchWithCredentials(url, options);\n        } else {\n          return fetch(url, options);\n        }\n      }).then(onHttpError('Error while fetching resource'));\n    };\n  }\n  /**\n   * bearerTokenFor\n   *\n   * @param url {string}\n   *\n   * @returns {Promise<string>}\n   */\n\n\n  bearerTokenFor(url) {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return PoPToken.issueFor(url, this);\n\n      default:\n        // 'access_token' etc\n        return Promise.resolve(this.authorization[this.credentialType]);\n    }\n  }\n  /**\n   * hasCredentials\n   *\n   * @returns {boolean}\n   */\n\n\n  hasCredentials() {\n    switch (this.credentialType) {\n      case 'pop_token':\n        return !!this.authorization['id_token'];\n\n      default:\n        // 'access_token' etc\n        return !!this.authorization[this.credentialType];\n    }\n  }\n  /**\n   * fetchWithCredentials\n   *\n   * @param url {RequestInfo|string}\n   * @param options {object}\n   *\n   * @returns {Promise<Response>}\n   */\n\n\n  fetchWithCredentials(url, options = {}) {\n    options.headers = options.headers || {};\n    return this.bearerTokenFor(url).then(token => {\n      options.headers.authorization = `Bearer ${token}`;\n      return fetch(url, options);\n    });\n  }\n\n}\n\nmodule.exports = Session;\n\n/***/ }),\n/* 74 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n/**\n * Throws an error when a fetch response status code indicates a 400 or 500\n * HTTP error. (The whatwg fetch api does not normally reject on http error\n * responses).\n *\n * Usage:\n *\n * ```\n * return fetch(url)\n *   .then(onHttpError('Error while fetching resource')\n *   .catch(err => console.log(err))\n *\n * // -> 'Error while fetching resource: 404 Not Found' error\n * // if a 404 response is encountered\n * ```\n *\n * @param [message] {string} Optional error message to clarify context\n *\n * @throws {Error} For http status codes > 300\n *\n * @return {Object} fetch response object (passed through if no error)\n */\n\nfunction onHttpError(message = 'fetch error') {\n  return response => {\n    if (response.status >= 200 && response.status < 300) {\n      return response;\n    }\n\n    let errorMessage = `${message}: ${response.status} ${response.statusText}`;\n    let error = new Error(errorMessage);\n    error.response = response;\n    error.statusCode = response.status;\n    throw error;\n  };\n}\n\nmodule.exports = onHttpError;\n\n/***/ }),\n/* 75 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nconst {\n  URL\n} = __webpack_require__(27);\n\nconst {\n  JWT,\n  JWK\n} = __webpack_require__(37);\n\nconst DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nclass PoPToken extends JWT {\n  /**\n   * @param resourceServerUri {string} RS URI for which this token is intended\n   *\n   * @param session {Session}\n   * @param session.sessionKey {string}\n   * @param session.authorization.client_id {string}\n   * @param session.authorization.id_token {string}\n   *\n   * @returns {Promise<string>} PoPToken, encoded as compact JWT\n   */\n  static issueFor(resourceServerUri, session) {\n    if (!resourceServerUri) {\n      throw new Error('Cannot issue PoPToken - missing resource server URI');\n    }\n\n    if (!session.sessionKey) {\n      throw new Error('Cannot issue PoPToken - missing session key');\n    }\n\n    if (!session.authorization.id_token) {\n      throw new Error('Cannot issue PoPToken - missing id token');\n    }\n\n    let jwk = JSON.parse(session.sessionKey);\n    return JWK.importKey(jwk).then(importedSessionJwk => {\n      let options = {\n        aud: new URL(resourceServerUri).origin,\n        key: importedSessionJwk,\n        iss: session.authorization.client_id,\n        id_token: session.authorization.id_token\n      };\n      return PoPToken.issue(options);\n    }).then(jwt => {\n      return jwt.encode();\n    });\n  }\n  /**\n   * issue\n   *\n   * @param options {Object}\n   * @param options.iss {string} Token issuer (RP client_id)\n   * @param options.aud {string|Array<string>} Audience for the token\n   *   (such as the Resource Server url)\n   * @param options.key {JWK} Proof of Possession (private) signing key, see\n   *   https://tools.ietf.org/html/rfc7800#section-3.1\n   *\n   * @param options.id_token {string} JWT compact encoded ID Token\n   *\n   * Optional:\n   * @param [options.iat] {number} Issued at timestamp (in seconds)\n   * @param [options.max] {number} Max token lifetime in seconds\n   *\n   * @returns {PoPToken} Proof of Possession Token (JWT instance)\n   */\n\n\n  static issue(options) {\n    let {\n      aud,\n      iss,\n      key\n    } = options;\n    let alg = key.alg;\n    let iat = options.iat || Math.floor(Date.now() / 1000);\n    let max = options.max || DEFAULT_MAX_AGE;\n    let exp = iat + max; // token expiration\n\n    let header = {\n      alg\n    };\n    let payload = {\n      iss,\n      aud,\n      exp,\n      iat,\n      id_token: options.id_token,\n      token_type: 'pop'\n    };\n    let jwt = new PoPToken({\n      header,\n      payload,\n      key: key.cryptoKey\n    }, {\n      filter: false\n    });\n    return jwt;\n  }\n\n}\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 76 */\n/***/ (function(module, exports, __webpack_require__) {\n\nexports = module.exports = HttpError\nvar StandardError = __webpack_require__(77)\nvar STATUS_CODE_TO_NAME = __webpack_require__(78)\nvar STATUS_NAME_TO_CODE = exports\n\nfunction HttpError(code, msg, props) {\n  if (typeof code == \"string\") code = STATUS_NAME_TO_CODE[code]\n  if (typeof code != \"number\") throw new TypeError(\"Non-numeric HTTP code\")\n  if (typeof msg == \"object\" && msg != null) { props = msg; msg = null }\n  StandardError.call(this, msg || STATUS_CODE_TO_NAME[code], props)\n  this.code = code\n}\n\nHttpError.prototype = Object.create(StandardError.prototype, {\n  constructor: {value: HttpError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nHttpError.prototype.name = \"HttpError\"\n\nObject.defineProperties(HttpError.prototype, {\n  statusCode: alias(\"code\"),\n  statusMessage: alias(\"message\"),\n\n  status: {\n    configurable: true,\n    get: function() { return this.code },\n    set: function(value) {\n      Object.defineProperty(this, \"status\", {\n        value: value, configurable: true, enumerable: true, writable: true\n      })\n    }\n  }\n})\n\nHttpError.prototype.toString = function() {\n  return this.name + \": \" + this.code + \" \" + this.message\n}\n\nfor (var code in STATUS_CODE_TO_NAME) {\n  var name = STATUS_CODE_TO_NAME[code]\n  exports[name.replace(\"'\", \"\").replace(/[- ]/g, \"_\").toUpperCase()] = +code\n}\n\nfunction alias(name) {\n  return {\n    configurable: true,\n    get: function() { return this[name] },\n    set: function(value) { return this[name] = value }\n  }\n}\n\n\n/***/ }),\n/* 77 */\n/***/ (function(module, exports) {\n\nvar has = Object.hasOwnProperty\nvar proto = Object.getPrototypeOf\nvar trace = Error.captureStackTrace\nmodule.exports = StandardError\n\nfunction StandardError(msg, props) {\n  // Let all properties be enumerable for easier serialization.\n  if (msg && typeof msg == \"object\") props = msg, msg = undefined\n  else this.message = msg\n\n  // Name has to be an own property (or on the prototype a single step up) for\n  // the stack to be printed with the correct name.\n  if (props) for (var key in props) this[key] = props[key]\n  if (!has.call(this, \"name\"))\n    this.name = has.call(proto(this), \"name\")? this.name : this.constructor.name\n\n  if (trace && !(\"stack\" in this)) trace(this, this.constructor)\n}\n\nStandardError.prototype = Object.create(Error.prototype, {\n  constructor: {value: StandardError, configurable: true, writable: true}\n})\n\n// Set name explicitly for when the code gets minified.\nStandardError.prototype.name = \"StandardError\"\n\n\n/***/ }),\n/* 78 */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"100\\\":\\\"Continue\\\",\\\"101\\\":\\\"Switching Protocols\\\",\\\"102\\\":\\\"Processing\\\",\\\"200\\\":\\\"OK\\\",\\\"201\\\":\\\"Created\\\",\\\"202\\\":\\\"Accepted\\\",\\\"203\\\":\\\"Non-Authoritative Information\\\",\\\"204\\\":\\\"No Content\\\",\\\"205\\\":\\\"Reset Content\\\",\\\"206\\\":\\\"Partial Content\\\",\\\"207\\\":\\\"Multi-Status\\\",\\\"208\\\":\\\"Already Reported\\\",\\\"226\\\":\\\"IM Used\\\",\\\"300\\\":\\\"Multiple Choices\\\",\\\"301\\\":\\\"Moved Permanently\\\",\\\"302\\\":\\\"Found\\\",\\\"303\\\":\\\"See Other\\\",\\\"304\\\":\\\"Not Modified\\\",\\\"305\\\":\\\"Use Proxy\\\",\\\"307\\\":\\\"Temporary Redirect\\\",\\\"308\\\":\\\"Permanent Redirect\\\",\\\"400\\\":\\\"Bad Request\\\",\\\"401\\\":\\\"Unauthorized\\\",\\\"402\\\":\\\"Payment Required\\\",\\\"403\\\":\\\"Forbidden\\\",\\\"404\\\":\\\"Not Found\\\",\\\"405\\\":\\\"Method Not Allowed\\\",\\\"406\\\":\\\"Not Acceptable\\\",\\\"407\\\":\\\"Proxy Authentication Required\\\",\\\"408\\\":\\\"Request Timeout\\\",\\\"409\\\":\\\"Conflict\\\",\\\"410\\\":\\\"Gone\\\",\\\"411\\\":\\\"Length Required\\\",\\\"412\\\":\\\"Precondition Failed\\\",\\\"413\\\":\\\"Payload Too Large\\\",\\\"414\\\":\\\"URI Too Long\\\",\\\"415\\\":\\\"Unsupported Media Type\\\",\\\"416\\\":\\\"Range Not Satisfiable\\\",\\\"417\\\":\\\"Expectation Failed\\\",\\\"418\\\":\\\"I'm a teapot\\\",\\\"421\\\":\\\"Misdirected Request\\\",\\\"422\\\":\\\"Unprocessable Entity\\\",\\\"423\\\":\\\"Locked\\\",\\\"424\\\":\\\"Failed Dependency\\\",\\\"425\\\":\\\"Unordered Collection\\\",\\\"426\\\":\\\"Upgrade Required\\\",\\\"428\\\":\\\"Precondition Required\\\",\\\"429\\\":\\\"Too Many Requests\\\",\\\"431\\\":\\\"Request Header Fields Too Large\\\",\\\"500\\\":\\\"Internal Server Error\\\",\\\"501\\\":\\\"Not Implemented\\\",\\\"502\\\":\\\"Bad Gateway\\\",\\\"503\\\":\\\"Service Unavailable\\\",\\\"504\\\":\\\"Gateway Timeout\\\",\\\"505\\\":\\\"HTTP Version Not Supported\\\",\\\"506\\\":\\\"Variant Also Negotiates\\\",\\\"507\\\":\\\"Insufficient Storage\\\",\\\"508\\\":\\\"Loop Detected\\\",\\\"509\\\":\\\"Bandwidth Limit Exceeded\\\",\\\"510\\\":\\\"Not Extended\\\",\\\"511\\\":\\\"Network Authentication Required\\\"}\");\n\n/***/ }),\n/* 79 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/**\n * Dependencies\n */\nconst {\n  JSONSchema\n} = __webpack_require__(28);\n/**\n * RelyingParty Schema\n *\n * This schema initializes and verifies Relying Party client configuration.\n * RelyingParty objects can be persisted and rehydrated. By encapsulating this data in\n * it's own class, it's possible to have multiple RP configurations running\n * simultaneously.\n */\n\n\nconst RelyingPartySchema = new JSONSchema({\n  type: 'object',\n  properties: {\n    /**\n     * provider\n     *\n     * Information about the provider, including issuer URL, human readable name,\n     * and any configuration or provider metadata retrieved from the OP.\n     */\n    provider: {\n      type: 'object',\n      properties: {\n        name: {\n          type: 'string'\n        },\n        url: {\n          type: 'string',\n          format: 'uri'\n        },\n        // NOTE:\n        // OpenID Configuration (discovery response) and JSON Web Keys Set for an\n        // issuer can be cached here. However the cache should not be persisted or\n        // relied upon.\n        //\n        configuration: {},\n        // .well-known/openid-configuration\n        jwks: {} // /jwks\n\n      },\n      required: ['url']\n    },\n\n    /**\n     * defaults\n     *\n     * Default request parameters for authentication and dynamic registration requests.\n     * These values can be extended or overridden via arguments to the respective\n     * request methods.\n     *\n     * These are part of the relying party client configuration and can be serialized\n     * and persisted.\n     */\n    defaults: {\n      type: 'object',\n      properties: {\n        /**\n         * Use Proof of Possession token semantics for the ID Token\n         */\n        popToken: {\n          type: 'boolean',\n          default: false\n        },\n\n        /**\n         * Default authentication request parameters\n         */\n        authenticate: {\n          type: 'object',\n          properties: {\n            redirect_uri: {\n              type: 'string',\n              format: 'uri'\n            },\n            response_type: {\n              type: 'string',\n              default: 'id_token token',\n              // browser detection\n              enum: ['code', 'token', 'id_token token', 'id_token token code']\n            },\n            display: {\n              type: 'string',\n              default: 'page',\n              enum: ['page', 'popup']\n            },\n            scope: {\n              type: ['string', 'array'],\n              default: ['openid']\n            }\n          }\n        },\n\n        /**\n         * Default client registration parameters\n         */\n        register: {}\n      }\n    },\n\n    /**\n     * registration\n     *\n     * This is the client registration response from dynamic registration. It should\n     * always reflect the client configuration on the openid provider. A client access\n     * token is stored here\n     */\n    registration: {},\n    // ClientMetadataSchema\n\n    /**\n     * store\n     */\n    store: {\n      type: 'object',\n      default: {}\n    }\n  }\n});\n/**\n * Export\n */\n\nmodule.exports = RelyingPartySchema;\n\n/***/ }),\n/* 80 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar _require = __webpack_require__(27),\n    URL = _require.URL;\n\nvar _require2 = __webpack_require__(37),\n    JWT = _require2.JWT,\n    JWK = _require2.JWK;\n\nvar DEFAULT_MAX_AGE = 3600; // Default token expiration, in seconds\n\nvar PoPToken = function (_JWT) {\n  _inherits(PoPToken, _JWT);\n\n  function PoPToken() {\n    _classCallCheck(this, PoPToken);\n\n    return _possibleConstructorReturn(this, (PoPToken.__proto__ || Object.getPrototypeOf(PoPToken)).apply(this, arguments));\n  }\n\n  _createClass(PoPToken, null, [{\n    key: 'issueFor',\n\n    /**\n     * @param resourceServerUri {string} RS URI for which this token is intended\n     *\n     * @param session {Session}\n     * @param session.sessionKey {string}\n     * @param session.authorization.client_id {string}\n     * @param session.authorization.id_token {string}\n     *\n     * @returns {Promise<string>} PoPToken, encoded as compact JWT\n     */\n    value: function issueFor(resourceServerUri, session) {\n      if (!resourceServerUri) {\n        throw new Error('Cannot issue PoPToken - missing resource server URI');\n      }\n\n      if (!session.sessionKey) {\n        throw new Error('Cannot issue PoPToken - missing session key');\n      }\n\n      if (!session.authorization.id_token) {\n        throw new Error('Cannot issue PoPToken - missing id token');\n      }\n\n      var jwk = JSON.parse(session.sessionKey);\n      return JWK.importKey(jwk).then(function (importedSessionJwk) {\n        var options = {\n          aud: new URL(resourceServerUri).origin,\n          key: importedSessionJwk,\n          iss: session.authorization.client_id,\n          id_token: session.authorization.id_token\n        };\n        return PoPToken.issue(options);\n      }).then(function (jwt) {\n        return jwt.encode();\n      });\n    }\n    /**\n     * issue\n     *\n     * @param options {Object}\n     * @param options.iss {string} Token issuer (RP client_id)\n     * @param options.aud {string|Array<string>} Audience for the token\n     *   (such as the Resource Server url)\n     * @param options.key {JWK} Proof of Possession (private) signing key, see\n     *   https://tools.ietf.org/html/rfc7800#section-3.1\n     *\n     * @param options.id_token {string} JWT compact encoded ID Token\n     *\n     * Optional:\n     * @param [options.iat] {number} Issued at timestamp (in seconds)\n     * @param [options.max] {number} Max token lifetime in seconds\n     *\n     * @returns {PoPToken} Proof of Possession Token (JWT instance)\n     */\n\n  }, {\n    key: 'issue',\n    value: function issue(options) {\n      var aud = options.aud,\n          iss = options.iss,\n          key = options.key;\n      var alg = key.alg;\n      var iat = options.iat || Math.floor(Date.now() / 1000);\n      var max = options.max || DEFAULT_MAX_AGE;\n      var exp = iat + max; // token expiration\n\n      var header = {\n        alg: alg\n      };\n      var payload = {\n        iss: iss,\n        aud: aud,\n        exp: exp,\n        iat: iat,\n        id_token: options.id_token,\n        token_type: 'pop'\n      };\n      var jwt = new PoPToken({\n        header: header,\n        payload: payload,\n        key: key.cryptoKey\n      }, {\n        filter: false\n      });\n      return jwt;\n    }\n  }]);\n\n  return PoPToken;\n}(JWT);\n\nmodule.exports = PoPToken;\n\n/***/ }),\n/* 81 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"openIdpPopup\", function() { return openIdpPopup; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"obtainSession\", function() { return obtainSession; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"popupHandler\", function() { return popupHandler; });\n/* harmony import */ var _ipc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(10);\n/* harmony import */ var _url_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6);\n\n\nfunction openIdpPopup(popupUri) {\n  const width = 650;\n  const height = 400;\n  const left = window.screenX + (window.innerWidth - width) / 2;\n  const top = window.screenY + (window.innerHeight - height) / 2;\n  const settings = \"width=\".concat(width, \",height=\").concat(height, \",left=\").concat(left, \",top=\").concat(top);\n  return window.open(popupUri, 'solid-auth-client', settings);\n}\nfunction obtainSession(store, popup, options) {\n  return new Promise((resolve, reject) => {\n    const popupServer = new _ipc__WEBPACK_IMPORTED_MODULE_0__[\"Server\"](popup, Object(_url_util__WEBPACK_IMPORTED_MODULE_1__[\"originOf\"])(options.popupUri || ''), popupHandler(store, options, session => {\n      popupServer.stop();\n      resolve(session);\n    }));\n    popupServer.start();\n  });\n}\nfunction popupHandler(store, _ref, foundSessionCb) {\n  let {\n    popupUri,\n    callbackUri\n  } = _ref;\n  return async function (method) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    switch (method) {\n      // Origin\n      case 'getAppOrigin':\n        return window.location.origin;\n      // Storage\n\n      case 'storage/getItem':\n        return store.getItem(...args);\n\n      case 'storage/setItem':\n        return store.setItem(...args);\n\n      case 'storage/removeItem':\n        return store.removeItem(...args);\n      // Login\n\n      case 'getLoginOptions':\n        return {\n          popupUri,\n          callbackUri\n        };\n\n      case 'foundSession':\n        foundSessionCb(...args);\n    }\n  };\n}\n\n/***/ })\n/******/ ])[\"default\"];\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29saWQtYXV0aC1jbGllbnQvYnJvd3Nlci9pbmRleC5qcz8wMGU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELGdDQUFnQztBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usa0JBQWtCO0FBQ2xGO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsaUNBQWlDO0FBQ2xGLHdIQUF3SCxtQkFBbUIsRUFBRTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMEJBQTBCLEVBQUU7QUFDL0QseUNBQXlDLGVBQWU7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCwrREFBK0Q7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxRUFBcUU7QUFDckU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUU7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRyx3QkFBd0IsRUFBRTtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsMENBQTBDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELDhEQUE4RCxnRUFBZ0UsRUFBRSxFQUFFLGdDQUFnQyxFQUFFLGFBQWE7O0FBRW5WLGdDQUFnQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEsK0NBQStDLHdHQUF3RyxFQUFFLEVBQUUsRUFBRSw2Q0FBNkMsMkVBQTJFLEVBQUUsT0FBTyx5Q0FBeUMsa0ZBQWtGLEVBQUUsRUFBRSxFQUFFLEVBQUUsZUFBZTs7QUFFamtCOzs7Ozs7O0FBT0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixpR0FBaUc7QUFDL0g7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QiwyQkFBMkI7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SDs7QUFFdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLHlFQUF5RTs7QUFFOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIscUJBQXFCLFFBQVE7QUFDN0I7QUFDQSxlQUFlO0FBQ2Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGdEQUFnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNILHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0Msb0JBQW9COztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0JBQWdCLHNCQUFzQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isb0JBQW9CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCx1QkFBdUIsU0FBUztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEMsS0FBSzs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyxPQUFPO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxFQUFFO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EscUJBQXFCLGVBQWU7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsU0FBUztBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPO0FBQzlEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsWUFBWTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0EsUUFBUSxVQUFVOztBQUVsQjtBQUNBOzs7QUFHQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxjQUFjO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEI7O0FBRTVCLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEO0FBQ2hELGdEQUFnRDtBQUNoRCxnREFBZ0Q7QUFDaEQsZ0RBQWdEOztBQUVoRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQSxhQUFhLG1DQUFtQyxFQUFFOztBQUVsRCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQSxhQUFhLHdDQUF3QyxFQUFFOztBQUV2RCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQywyQ0FBMkMsZ0JBQWdCLGtCQUFrQixPQUFPLDJCQUEyQix3REFBd0QsZ0NBQWdDLHVEQUF1RCwyREFBMkQsRUFBRSxFQUFFLHlEQUF5RCxxRUFBcUUsNkRBQTZELG9CQUFvQixHQUFHLEVBQUU7O0FBRWpqQixpREFBaUQsMENBQTBDLDBEQUEwRCxFQUFFOztBQUV2SjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxhQUFhO0FBQzFCO0FBQ0EsZUFBZTtBQUNmOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsYUFBYTtBQUM1QixlQUFlLGFBQWE7QUFDNUI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsNEJBQTRCOztBQUU1QixPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0EsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLDJDQUEyQyxnQkFBZ0Isa0JBQWtCLE9BQU8sMkJBQTJCLHdEQUF3RCxnQ0FBZ0MsdURBQXVELDJEQUEyRCxFQUFFLEVBQUUseURBQXlELHFFQUFxRSw2REFBNkQsb0JBQW9CLEdBQUcsRUFBRTs7QUFFampCLGlEQUFpRCwwQ0FBMEMsMERBQTBELEVBQUU7O0FBRXZKLGlEQUFpRCxhQUFhLHVGQUF1RixFQUFFLHVGQUF1Rjs7QUFFOU8sMENBQTBDLCtEQUErRCxxR0FBcUcsRUFBRSx5RUFBeUUsZUFBZSx5RUFBeUUsRUFBRSxFQUFFLHVIQUF1SDs7QUFFNWU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBLG9HQUFvRyxtQkFBbUIsRUFBRSxtQkFBbUIsOEhBQThIOztBQUUxUSxnQ0FBZ0MsMkNBQTJDLGdCQUFnQixrQkFBa0IsT0FBTywyQkFBMkIsd0RBQXdELGdDQUFnQyx1REFBdUQsMkRBQTJELEVBQUUsRUFBRSx5REFBeUQscUVBQXFFLDZEQUE2RCxvQkFBb0IsR0FBRyxFQUFFOztBQUVqakIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosaURBQWlELGFBQWEsdUZBQXVGLEVBQUUsdUZBQXVGOztBQUU5TywwQ0FBMEMsK0RBQStELHFHQUFxRyxFQUFFLHlFQUF5RSxlQUFlLHlFQUF5RSxFQUFFLEVBQUUsdUhBQXVIOztBQUU1ZTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0EsZ0RBQWdEO0FBQ2hELFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQSxxQ0FBcUMsZ0JBQWdCOztBQUVyRDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsdUhBQXVILEdBQUcsZ0JBQWdCO0FBQzdLOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFVBQVU7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEI7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RTtBQUN2RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtB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Q0E7QUFDQSw2QkFBNkIsT0FBTztBQUNwQyw2QkFBNkIsT0FBTztBQUNwQztBQUNBLGlCQUFpQixTQUFTO0FBQzFCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxDQUFDOztBQUVEOztBQUVBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzR0FBc0cscUJBQXFCLEVBQUU7QUFDN0gsdUdBQXVHLHNCQUFzQixFQUFFO0FBQy9ILHNHQUFzRyxxQkFBcUIsRUFBRTtBQUM3SDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfYXV0aF9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4gLy8gRXhwb3J0IGEgc2luZ2xldG9uIGluc3RhbmNlIG9mIFNvbGlkQXV0aENsaWVudFxuXG5jb25zdCBhdXRoID0gbmV3IF9zb2xpZF9hdXRoX2NsaWVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1wiZGVmYXVsdFwiXSgpO1xuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9IChhdXRoKTsgLy8gQmluZCBtZXRob2RzIHRvIGluc3RhbmNlLCBzbyB0aGV5IGNhbiBiZSBpbnZva2VkIGFzIHJlZ3VsYXIgZnVuY3Rpb25zXG4vLyAoZS5nLiwgdG8gcGFzcyBhcm91bmQgdGhlIGZldGNoIGZ1bmN0aW9uKVxuXG5PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhfc29saWRfYXV0aF9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcImRlZmF1bHRcIl0ucHJvdG90eXBlKS5mb3JFYWNoKHByb3BlcnR5ID0+IHtcbiAgY29uc3QgdmFsdWUgPSBhdXRoW3Byb3BlcnR5XTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXV0aFtwcm9wZXJ0eV0gPSB2YWx1ZS5iaW5kKGF1dGgpO1xuICB9XG59KTsgLy8gRXhwb3NlIHdpbmRvdy5Tb2xpZEF1dGhDbGllbnQgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIGlmICgnU29saWRBdXRoQ2xpZW50JyBpbiB3aW5kb3cpIHtcbiAgICBjb25zb2xlLndhcm4oJ0NhdXRpb246IG11bHRpcGxlIHZlcnNpb25zIG9mIHNvbGlkLWF1dGgtY2xpZW50IGFjdGl2ZS4nKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgd2FybmVkID0gZmFsc2U7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdywgJ1NvbGlkQXV0aENsaWVudCcsIHtcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnNvbGUud2Fybignd2luZG93LlNvbGlkQXV0aENsaWVudCBoYXMgYmVlbiBkZXByZWNhdGVkLicpO1xuICAgICAgICAgIGNvbnNvbGUud2FybignUGxlYXNlIHVzZSB3aW5kb3cuc29saWQuYXV0aCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGF1dGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTb2xpZEF1dGhDbGllbnQ7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZXZlbnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGV2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGV2ZW50c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXV0aG5fZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BvcHVwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuXG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhzb3VyY2UsIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKiBnbG9iYWwgZmV0Y2ggKi9cblxuXG5cblxuXG5cbiAvLyBTdG9yZSB0aGUgZ2xvYmFsIGZldGNoLCBzbyB0aGUgdXNlciBpcyBmcmVlIHRvIG92ZXJyaWRlIGl0XG5cbmNvbnN0IGdsb2JhbEZldGNoID0gZmV0Y2g7XG5jbGFzcyBTb2xpZEF1dGhDbGllbnQgZXh0ZW5kcyBldmVudHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0LmEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9wZW5kaW5nU2Vzc2lvblwiLCB2b2lkIDApO1xuICB9XG5cbiAgZmV0Y2goaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCBPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJ0b1VybFN0cmluZ1wiXSkoaW5wdXQpKTtcbiAgICByZXR1cm4gT2JqZWN0KF9hdXRobl9mZXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1wiYXV0aG5GZXRjaFwiXSkoT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bXCJkZWZhdWx0U3RvcmFnZVwiXSkoKSwgZ2xvYmFsRmV0Y2gsIGlucHV0LCBvcHRpb25zKTtcbiAgfVxuXG4gIGxvZ2luKGlkcCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0TG9naW5PcHRpb25zKE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImN1cnJlbnRVcmxOb1BhcmFtc1wiXSkoKSksIHt9LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ2luXCJdKGlkcCwgb3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyBwb3B1cExvZ2luKG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdExvZ2luT3B0aW9ucygpLCB7fSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoIS9odHRwcz86Ly50ZXN0KG9wdGlvbnMucG9wdXBVcmkpKSB7XG4gICAgICBvcHRpb25zLnBvcHVwVXJpID0gbmV3IFVSTChvcHRpb25zLnBvcHVwVXJpIHx8ICcvLndlbGwta25vd24vc29saWQvbG9naW4nLCB3aW5kb3cubG9jYXRpb24pLnRvU3RyaW5nKCk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmNhbGxiYWNrVXJpKSB7XG4gICAgICBvcHRpb25zLmNhbGxiYWNrVXJpID0gb3B0aW9ucy5wb3B1cFVyaTtcbiAgICB9XG5cbiAgICBjb25zdCBwb3B1cCA9IE9iamVjdChfcG9wdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm9wZW5JZHBQb3B1cFwiXSkob3B0aW9ucy5wb3B1cFVyaSk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfcG9wdXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcIm9idGFpblNlc3Npb25cIl0pKG9wdGlvbnMuc3RvcmFnZSwgcG9wdXAsIG9wdGlvbnMpO1xuICAgIHRoaXMuZW1pdCgnbG9naW4nLCBzZXNzaW9uKTtcbiAgICB0aGlzLmVtaXQoJ3Nlc3Npb24nLCBzZXNzaW9uKTtcbiAgICByZXR1cm4gc2Vzc2lvbjtcbiAgfVxuXG4gIGFzeW5jIGN1cnJlbnRTZXNzaW9uKCkge1xuICAgIGxldCBzdG9yYWdlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImRlZmF1bHRTdG9yYWdlXCJdKSgpO1xuICAgIC8vIFRyeSB0byBvYnRhaW4gYSBzdG9yZWQgb3IgcGVuZGluZyBzZXNzaW9uXG4gICAgbGV0IHNlc3Npb24gPSB0aGlzLl9wZW5kaW5nU2Vzc2lvbiB8fCAoYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJnZXRTZXNzaW9uXCJdKShzdG9yYWdlKSk7IC8vIElmIG5vbmUgZm91bmQsIGF0dGVtcHQgdG8gY3JlYXRlIGEgbmV3IHNlc3Npb25cblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgLy8gVHJ5IHRvIGNyZWF0ZSBhIG5ldyBPSURDIHNlc3Npb24gZnJvbSBzdG9yZWQgdG9rZW5zXG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nU2Vzc2lvbiA9IF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXCJjdXJyZW50U2Vzc2lvblwiXShzdG9yYWdlKTtcbiAgICAgICAgc2Vzc2lvbiA9IGF3YWl0IHRoaXMuX3BlbmRpbmdTZXNzaW9uO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH0gLy8gU2F2ZSB0aGUgbmV3IHNlc3Npb24gYW5kIGVtaXQgc2Vzc2lvbiBldmVudHNcblxuXG4gICAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgICBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcInNhdmVTZXNzaW9uXCJdKShzdG9yYWdlKShzZXNzaW9uKTtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2dpbicsIHNlc3Npb24pO1xuICAgICAgICB0aGlzLmVtaXQoJ3Nlc3Npb24nLCBzZXNzaW9uKTtcbiAgICAgIH1cblxuICAgICAgZGVsZXRlIHRoaXMuX3BlbmRpbmdTZXNzaW9uO1xuICAgIH1cblxuICAgIHJldHVybiBzZXNzaW9uO1xuICB9XG5cbiAgYXN5bmMgdHJhY2tTZXNzaW9uKGNhbGxiYWNrKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgc3RhbmRhcmQvbm8tY2FsbGJhY2stbGl0ZXJhbCAqL1xuICAgIGNhbGxiYWNrKChhd2FpdCB0aGlzLmN1cnJlbnRTZXNzaW9uKCkpKTtcbiAgICB0aGlzLm9uKCdzZXNzaW9uJywgY2FsbGJhY2spO1xuICB9XG5cbiAgc3RvcFRyYWNrU2Vzc2lvbihjYWxsYmFjaykge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ3Nlc3Npb24nLCBjYWxsYmFjayk7XG4gIH1cblxuICBhc3luYyBsb2dvdXQoKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKCk7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1wiZ2V0U2Vzc2lvblwiXSkoc3RvcmFnZSk7XG5cbiAgICBpZiAoc2Vzc2lvbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcImxvZ291dFwiXShzdG9yYWdlLCBnbG9iYWxGZXRjaCk7XG4gICAgICAgIHRoaXMuZW1pdCgnbG9nb3V0Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgnc2Vzc2lvbicsIG51bGwpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9nZ2luZyBvdXQ6Jyk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgIH1cblxuICAgICAgYXdhaXQgT2JqZWN0KF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJjbGVhclNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuICAgIH1cbiAgfVxuXG59XG5cbmZ1bmN0aW9uIGRlZmF1bHRMb2dpbk9wdGlvbnModXJsKSB7XG4gIHJldHVybiB7XG4gICAgY2FsbGJhY2tVcmk6IHVybCA/IHVybC5zcGxpdCgnIycpWzBdIDogJycsXG4gICAgcG9wdXBVcmk6ICcnLFxuICAgIHN0b3JhZ2U6IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wiZGVmYXVsdFN0b3JhZ2VcIl0pKClcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9kZWZpbmVQcm9wZXJ0eTtcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cblxuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXV0aG5GZXRjaFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGF1dGhuRmV0Y2g7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGlzb21vcnBoaWNfZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgaXNvbW9ycGhpY19mZXRjaF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGlzb21vcnBoaWNfZmV0Y2hfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9ob3N0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5cblxuXG5hc3luYyBmdW5jdGlvbiBhdXRobkZldGNoKHN0b3JhZ2UsIGZldGNoLCBpbnB1dCwgb3B0aW9ucykge1xuICAvLyBJZiBub3QgYXV0aGVudGljYXRlZCwgcGVyZm9ybSBhIHJlZ3VsYXIgZmV0Y2hcbiAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IE9iamVjdChfc2Vzc2lvbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wiZ2V0U2Vzc2lvblwiXSkoc3RvcmFnZSk7XG5cbiAgaWYgKCFzZXNzaW9uKSB7XG4gICAgcmV0dXJuIGZldGNoKGlucHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiB3ZSBrbm93IHRoZSBzZXJ2ZXIgZXhwZWN0cyBjcmVkZW50aWFscywgc2VuZCB0aGVtXG5cblxuICBpZiAoYXdhaXQgc2hvdWxkU2hhcmVDcmVkZW50aWFscyhzdG9yYWdlLCBpbnB1dCkpIHtcbiAgICByZXR1cm4gT2JqZWN0KF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXCJmZXRjaFdpdGhDcmVkZW50aWFsc1wiXSkoc2Vzc2lvbiwgZmV0Y2gsIGlucHV0LCBvcHRpb25zKTtcbiAgfSAvLyBJZiB3ZSBkb24ndCBrbm93IGZvciBzdXJlLCB0cnkgYSByZWd1bGFyIGZldGNoIGZpcnN0XG5cblxuICBsZXQgcmVzcCA9IGF3YWl0IGZldGNoKGlucHV0LCBvcHRpb25zKTsgLy8gSWYgdGhlIHNlcnZlciB0aGVuIHJlcXVlc3RzIGNyZWRlbnRpYWxzLCBzZW5kIHRoZW1cblxuICBpZiAocmVzcC5zdGF0dXMgPT09IDQwMSkge1xuICAgIGF3YWl0IE9iamVjdChfaG9zdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1widXBkYXRlSG9zdEZyb21SZXNwb25zZVwiXSkoc3RvcmFnZSkocmVzcCk7XG5cbiAgICBpZiAoYXdhaXQgc2hvdWxkU2hhcmVDcmVkZW50aWFscyhzdG9yYWdlLCBpbnB1dCkpIHtcbiAgICAgIHJlc3AgPSBPYmplY3QoX3dlYmlkX29pZGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1tcImZldGNoV2l0aENyZWRlbnRpYWxzXCJdKShzZXNzaW9uLCBmZXRjaCwgaW5wdXQsIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXNwO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzaG91bGRTaGFyZUNyZWRlbnRpYWxzKHN0b3JhZ2UsIGlucHV0KSB7XG4gIGNvbnN0IHJlcXVlc3RIb3N0ID0gYXdhaXQgT2JqZWN0KF9ob3N0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJnZXRIb3N0XCJdKShzdG9yYWdlKShPYmplY3QoX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJ0b1VybFN0cmluZ1wiXSkoaW5wdXQpKTtcbiAgcmV0dXJuIHJlcXVlc3RIb3N0ICE9IG51bGwgJiYgcmVxdWVzdEhvc3QucmVxdWlyZXNBdXRoO1xufVxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuKGZ1bmN0aW9uKCkgeyBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvd1tcImZldGNoXCJdOyB9KCkpO1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3VycmVudFVybFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRVcmw7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImN1cnJlbnRVcmxOb1BhcmFtc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGN1cnJlbnRVcmxOb1BhcmFtczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibmF2aWdhdGVUb1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5hdmlnYXRlVG87IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9yaWdpbk9mXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gb3JpZ2luT2Y7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInRvVXJsU3RyaW5nXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdG9VcmxTdHJpbmc7IH0pO1xuLyogZXNsaW50LWVudiBicm93c2VyICovXG5mdW5jdGlvbiBnZXRMb2NhdGlvbigpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmxvY2F0aW9uIDoge1xuICAgIGhyZWY6ICdodHRwczovL2V4YW1wbGUub3JnLycsXG4gICAgcGF0aG5hbWU6ICcvJyxcbiAgICBvcmlnaW46ICdleGFtcGxlLm9yZydcbiAgfTtcbn1cblxuY29uc3QgY3VycmVudFVybCA9ICgpID0+IGdldExvY2F0aW9uKCkuaHJlZjtcbmNvbnN0IGN1cnJlbnRVcmxOb1BhcmFtcyA9ICgpID0+IGdldExvY2F0aW9uKCkub3JpZ2luICsgZ2V0TG9jYXRpb24oKS5wYXRobmFtZTtcbmNvbnN0IG5hdmlnYXRlVG8gPSB1cmwgPT4ge1xuICBnZXRMb2NhdGlvbigpLmhyZWYgPSB1cmw7XG59O1xuY29uc3Qgb3JpZ2luT2YgPSB1cmwgPT4gbmV3IFVSTCh1cmwpLm9yaWdpbjtcbmNvbnN0IHRvVXJsU3RyaW5nID0gdXJsID0+IHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSB7XG4gICAgdXJsID0gJ3VybCcgaW4gdXJsID8gdXJsLnVybCA6IHVybC50b1N0cmluZygpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBVUkwodXJsLCBjdXJyZW50VXJsKCkpLnRvU3RyaW5nKCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZ2V0SG9zdFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGdldEhvc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInNhdmVIb3N0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gc2F2ZUhvc3Q7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInVwZGF0ZUhvc3RGcm9tUmVzcG9uc2VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiB1cGRhdGVIb3N0RnJvbVJlc3BvbnNlOyB9KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXNzaW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJpZF9vaWRjX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogZ2xvYmFsUmVxdWVzdCwgUmVzcG9uc2UsIFVSTCAqL1xuXG5cblxuZnVuY3Rpb24gZ2V0SG9zdChzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyB1cmwgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIGhvc3RcbiAgICB9ID0gbmV3IFVSTCh1cmwpO1xuICAgIGNvbnN0IHNlc3Npb24gPSBhd2FpdCBPYmplY3QoX3Nlc3Npb25fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldFNlc3Npb25cIl0pKHN0b3JhZ2UpO1xuXG4gICAgaWYgKHNlc3Npb24gJiYgaG9zdCA9PT0gbmV3IFVSTChzZXNzaW9uLmlkcCkuaG9zdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdXJsOiBob3N0LFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgaG9zdHNcbiAgICB9ID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgICByZXR1cm4gaG9zdHMgJiYgaG9zdHNbaG9zdF07XG4gIH07XG59XG5mdW5jdGlvbiBzYXZlSG9zdChzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyAoX3JlZikgPT4ge1xuICAgIGxldCB7XG4gICAgICB1cmwsXG4gICAgICByZXF1aXJlc0F1dGhcbiAgICB9ID0gX3JlZjtcbiAgICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsIGRhdGEgPT4gX29iamVjdFNwcmVhZCh7fSwgZGF0YSwge1xuICAgICAgaG9zdHM6IF9vYmplY3RTcHJlYWQoe30sIGRhdGEuaG9zdHMsIHtcbiAgICAgICAgW3VybF06IHtcbiAgICAgICAgICByZXF1aXJlc0F1dGhcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KSk7XG4gIH07XG59XG5mdW5jdGlvbiB1cGRhdGVIb3N0RnJvbVJlc3BvbnNlKHN0b3JhZ2UpIHtcbiAgcmV0dXJuIGFzeW5jIHJlc3AgPT4ge1xuICAgIGlmIChfd2ViaWRfb2lkY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1wicmVxdWlyZXNBdXRoXCJdKHJlc3ApKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGhvc3RcbiAgICAgIH0gPSBuZXcgVVJMKHJlc3AudXJsKTtcbiAgICAgIGF3YWl0IHNhdmVIb3N0KHN0b3JhZ2UpKHtcbiAgICAgICAgdXJsOiBob3N0LFxuICAgICAgICByZXF1aXJlc0F1dGg6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldFNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRTZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJzYXZlU2Vzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHNhdmVTZXNzaW9uOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJjbGVhclNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjbGVhclNlc3Npb247IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKHNvdXJjZSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhzb3VyY2UpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cblxuYXN5bmMgZnVuY3Rpb24gZ2V0U2Vzc2lvbihzdG9yYWdlKSB7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcImdldERhdGFcIl0pKHN0b3JhZ2UpO1xuICByZXR1cm4gZGF0YS5zZXNzaW9uIHx8IG51bGw7XG59XG5mdW5jdGlvbiBzYXZlU2Vzc2lvbihzdG9yYWdlKSB7XG4gIHJldHVybiBhc3luYyBzZXNzaW9uID0+IHtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJ1cGRhdGVTdG9yYWdlXCJdKShzdG9yYWdlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICAgIHNlc3Npb25cbiAgICB9KSk7XG4gICAgcmV0dXJuIGRhdGEuc2Vzc2lvbjtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGNsZWFyU2Vzc2lvbihzdG9yYWdlKSB7XG4gIGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1widXBkYXRlU3RvcmFnZVwiXSkoc3RvcmFnZSwgZGF0YSA9PiBfb2JqZWN0U3ByZWFkKHt9LCBkYXRhLCB7XG4gICAgc2Vzc2lvbjogbnVsbFxuICB9KSk7XG59XG5cbi8qKiovIH0pLFxuLyogOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJOQU1FU1BBQ0VcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBOQU1FU1BBQ0U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImRlZmF1bHRTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gZGVmYXVsdFN0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImdldERhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXREYXRhOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJ1cGRhdGVTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gdXBkYXRlU3RvcmFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYXN5bmNTdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYXN5bmNTdG9yYWdlOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJtZW1TdG9yYWdlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWVtU3RvcmFnZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiaXBjU3RvcmFnZVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIGlwY1N0b3JhZ2U7IH0pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9pcGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xuXG5jb25zdCBOQU1FU1BBQ0UgPSAnc29saWQtYXV0aC1jbGllbnQnO1xuY29uc3QgZGVmYXVsdFN0b3JhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IGhhc0xvY2FsU3RvcmFnZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdztcbiAgcmV0dXJuIGFzeW5jU3RvcmFnZShoYXNMb2NhbFN0b3JhZ2UgPyB3aW5kb3cubG9jYWxTdG9yYWdlIDogbWVtU3RvcmFnZSgpKTtcbn07XG4vKipcbiAqIEdldHMgdGhlIGRlc2VyaWFsaXplZCBzdG9yZWQgZGF0YVxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGdldERhdGEoc3RvcmUpIHtcbiAgbGV0IHNlcmlhbGl6ZWQ7XG4gIGxldCBkYXRhO1xuXG4gIHRyeSB7XG4gICAgc2VyaWFsaXplZCA9IGF3YWl0IHN0b3JlLmdldEl0ZW0oTkFNRVNQQUNFKTtcbiAgICBkYXRhID0gSlNPTi5wYXJzZShzZXJpYWxpemVkIHx8ICd7fScpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZGVzZXJpYWxpemUgZGF0YTonLCBzZXJpYWxpemVkKTtcbiAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIGRhdGEgPSB7fTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBVcGRhdGVzIGEgU3RvcmFnZSBvYmplY3Qgd2l0aG91dCBtdXRhdGluZyBpdHMgaW50ZXJtZWRpYXRlIHJlcHJlc2VudGF0aW9uLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVN0b3JhZ2Uoc3RvcmUsIHVwZGF0ZSkge1xuICBjb25zdCBjdXJyZW50RGF0YSA9IGF3YWl0IGdldERhdGEoc3RvcmUpO1xuICBjb25zdCBuZXdEYXRhID0gdXBkYXRlKGN1cnJlbnREYXRhKTtcbiAgYXdhaXQgc3RvcmUuc2V0SXRlbShOQU1FU1BBQ0UsIEpTT04uc3RyaW5naWZ5KG5ld0RhdGEpKTtcbiAgcmV0dXJuIG5ld0RhdGE7XG59XG4vKipcbiAqIFRha2VzIGEgc3luY2hyb25vdXMgc3RvcmFnZSBpbnRlcmZhY2UgYW5kIHdyYXBzIGl0IHdpdGggYW4gYXN5bmMgaW50ZXJmYWNlLlxuICovXG5cbmZ1bmN0aW9uIGFzeW5jU3RvcmFnZShzdG9yYWdlKSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgIH0sXG4gICAgc2V0SXRlbTogKGtleSwgdmFsKSA9PiB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHN0b3JhZ2Uuc2V0SXRlbShrZXksIHZhbCkpO1xuICAgIH0sXG4gICAgcmVtb3ZlSXRlbToga2V5ID0+IHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc3RvcmFnZS5yZW1vdmVJdGVtKGtleSkpO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IG1lbVN0b3JhZ2UgPSAoKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0ge307XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IHtcbiAgICAgIGlmICh0eXBlb2Ygc3RvcmVba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHN0b3JlW2tleV07XG4gICAgfSxcbiAgICBzZXRJdGVtOiAoa2V5LCB2YWwpID0+IHtcbiAgICAgIHN0b3JlW2tleV0gPSB2YWw7XG4gICAgfSxcbiAgICByZW1vdmVJdGVtOiBrZXkgPT4ge1xuICAgICAgZGVsZXRlIHN0b3JlW2tleV07XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGlwY1N0b3JhZ2UoY2xpZW50KSB7XG4gIHJldHVybiB7XG4gICAgZ2V0SXRlbToga2V5ID0+IGNsaWVudC5yZXF1ZXN0KCdzdG9yYWdlL2dldEl0ZW0nLCBrZXkpLFxuICAgIHNldEl0ZW06IChrZXksIHZhbCkgPT4gY2xpZW50LnJlcXVlc3QoJ3N0b3JhZ2Uvc2V0SXRlbScsIGtleSwgdmFsKSxcbiAgICByZW1vdmVJdGVtOiBrZXkgPT4gY2xpZW50LnJlcXVlc3QoJ3N0b3JhZ2UvcmVtb3ZlSXRlbScsIGtleSlcbiAgfTtcbn1cblxuLyoqKi8gfSksXG4vKiAxMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJTZXJ2ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBTZXJ2ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIkNsaWVudFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIENsaWVudDsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcblxuXG4vKlxuICBUaGlzIG1vZHVsZSBkZXNjcmliZXMgYSBzaW1wbGUgSVBDIGludGVyZmFjZSBmb3IgY29tbXVuaWNhdGluZyBiZXR3ZWVuIGJyb3dzZXIgd2luZG93cy5cbiAgd2luZG93LnBvc3RNZXNzYWdlKCkgaXMgdGhlIHRyYW5zcG9ydCBpbnRlcmZhY2UsIGFuZCBhIHJlcXVlc3QvcmVzcG9uc2UgaW50ZXJmYWNlXG4gIGlzIGRlZmluZWQgb24gdG9wIG9mIGl0IGFzIGZvbGxvd3M6XG5cbiAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAnc29saWQtYXV0aC1jbGllbnQnOiB7XG4gICAgICBpZDogMTIzNCxcbiAgICAgIG1ldGhvZDogJ2RvU29tZXRoaW5nUGxlYXNlJyxcbiAgICAgIGFyZ3M6IFsgJ29uZScsICd0d28nLCAndGhyZWUnIF1cbiAgICB9XG4gIH1cblxuICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAnc29saWQtYXV0aC1jbGllbnQnOiB7XG4gICAgICBpZDogMTIzNCxcbiAgICAgIHJldDogJ3RoZV92YWx1ZSdcbiAgICB9XG4gIH1cbiovXG5jb25zdCBOQU1FU1BBQ0UgPSAnc29saWQtYXV0aC1jbGllbnQnO1xuLyoqXG4gKiBSZWNlaXZlcyBhbmQgaGFuZGxlcyByZW1vdGUgcHJvY2VkdXJlIGNhbGxzLlxuICovXG5cbmNsYXNzIFNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGNsaWVudFdpbmRvdywgY2xpZW50T3JpZ2luLCBoYW5kbGUpIHtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIFwiX2NsaWVudFdpbmRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9jbGllbnRPcmlnaW5cIiwgdm9pZCAwKTtcblxuICAgIF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfZGVmaW5lUHJvcGVydHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkodGhpcywgXCJfaGFuZGxlclwiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9tZXNzYWdlTGlzdGVuZXJcIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX2NsaWVudFdpbmRvdyA9IGNsaWVudFdpbmRvdztcbiAgICB0aGlzLl9jbGllbnRPcmlnaW4gPSBjbGllbnRPcmlnaW47XG4gICAgdGhpcy5faGFuZGxlciA9IGhhbmRsZTtcblxuICAgIHRoaXMuX21lc3NhZ2VMaXN0ZW5lciA9IGV2ZW50ID0+IHRoaXMuX2hhbmRsZU1lc3NhZ2UoZXZlbnQpO1xuICB9XG5cbiAgYXN5bmMgX2hhbmRsZU1lc3NhZ2UoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBkYXRhLFxuICAgICAgb3JpZ2luXG4gICAgfSA9IF9yZWY7XG5cbiAgICAvLyBFbnN1cmUgd2UgY2FuIHBvc3QgdG8gdGhlIG9yaWdpblxuICAgIGlmIChvcmlnaW4gIT09IHRoaXMuX2NsaWVudE9yaWdpbikge1xuICAgICAgY29uc29sZS53YXJuKFwic29saWQtYXV0aC1jbGllbnQgaXMgbGlzdGVuaW5nIHRvIFwiLmNvbmNhdCh0aGlzLl9jbGllbnRPcmlnaW4sIFwiIFwiKSArIFwic28gaWdub3JlZCBhIG1lc3NhZ2UgcmVjZWl2ZWQgZnJvbSBcIi5jb25jYXQob3JpZ2luLCBcIi5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gUGFyc2UgdGhlIHJlcXVlc3QgYW5kIHNlbmQgaXQgdG8gdGhlIGhhbmRsZXJcblxuXG4gICAgY29uc3QgcmVxID0gZGF0YSAmJiBkYXRhW05BTUVTUEFDRV07XG5cbiAgICBpZiAocmVxICYmIHJlcS5tZXRob2QpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgYXJnc1xuICAgICAgfSA9IHJlcTtcbiAgICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuX2hhbmRsZXIobWV0aG9kLCAuLi5hcmdzKTtcblxuICAgICAgdGhpcy5fY2xpZW50V2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgICAgW05BTUVTUEFDRV06IHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICByZXRcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5fY2xpZW50T3JpZ2luKTtcbiAgICB9XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHRoaXMuX21lc3NhZ2VMaXN0ZW5lcik7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5fbWVzc2FnZUxpc3RlbmVyKTtcbiAgfVxuXG59XG4vKipcbiAqIE1ha2VzIHJlbW90ZSBwcm9jZWR1cmUgY2FsbHMuXG4gKi9cblxuY2xhc3MgQ2xpZW50IHtcbiAgY29uc3RydWN0b3Ioc2VydmVyV2luZG93LCBzZXJ2ZXJPcmlnaW4pIHtcbiAgICBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIFwiX3NlcnZlcldpbmRvd1wiLCB2b2lkIDApO1xuXG4gICAgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSh0aGlzLCBcIl9zZXJ2ZXJPcmlnaW5cIiwgdm9pZCAwKTtcblxuICAgIHRoaXMuX3NlcnZlcldpbmRvdyA9IHNlcnZlcldpbmRvdztcbiAgICB0aGlzLl9zZXJ2ZXJPcmlnaW4gPSBzZXJ2ZXJPcmlnaW47XG4gIH1cblxuICByZXF1ZXN0KG1ldGhvZCkge1xuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3QgYXMgYSBtZXNzYWdlIHRvIHRoZSBzZXJ2ZXIgd2luZG93XG4gICAgY29uc3QgaWQgPSBNYXRoLnJhbmRvbSgpO1xuXG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdGhpcy5fc2VydmVyV2luZG93LnBvc3RNZXNzYWdlKHtcbiAgICAgIFtOQU1FU1BBQ0VdOiB7XG4gICAgICAgIGlkLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGFyZ3NcbiAgICAgIH1cbiAgICB9LCB0aGlzLl9zZXJ2ZXJPcmlnaW4pOyAvLyBDcmVhdGUgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHJlcXVlc3QncyByZXR1cm4gdmFsdWVcblxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIExpc3RlbiBmb3IgcmVzcG9uc2VzIHRvIHRoZSByZXF1ZXN0XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlc3BvbnNlTGlzdGVuZXIpOyAvLyBDYW5jZWwgaWYgdGhlIHJlc3BvbnNlIHRha2VzIHRvbyBsb25nXG5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignQ291bGQgbm90IGNvbm5lY3QgdG8gbWFpbiB3aW5kb3cuJykpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIHJlc3BvbnNlTGlzdGVuZXIpO1xuICAgICAgfSwgMjAwMCk7IC8vIFByb2Nlc3NlcyBhIHBvc3NpYmxlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0XG5cbiAgICAgIGZ1bmN0aW9uIHJlc3BvbnNlTGlzdGVuZXIoX3JlZjIpIHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICBkYXRhXG4gICAgICAgIH0gPSBfcmVmMjtcbiAgICAgICAgY29uc3QgcmVzcCA9IGRhdGEgJiYgZGF0YVtOQU1FU1BBQ0VdO1xuXG4gICAgICAgIGlmIChyZXNwICYmIHJlc3AuaWQgPT09IGlkICYmIHJlc3AuaGFzT3duUHJvcGVydHkoJ3JldCcpKSB7XG4gICAgICAgICAgcmVzb2x2ZShyZXNwLnJldCk7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcmVzcG9uc2VMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59XG5cbi8qKiovIH0pLFxuLyogMTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9naW5cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBsb2dpbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiY3VycmVudFNlc3Npb25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBjdXJyZW50U2Vzc2lvbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwibG9nb3V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gbG9nb3V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJnZXRSZWdpc3RlcmVkUnBcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBnZXRSZWdpc3RlcmVkUnA7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInJlcXVpcmVzQXV0aFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHJlcXVpcmVzQXV0aDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiZmV0Y2hXaXRoQ3JlZGVudGlhbHNcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBmZXRjaFdpdGhDcmVkZW50aWFsczsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19vYmplY3RXaXRob3V0UHJvcGVydGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19vYmplY3RXaXRob3V0UHJvcGVydGllc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9iYWJlbF9ydW50aW1lX2hlbHBlcnNfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYmFiZWxfcnVudGltZV9oZWxwZXJzX2RlZmluZVByb3BlcnR5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBhdXRoX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgYXV0aF9oZWFkZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihhdXRoX2hlYWRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfb2lkY19ycF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfc29saWRfb2lkY19ycF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc29saWRfb2lkY19ycF9saWJfUG9QVG9rZW5fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oODApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zb2xpZF9vaWRjX3JwX2xpYl9Qb1BUb2tlbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKF9zb2xpZF9vaWRjX3JwX2xpYl9Qb1BUb2tlbl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XG5cblxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoc291cmNlLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2JhYmVsX3J1bnRpbWVfaGVscGVyc19kZWZpbmVQcm9wZXJ0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuLyogZ2xvYmFsIFJlc3BvbnNlICovXG5cblxuXG5cblxuYXN5bmMgZnVuY3Rpb24gbG9naW4oaWRwLCBvcHRpb25zKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcnAgPSBhd2FpdCBnZXRSZWdpc3RlcmVkUnAoaWRwLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzYXZlQXBwSGFzaEZyYWdtZW50KG9wdGlvbnMuc3RvcmFnZSk7XG4gICAgcmV0dXJuIHNlbmRBdXRoUmVxdWVzdChycCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybignRXJyb3IgbG9nZ2luZyBpbiB3aXRoIFdlYklELU9JREMnKTtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGN1cnJlbnRTZXNzaW9uKCkge1xuICBsZXQgc3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJkZWZhdWx0U3RvcmFnZVwiXSkoKTtcblxuICB0cnkge1xuICAgIC8vIE9idGFpbiB0aGUgUmVseWluZyBQYXJ0eVxuICAgIGNvbnN0IHJwID0gYXdhaXQgZ2V0U3RvcmVkUnAoc3RvcmFnZSk7XG5cbiAgICBpZiAoIXJwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIE9idGFpbiBhbmQgY2xlYXIgdGhlIE9JREMgVVJMIGZyYWdtZW50XG5cblxuICAgIGNvbnN0IHVybCA9IE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcImN1cnJlbnRVcmxcIl0pKCk7XG5cbiAgICBpZiAoIS8jKC4qJik/YWNjZXNzX3Rva2VuPS8udGVzdCh1cmwpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcnO1xuICAgIGF3YWl0IHJlc3RvcmVBcHBIYXNoRnJhZ21lbnQoc3RvcmFnZSk7IC8vIE9idGFpbiBhIHNlc3Npb24gZnJvbSB0aGUgUmVseWluZyBQYXJ0eVxuXG4gICAgY29uc3Qgc3RvcmVEYXRhID0gYXdhaXQgT2JqZWN0KF9zdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bXCJnZXREYXRhXCJdKShzdG9yYWdlKTtcbiAgICBjb25zdCBzZXNzaW9uID0gYXdhaXQgcnAudmFsaWRhdGVSZXNwb25zZSh1cmwsIHN0b3JlRGF0YSk7XG5cbiAgICBpZiAoIXNlc3Npb24pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKHt9LCBzZXNzaW9uLCB7XG4gICAgICB3ZWJJZDogc2Vzc2lvbi5pZENsYWltcy5zdWIsXG4gICAgICBpZHA6IHNlc3Npb24uaXNzdWVyXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnNvbGUud2FybignRXJyb3IgZmluZGluZyBhIFdlYklELU9JREMgc2Vzc2lvbicpO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gbG9nb3V0KHN0b3JhZ2UsIGZldGNoKSB7XG4gIGNvbnN0IHJwID0gYXdhaXQgZ2V0U3RvcmVkUnAoc3RvcmFnZSk7XG5cbiAgaWYgKHJwKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEZpcnN0IGxvZyBvdXQgZnJvbSB0aGUgSURQXG4gICAgICBhd2FpdCBycC5sb2dvdXQoKTsgLy8gVGhlbiwgbG9nIG91dCBmcm9tIHRoZSBSUFxuXG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBmZXRjaCgnLy53ZWxsLWtub3duL3NvbGlkL2xvZ291dCcsIHtcbiAgICAgICAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZSkgey8vIElnbm9yZSBlcnJvcnMgZm9yIHdoZW4gd2UgYXJlIG5vdCBvbiBhIFNvbGlkIHBvZFxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS53YXJuKCdFcnJvciBsb2dnaW5nIG91dCBvZiB0aGUgV2ViSUQtT0lEQyBzZXNzaW9uJyk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRSZWdpc3RlcmVkUnAoaWRwLCBvcHRpb25zKSB7XG4gIC8vIFRvIHJldXNlIGEgcG9zc2libGUgcHJldmlvdXMgUlAsXG4gIC8vIGl0IGJlIGZvciB0aGUgc2FtZSBJRFAgYW5kIHJlZGlyZWN0IFVSSVxuICBsZXQgcnAgPSBhd2FpdCBnZXRTdG9yZWRScChvcHRpb25zLnN0b3JhZ2UpO1xuXG4gIGlmICghcnAgfHwgcnAucHJvdmlkZXIudXJsICE9PSBpZHAgfHwgIXJwLnJlZ2lzdHJhdGlvbi5yZWRpcmVjdF91cmlzLmluY2x1ZGVzKG9wdGlvbnMuY2FsbGJhY2tVcmkpKSB7XG4gICAgLy8gUmVnaXN0ZXIgYSBuZXcgUlBcbiAgICBycCA9IGF3YWl0IHJlZ2lzdGVyUnAoaWRwLCBvcHRpb25zKTtcbiAgICBhd2FpdCBzdG9yZVJwKG9wdGlvbnMuc3RvcmFnZSwgaWRwLCBycCk7XG4gIH1cblxuICByZXR1cm4gcnA7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZFJwKHN0b3JhZ2UpIHtcbiAgY29uc3QgZGF0YSA9IGF3YWl0IE9iamVjdChfc3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fW1wiZ2V0RGF0YVwiXSkoc3RvcmFnZSk7XG4gIGNvbnN0IHtcbiAgICBycENvbmZpZ1xuICB9ID0gZGF0YTtcblxuICBpZiAocnBDb25maWcpIHtcbiAgICBycENvbmZpZy5zdG9yZSA9IHN0b3JhZ2U7XG4gICAgcmV0dXJuIF9zb2xpZF9vaWRjX3JwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmZyb20ocnBDb25maWcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHN0b3JlUnAoc3RvcmFnZSwgaWRwLCBycCkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsIGRhdGEgPT4gX29iamVjdFNwcmVhZCh7fSwgZGF0YSwge1xuICAgIHJwQ29uZmlnOiBycFxuICB9KSk7XG4gIHJldHVybiBycDtcbn1cblxuZnVuY3Rpb24gcmVnaXN0ZXJScChpZHAsIG9wdHMpIHtcbiAgY29uc3Qge1xuICAgIHN0b3JhZ2UsXG4gICAgY2FsbGJhY2tVcmlcbiAgfSA9IG9wdHM7XG4gIGNvbnN0IHJlc3BvbnNlVHlwZSA9ICdpZF90b2tlbiB0b2tlbic7XG4gIGNvbnN0IGNsaWVudE5hbWVJMThuID0ge307XG4gIE9iamVjdC5lbnRyaWVzKG9wdHMpLmZpbHRlcigoX3JlZikgPT4ge1xuICAgIGxldCBba2V5LCBfXSA9IF9yZWY7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKCdjbGllbnROYW1lIycpO1xuICB9KS5mb3JFYWNoKChfcmVmMikgPT4ge1xuICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICByZXR1cm4gY2xpZW50TmFtZUkxOG5ba2V5LnJlcGxhY2UoJ2NsaWVudE5hbWUjJywgJ2NsaWVudF9uYW1lIycpXSA9IHZhbHVlO1xuICB9KTtcbiAgY29uc3Qgc3VwcGxlbWVudGFyeU9wdGlvbnMgPSB7XG4gICAgbG9nb191cmk6IG9wdHMubG9nb1VyaSxcbiAgICBjb250YWN0czogb3B0cy5jb250YWN0cyxcbiAgICBjbGllbnRfbmFtZTogb3B0cy5jbGllbnROYW1lXG4gIH07XG5cbiAgY29uc3QgcmVnaXN0cmF0aW9uID0gX29iamVjdFNwcmVhZCh7XG4gICAgaXNzdWVyOiBpZHAsXG4gICAgZ3JhbnRfdHlwZXM6IFsnaW1wbGljaXQnXSxcbiAgICByZWRpcmVjdF91cmlzOiBbY2FsbGJhY2tVcmldLFxuICAgIHJlc3BvbnNlX3R5cGVzOiBbcmVzcG9uc2VUeXBlXSxcbiAgICBzY29wZTogJ29wZW5pZCBwcm9maWxlJ1xuICB9LCBjbGllbnROYW1lSTE4biwge30sIHN1cHBsZW1lbnRhcnlPcHRpb25zKTtcblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgIGRlZmF1bHRzOiB7XG4gICAgICBhdXRoZW50aWNhdGU6IHtcbiAgICAgICAgcmVkaXJlY3RfdXJpOiBjYWxsYmFja1VyaSxcbiAgICAgICAgcmVzcG9uc2VfdHlwZTogcmVzcG9uc2VUeXBlXG4gICAgICB9XG4gICAgfSxcbiAgICBzdG9yZTogc3RvcmFnZVxuICB9O1xuICByZXR1cm4gX3NvbGlkX29pZGNfcnBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEucmVnaXN0ZXIoaWRwLCByZWdpc3RyYXRpb24sIG9wdGlvbnMpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBzZW5kQXV0aFJlcXVlc3QocnAsIF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY2FsbGJhY2tVcmksXG4gICAgc3RvcmFnZVxuICB9ID0gX3JlZjM7XG4gIGNvbnN0IGRhdGEgPSBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcImdldERhdGFcIl0pKHN0b3JhZ2UpO1xuICBjb25zdCB1cmwgPSBhd2FpdCBycC5jcmVhdGVSZXF1ZXN0KHtcbiAgICByZWRpcmVjdF91cmk6IGNhbGxiYWNrVXJpXG4gIH0sIGRhdGEpO1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JhZ2UsICgpID0+IGRhdGEpO1xuICByZXR1cm4gT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1wibmF2aWdhdGVUb1wiXSkodXJsKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2F2ZUFwcEhhc2hGcmFnbWVudChzdG9yZSkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JlLCBkYXRhID0+IF9vYmplY3RTcHJlYWQoe30sIGRhdGEsIHtcbiAgICBhcHBIYXNoRnJhZ21lbnQ6IHdpbmRvdy5sb2NhdGlvbi5oYXNoXG4gIH0pKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVzdG9yZUFwcEhhc2hGcmFnbWVudChzdG9yZSkge1xuICBhd2FpdCBPYmplY3QoX3N0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1tcInVwZGF0ZVN0b3JhZ2VcIl0pKHN0b3JlLCAoX3JlZjQpID0+IHtcbiAgICBsZXQge1xuICAgICAgYXBwSGFzaEZyYWdtZW50ID0gJydcbiAgICB9ID0gX3JlZjQsXG4gICAgICAgIGRhdGEgPSBfYmFiZWxfcnVudGltZV9oZWxwZXJzX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKF9yZWY0LCBbXCJhcHBIYXNoRnJhZ21lbnRcIl0pO1xuXG4gICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBhcHBIYXNoRnJhZ21lbnQ7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0pO1xufVxuLyoqXG4gKiBBbnN3ZXJzIHdoZXRoZXIgYSBIVFRQIHJlc3BvbnNlIHJlcXVpcmVzIFdlYklELU9JREMgYXV0aGVudGljYXRpb24uXG4gKi9cblxuXG5mdW5jdGlvbiByZXF1aXJlc0F1dGgocmVzcCkge1xuICBpZiAocmVzcC5zdGF0dXMgIT09IDQwMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHd3d0F1dGhIZWFkZXIgPSByZXNwLmhlYWRlcnMuZ2V0KCd3d3ctYXV0aGVudGljYXRlJyk7XG5cbiAgaWYgKCF3d3dBdXRoSGVhZGVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgYXV0aCA9IGF1dGhfaGVhZGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYXJzZVwiXSh3d3dBdXRoSGVhZGVyKTtcbiAgcmV0dXJuIGF1dGguc2NoZW1lID09PSAnQmVhcmVyJyAmJiBhdXRoLnBhcmFtcyAmJiBhdXRoLnBhcmFtcy5zY29wZSA9PT0gJ29wZW5pZCB3ZWJpZCc7XG59XG4vKipcbiAqIEZldGNoZXMgYSByZXNvdXJjZSwgcHJvdmlkaW5nIHRoZSBXZWJJRC1PSURDIElEIFRva2VuIGFzIGF1dGhlbnRpY2F0aW9uLlxuICogQXNzdW1lcyB0aGF0IHRoZSByZXNvdXJjZSBoYXMgcmVxdWVzdGVkIHRob3NlIHRva2VucyBpbiBhIHByZXZpb3VzIHJlc3BvbnNlLlxuICovXG5cbmFzeW5jIGZ1bmN0aW9uIGZldGNoV2l0aENyZWRlbnRpYWxzKHNlc3Npb24sIGZldGNoLCBpbnB1dCwgb3B0aW9ucykge1xuICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBoZWFkZXJzXG4gIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgY29uc3Qgb3JpZ0hlYWRlcnMgPSBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogaW5wdXQuaGVhZGVycztcblxuICBpZiAob3JpZ0hlYWRlcnMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gdHlwZW9mIG9yaWdIZWFkZXJzLmVudHJpZXMgPT09ICdmdW5jdGlvbicgPyBvcmlnSGVhZGVycy5lbnRyaWVzKCkgOiBPYmplY3QuZW50cmllcyhvcmlnSGVhZGVycyk7XG5cbiAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgfSAvLyBBZGQgQXV0aG9yaXphdGlvbiBoZWFkZXJcblxuXG4gIGNvbnN0IHBvcFRva2VuID0gYXdhaXQgX3NvbGlkX29pZGNfcnBfbGliX1BvUFRva2VuX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdC5hLmlzc3VlRm9yKE9iamVjdChfdXJsX3V0aWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1tcInRvVXJsU3RyaW5nXCJdKShpbnB1dCksIHNlc3Npb24pO1xuICBoZWFkZXJzLmF1dGhvcml6YXRpb24gPSBcIkJlYXJlciBcIi5jb25jYXQocG9wVG9rZW4pO1xuICByZXR1cm4gZmV0Y2goaW5wdXQsIF9vYmplY3RTcHJlYWQoe30sIG9wdGlvbnMsIHtcbiAgICBjcmVkZW50aWFsczogJ2luY2x1ZGUnLFxuICAgIGhlYWRlcnNcbiAgfSkpO1xufVxuXG4vKioqLyB9KSxcbi8qIDEyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbnZhciBvYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShzb3VyY2UsIGV4Y2x1ZGVkKTtcbiAgdmFyIGtleSwgaTtcblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBzb3VyY2VTeW1ib2xLZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2UpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXM7XG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2U7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImZvcm1hdFwiLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfZm9ybWF0LmRlZmF1bHQ7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwicGFyc2VcIiwge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX3BhcnNlLmRlZmF1bHQ7XG4gIH1cbn0pO1xuXG52YXIgX2Zvcm1hdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xuXG52YXIgX3BhcnNlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAxNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheShhcnIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpOyB9XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpOyB9XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikgeyBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChpdGVyKSB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXRlcikgPT09IFwiW29iamVjdCBBcmd1bWVudHNdXCIpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpOyB9XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykgeyBhcnIyW2ldID0gYXJyW2ldOyB9IHJldHVybiBhcnIyOyB9IH1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7IHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7IH1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoX2QpIHRocm93IF9lOyB9IH0gcmV0dXJuIF9hcnI7IH1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyOyB9XG5cbnZhciB4eHggPSBmdW5jdGlvbiB4eHgoa2V5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gYCR7a2V5fT0ke3ZhbHVlICYmICEoMCwgX3V0aWwuaXNUb2tlbikodmFsdWUpID8gKDAsIF91dGlsLnF1b3RlKSh2YWx1ZSkgOiB2YWx1ZX1gO1xuICB9O1xufTtcblxudmFyIGJ1aWxkID0gZnVuY3Rpb24gYnVpbGQocGFyYW1zKSB7XG4gIHJldHVybiBwYXJhbXMucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBfcmVmKSB7XG4gICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksXG4gICAgICAgIGtleSA9IF9yZWYyWzBdLFxuICAgICAgICB2YWx1ZXMgPSBfcmVmMlsxXTtcblxuICAgIHZhciB0cmFuc2Zvcm0gPSB4eHgoa2V5KTtcblxuICAgIGlmICghKDAsIF91dGlsLmlzVG9rZW4pKGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTtcbiAgICB9XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHByZXYpLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodmFsdWVzLm1hcCh0cmFuc2Zvcm0pKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF90b0NvbnN1bWFibGVBcnJheShwcmV2KS5jb25jYXQoW3RyYW5zZm9ybSh2YWx1ZXMpXSk7XG4gIH0sIFtdKTtcbn07XG5cbnZhciBjaGFsbGVuZ2UgPSBmdW5jdGlvbiBjaGFsbGVuZ2UocGFyYW1zLCBvcHRpb25zKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICByZXR1cm4gYnVpbGQocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBlbnRyaWVzID0gcGFyYW1zO1xuICAgIHJldHVybiBjaGFsbGVuZ2UoT2JqZWN0LmtleXMocGFyYW1zKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIFtrZXksIGVudHJpZXNba2V5XV07XG4gICAgfSksIG9wdGlvbnMpO1xuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xufTtcblxudmFyIF9kZWZhdWx0ID0gZnVuY3Rpb24gX2RlZmF1bHQoc2NoZW1lLCB0b2tlbiwgcGFyYW1zKSB7XG4gIHZhciBvYmogPSB0eXBlb2Ygc2NoZW1lID09PSAnc3RyaW5nJyA/IHtcbiAgICBzY2hlbWUsXG4gICAgdG9rZW4sXG4gICAgcGFyYW1zXG4gIH0gOiBzY2hlbWU7XG5cbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICB9IGVsc2UgaWYgKCEoMCwgX3V0aWwuaXNTY2hlbWUpKG9iai5zY2hlbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzY2hlbWUuJyk7XG4gIH1cblxuICByZXR1cm4gW29iai5zY2hlbWVdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkodHlwZW9mIG9iai50b2tlbiAhPT0gJ3VuZGVmaW5lZCcgPyBbb2JqLnRva2VuXSA6IFtdKSwgX3RvQ29uc3VtYWJsZUFycmF5KHR5cGVvZiBvYmoucGFyYW1zICE9PSAndW5kZWZpbmVkJyA/IGNoYWxsZW5nZShvYmoucGFyYW1zKSA6IFtdKSkuam9pbignICcpO1xufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gX2RlZmF1bHQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXQuanMubWFwXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHMudW5xdW90ZSA9IGV4cG9ydHMucXVvdGUgPSBleHBvcnRzLmlzU2NoZW1lID0gZXhwb3J0cy5pc1Rva2VuID0gdm9pZCAwO1xudmFyIHRva2VuID0gL15bXlxcdTAwMDAtXFx1MDAxRlxcdTAwN0YoKTw+QCw7OlxcXFxcIi8/PXt9XFxbXFxdXFx1MDAyMFxcdTAwMDldKyQvO1xuXG52YXIgaXNUb2tlbiA9IGZ1bmN0aW9uIGlzVG9rZW4oc3RyKSB7XG4gIHJldHVybiB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyAmJiB0b2tlbi50ZXN0KHN0cik7XG59O1xuXG5leHBvcnRzLmlzVG9rZW4gPSBpc1Rva2VuO1xudmFyIGlzU2NoZW1lID0gaXNUb2tlbjtcbmV4cG9ydHMuaXNTY2hlbWUgPSBpc1NjaGVtZTtcblxudmFyIHF1b3RlID0gZnVuY3Rpb24gcXVvdGUoc3RyKSB7XG4gIHJldHVybiBgXCIke3N0ci5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyl9XCJgO1xufTtcblxuZXhwb3J0cy5xdW90ZSA9IHF1b3RlO1xuXG52YXIgdW5xdW90ZSA9IGZ1bmN0aW9uIHVucXVvdGUoc3RyKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKDEsIHN0ci5sZW5ndGggLSAyKS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJyk7XG59O1xuXG5leHBvcnRzLnVucXVvdGUgPSB1bnF1b3RlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXBcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0cy5kZWZhdWx0ID0gdm9pZCAwO1xuXG52YXIgX3V0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuLy8gbG9sIGRpc1xudmFyIGJvZHkgPSAvKCg/OlthLXpBLVowLTkuX34rXFwvLV0rPSooPzpcXHMrfCQpKXxbXlxcdTAwMDAtXFx1MDAxRlxcdTAwN0YoKTw+QCw7OlxcXFxcIi8/PXt9XFxbXFxdXFx1MDAyMFxcdTAwMDldKykoPzo9KFteXFxcXFwiPVxccyxdK3xcIig/OlteXCJcXFxcXXxcXFxcLikqXCIpKT8vZzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG52YXIgbm9ybWFsaXplID0gZnVuY3Rpb24gbm9ybWFsaXplKHByZXYsIF9jdXIpIHtcbiAgLy8gRml4dXAgcXVvdGVkIHN0cmluZ3MgYW5kIHRva2VucyB3aXRoIHNwYWNlcyBhcm91bmQgdGhlbVxuICB2YXIgY3VyID0gX2N1ci5jaGFyQXQoMCkgPT09ICdcIicgPyAoMCwgX3V0aWwudW5xdW90ZSkoX2N1cikgOiBfY3VyLnRyaW0oKTsgLy8gTWFyc2hhbFxuXG4gIGlmIChBcnJheS5pc0FycmF5KHByZXYpKSB7XG4gICAgcmV0dXJuIHByZXYuY29uY2F0KGN1cik7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByZXYgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIFtwcmV2LCBjdXJdO1xuICB9XG5cbiAgcmV0dXJuIGN1cjtcbn07XG5cbnZhciBwYXJzZVByb3BlcnRpZXMgPSBmdW5jdGlvbiBwYXJzZVByb3BlcnRpZXMoc2NoZW1lLCBzdHJpbmcpIHtcbiAgdmFyIHRva2VuID0gbnVsbDtcbiAgdmFyIHBhcmFtcyA9IHt9OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcmVzID0gYm9keS5leGVjKHN0cmluZyk7XG5cbiAgICBpZiAocmVzID09PSBudWxsKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocmVzWzJdKSB7XG4gICAgICBwYXJhbXNbcmVzWzFdXSA9IG5vcm1hbGl6ZShwYXJhbXNbcmVzWzFdXSwgcmVzWzJdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9rZW4gPSBub3JtYWxpemUodG9rZW4sIHJlc1sxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzY2hlbWUsXG4gICAgcGFyYW1zLFxuICAgIHRva2VuXG4gIH07XG59O1xuXG52YXIgX2RlZmF1bHQgPSBmdW5jdGlvbiBfZGVmYXVsdChzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSGVhZGVyIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gIH1cblxuICB2YXIgc3RhcnQgPSBzdHIuaW5kZXhPZignICcpO1xuICB2YXIgc2NoZW1lID0gc3RyLnN1YnN0cigwLCBzdGFydCk7XG5cbiAgaWYgKCEoMCwgX3V0aWwuaXNTY2hlbWUpKHNjaGVtZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHNjaGVtZSAke3NjaGVtZX1gKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZVByb3BlcnRpZXMoc2NoZW1lLCBzdHIuc3Vic3RyKHN0YXJ0KSk7XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBfZGVmYXVsdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlLmpzLm1hcFxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IGFzc2VydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xuXG5jb25zdCBmZXRjaCA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbmNvbnN0IHtcbiAgVVJMXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmNvbnN0IEhlYWRlcnMgPSBmZXRjaC5IZWFkZXJzID8gZmV0Y2guSGVhZGVycyA6IGdsb2JhbC5IZWFkZXJzO1xuXG5jb25zdCB7XG4gIEpTT05Eb2N1bWVudFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuXG5jb25zdCB7XG4gIEpXS1NldFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5jb25zdCBBdXRoZW50aWNhdGlvblJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY4KTtcblxuY29uc3QgQXV0aGVudGljYXRpb25SZXNwb25zZSA9IF9fd2VicGFja19yZXF1aXJlX18oNzApO1xuXG5jb25zdCBSZWx5aW5nUGFydHlTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc5KTtcblxuY29uc3Qgb25IdHRwRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDc0KTtcblxuY29uc3QgRm9ybVVybEVuY29kZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcbi8qKlxuICogUmVseWluZ1BhcnR5XG4gKlxuICogQGNsYXNzXG4gKiBDbGllbnQgaW50ZXJmYWNlIGZvciBPcGVuSUQgQ29ubmVjdCBSZWx5aW5nIFBhcnR5LlxuICpcbiAqIEBleGFtcGxlXG4gKiAgbGV0IGNsaWVudCA9IFJlbHlpbmdQYXJ0eSh7XG4gKiAgICBwcm92aWRlcjoge1xuICogICAgICBuYW1lOiAnQW52aWwgUmVzZWFyY2gsIEluYy4nLFxuICogICAgICB1cmw6ICdodHRwczovL2ZvcmdlLmFudmlsLmlvJ1xuICogICAgICAvLyBjb25maWd1cmF0aW9uXG4gKiAgICAgIC8vIGp3a3NcbiAqICAgIH0sXG4gKiAgICBkZWZhdWx0czoge1xuICogICAgICBwb3BUb2tlbjogZmFsc2UsXG4gKiAgICAgIGF1dGhlbnRpY2F0ZToge1xuICogICAgICAgIHJlc3BvbnNlX3R5cGU6ICdjb2RlJyxcbiAqICAgICAgICBkaXNwbGF5OiAncG9wdXAnLFxuICogICAgICAgIHNjb3BlOiAnb3BlbmlkIHByb2ZpbGUgZW1haWwnXG4gKiAgICAgIH0sXG4gKiAgICAgIHJlZ2lzdGVyOiB7XG4gKiAgICAgICAgY2xpZW50X25hbWU6ICdFeGFtcGxlJyxcbiAqICAgICAgICBjbGllbnRfdXJpOiAnaHR0cHM6Ly9leGFtcGxlLmNvbScsXG4gKiAgICAgICAgbG9nb191cmk6ICdodHRwczovL2V4YW1wbGUuY29tL2Fzc2V0cy9sb2dvLnBuZycsXG4gKiAgICAgICAgcmVkaXJlY3RfdXJpczogWydodHRwczovL2FwcC5leGFtcGxlLmNvbS9jYWxsYmFjayddLFxuICogICAgICAgIHJlc3BvbnNlX3R5cGVzOiBbJ2NvZGUnLCAnY29kZSBpZF90b2tlbiB0b2tlbiddLFxuICogICAgICAgIGdyYW50X3R5cGVzOiBbJ2F1dGhvcml6YXRpb25fY29kZSddLFxuICogICAgICAgIGRlZmF1bHRfbWF4X2FnZTogNzIwMCxcbiAqICAgICAgICBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmlzOiBbJ2h0dHBzOi8vYXBwLmV4YW1wbGUuY29tJ11cbiAqICAgICAgfSxcbiAqICAgIH0sXG4gKiAgICByZWdpc3RyYXRpb246IHtcbiAqICAgICAgLy8gaWYgeW91IGhhdmUgaXQgc2F2ZWQgc29tZXdoZXJlXG4gKiAgICB9LFxuICogICAgc3RvcmU6IGxvY2FsU3RvcmFnZSB8fCByZXEuc2Vzc2lvblxuICogIH0pXG4gKlxuICogIGNsaWVudC5kaXNjb3ZlcigpID0+IFByb21pc2VcbiAqICBjbGllbnQuandrcygpID0+IFByb21pc2VcbiAqICBjbGllbnQuYXV0aGVudGljYXRlKClcbiAqICBjbGllbnQuYXV0aGVudGljYXRlVXJpKClcbiAqICBjbGllbnQudmFsaWRhdGVSZXNwb25zZSh1cmkpID0+IFByb21pc2VcbiAqICBjbGllbnQudXNlcmluZm8oKSA9PiBQcm9taXNlXG4gKiAgY2xpZW50LmxvZ291dCgpXG4gKi9cblxuXG5jbGFzcyBSZWx5aW5nUGFydHkgZXh0ZW5kcyBKU09ORG9jdW1lbnQge1xuICAvKipcbiAgICogU2NoZW1hXG4gICAqL1xuICBzdGF0aWMgZ2V0IHNjaGVtYSgpIHtcbiAgICByZXR1cm4gUmVseWluZ1BhcnR5U2NoZW1hO1xuICB9XG4gIC8qKlxuICAgKiBmcm9tXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGUgYSBSZWx5aW5nUGFydHkgaW5zdGFuY2UgZnJvbSBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjbGllbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFJlbHlpbmdQYXJ0eT59XG4gICAqL1xuXG5cbiAgc3RhdGljIGZyb20oZGF0YSkge1xuICAgIGxldCBycCA9IG5ldyBSZWx5aW5nUGFydHkoZGF0YSk7XG4gICAgbGV0IHZhbGlkYXRpb24gPSBycC52YWxpZGF0ZSgpOyAvLyBzY2hlbWEgdmFsaWRhdGlvblxuXG4gICAgaWYgKCF2YWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb24pKSk7XG4gICAgfVxuXG4gICAgbGV0IGp3a3MgPSBycC5wcm92aWRlci5qd2tzOyAvLyByZXF1ZXN0IHRoZSBKV0sgU2V0IGlmIG1pc3NpbmdcblxuICAgIGlmICghandrcykge1xuICAgICAgcmV0dXJuIHJwLmp3a3MoKS50aGVuKCgpID0+IHJwKTtcbiAgICB9IC8vIG90aGVyd2lzZSBpbXBvcnQgdGhlIEpXSyBTZXQgdG8gd2ViY3J5cHRvXG5cblxuICAgIHJldHVybiBKV0tTZXQuaW1wb3J0S2V5cyhqd2tzKS50aGVuKGp3a3MgPT4ge1xuICAgICAgcnAucHJvdmlkZXIuandrcyA9IGp3a3M7XG4gICAgICByZXR1cm4gcnA7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlZ2lzdGVyXG4gICAqXG4gICAqIEBwYXJhbSBpc3N1ZXIge3N0cmluZ30gUHJvdmlkZXIgVVJMXG4gICAqIEBwYXJhbSByZWdpc3RyYXRpb24ge09iamVjdH0gQ2xpZW50IGR5bmFtaWMgcmVnaXN0cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuZGVmYXVsdHNcbiAgICogQHBhcmFtIFtvcHRpb25zLnN0b3JlXSB7U2Vzc2lvbnxTdG9yYWdlfVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxSZWx5aW5nUGFydHk+fSBSZWx5aW5nUGFydHkgaW5zdGFuY2UsIHJlZ2lzdGVyZWQuXG4gICAqL1xuXG5cbiAgc3RhdGljIHJlZ2lzdGVyKGlzc3VlciwgcmVnaXN0cmF0aW9uLCBvcHRpb25zKSB7XG4gICAgbGV0IHJwID0gbmV3IFJlbHlpbmdQYXJ0eSh7XG4gICAgICBwcm92aWRlcjoge1xuICAgICAgICB1cmw6IGlzc3VlclxuICAgICAgfSxcbiAgICAgIGRlZmF1bHRzOiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmRlZmF1bHRzKSxcbiAgICAgIHN0b3JlOiBvcHRpb25zLnN0b3JlXG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gcnAuZGlzY292ZXIoKSkudGhlbigoKSA9PiBycC5qd2tzKCkpLnRoZW4oKCkgPT4gcnAucmVnaXN0ZXIocmVnaXN0cmF0aW9uKSkudGhlbigoKSA9PiBycCk7XG4gIH1cbiAgLyoqXG4gICAqIERpc2NvdmVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBGZXRjaGVzIHRoZSBpc3N1ZXIncyBPcGVuSUQgQ29uZmlndXJhdGlvbi5cbiAgICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gUmVzb2x2ZXMgd2l0aCB0aGUgcHJvdmlkZXIgY29uZmlndXJhdGlvbiByZXNwb25zZVxuICAgKi9cblxuXG4gIGRpc2NvdmVyKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgaXNzdWVyID0gdGhpcy5wcm92aWRlci51cmw7XG4gICAgICBhc3NlcnQoaXNzdWVyLCAnUmVseWluZ1BhcnR5IHByb3ZpZGVyIG11c3QgZGVmaW5lIFwidXJsXCInKTtcbiAgICAgIGxldCB1cmwgPSBuZXcgVVJMKGlzc3Vlcik7XG4gICAgICB1cmwucGF0aG5hbWUgPSAnLndlbGwta25vd24vb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuICAgICAgcmV0dXJuIGZldGNoKHVybC50b1N0cmluZygpKS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBmZXRjaGluZyBvcGVuaWQgY29uZmlndXJhdGlvbicpKS50aGVuKHJlc3BvbnNlID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmpzb24oKS50aGVuKGpzb24gPT4gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uID0ganNvbik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJlZ2lzdGVyXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvbiBSZWdpc3RlcidzIGEgY2xpZW50IHdpdGggcHJvdmlkZXIgYXMgYSBSZWx5aW5nIFBhcnR5XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFJlc29sdmVzIHdpdGggdGhlIHJlZ2lzdHJhdGlvbiByZXNwb25zZSBvYmplY3RcbiAgICovXG5cblxuICByZWdpc3RlcihvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24sICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbi5yZWdpc3RyYXRpb25fZW5kcG9pbnQsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIHJlZ2lzdHJhdGlvbl9lbmRwb2ludC4nKTtcbiAgICAgIGxldCB1cmkgPSBjb25maWd1cmF0aW9uLnJlZ2lzdHJhdGlvbl9lbmRwb2ludDtcbiAgICAgIGxldCBtZXRob2QgPSAncG9zdCc7XG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgfSk7XG4gICAgICBsZXQgcGFyYW1zID0gdGhpcy5kZWZhdWx0cy5yZWdpc3RlcjtcbiAgICAgIGxldCBib2R5ID0gSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zLCBvcHRpb25zKSk7XG4gICAgICByZXR1cm4gZmV0Y2godXJpLCB7XG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keVxuICAgICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3IgcmVnaXN0ZXJpbmcgY2xpZW50JykpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oanNvbiA9PiB0aGlzLnJlZ2lzdHJhdGlvbiA9IGpzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG5cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogandrc1xuICAgKlxuICAgKiBAZGVzY3JpcHRpb24gUHJvbWlzZXMgdGhlIGlzc3VlcidzIEpXSyBTZXQuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIGp3a3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGxldCBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24sICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQuJyk7XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbi5qd2tzX3VyaSwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG1pc3Npbmcgandrc191cmkuJyk7XG4gICAgICBsZXQgdXJpID0gY29uZmlndXJhdGlvbi5qd2tzX3VyaTtcbiAgICAgIHJldHVybiBmZXRjaCh1cmkpLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIHJlc29sdmluZyBwcm92aWRlciBrZXlzJykpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuanNvbigpLnRoZW4oanNvbiA9PiBKV0tTZXQuaW1wb3J0S2V5cyhqc29uKSkudGhlbihqd2tzID0+IHRoaXMucHJvdmlkZXIuandrcyA9IGp3a3MpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBjcmVhdGVSZXF1ZXN0XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IEF1dGhuIHJlcXVlc3Qgb3B0aW9ucyBoYXNobWFwXG4gICAqIEBwYXJhbSBvcHRpb25zLnJlZGlyZWN0X3VyaSB7c3RyaW5nfVxuICAgKiBAcGFyYW0gb3B0aW9ucy5yZXNwb25zZV90eXBlIHtzdHJpbmd9IGUuZy4gJ2NvZGUnIG9yICdpZF90b2tlbiB0b2tlbidcbiAgICogQHBhcmFtIHNlc3Npb24ge1Nlc3Npb258U3RvcmFnZX0gcmVxLnNlc3Npb24gb3IgbG9jYWxTdG9yYWdlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHN0cmluZz59IEF1dGhuIHJlcXVlc3QgVVJMXG4gICAqL1xuXG5cbiAgY3JlYXRlUmVxdWVzdChvcHRpb25zLCBzZXNzaW9uKSB7XG4gICAgcmV0dXJuIEF1dGhlbnRpY2F0aW9uUmVxdWVzdC5jcmVhdGUodGhpcywgb3B0aW9ucywgc2Vzc2lvbiB8fCB0aGlzLnN0b3JlKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgUmVzcG9uc2VcbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtzdHJpbmd9IHJlcS5xdWVyeSBvciByZXEuYm9keS50ZXh0XG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufFN0b3JhZ2V9IHJlcS5zZXNzaW9uIG9yIGxvY2FsU3RvcmFnZSBvciBzaW1pbGFyXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlc3Npb24+fVxuICAgKi9cblxuXG4gIHZhbGlkYXRlUmVzcG9uc2UocmVzcG9uc2UsIHNlc3Npb24gPSB0aGlzLnN0b3JlKSB7XG4gICAgbGV0IG9wdGlvbnM7XG5cbiAgICBpZiAocmVzcG9uc2UubWF0Y2goL15odHRwKHM/KTpcXC9cXC8vKSkge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcnA6IHRoaXMsXG4gICAgICAgIHJlZGlyZWN0OiByZXNwb25zZSxcbiAgICAgICAgc2Vzc2lvblxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgcnA6IHRoaXMsXG4gICAgICAgIGJvZHk6IHJlc3BvbnNlLFxuICAgICAgICBzZXNzaW9uXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IGF1dGhSZXNwb25zZSA9IG5ldyBBdXRoZW50aWNhdGlvblJlc3BvbnNlKG9wdGlvbnMpO1xuICAgIHJldHVybiBBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlUmVzcG9uc2UoYXV0aFJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogdXNlcmluZm9cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFByb21pc2VzIHRoZSBhdXRoZW50aWNhdGVkIHVzZXIncyBjbGFpbXMuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHVzZXJpbmZvKCkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbiA9IHRoaXMucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkLicpO1xuICAgICAgYXNzZXJ0KGNvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nIHVzZXJpbmZvX2VuZHBvaW50LicpO1xuICAgICAgbGV0IHVyaSA9IGNvbmZpZ3VyYXRpb24udXNlcmluZm9fZW5kcG9pbnQ7XG4gICAgICBsZXQgYWNjZXNzX3Rva2VuID0gdGhpcy5zdG9yZS5hY2Nlc3NfdG9rZW47XG4gICAgICBhc3NlcnQoYWNjZXNzX3Rva2VuLCAnTWlzc2luZyBhY2Nlc3MgdG9rZW4uJyk7XG4gICAgICBsZXQgaGVhZGVycyA9IG5ldyBIZWFkZXJzKHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0F1dGhvcml6YXRpb24nOiBgQmVhcmVyICR7YWNjZXNzX3Rva2VufWBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZldGNoKHVyaSwge1xuICAgICAgICBoZWFkZXJzXG4gICAgICB9KS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyaW5mbycpKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBsb2dvdXRSZXF1ZXN0XG4gICAqXG4gICAqIENvbXBvc2VzIGFuZCByZXR1cm5zIHRoZSBsb2dvdXQgcmVxdWVzdCBVUkksIGJhc2VkIG9uIHRoZSBPUCdzXG4gICAqIGBlbmRfc2Vzc2lvbl9lbmRwb2ludGAsIHdpdGggYXBwcm9wcmlhdGUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogTm90ZTogQ2FsbGluZyBjbGllbnQgY29kZSBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IHRvIGNsZWFyIHRoZSBsb2NhbFxuICAgKiBzZXNzaW9uIHN0YXRlIChmb3IgZXhhbXBsZSwgYnkgY2FsbGluZyBgcnAuY2xlYXJTZXNzaW9uKClgKS4gSW4gYWRkaXRpb24sXG4gICAqIHNvbWUgSWRQcyAoc3VjaCBhcyBHb29nbGUpIG1heSBub3QgcHJvdmlkZSBhbiBgZW5kX3Nlc3Npb25fZW5kcG9pbnRgLFxuICAgKiBpbiB3aGljaCBjYXNlLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBudWxsLlxuICAgKlxuICAgKiBAc2VlIGh0dHBzOi8vb3BlbmlkLm5ldC9zcGVjcy9vcGVuaWQtY29ubmVjdC1zZXNzaW9uLTFfMC5odG1sI1JQTG9nb3V0XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBwcm92aWRlciBjb25maWcgaXMgbm90IGluaXRpYWxpemVkXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpYCB3YXMgcHJvdmlkZWQgd2l0aG91dCBhXG4gICAqICAgY29ycmVzcG9uZGluZyBgaWRfdG9rZW5faGludGBcbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zPXt9XSB7b2JqZWN0fVxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMuaWRfdG9rZW5faGludF0ge3N0cmluZ30gUkVDT01NRU5ERUQuXG4gICAqICAgUHJldmlvdXNseSBpc3N1ZWQgSUQgVG9rZW4gcGFzc2VkIHRvIHRoZSBsb2dvdXQgZW5kcG9pbnQgYXNcbiAgICogICBhIGhpbnQgYWJvdXQgdGhlIEVuZC1Vc2VyJ3MgY3VycmVudCBhdXRoZW50aWNhdGVkIHNlc3Npb24gd2l0aCB0aGVcbiAgICogICBDbGllbnQuIFRoaXMgaXMgdXNlZCBhcyBhbiBpbmRpY2F0aW9uIG9mIHRoZSBpZGVudGl0eSBvZiB0aGUgRW5kLVVzZXJcbiAgICogICB0aGF0IHRoZSBSUCBpcyByZXF1ZXN0aW5nIGJlIGxvZ2dlZCBvdXQgYnkgdGhlIE9QLiBUaGUgT1AgKm5lZWQgbm90KiBiZVxuICAgKiAgIGxpc3RlZCBhcyBhbiBhdWRpZW5jZSBvZiB0aGUgSUQgVG9rZW4gd2hlbiBpdCBpcyB1c2VkIGFzIGFuXG4gICAqICAgYGlkX3Rva2VuX2hpbnRgIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMucG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpXSB7c3RyaW5nfSBPUFRJT05BTC4gVVJMIHRvIHdoaWNoXG4gICAqICAgdGhlIFJQIGlzIHJlcXVlc3RpbmcgdGhhdCB0aGUgRW5kLVVzZXIncyBVc2VyIEFnZW50IGJlIHJlZGlyZWN0ZWQgYWZ0ZXJcbiAgICogICBhIGxvZ291dCBoYXMgYmVlbiBwZXJmb3JtZWQuIFRoZSB2YWx1ZSBNVVNUIGhhdmUgYmVlbiBwcmV2aW91c2x5XG4gICAqICAgcmVnaXN0ZXJlZCB3aXRoIHRoZSBPUCwgZWl0aGVyIHVzaW5nIHRoZSBgcG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpc2BcbiAgICogICBSZWdpc3RyYXRpb24gcGFyYW1ldGVyIG9yIHZpYSBhbm90aGVyIG1lY2hhbmlzbS4gSWYgc3VwcGxpZWQsIHRoZSBPUFxuICAgKiAgIFNIT1VMRCBob25vciB0aGlzIHJlcXVlc3QgZm9sbG93aW5nIHRoZSBsb2dvdXQuXG4gICAqXG4gICAqICAgTm90ZTogVGhlIHJlcXVpcmVtZW50IHRvIHZhbGlkYXRlIHRoZSB1cmkgZm9yIHByZXZpb3VzIHJlZ2lzdHJhdGlvbiBtZWFuc1xuICAgKiAgIHRoYXQsIGluIHByYWN0aWNlLCB0aGUgYGlkX3Rva2VuX2hpbnRgIGlzIFJFUVVJUkVEIGlmXG4gICAqICAgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaWAgaXMgdXNlZC4gT3RoZXJ3aXNlLCB0aGUgT1AgaGFzIG5vIHdheSB0byBnZXRcbiAgICogICB0aGUgYGNsaWVudF9pZGAgdG8gbG9hZCB0aGUgc2F2ZWQgY2xpZW50IHJlZ2lzdHJhdGlvbiwgdG8gdmFsaWRhdGUgdGhlXG4gICAqICAgdXJpLiBUaGUgb25seSB3YXkgaXQgY2FuIGdldCBpdCBpcyBieSBkZWNvZGluZyB0aGUgYGlkX3Rva2VuX2hpbnRgLlxuICAgKlxuICAgKiBAcGFyYW0gW29wdGlvbnMuc3RhdGVdIHtzdHJpbmd9IE9QVElPTkFMLiBPcGFxdWUgdmFsdWUgdXNlZCBieSB0aGUgUlAgdG9cbiAgICogICBtYWludGFpbiBzdGF0ZSBiZXR3ZWVuIHRoZSBsb2dvdXQgcmVxdWVzdCBhbmQgdGhlIGNhbGxiYWNrIHRvIHRoZVxuICAgKiAgIGVuZHBvaW50IHNwZWNpZmllZCBieSB0aGUgYHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaWAgcXVlcnkgcGFyYW1ldGVyLiBJZlxuICAgKiAgIGluY2x1ZGVkIGluIHRoZSBsb2dvdXQgcmVxdWVzdCwgdGhlIE9QIHBhc3NlcyB0aGlzIHZhbHVlIGJhY2sgdG8gdGhlIFJQXG4gICAqICAgdXNpbmcgdGhlIGBzdGF0ZWAgcXVlcnkgcGFyYW1ldGVyIHdoZW4gcmVkaXJlY3RpbmcgdGhlIFVzZXIgQWdlbnQgYmFjayB0b1xuICAgKiAgIHRoZSBSUC5cbiAgICpcbiAgICogVE9ETzogSW4gdGhlIGZ1dHVyZSwgY29uc2lkZXIgYWRkaW5nIGByZXNwb25zZV9tb2RlYCBwYXJhbSwgZm9yIHRoZSBPUCB0b1xuICAgKiAgIGRldGVybWluZSBob3cgdG8gcmV0dXJuIHRoZSBgc3RhdGVgIGJhY2sgdGhlIFJQLlxuICAgKiAgIEBzZWUgaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb2F1dGgtdjItbXVsdGlwbGUtcmVzcG9uc2UtdHlwZXMtMV8wLmh0bWwjUmVzcG9uc2VNb2Rlc1xuICAgKlxuICAgKiBUT0RPOiBIYW5kbGUgc3BlY2lhbCBjYXNlcyBmb3IgcG9wdWxhciBwcm92aWRlcnMgKEdvb2dsZSwgTVNGVClcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ3xudWxsfSBMb2dvdXQgdXJpIChvciBudWxsIGlmIG5vIGVuZF9zZXNzaW9uX2VuZHBvaW50IHdhc1xuICAgKiAgIHByb3ZpZGVkIGluIHRoZSBJZFAgY29uZmlnKVxuICAgKi9cblxuXG4gIGxvZ291dFJlcXVlc3Qob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3Qge1xuICAgICAgaWRfdG9rZW5faGludCxcbiAgICAgIHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSxcbiAgICAgIHN0YXRlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGNvbmZpZ3VyYXRpb247XG4gICAgYXNzZXJ0KHRoaXMucHJvdmlkZXIsICdPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBub3QgaW5pdGlhbGl6ZWQnKTtcbiAgICBjb25maWd1cmF0aW9uID0gdGhpcy5wcm92aWRlci5jb25maWd1cmF0aW9uO1xuICAgIGFzc2VydChjb25maWd1cmF0aW9uLCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbm90IGluaXRpYWxpemVkJyk7XG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBPcGVuSWQgQ29uZmlndXJhdGlvbiBmb3IgYCArIGAke2NvbmZpZ3VyYXRpb24uaXNzdWVyfSBpcyBtaXNzaW5nIGVuZF9zZXNzaW9uX2VuZHBvaW50YCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAocG9zdF9sb2dvdXRfcmVkaXJlY3RfdXJpICYmICFpZF90b2tlbl9oaW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lkX3Rva2VuX2hpbnQgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBwb3N0X2xvZ291dF9yZWRpcmVjdF91cmknKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmIChpZF90b2tlbl9oaW50KSB7XG4gICAgICBwYXJhbXMuaWRfdG9rZW5faGludCA9IGlkX3Rva2VuX2hpbnQ7XG4gICAgfVxuXG4gICAgaWYgKHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSkge1xuICAgICAgcGFyYW1zLnBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaSA9IHBvc3RfbG9nb3V0X3JlZGlyZWN0X3VyaTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdGUpIHtcbiAgICAgIHBhcmFtcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoY29uZmlndXJhdGlvbi5lbmRfc2Vzc2lvbl9lbmRwb2ludCk7XG4gICAgdXJsLnNlYXJjaCA9IEZvcm1VcmxFbmNvZGVkLmVuY29kZShwYXJhbXMpO1xuICAgIHJldHVybiB1cmwuaHJlZjtcbiAgfVxuICAvKipcbiAgICogTG9nb3V0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqXG4gICAqIFRPRE86IEFkZCBkZXByZWNhdGlvbiB3YXJuaW5ncywgdGhlbiByZW1vdmUuIENsaWVudCBjb2RlIHNob3VsZFxuICAgKiAgIHVzZSBgbG9nb3V0UmVxdWVzdCgpYCBpbnN0ZWFkXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIGxvZ291dCgpIHtcbiAgICBsZXQgY29uZmlndXJhdGlvbjtcblxuICAgIHRyeSB7XG4gICAgICBhc3NlcnQodGhpcy5wcm92aWRlciwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgIGNvbmZpZ3VyYXRpb24gPSB0aGlzLnByb3ZpZGVyLmNvbmZpZ3VyYXRpb247XG4gICAgICBhc3NlcnQoY29uZmlndXJhdGlvbiwgJ09wZW5JRCBDb25maWd1cmF0aW9uIGlzIG5vdCBpbml0aWFsaXplZC4nKTtcbiAgICAgIGFzc2VydChjb25maWd1cmF0aW9uLmVuZF9zZXNzaW9uX2VuZHBvaW50LCAnT3BlbklEIENvbmZpZ3VyYXRpb24gaXMgbWlzc2luZyBlbmRfc2Vzc2lvbl9lbmRwb2ludC4nKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQpIHtcbiAgICAgIHRoaXMuY2xlYXJTZXNzaW9uKCk7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgfVxuXG4gICAgbGV0IHVyaSA9IGNvbmZpZ3VyYXRpb24uZW5kX3Nlc3Npb25fZW5kcG9pbnQ7XG4gICAgbGV0IG1ldGhvZCA9ICdnZXQnO1xuICAgIHJldHVybiBmZXRjaCh1cmksIHtcbiAgICAgIG1ldGhvZCxcbiAgICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZSdcbiAgICB9KS50aGVuKG9uSHR0cEVycm9yKCdFcnJvciBsb2dnaW5nIG91dCcpKS50aGVuKCgpID0+IHRoaXMuY2xlYXJTZXNzaW9uKCkpOyAvLyBUT0RPOiBWYWxpZGF0ZSBgZnJvbnRjaGFubmVsX2xvZ291dF91cmlgIGlmIG5lY2Vzc2FyeVxuXG4gICAgLyoqXG4gICAgICogZnJvbnRjaGFubmVsX2xvZ291dF91cmkgLSBPUFRJT05BTC4gUlAgVVJMIHRoYXQgd2lsbCBjYXVzZSB0aGUgUlAgdG8gbG9nXG4gICAgICogaXRzZWxmIG91dCB3aGVuIHJlbmRlcmVkIGluIGFuIGlmcmFtZSBieSB0aGUgT1AuXG4gICAgICpcbiAgICAgKiBBbiBgaXNzYCAoaXNzdWVyKSBxdWVyeSBwYXJhbWV0ZXIgYW5kIGEgYHNpZGBcbiAgICAgKiAoc2Vzc2lvbiBJRCkgcXVlcnkgcGFyYW1ldGVyIE1BWSBiZSBpbmNsdWRlZCBieSB0aGUgT1AgdG8gZW5hYmxlIHRoZSBSUFxuICAgICAqIHRvIHZhbGlkYXRlIHRoZSByZXF1ZXN0IGFuZCB0byBkZXRlcm1pbmUgd2hpY2ggb2YgdGhlIHBvdGVudGlhbGx5XG4gICAgICogbXVsdGlwbGUgc2Vzc2lvbnMgaXMgdG8gYmUgbG9nZ2VkIG91dC4gSWYgYSBzaWQgKHNlc3Npb24gSUQpIHF1ZXJ5XG4gICAgICogcGFyYW1ldGVyIGlzIGluY2x1ZGVkLCBhbiBpc3MgKGlzc3VlcikgcXVlcnkgcGFyYW1ldGVyIE1VU1QgYWxzbyBiZVxuICAgICAqIGluY2x1ZGVkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9vcGVuaWQubmV0L3NwZWNzL29wZW5pZC1jb25uZWN0LWZyb250Y2hhbm5lbC0xXzAuaHRtbCNSUExvZ291dFxuICAgICAqL1xuICB9XG5cbiAgY2xlYXJTZXNzaW9uKCkge1xuICAgIGxldCBzZXNzaW9uID0gdGhpcy5zdG9yZTtcblxuICAgIGlmICghc2Vzc2lvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGRlbGV0ZSBzZXNzaW9uW1NFU1NJT05fUFJJVkFURV9LRVldO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gdXJpIHtzdHJpbmd9IFRhcmdldCBSZXNvdXJjZSBTZXJ2ZXIgVVJJXG4gICAqIEBwYXJhbSBpZFRva2VuIHtJRFRva2VufSBJRCBUb2tlbiB0byBiZSBlbWJlZGRlZCBpbiB0aGUgUG9QIHRva2VuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFBvUFRva2VuPn1cbiAgICovXG5cblxuICBwb3BUb2tlbkZvcih1cmksIGlkVG9rZW4pIHtcbiAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWVGb3IodXJpLCBpZFRva2VuKTtcbiAgfVxuXG59XG5cbmNvbnN0IFNFU1NJT05fUFJJVkFURV9LRVkgPSAnb2lkYy5zZXNzaW9uLnByaXZhdGVLZXknO1xuUmVseWluZ1BhcnR5LlNFU1NJT05fUFJJVkFURV9LRVkgPSBTRVNTSU9OX1BSSVZBVEVfS0VZO1xubW9kdWxlLmV4cG9ydHMgPSBSZWx5aW5nUGFydHk7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDIxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkge1xuXG52YXIgb2JqZWN0QXNzaWduID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIGNvbXBhcmUgYW5kIGlzQnVmZmVyIHRha2VuIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvYmxvYi82ODBlOWU1ZTQ4OGYyMmFhYzI3NTk5YTU3ZGM4NDRhNjMxNTkyOGRkL2luZGV4LmpzXG4vLyBvcmlnaW5hbCBub3RpY2U6XG5cbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmUoYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgdmFyIHggPSBhLmxlbmd0aDtcbiAgdmFyIHkgPSBiLmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXTtcbiAgICAgIHkgPSBiW2ldO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIGlmICh5IDwgeCkge1xuICAgIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gaXNCdWZmZXIoYikge1xuICBpZiAoZ2xvYmFsLkJ1ZmZlciAmJiB0eXBlb2YgZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGIpO1xuICB9XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpO1xufVxuXG4vLyBiYXNlZCBvbiBub2RlIGFzc2VydCwgb3JpZ2luYWwgbm90aWNlOlxuLy8gTkI6IFRoZSBVUkwgdG8gdGhlIENvbW1vbkpTIHNwZWMgaXMga2VwdCBqdXN0IGZvciB0cmFkaXRpb24uXG4vLyAgICAgbm9kZS1hc3NlcnQgaGFzIGV2b2x2ZWQgYSBsb3Qgc2luY2UgdGhlbiwgYm90aCBpbiBBUEkgYW5kIGJlaGF2aW9yLlxuXG4vLyBodHRwOi8vd2lraS5jb21tb25qcy5vcmcvd2lraS9Vbml0X1Rlc3RpbmcvMS4wXG4vL1xuLy8gVEhJUyBJUyBOT1QgVEVTVEVEIE5PUiBMSUtFTFkgVE8gV09SSyBPVVRTSURFIFY4IVxuLy9cbi8vIE9yaWdpbmFsbHkgZnJvbSBuYXJ3aGFsLmpzIChodHRwOi8vbmFyd2hhbGpzLm9yZylcbi8vIENvcHlyaWdodCAoYykgMjAwOSBUaG9tYXMgUm9iaW5zb24gPDI4MG5vcnRoLmNvbT5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSAnU29mdHdhcmUnKSwgdG9cbi8vIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlXG4vLyByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Jcbi8vIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4vLyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4vLyBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgJ0FTIElTJywgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOXG4vLyBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OXG4vLyBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHV0aWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbi8vIEV4cG9zZSBhIHN0cmljdCBvbmx5IHZhcmlhbnQgb2YgYXNzZXJ0XG5mdW5jdGlvbiBzdHJpY3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgaWYgKCF2YWx1ZSkgZmFpbCh2YWx1ZSwgdHJ1ZSwgbWVzc2FnZSwgJz09Jywgc3RyaWN0KTtcbn1cbmFzc2VydC5zdHJpY3QgPSBvYmplY3RBc3NpZ24oc3RyaWN0LCBhc3NlcnQsIHtcbiAgZXF1YWw6IGFzc2VydC5zdHJpY3RFcXVhbCxcbiAgZGVlcEVxdWFsOiBhc3NlcnQuZGVlcFN0cmljdEVxdWFsLFxuICBub3RFcXVhbDogYXNzZXJ0Lm5vdFN0cmljdEVxdWFsLFxuICBub3REZWVwRXF1YWw6IGFzc2VydC5ub3REZWVwU3RyaWN0RXF1YWxcbn0pO1xuYXNzZXJ0LnN0cmljdC5zdHJpY3QgPSBhc3NlcnQuc3RyaWN0O1xuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIGtleXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMjApKSlcblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihwcm9jZXNzKSB7Ly8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgfHxcbiAgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG4gICAgdmFyIGRlc2NyaXB0b3JzID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXNjcmlwdG9yc1trZXlzW2ldXSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBrZXlzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICB9O1xuXG52YXIgZm9ybWF0UmVnRXhwID0gLyVbc2RqJV0vZztcbmV4cG9ydHMuZm9ybWF0ID0gZnVuY3Rpb24oZikge1xuICBpZiAoIWlzU3RyaW5nKGYpKSB7XG4gICAgdmFyIG9iamVjdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3RzLmpvaW4oJyAnKTtcbiAgfVxuXG4gIHZhciBpID0gMTtcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgdmFyIHN0ciA9IFN0cmluZyhmKS5yZXBsYWNlKGZvcm1hdFJlZ0V4cCwgZnVuY3Rpb24oeCkge1xuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xuICAgIGlmIChpID49IGxlbikgcmV0dXJuIHg7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcbiAgICAgIGNhc2UgJyVkJzogcmV0dXJuIE51bWJlcihhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWonOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhcmdzW2krK10pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9KTtcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcbiAgICBpZiAoaXNOdWxsKHgpIHx8ICFpc09iamVjdCh4KSkge1xuICAgICAgc3RyICs9ICcgJyArIHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSAnICcgKyBpbnNwZWN0KHgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyO1xufTtcblxuXG4vLyBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbi8vIElmIC0tbm8tZGVwcmVjYXRpb24gaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG5leHBvcnRzLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKGZuLCBtc2cpIHtcbiAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiBwcm9jZXNzLm5vRGVwcmVjYXRpb24gPT09IHRydWUpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICAvLyBBbGxvdyBmb3IgZGVwcmVjYXRpbmcgdGhpbmdzIGluIHRoZSBwcm9jZXNzIG9mIHN0YXJ0aW5nIHVwLlxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVwcmVjYXRlKGZuLCBtc2cpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKHByb2Nlc3MudGhyb3dEZXByZWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59O1xuXG5cbnZhciBkZWJ1Z3MgPSB7fTtcbnZhciBkZWJ1Z0Vudmlyb247XG5leHBvcnRzLmRlYnVnbG9nID0gZnVuY3Rpb24oc2V0KSB7XG4gIGlmIChpc1VuZGVmaW5lZChkZWJ1Z0Vudmlyb24pKVxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XG4gIHNldCA9IHNldC50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWRlYnVnc1tzZXRdKSB7XG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxiJyArIHNldCArICdcXFxcYicsICdpJykudGVzdChkZWJ1Z0Vudmlyb24pKSB7XG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbXNnID0gZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcbn07XG5cblxuLyoqXG4gKiBFY2hvcyB0aGUgdmFsdWUgb2YgYSB2YWx1ZS4gVHJ5cyB0byBwcmludCB0aGUgdmFsdWUgb3V0XG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqIFRoZSBvYmplY3QgdG8gcHJpbnQgb3V0LlxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cbiAqL1xuLyogbGVnYWN5OiBvYmosIHNob3dIaWRkZW4sIGRlcHRoLCBjb2xvcnMqL1xuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcbiAgLy8gZGVmYXVsdCBvcHRpb25zXG4gIHZhciBjdHggPSB7XG4gICAgc2VlbjogW10sXG4gICAgc3R5bGl6ZTogc3R5bGl6ZU5vQ29sb3JcbiAgfTtcbiAgLy8gbGVnYWN5Li4uXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID49IDMpIGN0eC5kZXB0aCA9IGFyZ3VtZW50c1syXTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkgY3R4LmNvbG9ycyA9IGFyZ3VtZW50c1szXTtcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xuICAgIC8vIGxlZ2FjeS4uLlxuICAgIGN0eC5zaG93SGlkZGVuID0gb3B0cztcbiAgfSBlbHNlIGlmIChvcHRzKSB7XG4gICAgLy8gZ290IGFuIFwib3B0aW9uc1wiIG9iamVjdFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xuICB9XG4gIC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5kZXB0aCkpIGN0eC5kZXB0aCA9IDI7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY29sb3JzKSkgY3R4LmNvbG9ycyA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XG4gIGlmIChjdHguY29sb3JzKSBjdHguc3R5bGl6ZSA9IHN0eWxpemVXaXRoQ29sb3I7XG4gIHJldHVybiBmb3JtYXRWYWx1ZShjdHgsIG9iaiwgY3R4LmRlcHRoKTtcbn1cbmV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cblxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9BTlNJX2VzY2FwZV9jb2RlI2dyYXBoaWNzXG5pbnNwZWN0LmNvbG9ycyA9IHtcbiAgJ2JvbGQnIDogWzEsIDIyXSxcbiAgJ2l0YWxpYycgOiBbMywgMjNdLFxuICAndW5kZXJsaW5lJyA6IFs0LCAyNF0sXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXG4gICd3aGl0ZScgOiBbMzcsIDM5XSxcbiAgJ2dyZXknIDogWzkwLCAzOV0sXG4gICdibGFjaycgOiBbMzAsIDM5XSxcbiAgJ2JsdWUnIDogWzM0LCAzOV0sXG4gICdjeWFuJyA6IFszNiwgMzldLFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXG4gICdtYWdlbnRhJyA6IFszNSwgMzldLFxuICAncmVkJyA6IFszMSwgMzldLFxuICAneWVsbG93JyA6IFszMywgMzldXG59O1xuXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcbmluc3BlY3Quc3R5bGVzID0ge1xuICAnc3BlY2lhbCc6ICdjeWFuJyxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxuICAnYm9vbGVhbic6ICd5ZWxsb3cnLFxuICAndW5kZWZpbmVkJzogJ2dyZXknLFxuICAnbnVsbCc6ICdib2xkJyxcbiAgJ3N0cmluZyc6ICdncmVlbicsXG4gICdkYXRlJzogJ21hZ2VudGEnLFxuICAvLyBcIm5hbWVcIjogaW50ZW50aW9uYWxseSBub3Qgc3R5bGluZ1xuICAncmVnZXhwJzogJ3JlZCdcbn07XG5cblxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICB2YXIgc3R5bGUgPSBpbnNwZWN0LnN0eWxlc1tzdHlsZVR5cGVdO1xuXG4gIGlmIChzdHlsZSkge1xuICAgIHJldHVybiAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcbiAgICAgICAgICAgJ1xcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc3R5bGl6ZU5vQ29sb3Ioc3RyLCBzdHlsZVR5cGUpIHtcbiAgcmV0dXJuIHN0cjtcbn1cblxuXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xuICB2YXIgaGFzaCA9IHt9O1xuXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcbiAgICBoYXNoW3ZhbF0gPSB0cnVlO1xuICB9KTtcblxuICByZXR1cm4gaGFzaDtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRWYWx1ZShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMpIHtcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxuICAvLyBDaGVjayB0aGF0IHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGFuIGluc3BlY3QgZnVuY3Rpb24gb24gaXRcbiAgaWYgKGN0eC5jdXN0b21JbnNwZWN0ICYmXG4gICAgICB2YWx1ZSAmJlxuICAgICAgaXNGdW5jdGlvbih2YWx1ZS5pbnNwZWN0KSAmJlxuICAgICAgLy8gRmlsdGVyIG91dCB0aGUgdXRpbCBtb2R1bGUsIGl0J3MgaW5zcGVjdCBmdW5jdGlvbiBpcyBzcGVjaWFsXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcbiAgICAgIC8vIEFsc28gZmlsdGVyIG91dCBhbnkgcHJvdG90eXBlIG9iamVjdHMgdXNpbmcgdGhlIGNpcmN1bGFyIGNoZWNrLlxuICAgICAgISh2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgPT09IHZhbHVlKSkge1xuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcbiAgICBpZiAoIWlzU3RyaW5nKHJldCkpIHtcbiAgICAgIHJldCA9IGZvcm1hdFZhbHVlKGN0eCwgcmV0LCByZWN1cnNlVGltZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9XG5cbiAgLy8gUHJpbWl0aXZlIHR5cGVzIGNhbm5vdCBoYXZlIHByb3BlcnRpZXNcbiAgdmFyIHByaW1pdGl2ZSA9IGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKTtcbiAgaWYgKHByaW1pdGl2ZSkge1xuICAgIHJldHVybiBwcmltaXRpdmU7XG4gIH1cblxuICAvLyBMb29rIHVwIHRoZSBrZXlzIG9mIHRoZSBvYmplY3QuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcblxuICBpZiAoY3R4LnNob3dIaWRkZW4pIHtcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xuICB9XG5cbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxuICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvaWUvZHd3NTJzYnQodj12cy45NCkuYXNweFxuICBpZiAoaXNFcnJvcih2YWx1ZSlcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xuICAgIHJldHVybiBmb3JtYXRFcnJvcih2YWx1ZSk7XG4gIH1cblxuICAvLyBTb21lIHR5cGUgb2Ygb2JqZWN0IHdpdGhvdXQgcHJvcGVydGllcyBjYW4gYmUgc2hvcnRjdXR0ZWQuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCkge1xuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFyIG5hbWUgPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW0Z1bmN0aW9uJyArIG5hbWUgKyAnXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfVxuICAgIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdkYXRlJyk7XG4gICAgfVxuICAgIGlmIChpc0Vycm9yKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xuXG4gIC8vIE1ha2UgQXJyYXkgc2F5IHRoYXQgdGhleSBhcmUgQXJyYXlcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgYXJyYXkgPSB0cnVlO1xuICAgIGJyYWNlcyA9IFsnWycsICddJ107XG4gIH1cblxuICAvLyBNYWtlIGZ1bmN0aW9ucyBzYXkgdGhhdCB0aGV5IGFyZSBmdW5jdGlvbnNcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgdmFyIG4gPSB2YWx1ZS5uYW1lID8gJzogJyArIHZhbHVlLm5hbWUgOiAnJztcbiAgICBiYXNlID0gJyBbRnVuY3Rpb24nICsgbiArICddJztcbiAgfVxuXG4gIC8vIE1ha2UgUmVnRXhwcyBzYXkgdGhhdCB0aGV5IGFyZSBSZWdFeHBzXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZGF0ZXMgd2l0aCBwcm9wZXJ0aWVzIGZpcnN0IHNheSB0aGUgZGF0ZVxuICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgfVxuXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcbiAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIGlmIChrZXlzLmxlbmd0aCA9PT0gMCAmJiAoIWFycmF5IHx8IHZhbHVlLmxlbmd0aCA9PSAwKSkge1xuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xuICB9XG5cbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ3JlZ2V4cCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3R4LnN0eWxpemUoJ1tPYmplY3RdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cblxuICBjdHguc2Vlbi5wdXNoKHZhbHVlKTtcblxuICB2YXIgb3V0cHV0O1xuICBpZiAoYXJyYXkpIHtcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBrZXlzLm1hcChmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcbiAgICB9KTtcbiAgfVxuXG4gIGN0eC5zZWVuLnBvcCgpO1xuXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKHZhbHVlKSlcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcbiAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgIHZhciBzaW1wbGUgPSAnXFwnJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKS5yZXBsYWNlKC9eXCJ8XCIkL2csICcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcIi9nLCAnXCInKSArICdcXCcnO1xuICAgIHJldHVybiBjdHguc3R5bGl6ZShzaW1wbGUsICdzdHJpbmcnKTtcbiAgfVxuICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnbnVtYmVyJyk7XG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnJyArIHZhbHVlLCAnYm9vbGVhbicpO1xuICAvLyBGb3Igc29tZSByZWFzb24gdHlwZW9mIG51bGwgaXMgXCJvYmplY3RcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXG4gIGlmIChpc051bGwodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgnbnVsbCcsICdudWxsJyk7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcbiAgcmV0dXJuICdbJyArIEVycm9yLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSArICddJztcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodmFsdWUsIFN0cmluZyhpKSkpIHtcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXG4gICAgICAgICAgU3RyaW5nKGkpLCB0cnVlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICB9XG4gIH1cbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgIGlmICgha2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBrZXksIHRydWUpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0cHV0O1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcbiAgdmFyIG5hbWUsIHN0ciwgZGVzYztcbiAgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodmFsdWUsIGtleSkgfHwgeyB2YWx1ZTogdmFsdWVba2V5XSB9O1xuICBpZiAoZGVzYy5nZXQpIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyL1NldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0dldHRlcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVzYy5zZXQpIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmICghaGFzT3duUHJvcGVydHkodmlzaWJsZUtleXMsIGtleSkpIHtcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xuICB9XG4gIGlmICghc3RyKSB7XG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XG4gICAgICBpZiAoaXNOdWxsKHJlY3Vyc2VUaW1lcykpIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0ciA9IGZvcm1hdFZhbHVlKGN0eCwgZGVzYy52YWx1ZSwgcmVjdXJzZVRpbWVzIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcbicpID4gLTEpIHtcbiAgICAgICAgaWYgKGFycmF5KSB7XG4gICAgICAgICAgc3RyID0gc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICcgKyBsaW5lO1xuICAgICAgICAgIH0pLmpvaW4oJ1xcbicpLnN1YnN0cigyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHIgPSAnXFxuJyArIHN0ci5zcGxpdCgnXFxuJykubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgIHJldHVybiAnICAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcbiAgICBpZiAoYXJyYXkgJiYga2V5Lm1hdGNoKC9eXFxkKyQvKSkge1xuICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcbiAgICBpZiAobmFtZS5tYXRjaCgvXlwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXCIkLykpIHtcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICduYW1lJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXCJcXFxcJ1wiKVxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlwifFwiJCkvZywgXCInXCIpO1xuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSArICc6ICcgKyBzdHI7XG59XG5cblxuZnVuY3Rpb24gcmVkdWNlVG9TaW5nbGVTdHJpbmcob3V0cHV0LCBiYXNlLCBicmFjZXMpIHtcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcbiAgdmFyIGxlbmd0aCA9IG91dHB1dC5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgY3VyKSB7XG4gICAgbnVtTGluZXNFc3QrKztcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcbicpID49IDApIG51bUxpbmVzRXN0Kys7XG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFx1MDAxYlxcW1xcZFxcZD9tL2csICcnKS5sZW5ndGggKyAxO1xuICB9LCAwKTtcblxuICBpZiAobGVuZ3RoID4gNjApIHtcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcbiAgICAgICAgICAgKGJhc2UgPT09ICcnID8gJycgOiBiYXNlICsgJ1xcbiAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIG91dHB1dC5qb2luKCcsXFxuICAnKSArXG4gICAgICAgICAgICcgJyArXG4gICAgICAgICAgIGJyYWNlc1sxXTtcbiAgfVxuXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XG59XG5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXIpO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gaXNPYmplY3QocmUpICYmIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGUpICYmXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI1KTtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuXG5cbmZ1bmN0aW9uIHBhZChuKSB7XG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xufVxuXG5cbnZhciBtb250aHMgPSBbJ0phbicsICdGZWInLCAnTWFyJywgJ0FwcicsICdNYXknLCAnSnVuJywgJ0p1bCcsICdBdWcnLCAnU2VwJyxcbiAgICAgICAgICAgICAgJ09jdCcsICdOb3YnLCAnRGVjJ107XG5cbi8vIDI2IEZlYiAxNjoxOTozNFxuZnVuY3Rpb24gdGltZXN0YW1wKCkge1xuICB2YXIgZCA9IG5ldyBEYXRlKCk7XG4gIHZhciB0aW1lID0gW3BhZChkLmdldEhvdXJzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRNaW51dGVzKCkpLFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XG4gIHJldHVybiBbZC5nZXREYXRlKCksIG1vbnRoc1tkLmdldE1vbnRoKCldLCB0aW1lXS5qb2luKCcgJyk7XG59XG5cblxuLy8gbG9nIGlzIGp1c3QgYSB0aGluIHdyYXBwZXIgdG8gY29uc29sZS5sb2cgdGhhdCBwcmVwZW5kcyBhIHRpbWVzdGFtcFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcbiAgY29uc29sZS5sb2coJyVzIC0gJXMnLCB0aW1lc3RhbXAoKSwgZXhwb3J0cy5mb3JtYXQuYXBwbHkoZXhwb3J0cywgYXJndW1lbnRzKSk7XG59O1xuXG5cbi8qKlxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxuICpcbiAqIFRoZSBGdW5jdGlvbi5wcm90b3R5cGUuaW5oZXJpdHMgZnJvbSBsYW5nLmpzIHJld3JpdHRlbiBhcyBhIHN0YW5kYWxvbmVcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxuICogZHVyaW5nIGJvb3RzdHJhcHBpbmcgdGhpcyBmdW5jdGlvbiBuZWVkcyB0byBiZSByZXdyaXR0ZW4gdXNpbmcgc29tZSBuYXRpdmVcbiAqIGZ1bmN0aW9ucyBhcyBwcm90b3R5cGUgc2V0dXAgdXNpbmcgbm9ybWFsIEphdmFTY3JpcHQgZG9lcyBub3Qgd29yayBhc1xuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB3aGljaCBuZWVkcyB0byBpbmhlcml0IHRoZVxuICogICAgIHByb3RvdHlwZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHN1cGVyQ3RvciBDb25zdHJ1Y3RvciBmdW5jdGlvbiB0byBpbmhlcml0IHByb3RvdHlwZSBmcm9tLlxuICovXG5leHBvcnRzLmluaGVyaXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNik7XG5cbmV4cG9ydHMuX2V4dGVuZCA9IGZ1bmN0aW9uKG9yaWdpbiwgYWRkKSB7XG4gIC8vIERvbid0IGRvIGFueXRoaW5nIGlmIGFkZCBpc24ndCBhbiBvYmplY3RcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhhZGQpO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgb3JpZ2luW2tleXNbaV1dID0gYWRkW2tleXNbaV1dO1xuICB9XG4gIHJldHVybiBvcmlnaW47XG59O1xuXG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG52YXIga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2woJ3V0aWwucHJvbWlzaWZ5LmN1c3RvbScpIDogdW5kZWZpbmVkO1xuXG5leHBvcnRzLnByb21pc2lmeSA9IGZ1bmN0aW9uIHByb21pc2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCAmJiBvcmlnaW5hbFtrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2xdKSB7XG4gICAgdmFyIGZuID0gb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXTtcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ1dGlsLnByb21pc2lmeS5jdXN0b21cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgZnVuY3Rpb24gZm4oKSB7XG4gICAgdmFyIHByb21pc2VSZXNvbHZlLCBwcm9taXNlUmVqZWN0O1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgcHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgcHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICB9KTtcblxuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cbiAgICBhcmdzLnB1c2goZnVuY3Rpb24gKGVyciwgdmFsdWUpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvbWlzZVJlc29sdmUodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdHJ5IHtcbiAgICAgIG9yaWdpbmFsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcHJvbWlzZVJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGZuLCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob3JpZ2luYWwpKTtcblxuICBpZiAoa0N1c3RvbVByb21pc2lmaWVkU3ltYm9sKSBPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCwge1xuICAgIHZhbHVlOiBmbiwgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoXG4gICAgZm4sXG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvcmlnaW5hbClcbiAgKTtcbn1cblxuZXhwb3J0cy5wcm9taXNpZnkuY3VzdG9tID0ga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXG5cbmZ1bmN0aW9uIGNhbGxiYWNraWZ5T25SZWplY3RlZChyZWFzb24sIGNiKSB7XG4gIC8vIGAhcmVhc29uYCBndWFyZCBpbnNwaXJlZCBieSBibHVlYmlyZCAoUmVmOiBodHRwczovL2dvby5nbC90NUlTNk0pLlxuICAvLyBCZWNhdXNlIGBudWxsYCBpcyBhIHNwZWNpYWwgZXJyb3IgdmFsdWUgaW4gY2FsbGJhY2tzIHdoaWNoIG1lYW5zIFwibm8gZXJyb3JcbiAgLy8gb2NjdXJyZWRcIiwgd2UgZXJyb3Itd3JhcCBzbyB0aGUgY2FsbGJhY2sgY29uc3VtZXIgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAgLy8gXCJ0aGUgcHJvbWlzZSByZWplY3RlZCB3aXRoIG51bGxcIiBvciBcInRoZSBwcm9taXNlIGZ1bGZpbGxlZCB3aXRoIHVuZGVmaW5lZFwiLlxuICBpZiAoIXJlYXNvbikge1xuICAgIHZhciBuZXdSZWFzb24gPSBuZXcgRXJyb3IoJ1Byb21pc2Ugd2FzIHJlamVjdGVkIHdpdGggYSBmYWxzeSB2YWx1ZScpO1xuICAgIG5ld1JlYXNvbi5yZWFzb24gPSByZWFzb247XG4gICAgcmVhc29uID0gbmV3UmVhc29uO1xuICB9XG4gIHJldHVybiBjYihyZWFzb24pO1xufVxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeShvcmlnaW5hbCkge1xuICBpZiAodHlwZW9mIG9yaWdpbmFsICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwib3JpZ2luYWxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgfVxuXG4gIC8vIFdlIERPIE5PVCByZXR1cm4gdGhlIHByb21pc2UgYXMgaXQgZ2l2ZXMgdGhlIHVzZXIgYSBmYWxzZSBzZW5zZSB0aGF0XG4gIC8vIHRoZSBwcm9taXNlIGlzIGFjdHVhbGx5IHNvbWVob3cgcmVsYXRlZCB0byB0aGUgY2FsbGJhY2sncyBleGVjdXRpb25cbiAgLy8gYW5kIHRoYXQgdGhlIGNhbGxiYWNrIHRocm93aW5nIHdpbGwgcmVqZWN0IHRoZSBwcm9taXNlLlxuICBmdW5jdGlvbiBjYWxsYmFja2lmaWVkKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICAgIH1cblxuICAgIHZhciBtYXliZUNiID0gYXJncy5wb3AoKTtcbiAgICBpZiAodHlwZW9mIG1heWJlQ2IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsYXN0IGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGNiID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbWF5YmVDYi5hcHBseShzZWxmLCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gSW4gdHJ1ZSBub2RlIHN0eWxlIHdlIHByb2Nlc3MgdGhlIGNhbGxiYWNrIG9uIGBuZXh0VGlja2Agd2l0aCBhbGwgdGhlXG4gICAgLy8gaW1wbGljYXRpb25zIChzdGFjaywgYHVuY2F1Z2h0RXhjZXB0aW9uYCwgYGFzeW5jX2hvb2tzYClcbiAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKVxuICAgICAgLnRoZW4oZnVuY3Rpb24ocmV0KSB7IHByb2Nlc3MubmV4dFRpY2soY2IsIG51bGwsIHJldCkgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uKHJlaikgeyBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNraWZ5T25SZWplY3RlZCwgcmVqLCBjYikgfSk7XG4gIH1cblxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoY2FsbGJhY2tpZmllZCwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNhbGxiYWNraWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpKTtcbiAgcmV0dXJuIGNhbGxiYWNraWZpZWQ7XG59XG5leHBvcnRzLmNhbGxiYWNraWZ5ID0gY2FsbGJhY2tpZnk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSkpXG5cbi8qKiovIH0pLFxuLyogMjQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgJiYgdHlwZW9mIGFyZyA9PT0gJ29iamVjdCdcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLmZpbGwgPT09ICdmdW5jdGlvbidcbiAgICAmJiB0eXBlb2YgYXJnLnJlYWRVSW50OCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gIH1cbn1cblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJ3aW5kb3dcIl07IH0oKSk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEZvcm1hdHM6IF9fd2VicGFja19yZXF1aXJlX18oMjkpLFxuICBJbml0aWFsaXplcjogX193ZWJwYWNrX3JlcXVpcmVfXygzMCksXG4gIEpTT05Eb2N1bWVudDogX193ZWJwYWNrX3JlcXVpcmVfXygzMSksXG4gIEpTT05NYXBwaW5nOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSxcbiAgSlNPTlBhdGNoOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKSxcbiAgSlNPTlBvaW50ZXI6IF9fd2VicGFja19yZXF1aXJlX18oMzMpLFxuICBKU09OU2NoZW1hOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM1KSxcbiAgVmFsaWRhdG9yOiBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KVxufTtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEpTT04gU2NoZW1hIEZvcm1hdHNcbiAqXG4gKiBUT0RPXG4gKiBJcyB0aGVyZSBhIGdvb2Qgd2F5IHRvIGV4cHJlc3MgdGhlc2Ugb3ZlciBtdWx0aXBsZSBsaW5lcyB3aXRoIGNvbW1lbnRzXG4gKiBmb3IgZWFzaWVyIGRlYnVnZ2luZyBhbmQgYXVkaXRpbmc/XG4gKi9cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIERBVEVUSU1FX1JFR0VYUCA9IC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGQoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQ6XFxkXFxkKSQvaTtcbnZhciBVUklfUkVHRVhQID0gL14oPzpbYS16XVthLXowLTkrLS5dKik/KD86XFw6fFxcLylcXC8/W15cXHNdKiQvaTtcbnZhciBFTUFJTF9SRUdFWFAgPSAvXlthLXowLTkuISMkJSYnKitcXC89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2k7XG52YXIgSVBWNF9SRUdFWFAgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSQvO1xudmFyIElQVjZfUkVHRVhQID0gL15cXHMqKD86KD86KD86WzAtOWEtZl17MSw0fTopezd9KD86WzAtOWEtZl17MSw0fXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezZ9KD86OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs1fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKD86XFwuKD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCg/Oig/OlswLTlhLWZdezEsNH06KXs0fSg/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDN9KXwoPzooPzo6WzAtOWEtZl17MSw0fSk/Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezN9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNH0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDJ9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezJ9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNX0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDN9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86KD86WzAtOWEtZl17MSw0fTopezF9KD86KD86KD86OlswLTlhLWZdezEsNH0pezEsNn0pfCg/Oig/OjpbMC05YS1mXXsxLDR9KXswLDR9Oig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSg/OlxcLig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KD86Oig/Oig/Oig/OjpbMC05YS1mXXsxLDR9KXsxLDd9KXwoPzooPzo6WzAtOWEtZl17MSw0fSl7MCw1fTooPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoPzpcXC4oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSg/OiUuKyk/XFxzKiQvaTtcbnZhciBIT1NUTkFNRV9SRUdFWFAgPSAvXlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KFxcLlthLXpdKD86KD86Wy0wLTlhLXpdezAsNjF9KT9bMC05YS16XSk/KSokL2k7XG5cbi8qKlxuICogRm9ybWF0c1xuICovXG5cbnZhciBGb3JtYXRzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBGb3JtYXRzKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBGb3JtYXRzKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhGb3JtYXRzLCBbe1xuICAgIGtleTogJ3JlZ2lzdGVyJyxcblxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IG1hcHBpbmcgZnJvbSBuYW1lZCBmb3JtYXQgdG8gUmVnRXhwIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBUT0RPXG4gICAgICogV2UgY2FuIGRvIHNvbWUgZXh0cmEgdmFsaWRhdGlvbiBvZiB0aGUgUmVnRXhwIHRvXG4gICAgICogZW5zdXJlIGl0J3MgdGhlIGFjY2VwdGFibGUgc3Vic2V0IG9mIFJlZ0V4cHMgYWxsb3dlZFxuICAgICAqIGJ5IEpTT04gU2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcGF0dGVyblxuICAgICAqIEByZXR1cm5zIHtSZWdFeHB9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyKG5hbWUsIHBhdHRlcm4pIHtcbiAgICAgIC8vIHZlcmlmeSBuYW1lIGlzIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRm9ybWF0IG5hbWUgbXVzdCBiZSBhIHN0cmluZycpO1xuICAgICAgfVxuXG4gICAgICAvLyBjYXN0IGEgc3RyaW5nIHRvIFJlZ0V4cFxuICAgICAgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXNbbmFtZV0gPSBwYXR0ZXJuO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlc29sdmVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdpdmVuIGEgZm9ybWF0IG5hbWUsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZWdpc3RlcmVkIHZhbGlkYXRpb24uIEluIHRoZVxuICAgICAqIGV2ZW50IGEgZm9ybWF0IGlzIG5vdCByZWdpc3RlcmVkLCB0aHJvdyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHJldHVybnMge1JlZ0V4cH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVzb2x2ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmUobmFtZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXNbbmFtZV07XG5cbiAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBKU09OIFNjaGVtYSBmb3JtYXQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmb3JtYXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogVGVzdCB0aGF0IGEgdmFsdWUgY29uZm9ybXMgdG8gYSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChuYW1lLCB2YWx1ZSkge1xuICAgICAgdmFyIGZvcm1hdCA9IHRoaXMucmVzb2x2ZShuYW1lKTtcbiAgICAgIHJldHVybiBmb3JtYXQudGVzdCh2YWx1ZSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdpbml0aWFsaXplJyxcblxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ3JlYXRlIGEgbmV3IEZvcm1hdHMgaW5zdGFuY2UgYW5kIHJlZ2lzdGVyIGRlZmF1bHQgZm9ybWF0c1xuICAgICAqXG4gICAgICogQHJldHVybnMge0Zvcm1hdHN9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgICB2YXIgZm9ybWF0cyA9IG5ldyBGb3JtYXRzKCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdkYXRlLXRpbWUnLCBEQVRFVElNRV9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcigndXJpJywgVVJJX1JFR0VYUCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdlbWFpbCcsIEVNQUlMX1JFR0VYUCk7XG4gICAgICBmb3JtYXRzLnJlZ2lzdGVyKCdpcHY0JywgSVBWNF9SRUdFWFApO1xuICAgICAgZm9ybWF0cy5yZWdpc3RlcignaXB2NicsIElQVjZfUkVHRVhQKTtcbiAgICAgIGZvcm1hdHMucmVnaXN0ZXIoJ2hvc3RuYW1lJywgSE9TVE5BTUVfUkVHRVhQKTtcbiAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBGb3JtYXRzO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBGb3JtYXRzLmluaXRpYWxpemUoKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEluaXRpYWxpemVyXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBJbml0aWFsaXplcihzY2hlbWEsIG9wdGlvbnMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW5pdGlhbGl6ZXIpO1xuXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBvcHRpb25zIHx8IHt9KTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLnJvb3QgfHwgdGhpcztcblxuICAgIHRoaXMucm9vdC5kZXB0aCA9IHRoaXMucm9vdC5kZXB0aCB8fCAxO1xuXG4gICAgaWYgKHRoaXMubGV2ZWwgPiB0aGlzLnJvb3QuZGVwdGgpIHtcbiAgICAgIHRoaXMucm9vdC5kZXB0aCA9IHRoaXMubGV2ZWw7XG4gICAgfVxuXG4gICAgdGhpcy5sZXZlbCA9IHRoaXMubGV2ZWwgfHwgMDtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgfVxuXG4gIC8qKlxuICAgKiBjb21waWxlIChzdGF0aWMpXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEluaXRpYWxpemVyLCBbe1xuICAgIGtleTogJ2NvbXBpbGUnLFxuXG5cbiAgICAvKipcbiAgICAgKiBjb21waWxlXG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgICB2YXIgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBkZXB0aCA9IHRoaXMuZGVwdGgsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsO1xuXG4gICAgICB2YXIgZGVjbGFyYXRpb25zID0gJyc7XG4gICAgICB2YXIgYm9keSA9ICcnO1xuXG4gICAgICAvLyB0cmF2ZXJzZSB0aGUgc2NoZW1hIGFuZCBnZW5lcmF0ZSBjb2RlXG4gICAgICBib2R5ICs9IHRoaXMuZGVmYXVsdCgpO1xuICAgICAgYm9keSArPSB0aGlzLnByb3BlcnRpZXMoKTtcbiAgICAgIC8vYm9keSArPSB0aGlzLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKClcbiAgICAgIGJvZHkgKz0gdGhpcy5pdGVtcygpO1xuICAgICAgLy9ib2R5ICs9IHRoaXMuYWRkaXRpb25hbEl0ZW1zKClcblxuXG4gICAgICAvLyB2YWx1ZVxuICAgICAgYm9keSArPSB0aGlzLm1lbWJlcigpO1xuICAgICAgYm9keSArPSB0aGlzLml0ZW0oKTtcblxuICAgICAgLy8gYWZ0ZXIgdHJhdmVyc2luZyB0aGUgc2NoZW1hXG4gICAgICAvLyBnZW5lcmF0ZSB0aGUgdmFyaWFibGUgZGVjbGFyYXRpb25zXG4gICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB0aGlzLnJvb3QuZGVwdGg7IGkrKykge1xuICAgICAgICAgIGRlY2xhcmF0aW9ucyArPSB0aGlzLmRlY2xhcmF0aW9uKGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICdcXG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XFxuXFxuICAgICAgICBpZiAob3B0aW9ucy5maWx0ZXIgPT09IGZhbHNlKSB7XFxuICAgICAgICAgIE9iamVjdC5hc3NpZ24odGFyZ2V0LCBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNvdXJjZSkpKVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgJyArIGRlY2xhcmF0aW9ucyArICdcXG4gICAgICAgICcgKyBib2R5ICsgJ1xcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBib2R5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGRlY2xhcmF0aW9uXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlY2xhcmF0aW9uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjbGFyYXRpb24obGV2ZWwpIHtcbiAgICAgIHJldHVybiAnXFxuICAgICAgdmFyIHRhcmdldCcgKyBsZXZlbCArICdcXG4gICAgICB2YXIgc291cmNlJyArIGxldmVsICsgJ1xcbiAgICAgIHZhciBjb3VudCcgKyBsZXZlbCArICdcXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBkZWZhdWx0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2RlZmF1bHQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZGVmYXVsdCgpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYSxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIHZhbHVlID0gc2NoZW1hLmRlZmF1bHQ7IC8vIHJlbmFtZSBkZWZhdWx0IHRvIHZhbHVlIGJlY2F1c2UgaXQncyBhIGtleXdvcmQgYW5kIHN5bnRheCBoaWdobGlnaHRlciBicmVha3NcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChzY2hlbWEuaGFzT3duUHJvcGVydHkoJ2RlZmF1bHQnKSkge1xuXG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gJyArIEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPSAnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpICsgJ1xcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsZXZlbCA+IDEpIHtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAnO1xuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICBpZiAob3B0aW9ucy5kZWZhdWx0cyAhPT0gZmFsc2UpIHtcXG4gICAgICAgICAgJyArIGJsb2NrICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtZW1iZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWVtYmVyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWVtYmVyKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5O1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgICBpdGVtcyA9IHNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRpdGlvbmFsSXRlbXMgPSBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gYGtleWAgdGVsbHMgdXMgdG8gdHJlYXQgdGhpcyBzdWJzY2hlbWEgYXMgYW4gb2JqZWN0IG1lbWJlciB2cyBhbiBhcnJheSBpdGVtXG4gICAgICAvLyBhbmQgdGhlIGFic2VuY2Ugb2YgdGhlIG90aGVyIHZhbHVlcyBoZXJlIGluZGljYXRlcyB3ZSBhcmUgZGVhbGluZyB3aXRoIGFcbiAgICAgIC8vIHByaW1pdGl2ZSB2YWx1ZVxuICAgICAgaWYgKGtleSAmJiAhcHJvcGVydGllcyAmJiAhYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgIWl0ZW1zICYmICFhZGRpdGlvbmFsSXRlbXMpIHtcblxuICAgICAgICAvLyBmaXJzdCBnZW5lcmF0ZSB0aGUgYXNzaWdubWVudCBzdGF0ZW1lbnRcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICc7XG5cbiAgICAgICAgLy8gZm9yIG5lc3RlZCBjb250YWluZXIgb2JqZWN0cywgYWRkIHRoZSBjb3VudGVyIGluY3JlbWVudGluZyBzdGF0ZW1lbnRcbiAgICAgICAgaWYgKGxldmVsID4gMSkge1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3cmFwIHRoZSBmb3JlZ29pbmcgaW4gYSBjaGVjayBmb3IgcHJlc2VuY2Ugb24gdGhlIHNvdXJjZVxuICAgICAgICBibG9jayA9ICdcXG4gICAgICAgIGlmIChzb3VyY2UnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKSkge1xcbiAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGl0ZW1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXRlbScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGl0ZW0oKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICAgICAgICBpdGVtcyA9IHNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRpdGlvbmFsSXRlbXMgPSBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGluZGV4ICYmICFwcm9wZXJ0aWVzICYmICFhZGRpdGlvbmFsUHJvcGVydGllcyAmJiAhaXRlbXMgJiYgIWFkZGl0aW9uYWxJdGVtcykge1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddXFxuICAgICAgJztcblxuICAgICAgICBpZiAobGV2ZWwgPiAxKSB7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgaWYgKCcgKyBpbmRleCArICcgPCBsZW4pIHtcXG4gICAgICAgICAgJyArIGJsb2NrICsgJ1xcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwcm9wZXJ0aWVzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIHJvb3QgPSB0aGlzLnJvb3QsXG4gICAgICAgICAgbGV2ZWwgPSB0aGlzLmxldmVsLFxuICAgICAgICAgIGtleSA9IHRoaXMua2V5LFxuICAgICAgICAgIGluZGV4ID0gdGhpcy5pbmRleDtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXM7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgc3Vic2NoZW1hID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihzdWJzY2hlbWEsIHsga2V5OiBrZXksIHJvb3Q6IHJvb3QsIGxldmVsOiBsZXZlbCArIDEgfSk7XG5cbiAgICAgICAgICBibG9jayArPSBpbml0aWFsaXplci5jb21waWxlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHJvb3QtbGV2ZWwgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICBpZiAodHlwZW9mIHNvdXJjZSA9PT0gXFwnb2JqZWN0XFwnICYmIHNvdXJjZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09IFxcJ29iamVjdFxcJykge1xcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcJz9cXCcpXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHNvdXJjZTEgPSBzb3VyY2VcXG4gICAgICAgICAgICB0YXJnZXQxID0gdGFyZ2V0XFxuICAgICAgICAgICAgY291bnQxID0gMFxcblxcbiAgICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICAgIC8vIG5lc3RlZCBwcm9wZXJ0aWVzIGJvaWxlcnBsYXRlXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBpZiAoaW5kZXgpIHtcbiAgICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgc291cmNlJyArIGxldmVsICsgJy5sZW5ndGggfHwgdHlwZW9mIHNvdXJjZScgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gPT09IFxcJ29iamVjdFxcJykge1xcblxcbiAgICAgICAgICAgICAgc291cmNlJyArIChsZXZlbCArIDEpICsgJyA9IHNvdXJjZScgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gfHwge31cXG4gICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJyA9IDBcXG5cXG4gICAgICAgICAgICAgIGlmICgnICsgaW5kZXggKyAnIDwgdGFyZ2V0JyArIGxldmVsICsgJy5sZW5ndGggfHwgdHlwZW9mIHRhcmdldCcgKyBsZXZlbCArICdbJyArIGluZGV4ICsgJ10gIT09IFxcJ29iamVjdFxcJykge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0ge31cXG4gICAgICAgICAgICAgICAgaWYgKCcgKyBpbmRleCArICcgPCBzb3VyY2UnICsgbGV2ZWwgKyAnLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddXFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuXFxuICAgICAgICAgICAgICBpZiAoY291bnQnICsgKGxldmVsICsgMSkgKyAnID4gMCkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJ1xcbiAgICAgICAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnWycgKyBpbmRleCArICddID0gc291cmNlJyArIGxldmVsICsgJ1snICsgaW5kZXggKyAnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICAgICAgaWYgKCh0eXBlb2Ygc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPT09IFxcJ29iamVjdFxcJ1xcbiAgICAgICAgICAgICAgICAgICYmIHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddICE9PSBudWxsXFxuICAgICAgICAgICAgICAgICAgJiYgIUFycmF5LmlzQXJyYXkoc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10pKVxcbiAgICAgICAgICAgICAgICB8fCAhc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG5cXG4gICAgICAgICAgICAgIHNvdXJjZScgKyAobGV2ZWwgKyAxKSArICcgPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSB8fCB7fVxcbiAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnID0gMFxcblxcbiAgICAgICAgICAgICAgaWYgKCF0YXJnZXQnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKVxcbiAgICAgICAgICAgICAgICAgIHx8IHR5cGVvZiB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSAhPT0gXFwnb2JqZWN0XFwnXFxuICAgICAgICAgICAgICAgICAgfHwgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPT09IG51bGxcXG4gICAgICAgICAgICAgICAgICB8fCBBcnJheS5pc0FycmF5KHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddKSkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnID0ge31cXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZScgKyBsZXZlbCArICcuaGFzT3duUHJvcGVydHkoXFwnJyArIGtleSArICdcXCcpKSB7XFxuICAgICAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnKytcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGFyZ2V0JyArIChsZXZlbCArIDEpICsgJyA9IHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddXFxuICAgICAgICAgICAgICAgIGNvdW50JyArIChsZXZlbCArIDEpICsgJysrXFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAnICsgYmxvY2sgKyAnXFxuXFxuICAgICAgICAgICAgICBpZiAoY291bnQnICsgKGxldmVsICsgMSkgKyAnID4gMCkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9IHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICdcXG4gICAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdGFyZ2V0JyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gPSBzb3VyY2UnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgbGV2ZWwgKyAnKytcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0aWVzKCkge31cblxuICAgIC8qKlxuICAgICAqIGl0ZW1zXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2l0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICB2YXIgc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcm9vdCA9IHRoaXMucm9vdCxcbiAgICAgICAgICBsZXZlbCA9IHRoaXMubGV2ZWwsXG4gICAgICAgICAga2V5ID0gdGhpcy5rZXksXG4gICAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4O1xuICAgICAgdmFyIGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKGl0ZW1zKSB7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyAuLi5cblxuICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgaXRlbXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGl0ZW1zKSkgPT09ICdvYmplY3QnICYmIGl0ZW1zICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9pbmRleCA9ICdpJyArIChsZXZlbCArIDEpO1xuICAgICAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihpdGVtcywgeyBpbmRleDogX2luZGV4LCByb290OiByb290LCBsZXZlbDogbGV2ZWwgKyAxIH0pO1xuXG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICB2YXIgc0xlbiA9IHNvdXJjZScgKyAobGV2ZWwgKyAxKSArICcubGVuZ3RoIHx8IDBcXG4gICAgICAgICAgdmFyIHRMZW4gPSB0YXJnZXQnICsgKGxldmVsICsgMSkgKyAnLmxlbmd0aCB8fCAwXFxuICAgICAgICAgIHZhciBsZW4gPSAwXFxuXFxuICAgICAgICAgIGlmIChzTGVuID4gbGVuKSB7IGxlbiA9IHNMZW4gfVxcbiAgICAgICAgICAvLyBUSElTIElTIFdST05HLCBDQVVTRUQgU0lNUExFIEFSUkFZIElOSVQgVE8gRkFJTCAoT1ZFUldSSVRFXFxuICAgICAgICAgIC8vIEVYSVNUSU5HIFRBUkdFVCBWQUxVRVMgV0lUSCBVTkRFRklORUQgV0hFTiBTT1VSQ0UgSVMgU0hPUlRFUiBUSEFOXFxuICAgICAgICAgIC8vIFRBUkdFVCkuIExFQVZJTkcgSEVSRSBVTlRJTCBXRSBGSU5JU0ggVEVTVElORyBBTkQgU0VFIFdIWSBJVCBNSUdIVFxcbiAgICAgICAgICAvLyBIQVZFIEJFRU4gSEVSRSBJTiBUSEUgRklSU1QgUExBQ0UuXFxuICAgICAgICAgIC8vXFxuICAgICAgICAgIC8vIGlmICh0TGVuID4gbGVuKSB7IGxlbiA9IHRMZW4gfVxcblxcbiAgICAgICAgICBmb3IgKHZhciAnICsgX2luZGV4ICsgJyA9IDA7ICcgKyBfaW5kZXggKyAnIDwgbGVuOyAnICsgX2luZGV4ICsgJysrKSB7XFxuICAgICAgICAgICAgJyArIGluaXRpYWxpemVyLmNvbXBpbGUoKSArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJvb3QtbGV2ZWwgcHJvcGVydGllcyBib2lsZXJwbGF0ZVxuICAgICAgICBpZiAocm9vdCA9PT0gdGhpcykge1xuICAgICAgICAgIGJsb2NrID0gJ1xcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhcmdldCkpIHtcXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcXCc/XFwnKVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBzb3VyY2UxID0gc291cmNlXFxuICAgICAgICAgICAgdGFyZ2V0MSA9IHRhcmdldFxcblxcbiAgICAgICAgICAgICcgKyBibG9jayArICdcXG4gICAgICAgICAgfVxcbiAgICAgICAgJztcblxuICAgICAgICAgIC8vIG5lc3RlZCBwcm9wZXJ0aWVzIGJvaWxlcnBsYXRlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYmxvY2sgPSAnXFxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZScgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddKSB8fCAhc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG5cXG4gICAgICAgICAgICBzb3VyY2UnICsgKGxldmVsICsgMSkgKyAnID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ10gfHwgW11cXG4gICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcgPSAwXFxuXFxuICAgICAgICAgICAgaWYgKCF0YXJnZXQnICsgbGV2ZWwgKyAnLmhhc093blByb3BlcnR5KFxcJycgKyBrZXkgKyAnXFwnKSB8fCAhQXJyYXkuaXNBcnJheSh0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSkpIHtcXG4gICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSBbXVxcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlJyArIGxldmVsICsgJy5oYXNPd25Qcm9wZXJ0eShcXCcnICsga2V5ICsgJ1xcJykpIHtcXG4gICAgICAgICAgICAgICAgICBjb3VudCcgKyAobGV2ZWwgKyAxKSArICcrK1xcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICcgPSB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgICAgICAgY291bnQnICsgKGxldmVsICsgMSkgKyAnKytcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgJyArIGJsb2NrICsgJ1xcblxcbiAgICAgICAgICAgIGlmIChjb3VudCcgKyAobGV2ZWwgKyAxKSArICcgPiAwKSB7XFxuICAgICAgICAgICAgICB0YXJnZXQnICsgbGV2ZWwgKyAnW1xcJycgKyBrZXkgKyAnXFwnXSA9IHRhcmdldCcgKyAobGV2ZWwgKyAxKSArICdcXG4gICAgICAgICAgICAgIGNvdW50JyArIGxldmVsICsgJysrXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRhcmdldCcgKyBsZXZlbCArICdbXFwnJyArIGtleSArICdcXCddID0gc291cmNlJyArIGxldmVsICsgJ1tcXCcnICsga2V5ICsgJ1xcJ11cXG4gICAgICAgICAgICBjb3VudCcgKyBsZXZlbCArICcrK1xcbiAgICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGRpdGlvbmFsSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsSXRlbXMoKSB7fVxuICB9XSwgW3tcbiAgICBrZXk6ICdjb21waWxlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShzY2hlbWEpIHtcbiAgICAgIHZhciBpbml0aWFsaXplciA9IG5ldyBJbml0aWFsaXplcihzY2hlbWEpO1xuICAgICAgdmFyIGJsb2NrID0gaW5pdGlhbGl6ZXIuY29tcGlsZSgpO1xuXG4gICAgICAvL2NvbnNvbGUubG9nKGJlYXV0aWZ5KGJsb2NrKSlcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ3RhcmdldCcsICdzb3VyY2UnLCAnb3B0aW9ucycsIGJsb2NrKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSwgZS5zdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEluaXRpYWxpemVyO1xufSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluaXRpYWxpemVyO1xuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBKU09OUGF0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcblxuLyoqXG4gKiBKU09ORG9jdW1lbnRcbiAqXG4gKiBAY2xhc3NcbiAqIEpTT05Eb2N1bWVudCBpcyBhIGhpZ2ggbGV2ZWwgaW50ZXJmYWNlIHRoYXQgYmluZHMgdG9nZXRoZXIgYWxsIG90aGVyIGZlYXR1cmVzIG9mXG4gKiB0aGlzIHBhY2thZ2UgYW5kIHByb3ZpZGVzIHRoZSBwcmluY2lwbGUgbWV0aG9kIG9mIGRhdGEgbW9kZWxpbmcuXG4gKi9cblxudmFyIEpTT05Eb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgX2NyZWF0ZUNsYXNzKEpTT05Eb2N1bWVudCwgbnVsbCwgW3tcbiAgICBrZXk6ICdzY2hlbWEnLFxuXG5cbiAgICAvKipcbiAgICAgKiBTY2hlbWFcbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU2NoZW1hIG11c3QgYmUgZGVmaW5lZCBieSBjbGFzc2VzIGV4dGVuZGluZyBKU09ORG9jdW1lbnQnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqL1xuXG4gIH1dKTtcblxuICBmdW5jdGlvbiBKU09ORG9jdW1lbnQoKSB7XG4gICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09ORG9jdW1lbnQpO1xuXG4gICAgdGhpcy5pbml0aWFsaXplKGRhdGEsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTkRvY3VtZW50LCBbe1xuICAgIGtleTogJ2luaXRpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgICAgdmFyIGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuY29uc3RydWN0b3Iuc2NoZW1hO1xuXG4gICAgICBzY2hlbWEuaW5pdGlhbGl6ZSh0aGlzLCBkYXRhLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBhbHRlcm5hdGUgLSBPUFRJT05BTCBhbHRlcm5hdGUgc2NoZW1hXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmFsaWRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZShhbHRlcm5hdGUpIHtcbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLmNvbnN0cnVjdG9yLnNjaGVtYTtcblxuICAgICAgcmV0dXJuIChhbHRlcm5hdGUgfHwgc2NoZW1hKS52YWxpZGF0ZSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gb3BzXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdGNoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0Y2gob3BzKSB7XG4gICAgICB2YXIgcGF0Y2ggPSBuZXcgSlNPTlBhdGNoKG9wcyk7XG4gICAgICBwYXRjaC5hcHBseSh0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2VsZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VsZWN0KCkge31cblxuICAgIC8qKlxuICAgICAqIFByb2plY3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdpdmVuIGEgbWFwcGluZywgcmV0dXJuIGFuIG9iamVjdCBwcm9qZWN0ZWQgZnJvbSB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogbGV0IHNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgICAgKiAgIHByb3BlcnRpZXM6IHtcbiAgICAgKiAgICAgZm9vOiB7IHR5cGU6ICdBcnJheScgfVxuICAgICAqICAgfVxuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBsZXQgbWFwcGluZyA9IG5ldyBKU09OTWFwcGluZyh7XG4gICAgICogICAnL2Zvby8wJzogJy9iYXIvYmF6J1xuICAgICAqIH0pXG4gICAgICpcbiAgICAgKiBjbGFzcyBGb29UcmFja2VyIGV4dGVuZHMgSlNPTkRvY3VtZW50IHtcbiAgICAgKiAgIHN0YXRpYyBnZXQgc2NoZW1hICgpIHsgcmV0dXJuIHNjaGVtYSB9XG4gICAgICogfVxuICAgICAqXG4gICAgICogbGV0IGluc3RhbmNlID0gbmV3IEZvb1RyYWNrZXIoeyBmb286IFsncXV4J10gfSlcbiAgICAgKiBpbnN0YW5jZS5wcm9qZWN0KG1hcHBpbmcpXG4gICAgICogLy8gPT4geyBiYXI6IHsgYmF6OiAncXV4JyB9IH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTk1hcHBpbmd9IG1hcHBpbmdcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb2plY3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9qZWN0KG1hcHBpbmcpIHtcbiAgICAgIHJldHVybiBtYXBwaW5nLnByb2plY3QodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0XG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9XSwgW3tcbiAgICBrZXk6ICdzZXJpYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUob2JqZWN0KSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlcmlhbGl6ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXNlcmlhbGl6ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc2VyaWFsaXplKGRhdGEpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBKU09OJyk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05Eb2N1bWVudDtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTkRvY3VtZW50O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxudmFyIEpTT05Qb2ludGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzMyk7XG5cbi8qKlxuICogTW9kZXNcbiAqL1xudmFyIFRIUk9XID0gMDtcbnZhciBSRUNPVkVSID0gMTtcbnZhciBTSUxFTlQgPSAyO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgbGlzdFxuICovXG52YXIgT1BFUkFUSU9OUyA9IFsnYWRkJywgJ3JlbW92ZScsICdyZXBsYWNlJywgJ21vdmUnLCAnY29weScsICd0ZXN0J107XG5cbi8qKlxuICogUGF0Y2hcbiAqXG4gKiBAY2xhc3NcbiAqIEltcGxlbWVudHMgUkZDIDY5MDI6IEphdmFTY3JpcHQgT2JqZWN0IE5vdGF0aW9uIChKU09OKSBQYXRjaFxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDJcbiAqL1xuXG52YXIgSlNPTlBhdGNoID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvcHNcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05QYXRjaChvcHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlBhdGNoKTtcblxuICAgIHRoaXMub3BzID0gb3BzIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGx5XG4gICAqXG4gICAqIEB0b2RvIGhhbmRsZSBlcnJvcnMvcm9sbCBiYWNrXG4gICAqIEB0b2RvIHByb3RlY3QgcHJvcGVydGllcyB0aGF0IGFyZSBwcml2YXRlIGluIHRoZSBzY2hlbWFcbiAgICogQHRvZG8gbWFwIEpTT04gUG9pbnRlcnMgcmVhbCBwcm9wZXJ0eSBuYW1lc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEpTT05QYXRjaCwgW3tcbiAgICBrZXk6ICdhcHBseScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFwcGx5KHRhcmdldCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdGhpcy5vcHMuZm9yRWFjaChmdW5jdGlvbiAob3BlcmF0aW9uKSB7XG4gICAgICAgIHZhciBvcCA9IG9wZXJhdGlvbi5vcDtcblxuICAgICAgICBpZiAoIW9wKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwib3BcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKE9QRVJBVElPTlMuaW5kZXhPZihvcCkgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwib3BcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFvcGVyYXRpb24ucGF0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBcInBhdGhcIiBpbiBKU09OIFBhdGNoIG9wZXJhdGlvbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgX3RoaXNbb3BdKG9wZXJhdGlvbiwgdGFyZ2V0KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhZGQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwidmFsdWVcIiBpbiBKU09OIFBhdGNoIGFkZCBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCwgU0lMRU5UKTtcbiAgICAgIHBvaW50ZXIuYWRkKHRhcmdldCwgb3AudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUob3AsIHRhcmdldCkge1xuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICBwb2ludGVyLnJlbW92ZSh0YXJnZXQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVwbGFjZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlcGxhY2Uob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIFwidmFsdWVcIiBpbiBKU09OIFBhdGNoIHJlcGxhY2Ugb3BlcmF0aW9uJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb2ludGVyID0gbmV3IEpTT05Qb2ludGVyKG9wLnBhdGgpO1xuICAgICAgcG9pbnRlci5yZXBsYWNlKHRhcmdldCwgb3AudmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbW92ZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1vdmUob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBtb3ZlIG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICBpZiAob3AucGF0aC5tYXRjaChuZXcgUmVnRXhwKCdeJyArIG9wLmZyb20pKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBtb3ZlIG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG5ldyBKU09OUG9pbnRlcihvcC5wYXRoKTtcbiAgICAgIHZhciBmcm9tID0gbmV3IEpTT05Qb2ludGVyKG9wLmZyb20pO1xuICAgICAgdmFyIHZhbHVlID0gZnJvbS5nZXQodGFyZ2V0KTtcblxuICAgICAgZnJvbS5yZW1vdmUodGFyZ2V0KTtcbiAgICAgIHBvaW50ZXIuYWRkKHRhcmdldCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcHlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY29weScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkob3AsIHRhcmdldCkge1xuICAgICAgaWYgKG9wLmZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJmcm9tXCIgaW4gSlNPTiBQYXRjaCBjb3B5IG9wZXJhdGlvbicpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcG9pbnRlciA9IG5ldyBKU09OUG9pbnRlcihvcC5wYXRoKTtcbiAgICAgIHZhciBmcm9tID0gbmV3IEpTT05Qb2ludGVyKG9wLmZyb20pO1xuICAgICAgdmFyIHZhbHVlID0gZnJvbS5nZXQodGFyZ2V0KTtcblxuICAgICAgcG9pbnRlci5hZGQodGFyZ2V0LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGVzdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0ZXN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGVzdChvcCwgdGFyZ2V0KSB7XG4gICAgICBpZiAob3AudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgXCJ2YWx1ZVwiIGluIEpTT04gUGF0Y2ggdGVzdCBvcGVyYXRpb24nKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBvaW50ZXIgPSBuZXcgSlNPTlBvaW50ZXIob3AucGF0aCk7XG4gICAgICB2YXIgdmFsdWUgPSBwb2ludGVyLmdldCh0YXJnZXQpO1xuXG4gICAgICBzd2l0Y2ggKF90eXBlb2Yob3AudmFsdWUpKSB7XG4gICAgICAgIC8vY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgLy9jYXNlICdudW1iZXInOlxuICAgICAgICAvL2Nhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAvLyAgaWYgKHZhbHVlICE9PSBvcC52YWx1ZSkge1xuICAgICAgICAvLyAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIEpTT04gUGF0Y2ggdGVzdCB2YWx1ZScpXG4gICAgICAgIC8vICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSBvcC52YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBKU09OIFBhdGNoIHRlc3QgdmFsdWUnKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05QYXRjaDtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRzXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QYXRjaDtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZGUgZW51bWVyYXRpb25cbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgVEhST1cgPSAwO1xudmFyIFJFQ09WRVIgPSAxO1xudmFyIFNJTEVOVCA9IDI7XG5cbi8qKlxuICogSlNPTlBvaW50ZXJcbiAqXG4gKiBAY2xhc3NcbiAqIEltcGxlbWVudHMgUkZDIDY5MDE6IEphdmFTY3JpcHQgT2JqZWN0IE5vdGF0aW9uIChKU09OKSBQb2ludGVyXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICovXG5cbnZhciBKU09OUG9pbnRlciA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIEpTT05Qb2ludGVyKGV4cHIsIG1vZGUpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTlBvaW50ZXIpO1xuXG4gICAgdGhpcy5leHByID0gZXhwcjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlIHx8IFRIUk9XO1xuICAgIHRoaXMudG9rZW5zID0gZXhwciAmJiBleHByLmNoYXJBdCgwKSA9PT0gJyMnID8gdGhpcy5wYXJzZVVSSUZyYWdtZW50SWRlbnRpZmllcihleHByKSA6IHRoaXMucGFyc2VKU09OU3RyaW5nKGV4cHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVzY2FwZVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhKU09OUG9pbnRlciwgW3tcbiAgICBrZXk6ICdlc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlc2NhcGUoZXhwcikge1xuICAgICAgcmV0dXJuIGV4cHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVW5lc2NhcGVcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndW5lc2NhcGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmVzY2FwZShleHByKSB7XG4gICAgICByZXR1cm4gZXhwci5yZXBsYWNlKC9+MS9nLCAnLycpLnJlcGxhY2UoL34wL2csICd+Jyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VKU09OU3RyaW5nJyxcblxuXG4gICAgLyoqXG4gICAgICogUGFyc2UgSlNPTiBTdHJpbmdcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQYXJzZSBhbiBleHByZXNzaW9uIGludG8gYSBsaXN0IG9mIHRva2Vuc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZUpTT05TdHJpbmcoZXhwcikge1xuICAgICAgaWYgKHR5cGVvZiBleHByICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04gUG9pbnRlciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByID09PSAnJykge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIGlmIChleHByLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBKU09OIFBvaW50ZXInKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cHIgPT09ICcvJykge1xuICAgICAgICByZXR1cm4gWycnXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4cHIuc3Vic3RyKDEpLnNwbGl0KCcvJykubWFwKHRoaXMudW5lc2NhcGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvIEpTT04gU3RyaW5nXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVuZGVyIGEgSlNPTiBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBwb2ludGVyXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndG9KU09OU3RyaW5nJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcvJyArIHRoaXMudG9rZW5zLm1hcCh0aGlzLmVzY2FwZSkuam9pbignLycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlIFVSSSBGcmFnbWVudCBJZGVudGlmZXJcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncGFyc2VVUklGcmFnbWVudElkZW50aWZpZXInLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZVVSSUZyYWdtZW50SWRlbnRpZmllcihleHByKSB7XG4gICAgICBpZiAodHlwZW9mIGV4cHIgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTiBQb2ludGVyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4cHIuY2hhckF0KDApICE9PSAnIycpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gUG9pbnRlciBVUkkgRnJhZ21lbnQgSWRlbnRpZmllcicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUpTT05TdHJpbmcoZGVjb2RlVVJJQ29tcG9uZW50KGV4cHIuc3Vic3RyKDEpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG8gVVJJIEZyYWdtZW50IElkZW50aWZpZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW5kZXIgYSBVUkkgRnJhZ21lbnQgSWRlbnRpZmllciByZXByZXNlbnRhdGlvbiBvZiBhIHBvaW50ZXJcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0b1VSSUZyYWdtZW50SWRlbnRpZmllcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvVVJJRnJhZ21lbnRJZGVudGlmaWVyKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHZhbHVlID0gdGhpcy50b2tlbnMubWFwKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KF90aGlzLmVzY2FwZSh0b2tlbikpO1xuICAgICAgfSkuam9pbignLycpO1xuXG4gICAgICByZXR1cm4gJyMvJyArIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCBhIHZhbHVlIGZyb20gdGhlIHNvdXJjZSBvYmplY3QgcmVmZXJlbmNlZCBieSB0aGUgcG9pbnRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KHNvdXJjZSkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBzb3VyY2U7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghY3VycmVudCB8fCBjdXJyZW50W3Rva2Vuc1tpXV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICh0aGlzLm1vZGUgIT09IFRIUk9XKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSlNPTiBQb2ludGVyIHJlZmVyZW5jZScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3Rva2Vuc1tpXV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCBhIHZhbHVlIG9uIGEgdGFyZ2V0IG9iamVjdCByZWZlcmVuY2VkIGJ5IHRoZSBwb2ludGVyLiBQdXRcbiAgICAgKiB3aWxsIGluc2VydCBhbiBhcnJheSBlbGVtZW50LiBUbyBjaGFuZ2UgYW4gZXhpc3RpbmcgYXJyYXkgZWxlbW5lbnQsIHVzZVxuICAgICAqIGBwb2ludGVyLnNldCgpYFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgICB2YXIgY3VycmVudCA9IHRhcmdldDtcblxuICAgICAgLy8gaXRlcmF0ZSB0aHJvdWdoIHRoZSB0b2tlbnNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAvLyBzZXQgdGhlIHByb3BlcnR5IG9uIHRoZSB0YXJnZXQgbG9jYXRpb25cbiAgICAgICAgaWYgKGkgPT09IHRva2Vucy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgaWYgKHRva2VuID09PSAnLScpIHtcbiAgICAgICAgICAgIGN1cnJlbnQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjdXJyZW50LnNwbGljZSh0b2tlbiwgMCwgdmFsdWUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3VycmVudFt0b2tlbl0gPSB2YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBoYW5kbGUgbWlzc2luZyB0YXJnZXQgbG9jYXRpb24gYmFzZWQgb24gXCJtb2RlXCJcbiAgICAgICAgfSBlbHNlIGlmICghY3VycmVudFt0b2tlbl0pIHtcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSBUSFJPVzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIEpTT04gUG9pbnRlciByZWZlcmVuY2UnKTtcblxuICAgICAgICAgICAgY2FzZSBSRUNPVkVSOlxuICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl0gPSBwYXJzZUludCh0b2tlbikgPyBbXSA6IHt9O1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBTSUxFTlQ6XG4gICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvaW50ZXIgbW9kZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHJlZmVyZW5jZSB0aGUgbmV4dCBvYmplY3QgaW4gdGhlIHBhdGhcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IGEgdmFsdWUgb24gYSB0YXJnZXQgb2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIHBvaW50ZXIuIFNldCB3aWxsXG4gICAgICogb3ZlcndyaXRlIGFuIGV4aXN0aW5nIGFycmF5IGVsZW1lbnQgYXQgdGhlIHRhcmdldCBsb2NhdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXBsYWNlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZSh0YXJnZXQsIHZhbHVlKSB7XG4gICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbnM7XG4gICAgICB2YXIgY3VycmVudCA9IHRhcmdldDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgIGlmIChpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGN1cnJlbnRbdG9rZW5dID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWN1cnJlbnRbdG9rZW5dKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJlbnRbdG9rZW5dID0gcGFyc2VJbnQodG9rZW4pID8gW10gOiB7fTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50ID0gY3VycmVudFt0b2tlbl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWxcbiAgICAgKlxuICAgICAqIC0gaWYgdGhpcyBpcyBhbiBhcnJheSBpdCBzaG91bGQgc3BsaWNlIHRoZSB2YWx1ZSBvdXRcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVtb3ZlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlKHRhcmdldCkge1xuICAgICAgdmFyIHRva2VucyA9IHRoaXMudG9rZW5zO1xuICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXQ7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gdW5kZWZpbmVkIHx8IGN1cnJlbnRbdG9rZW5dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgICAgICBjdXJyZW50LnNwbGljZSh0b2tlbiwgMSk7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSB0b2tlbnMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGRlbGV0ZSBjdXJyZW50W3Rva2VuXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3Rva2VuXTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVsZXRlIGZyb20gdGhlIHRhcmdldFxuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiAncGFyc2UnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwYXJzZShleHByKSB7XG4gICAgICByZXR1cm4gbmV3IEpTT05Qb2ludGVyKGV4cHIpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKU09OUG9pbnRlcjtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRzXG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05Qb2ludGVyO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBKU09OUG9pbnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xuXG4vKipcbiAqIEpTT05Qb2ludGVyIG1vZGVcbiAqL1xudmFyIFJFQ09WRVIgPSAxO1xuXG4vKipcbiAqIEpTT05NYXBwaW5nXG4gKlxuICogQGNsYXNzXG4gKiBEZWZpbmVzIGEgbWVhbnMgdG8gZGVjbGFyYXRpdmVseSB0cmFuc2xhdGUgYmV0d2VlbiBvYmplY3RcbiAqIHJlcHJlc2VudGF0aW9ucyB1c2luZyBKU09OIFBvaW50ZXIgc3ludGF4LlxuICovXG5cbnZhciBKU09OTWFwcGluZyA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3JcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIFRyYW5zbGF0ZSBwb2ludGVycyBmcm9tIEpTT04gU3RyaW5ncyBpbnRvIFBvaW50ZXIgb2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gbWFwcGluZ1xuICAgKi9cbiAgZnVuY3Rpb24gSlNPTk1hcHBpbmcobWFwcGluZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSlNPTk1hcHBpbmcpO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtYXBwaW5nJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogbmV3IE1hcCgpXG4gICAgfSk7XG5cbiAgICBPYmplY3Qua2V5cyhtYXBwaW5nKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IG1hcHBpbmdba2V5XTtcbiAgICAgIF90aGlzLm1hcHBpbmcuc2V0KG5ldyBKU09OUG9pbnRlcihrZXksIFJFQ09WRVIpLCBuZXcgSlNPTlBvaW50ZXIodmFsdWUsIFJFQ09WRVIpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uIEFzc2lnbiB2YWx1ZXMgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0IGJ5IHJlYWRpbmcgdGhlIG1hcHBpbmdcbiAgICogZnJvbSByaWdodCB0byBsZWZ0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VcbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTk1hcHBpbmcsIFt7XG4gICAga2V5OiAnbWFwJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWFwKHRhcmdldCwgc291cmNlKSB7XG4gICAgICB0aGlzLm1hcHBpbmcuZm9yRWFjaChmdW5jdGlvbiAocmlnaHQsIGxlZnQpIHtcbiAgICAgICAgbGVmdC5hZGQodGFyZ2V0LCByaWdodC5nZXQoc291cmNlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm9qZWN0XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQXNzaWduIHZhbHVlcyBmcm9tIHNvdXJjZSB0byB0YXJnZXQgYnkgcmVhZGluZyB0aGUgbWFwcGluZ1xuICAgICAqIGZyb20gbGVmdCB0byByaWdodC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwcm9qZWN0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvamVjdChzb3VyY2UsIHRhcmdldCkge1xuICAgICAgdGhpcy5tYXBwaW5nLmZvckVhY2goZnVuY3Rpb24gKHJpZ2h0LCBsZWZ0KSB7XG4gICAgICAgIHJpZ2h0LmFkZCh0YXJnZXQsIGxlZnQuZ2V0KHNvdXJjZSkpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpTT05NYXBwaW5nO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydHNcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTk1hcHBpbmc7XG5cbi8qKiovIH0pLFxuLyogMzUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKiBAaWdub3JlXG4gKi9cblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgSW5pdGlhbGl6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKTtcbnZhciBWYWxpZGF0b3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KTtcblxuLyoqXG4gKiBKU09OU2NoZW1hXG4gKlxuICogQGNsYXNzXG4gKiBDb21waWxlcyBKU09OIFNjaGVtYSBkb2N1bWVudHMgdG8gYW4gb2JqZWN0IHdpdGggb2JqZWN0IGluaXRpYWxpemF0aW9uXG4gKiBhbmQgdmFsaWRhdGlvbiBtZXRob2RzLlxuICovXG5cbnZhciBKU09OU2NoZW1hID0gZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hXG4gICAqL1xuICBmdW5jdGlvbiBKU09OU2NoZW1hKHNjaGVtYSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKU09OU2NoZW1hKTtcblxuICAgIC8vIFRPRE86IG9wdGlvbmFsbHkgcGFyc2UgSlNPTiBzdHJpbmc/XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBzY2hlbWEpO1xuXG4gICAgLy8gYWRkIHNjaGVtYS1kZXJpdmVkIGluaXRpYWxpemUgYW5kIHZhbGlkYXRlIG1ldGhvZHNcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0aGlzLCB7XG4gICAgICBpbml0aWFsaXplOiB7XG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0ZWFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogSW5pdGlhbGl6ZXIuY29tcGlsZShzY2hlbWEpXG4gICAgICB9LFxuICAgICAgdmFsaWRhdGU6IHtcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIHdyaXRlYWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBWYWxpZGF0b3IuY29tcGlsZShzY2hlbWEpXG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXh0ZW5kXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiAuLi5cbiAgICogRGVhciBmdXR1cmUsXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb24gd2FzIG1ldGljdWxvdXNseSBwbGFnaWFyaXplZCBmcm9tIHNvbWUgY3VyaW91cyBhbWFsZ2FtIG9mXG4gICAqIHN0YWNrb3ZlcmZsb3cgcG9zdHMgd2hpbHN0IGRvemluZyBvZmYgYXQgbXkga2V5Ym9hcmQsIHRvbyBkZXByaXZlZCBvZiBSRU0tXG4gICAqIHNsZWVwIHRvIHJlY3Vyc2UgdW5hc3Npc3RlZC4gSWYgaXQgc3Vja3MsIHlvdSBoYXZlIG9ubHkgeW91cnNlbGYgdG8gYmxhbWUuXG4gICAqXG4gICAqIEdvb2RuaWdodC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHNjaGVtYVxuICAgKiBAcmV0dXJucyB7SlNPTlNjaGVtYX1cbiAgICovXG5cblxuICBfY3JlYXRlQ2xhc3MoSlNPTlNjaGVtYSwgW3tcbiAgICBrZXk6ICdleHRlbmQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRlbmQoc2NoZW1hKSB7XG4gICAgICBmdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhICYmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGF0YSkpID09PSAnb2JqZWN0JyAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBleHRlbmRlcih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmFzc2lnbih7fSwgdGFyZ2V0KTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldCkgJiYgaXNPYmplY3Qoc291cmNlKSkge1xuICAgICAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc291cmNlW2tleV0pKSB7XG4gICAgICAgICAgICAgIGlmICghKGtleSBpbiB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gZXh0ZW5kZXIodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBzb3VyY2Vba2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZXNjcmlwdG9yID0gZXh0ZW5kZXIodGhpcywgc2NoZW1hKTtcbiAgICAgIHJldHVybiBuZXcgSlNPTlNjaGVtYShkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSlNPTlNjaGVtYTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBmb3JtYXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOSk7XG5cbi8qKlxuICogRm9yIHZhcmlhYmxlIGl0ZXJhdG9yIGNvdW50ZXJcbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG52YXIgaW5kZXhDb3VudCA9IDA7XG5cbi8qKlxuICogVmFsaWRhdG9yXG4gKlxuICogQ29tcGlsZSBhbiBvYmplY3QgZGVzY3JpYmluZyBhIEpTT04gU2NoZW1hIGludG8gYSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbnZhciBWYWxpZGF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIG51bGwsIFt7XG4gICAga2V5OiAnY29tcGlsZScsXG5cblxuICAgIC8qKlxuICAgICAqIENvbXBpbGUgKHN0YXRpYylcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIENvbXBpbGUgYW4gb2JqZWN0IGRlc2NyaWJpbmcgYSBKU09OIFNjaGVtYSBpbnRvIGEgdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzY2hlbWFcbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoc2NoZW1hKSB7XG4gICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzY2hlbWEpO1xuXG4gICAgICB2YXIgYm9keSA9ICdcXG4gICAgICAvLyBcImN1cnNvclwiXFxuICAgICAgbGV0IHZhbHVlID0gZGF0YVxcbiAgICAgIGxldCBjb250YWluZXJcXG4gICAgICBsZXQgc3RhY2sgPSBbXVxcbiAgICAgIGxldCB0b3AgPSAtMVxcblxcbiAgICAgIC8vIGVycm9yIHN0YXRlXFxuICAgICAgbGV0IHZhbGlkID0gdHJ1ZVxcbiAgICAgIGxldCBlcnJvcnMgPSBbXVxcblxcbiAgICAgIC8vIGNvbXBsZXggc2NoZW1hIHN0YXRlXFxuICAgICAgbGV0IGluaXRpYWxWYWxpZGl0eVxcbiAgICAgIGxldCBhbnlWYWxpZFxcbiAgICAgIGxldCBub3RWYWxpZFxcbiAgICAgIGxldCBjb3VudE9mVmFsaWRcXG4gICAgICBsZXQgaW5pdGlhbEVycm9yQ291bnRcXG4gICAgICBsZXQgYWNjdW11bGF0ZWRFcnJvckNvdW50XFxuXFxuICAgICAgLy8gdmFsaWRhdGlvbiBjb2RlXFxuICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuXFxuICAgICAgLy8gdmFsaWRhdGlvbiByZXN1bHRcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgdmFsaWQsXFxuICAgICAgICBlcnJvcnNcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICAgIHJldHVybiBuZXcgRnVuY3Rpb24oJ2RhdGEnLCBib2R5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gY3VycmVudCBpdGVyYXRvciBpbmRleCBjb3VudGVyIGFuZCBpbmNyZWFzZSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnY291bnRlcicsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gaW5kZXhDb3VudCsrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdG9yXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2NoZW1hIC0gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIGEgc2NoZW1hXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG9wdGlvbnMgLSBjb21waWxhdGlvbiBvcHRpb25zXG4gICAgICovXG5cbiAgfV0pO1xuXG4gIGZ1bmN0aW9uIFZhbGlkYXRvcihzY2hlbWEpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmFsaWRhdG9yKTtcblxuICAgIC8vIGFzc2lnbiBzY2hlbWEgdG8gdGhpc1xuICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuXG4gICAgLy8gYXNzaWduIGFsbCBvcHRpb25zIHRvIHRoaXNcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgLy8gZW5zdXJlIGFkZHJlc3MgaXMgZGVmaW5lZFxuICAgIGlmICghdGhpcy5hZGRyZXNzKSB7XG4gICAgICB0aGlzLmFkZHJlc3MgPSAnJztcbiAgICB9XG5cbiAgICAvLyBlbnN1cmUgcmVxdWlyZSBpcyBib29sZWFuXG4gICAgaWYgKHRoaXMucmVxdWlyZSAhPT0gdHJ1ZSkge1xuICAgICAgdGhpcy5yZXF1aXJlID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXBpbGVcbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIFRoZSBpbnN0YW5jZSBjb21waWxlIG1ldGhvZCBpcyBcImR1bWJcIi4gSXQgb25seSBzZXF1ZW5jZXMgaW52b2NhdGlvbiBvZlxuICAgKiBtb3JlIHNwZWNpZmljIGNvbXBpbGF0aW9uIG1ldGhvZHMuIEl0IGdlbmVyYXRlcyBjb2RlIHRvXG4gICAqXG4gICAqICAtIHJlYWQgYSB2YWx1ZSBmcm9tIGlucHV0XG4gICAqICAtIHZhbGlkYXRlIHR5cGUocykgb2YgaW5wdXRcbiAgICogIC0gdmFsaWRhdGUgY29uc3RyYWludHMgZGVzY3JpYmVkIGJ5IHZhcmlvdXMgc2NoZW1hIGtleXdvcmRzXG4gICAqXG4gICAqIENvbmRpdGlvbmFsIGxvZ2ljIHJlbGF0ZWQgdG8gY29kZSBnZW5lcmF0aW9uIGlzIHB1c2hlZCBkb3duc3RlYW0gdG9cbiAgICogdHlwZS1zcGVjaWZpYyBtZXRob2RzLlxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhWYWxpZGF0b3IsIFt7XG4gICAga2V5OiAnY29tcGlsZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGUoKSB7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHRoaXMucmVxdWlyZSkge1xuICAgICAgICBibG9jayArPSB0aGlzLnJlcXVpcmVkKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHR5cGUgdmFsaWRhdGlvblxuICAgICAgYmxvY2sgKz0gdGhpcy50eXBlKCk7XG5cbiAgICAgIC8vIHR5cGUgc3BlY2lmaWMgdmFsaWRhdGlvbiBnZW5lcmF0b3JzXG4gICAgICAvLyBudWxsIGFuZCBib29sZWFuIGFyZSBjb3ZlcmVkIGJ5IHRoaXMudHlwZSgpXG4gICAgICAvLyBpbnRlZ2VyIHNob3VsZCBiZSBjb3ZlcmVkIGJ5IG51bWJlciBhbmQgdGhpcy50eXBlKClcbiAgICAgIGJsb2NrICs9IHRoaXMuYXJyYXkoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMubnVtYmVyKCk7XG4gICAgICBibG9jayArPSB0aGlzLm9iamVjdCgpO1xuICAgICAgYmxvY2sgKz0gdGhpcy5zdHJpbmcoKTtcblxuICAgICAgLy8gbm9uLXR5cGUtc3BlY2lmaWMgdmFsaWRhdGlvbiBnZW5lcmF0b3JzXG4gICAgICBibG9jayArPSB0aGlzLmVudW0oKTtcbiAgICAgIGJsb2NrICs9IHRoaXMuYW55T2YoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMuYWxsT2YoKTtcbiAgICAgIGJsb2NrICs9IHRoaXMubm90KCk7XG4gICAgICBibG9jayArPSB0aGlzLm9uZU9mKCk7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwdXNoXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3B1c2gnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICBzdGFjay5wdXNoKHZhbHVlKVxcbiAgICAgIGNvbnRhaW5lciA9IHZhbHVlXFxuICAgICAgdG9wKytcXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwb3BcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncG9wJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICBpZiAoc3RhY2subGVuZ3RoID4gMSkge1xcbiAgICAgICAgdG9wLS1cXG4gICAgICAgIHN0YWNrLnBvcCgpXFxuICAgICAgfVxcblxcbiAgICAgIHZhbHVlID0gY29udGFpbmVyID0gc3RhY2tbdG9wXVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHR5cGVcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gaW5zdGFuY2UgbWF0Y2hlcyBzdWNjZXNzZnVsbHkgaWYgaXRzIHByaW1pdGl2ZSB0eXBlIGlzIG9uZSBvZiB0aGVcbiAgICAgKiA+IHR5cGVzIGRlZmluZWQgYnkga2V5d29yZC4gUmVjYWxsOiBcIm51bWJlclwiIGluY2x1ZGVzIFwiaW50ZWdlclwiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd0eXBlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdHlwZSgpIHtcbiAgICAgIHZhciB0eXBlID0gdGhpcy5zY2hlbWEudHlwZSxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHR5cGUpIHtcbiAgICAgICAgdmFyIHR5cGVzID0gQXJyYXkuaXNBcnJheSh0eXBlKSA/IHR5cGUgOiBbdHlwZV07XG4gICAgICAgIHZhciBjb25kaXRpb25zID0gdHlwZXMubWFwKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgICAgLy8gVE9ETzogY2FuIHdlIG1ha2UgYSBtYXBwaW5nIG9iamVjdCBmb3IgdGhpcyB0byBjbGVhbiBpdCB1cD9cbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2FycmF5JykgcmV0dXJuICchQXJyYXkuaXNBcnJheSh2YWx1ZSknO1xuICAgICAgICAgIGlmICh0eXBlID09PSAnYm9vbGVhbicpIHJldHVybiAndHlwZW9mIHZhbHVlICE9PSBcXCdib29sZWFuXFwnJztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ2ludGVnZXInKSByZXR1cm4gJyFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdudWxsJykgcmV0dXJuICd2YWx1ZSAhPT0gbnVsbCc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdudW1iZXInKSByZXR1cm4gJ3R5cGVvZiB2YWx1ZSAhPT0gXFwnbnVtYmVyXFwnJztcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHJldHVybiAnKHR5cGVvZiB2YWx1ZSAhPT0gXFwnb2JqZWN0XFwnIHx8IEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlID09PSBudWxsKSc7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSByZXR1cm4gJ3R5cGVvZiB2YWx1ZSAhPT0gXFwnc3RyaW5nXFwnJztcbiAgICAgICAgfSkuam9pbignICYmICcpO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvLyAnICsgYWRkcmVzcyArICcgdHlwZSBjaGVja2luZ1xcbiAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICcgKyBjb25kaXRpb25zICsgJykge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCd0eXBlXFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBcXCdpbnZhbGlkIHR5cGVcXCdcXG4gICAgICAgIH0pXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUeXBlLXNwZWNpZmljIHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBUeXBlIGNoZWNraW5nIGlzIG9wdGlvbmFsIGluIEpTT04gU2NoZW1hLCBhbmQgYSBzY2hlbWEgY2FuIGFsbG93XG4gICAgICogbXVsdGlwbGUgdHlwZXMuIEdlbmVyYXRlZCBjb2RlIG5lZWRzIHRvIGFwcGx5IHR5cGUtc3BlY2lmaWMgdmFsaWRhdGlvbnNcbiAgICAgKiBvbmx5IHRvIGFwcHJvcHJpYXRlIHZhbHVlcywgYW5kIGlnbm9yZSBldmVyeXRoaW5nIGVsc2UuIFR5cGUgdmFsaWRhdGlvblxuICAgICAqIGl0c2VsZiBpcyBoYW5kbGVkIHNlcGFyYXRlbHkgZnJvbSBvdGhlciB2YWxpZGF0aW9uIGtleXdvcmRzLlxuICAgICAqXG4gICAgICogVGhlIG1ldGhvZHMgYGFycmF5YCwgYG51bWJlcmAsIGBvYmplY3RgLCBgc3RyaW5nYCBnZW5lcmF0ZSB0eXBlLXNwZWNpZmljXG4gICAgICogdmFsaWRhdGlvbiBjb2RlIGJsb2Nrcywgd3JhcHBlZCBpbiBhIGNvbmRpdGlvbmFsIHN1Y2ggdGhhdCB0aGV5IHdpbGxcbiAgICAgKiBvbmx5IGJlIGFwcGxpZWQgdG8gdmFsdWVzIG9mIHRoYXQgdHlwZS5cbiAgICAgKlxuICAgICAqIEZvciBleGFtcGxlLCB0aGUgYG51bWJlcmAgbWV0aG9kLCBnaXZlbiB0aGUgc2NoZW1hXG4gICAgICpcbiAgICAgKiAgICAgeyBtaW5pbXVtOiAzIH1cbiAgICAgKlxuICAgICAqIHdpbGwgZ2VuZXJhdGVcbiAgICAgKlxuICAgICAqICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAqICAgICAgIGlmICh2YWx1ZSA8IDMpIHtcbiAgICAgKiAgICAgICAgIHZhbGlkID0gZmFsc2VcbiAgICAgKiAgICAgICAgIGVycm9ycy5wdXNoKHsgbWVzc2FnZTogJy4uLicgfSlcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEludGVnZXIgdmFsdWVzIGFyZSBhbHNvIG51bWJlcnMsIGFuZCBhcmUgdmFsaWRhdGVkIHRoZSBzYW1lIGFzIG51bWJlcnNcbiAgICAgKiBvdGhlciB0aGFuIHRoZSB0eXBlIHZhbGlkYXRpb24gaXRzZWxmLiBUaGVyZWZvcmUgbm8gYGludGVnZXJgIG1ldGhvZCBpc1xuICAgICAqIG5lZWRlZC5cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIGFycmF5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJbnZva2UgbWV0aG9kcyBmb3IgYXJyYXktc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gYXJyYXkgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYXJyYXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhcnJheSgpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnYWRkaXRpb25hbEl0ZW1zJywgJ2l0ZW1zJywgJ21pbkl0ZW1zJywgJ21heEl0ZW1zJywgJ3VuaXF1ZUl0ZW1zJ107XG4gICAgICB2YXIgdmFsaWRhdGlvbnMgPSB0aGlzLnZhbGlkYXRpb25zKGtleXdvcmRzKTtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAodmFsaWRhdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgLyoqXFxuICAgICAgICogQXJyYXkgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBudW1iZXJcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBudW1iZXItc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gbnVtYmVyIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ251bWJlcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG51bWJlcigpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWluaW11bScsICdtYXhpbXVtJywgJ211bHRpcGxlT2YnXTtcbiAgICAgIHZhciB2YWxpZGF0aW9ucyA9IHRoaXMudmFsaWRhdGlvbnMoa2V5d29yZHMpO1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh2YWxpZGF0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAvKipcXG4gICAgICAgKiBOdW1iZXIgdmFsaWRhdGlvbnNcXG4gICAgICAgKi9cXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcXCdudW1iZXJcXCcpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBvYmplY3RcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBvYmplY3Qtc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gb2JqZWN0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29iamVjdCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9iamVjdCgpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWF4UHJvcGVydGllcycsICdtaW5Qcm9wZXJ0aWVzJywgJ2FkZGl0aW9uYWxQcm9wZXJ0aWVzJywgJ3Byb3BlcnRpZXMnLCAncGF0dGVyblByb3BlcnRpZXMnLCAnZGVwZW5kZW5jaWVzJywgJ3NjaGVtYURlcGVuZGVuY2llcycsICdwcm9wZXJ0eURlcGVuZGVuY2llcyddO1xuICAgICAgdmFyIHZhbGlkYXRpb25zID0gdGhpcy52YWxpZGF0aW9ucyhrZXl3b3Jkcyk7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHZhbGlkYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIE9iamVjdCB2YWxpZGF0aW9uc1xcbiAgICAgICAqL1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcJ29iamVjdFxcJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcXG4gICAgICAnICsgdmFsaWRhdGlvbnMgKyAnXFxuICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBzdHJpbmdcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEludm9rZSBtZXRob2RzIGZvciBzdHJpbmctc3BlY2lmaWMga2V5d29yZHMgYW5kIHdyYXAgcmVzdWx0aW5nIGNvZGUgaW5cbiAgICAgKiB0eXBlLWNoZWNraW5nIGNvbmRpdGlvbmFsIHNvIHRoYXQgYW55IHJlc3VsdGluZyB2YWxpZGF0aW9ucyBhcmUgb25seVxuICAgICAqIGFwcGxpZWQgdG8gc3RyaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3N0cmluZycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN0cmluZygpIHtcbiAgICAgIHZhciBrZXl3b3JkcyA9IFsnbWF4TGVuZ3RoJywgJ21pbkxlbmd0aCcsICdwYXR0ZXJuJywgJ2Zvcm1hdCddO1xuICAgICAgdmFyIHZhbGlkYXRpb25zID0gdGhpcy52YWxpZGF0aW9ucyhrZXl3b3Jkcyk7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHZhbGlkYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIFN0cmluZyB2YWxpZGF0aW9uc1xcbiAgICAgICAqL1xcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFxcJ3N0cmluZ1xcJykge1xcbiAgICAgICcgKyB2YWxpZGF0aW9ucyArICdcXG4gICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHZhbGlkYXRpb25zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBJdGVyYXRlIG92ZXIgYW4gYXJyYXkgb2Yga2V5d29yZHMgYW5kIGludm9rZSBjb2RlIGdlbmVyYXRvciBtZXRob2RzXG4gICAgICogZm9yIGVhY2guIENvbmNhdGVuYXRlIHRoZSByZXN1bHRzIHRvZ2V0aGVyIGFuZCByZXR1cm4uIFVzZWQgYnkgXCJ0eXBlXCJcbiAgICAgKiBtZXRob2RzIHN1Y2ggYXMgdGhpcy5hcnJheSgpIGFuZCB0aGlzLnN0cmluZygpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXl3b3Jkc1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZhbGlkYXRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsaWRhdGlvbnMoa2V5d29yZHMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBzY2hlbWEgPSB0aGlzLnNjaGVtYTtcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIHZhciBjb25zdHJhaW50cyA9IE9iamVjdC5rZXlzKHNjaGVtYSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleXdvcmRzLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG4gICAgICB9KTtcblxuICAgICAgY29uc3RyYWludHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5d29yZCkge1xuICAgICAgICBibG9jayArPSBfdGhpc1trZXl3b3JkXSgpO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBlbnVtXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIHZhbHVlXG4gICAgICogPiBpcyBlcXVhbCB0byBvbmUgb2YgdGhlIGVsZW1lbnRzIGluIHRoaXMga2V5d29yZCdzIGFycmF5IHZhbHVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbnVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2VudW0oKSB7XG4gICAgICB2YXIgZW51bWVyYXRlZCA9IHRoaXMuc2NoZW1hLmVudW0sXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbJ3ZhbHVlICE9PSB1bmRlZmluZWQnXTtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoZW51bWVyYXRlZCkge1xuICAgICAgICBlbnVtZXJhdGVkLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHZhbHVlKSkge1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgndmFsdWUgIT09ICcgKyB2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ3ZhbHVlICE9PSAnICsgdmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCd2YWx1ZSAhPT0gXCInICsgdmFsdWUgKyAnXCInKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmRpdGlvbnMucHVzaCgndmFsdWUgIT09IG51bGwnKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25kaXRpb25zLnB1c2goJ1xcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkgKyAnXFwnICE9PSBKU09OLnN0cmluZ2lmeSh2YWx1ZSknKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGluZ3MgYXJlIG5vdCB3ZWxsIGluIHRoZSBsYW5kIG9mIGVudW0nKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8qKlxcbiAgICAgICAqIFZhbGlkYXRlIFwiJyArIGFkZHJlc3MgKyAnXCIgZW51bVxcbiAgICAgICAqL1xcbiAgICAgIGlmICgnICsgY29uZGl0aW9ucy5qb2luKCcgJiYgJykgKyAnKSB7XFxuICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgIGtleXdvcmQ6IFxcJ2VudW1cXCcsXFxuICAgICAgICAgIG1lc3NhZ2U6IEpTT04uc3RyaW5naWZ5KHZhbHVlKSArIFxcJyBpcyBub3QgYW4gZW51bWVyYXRlZCB2YWx1ZVxcJ1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFueU9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBhdCBsZWFzdCBvbmUgc2NoZW1hIGRlZmluZWQgYnkgdGhpc1xuICAgICAqID4ga2V5d29yZCdzIHZhbHVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS40XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhbnlPZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFueU9mKCkge1xuICAgICAgdmFyIGFueU9mID0gdGhpcy5zY2hlbWEuYW55T2YsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFueU9mKSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBpbml0aWFsVmFsaWRpdHkgPSB2YWxpZFxcbiAgICAgICAgaW5pdGlhbEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICBhbnlWYWxpZCA9IGZhbHNlXFxuICAgICAgJztcblxuICAgICAgICBhbnlPZi5mb3JFYWNoKGZ1bmN0aW9uIChzdWJzY2hlbWEpIHtcbiAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBhY2N1bXVsYXRlZEVycm9yQ291bnQgPSBlcnJvcnMubGVuZ3RoXFxuICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgIGlmIChhY2N1bXVsYXRlZEVycm9yQ291bnQgPT09IGVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICAgYW55VmFsaWQgPSB0cnVlXFxuICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9KTtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIGlmIChhbnlWYWxpZCA9PT0gdHJ1ZSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gaW5pdGlhbFZhbGlkaXR5XFxuICAgICAgICAgICAgZXJyb3JzID0gZXJyb3JzLnNsaWNlKDAsIGluaXRpYWxFcnJvckNvdW50KVxcbiAgICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIGFsbE9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBhbGwgc2NoZW1hcyBkZWZpbmVkIGJ5IHRoaXMga2V5d29yZCdzXG4gICAgICogPiB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjUuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWxsT2YnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbGxPZigpIHtcbiAgICAgIHZhciBhbGxPZiA9IHRoaXMuc2NoZW1hLmFsbE9mLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxPZikpIHtcbiAgICAgICAgYWxsT2YuZm9yRWFjaChmdW5jdGlvbiAoc3Vic2NoZW1hKSB7XG4gICAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICAnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG9uZU9mXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRcbiAgICAgKiA+IHZhbGlkYXRlcyBzdWNjZXNzZnVsbHkgYWdhaW5zdCBleGFjdGx5IG9uZSBzY2hlbWEgZGVmaW5lZCBieSB0aGlzXG4gICAgICogPiBrZXl3b3JkJ3MgdmFsdWUuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS41LjVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uZU9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25lT2YoKSB7XG4gICAgICB2YXIgb25lT2YgPSB0aGlzLnNjaGVtYS5vbmVPZixcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob25lT2YpKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogVmFsaWRhdGUgJyArIGFkZHJlc3MgKyAnIG9uZU9mXFxuICAgICAgICAgKi9cXG4gICAgICAgIGluaXRpYWxWYWxpZGl0eSA9IHZhbGlkXFxuICAgICAgICBpbml0aWFsRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgIGNvdW50T2ZWYWxpZCA9IDBcXG4gICAgICAnO1xuXG4gICAgICAgIG9uZU9mLmZvckVhY2goZnVuY3Rpb24gKHN1YnNjaGVtYSkge1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzIH0pO1xuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgaWYgKGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9PT0gZXJyb3JzLmxlbmd0aCkge1xcbiAgICAgICAgICBjb3VudE9mVmFsaWQgKz0gMVxcbiAgICAgICAgfVxcbiAgICAgICAgJztcbiAgICAgICAgfSk7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBpZiAoY291bnRPZlZhbGlkID09PSAxKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBpbml0aWFsVmFsaWRpdHlcXG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuc2xpY2UoMCwgaW5pdGlhbEVycm9yQ291bnQpXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICAgIGtleXdvcmQ6IFxcJ29uZU9mXFwnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXFwnd2hhdCBpcyBhIHJlYXNvbmFibGUgZXJyb3IgbWVzc2FnZSBmb3IgdGhpcyBjYXNlP1xcJ1xcbiAgICAgICAgICAgIH0pXFxuICAgICAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbm90XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0IGZhaWxzIHRvIHZhbGlkYXRlXG4gICAgICogPiBzdWNjZXNzZnVsbHkgYWdhaW5zdCB0aGUgc2NoZW1hIGRlZmluZWQgYnkgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNS42XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdub3QnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3QoKSB7XG4gICAgICB2YXIgbm90ID0gdGhpcy5zY2hlbWEubm90LFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoKHR5cGVvZiBub3QgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG5vdCkpID09PSAnb2JqZWN0JyAmJiBub3QgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobm90KSkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gbm90O1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIE5PVFxcbiAgICAgICAgICovXFxuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBpbml0aWFsVmFsaWRpdHkgPSB2YWxpZFxcbiAgICAgICAgICBpbml0aWFsRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG4gICAgICAgICAgbm90VmFsaWQgPSB0cnVlXFxuXFxuICAgICAgICAgIGFjY3VtdWxhdGVkRXJyb3JDb3VudCA9IGVycm9ycy5sZW5ndGhcXG5cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuXFxuICAgICAgICAgIGlmIChhY2N1bXVsYXRlZEVycm9yQ291bnQgPT09IGVycm9ycy5sZW5ndGgpIHtcXG4gICAgICAgICAgICBub3RWYWxpZCA9IGZhbHNlXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKG5vdFZhbGlkID09PSB0cnVlKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBpbml0aWFsVmFsaWRpdHlcXG4gICAgICAgICAgICBlcnJvcnMgPSBlcnJvcnMuc2xpY2UoMCwgaW5pdGlhbEVycm9yQ291bnQpXFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5zbGljZSgwLCBpbml0aWFsRXJyb3JDb3VudClcXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdub3RcXCcsXFxuICAgICAgICAgICAgICBtZXNzYWdlOiBcXCdobW0uLi5cXCdcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEl0ZXJhdGUgb3ZlciB0aGUgYHByb3BlcnRpZXNgIHNjaGVtYSBwcm9wZXJ0eSBpZiBpdCBpcyBhbiBvYmplY3QuIEZvciBlYWNoXG4gICAgICoga2V5LCBpbml0aWFsaXplIGEgbmV3IFZhbGlkYXRvciBmb3IgdGhlIHN1YnNjaGVtYSByZXByZXNlbnRlZCBieSB0aGUgcHJvcGVydHlcbiAgICAgKiB2YWx1ZSBhbmQgaW52b2tlIGNvbXBpbGUuIEFwcGVuZCB0aGUgcmVzdWx0IG9mIGNvbXBpbGluZyBlYWNoIHN1YnNjaGVtYSB0b1xuICAgICAqIHRoZSBibG9jayBvZiBjb2RlIGJlaW5nIGdlbmVyYXRlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3Byb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIHNjaGVtYSA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzLFxuICAgICAgICAgIHJlcXVpcmVkID0gc2NoZW1hLnJlcXVpcmVkO1xuXG4gICAgICB2YXIgYmxvY2sgPSB0aGlzLnB1c2goKTtcblxuICAgICAgLy8gZW5zdXJlIHRoZSB2YWx1ZSBvZiBcInJlcXVpcmVkXCIgc2NoZW1hIHByb3BlcnR5IGlzIGFuIGFycmF5XG4gICAgICByZXF1aXJlZCA9IEFycmF5LmlzQXJyYXkocmVxdWlyZWQpID8gcmVxdWlyZWQgOiBbXTtcblxuICAgICAgaWYgKCh0eXBlb2YgcHJvcGVydGllcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YocHJvcGVydGllcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICB2YXIgc3Vic2NoZW1hID0gcHJvcGVydGllc1trZXldO1xuICAgICAgICAgIHZhciBpc1JlcXVpcmVkID0gcmVxdWlyZWQuaW5kZXhPZihrZXkpICE9PSAtMTtcbiAgICAgICAgICAvLyBUT0RPXG4gICAgICAgICAgLy8gaG93IHNob3VsZCB3ZSBiZSBjYWxjdWxhdGluZyB0aGVzZSB0aGluZ3M/IHNob3VsZCBiZSBqc29uIHBvaW50ZXI/XG4gICAgICAgICAgLy8gbmVlZHMgYSBzZXBhcmF0ZSBmdW5jdGlvblxuICAgICAgICAgIHZhciBwb2ludGVyID0gW2FkZHJlc3MsIGtleV0uZmlsdGVyKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gISFzZWdtZW50O1xuICAgICAgICAgIH0pLmpvaW4oJy4nKTtcbiAgICAgICAgICB2YXIgdmFsaWRhdGlvbiA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IHBvaW50ZXIsIHJlcXVpcmU6IGlzUmVxdWlyZWQgfSk7XG5cbiAgICAgICAgICAvLyByZWFkIHRoZSB2YWx1ZVxuICAgICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIHZhbHVlID0gY29udGFpbmVyW1xcJycgKyBrZXkgKyAnXFwnXVxcbiAgICAgICAgJztcblxuICAgICAgICAgIGJsb2NrICs9IHZhbGlkYXRpb24uY29tcGlsZSgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgYmxvY2sgKz0gdGhpcy5wb3AoKTtcblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE90aGVyIFByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFRoaXMgbWV0aG9kIGlzIG5vdCBmb3IgYSBrZXl3b3JkLiBJdCB3cmFwcyB2YWxpZGF0aW9ucyBmb3JcbiAgICAgKiBwYXR0ZXJuUHJvcGVydGllcyBhbmQgYWRkaXRpb25hbFByb3BlcnRpZXMgaW4gYSBzaW5nbGUgaXRlcmF0aW9uIG92ZXJcbiAgICAgKiBhbiBvYmplY3QtdHlwZSB2YWx1ZSdzIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBJdCBzaG91bGQgb25seSBiZSBpbnZva2VkIG9uY2UgZm9yIGEgZ2l2ZW4gc3Vic2NoZW1hLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnb3RoZXJQcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3RoZXJQcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuICdcXG4gICAgICAvKipcXG4gICAgICAgKiBWYWxpZGF0ZSBPdGhlciBQcm9wZXJ0aWVzXFxuICAgICAgICovXFxuICAgICAgJyArIHRoaXMucHVzaCgpICsgJ1xcblxcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb250YWluZXIpIHtcXG4gICAgICAgIHZhbHVlID0gY29udGFpbmVyW2tleV1cXG4gICAgICAgIG1hdGNoZWQgPSBmYWxzZVxcblxcbiAgICAgICAgJyArIHRoaXMucGF0dGVyblZhbGlkYXRpb25zKCkgKyAnXFxuICAgICAgICAnICsgdGhpcy5hZGRpdGlvbmFsVmFsaWRhdGlvbnMoKSArICdcXG4gICAgICB9XFxuXFxuICAgICAgJyArIHRoaXMucG9wKCkgKyAnXFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0dGVybiBWYWxpZGF0aW9uc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2VuZXJhdGUgdmFsaWRhdGlvbiBjb2RlIGZyb20gYSBzdWJzY2hlbWEgZm9yIHByb3BlcnRpZXMgbWF0Y2hpbmcgYVxuICAgICAqIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3BhdHRlcm5WYWxpZGF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm5WYWxpZGF0aW9ucygpIHtcbiAgICAgIHZhciBwYXR0ZXJuUHJvcGVydGllcyA9IHRoaXMuc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKCh0eXBlb2YgcGF0dGVyblByb3BlcnRpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHBhdHRlcm5Qcm9wZXJ0aWVzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHBhdHRlcm5Qcm9wZXJ0aWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IHBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm5dO1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSk7XG4gICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICBpZiAoa2V5Lm1hdGNoKFxcJycgKyBwYXR0ZXJuICsgJ1xcJykpIHtcXG4gICAgICAgICAgICBtYXRjaGVkID0gdHJ1ZVxcbiAgICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgICB9XFxuICAgICAgICAnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZGl0aW9uYWwgVmFsaWRhdGlvbnNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSwgZWl0aGVyIGZyb20gYSBzdWJzY2hlbWEgZm9yIHByb3BlcnRpZXMgbm90XG4gICAgICogZGVmaW5lZCBpbiB0aGUgc2NoZW1hLCBvciB0byBkaXNhbGxvdyBwcm9wZXJ0aWVzIG5vdCBkZWZpbmVkIGluIHRoZVxuICAgICAqIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZGl0aW9uYWxWYWxpZGF0aW9ucycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxWYWxpZGF0aW9ucygpIHtcbiAgICAgIHZhciBfc2NoZW1hID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgcHJvcGVydGllcyA9IF9zY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllcyA9IF9zY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIHZhbGlkYXRpb25zID0gJyc7XG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gY2F0Y2ggYWRkaXRpb25hbCB1bm1hdGNoZWQgcHJvcGVydGllc1xuICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbJ21hdGNoZWQgIT09IHRydWUnXTtcblxuICAgICAgLy8gaWdub3JlIGRlZmluZWQgcHJvcGVydGllc1xuICAgICAgT2JqZWN0LmtleXMocHJvcGVydGllcyB8fCB7fSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGNvbmRpdGlvbnMucHVzaCgna2V5ICE9PSBcXCcnICsga2V5ICsgJ1xcJycpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIHZhbGlkYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgaWYgKCh0eXBlb2YgYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGFkZGl0aW9uYWxQcm9wZXJ0aWVzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHZhciBzdWJzY2hlbWEgPSBhZGRpdGlvbmFsUHJvcGVydGllcztcbiAgICAgICAgdmFyIHZhbGlkYXRvciA9IG5ldyBWYWxpZGF0b3Ioc3Vic2NoZW1hLCB7IGFkZHJlc3M6IGFkZHJlc3MgKyAnW0FQS2V5XScgfSk7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIHZhbGlkYXRlIGFkZGl0aW9uYWwgcHJvcGVydGllc1xcbiAgICAgICAgaWYgKCcgKyBjb25kaXRpb25zLmpvaW4oJyAmJiAnKSArICcpIHtcXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgLy8gZXJyb3IgZm9yIGFkZGl0aW9uYWwgcHJvcGVydGllc1xuICAgICAgaWYgKGFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyB2YWxpZGF0ZSBub24tcHJlc2VuY2Ugb2YgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXFxuICAgICAgICBpZiAoJyArIGNvbmRpdGlvbnMuam9pbignICYmICcpICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdhZGRpdGlvbmFsUHJvcGVydGllc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBrZXkgKyBcXCcgaXMgbm90IGEgZGVmaW5lZCBwcm9wZXJ0eVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBwYXR0ZXJuUHJvcGVydGllc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogR2VuZXJhdGUgdmFsaWRhdGlvbiBjb2RlIGZvciBwcm9wZXJ0aWVzIG1hdGNoaW5nIGEgcGF0dGVyblxuICAgICAqIGRlZmluZWQgYnkgdGhlIHByb3BlcnR5IG5hbWUgKGtleSksIHdoaWNoIG11c3QgYmUgYSBzdHJpbmdcbiAgICAgKiByZXByZXNlbnRpbmcgYSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXR0ZXJuUHJvcGVydGllcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHBhdHRlcm5Qcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICghdGhpcy5vdGhlclByb3BlcnRpZXNDYWxsZWQpIHtcbiAgICAgICAgdGhpcy5vdGhlclByb3BlcnRpZXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICBibG9jayArPSB0aGlzLm90aGVyUHJvcGVydGllcygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEdlbmVyYXRlIHZhbGlkYXRpb24gY29kZSBmb3IgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIG5vdCBkZWZpbmVkXG4gICAgICogaW4gdGhlIHNjaGVtYSwgb3IgZGlzYWxsb3cgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGlmIHRoZSB2YWx1ZSBvZlxuICAgICAqIGBhZGRpdGlvbmFsUHJvcGVydGllc2AgaW4gdGhlIHNjaGVtYSBpcyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnYWRkaXRpb25hbFByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydGllcygpIHtcbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoIXRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkKSB7XG4gICAgICAgIHRoaXMub3RoZXJQcm9wZXJ0aWVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgYmxvY2sgKz0gdGhpcy5vdGhlclByb3BlcnRpZXMoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1pblByb3BlcnRpZXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gb2JqZWN0IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtaW5Qcm9wZXJ0aWVzXCIgaWYgaXRzIG51bWJlciBvZlxuICAgICAqID4gcHJvcGVydGllcyBpcyBncmVhdGVyIHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuNC4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtaW5Qcm9wZXJ0aWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluUHJvcGVydGllcygpIHtcbiAgICAgIHZhciBtaW5Qcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWEubWluUHJvcGVydGllcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgbWluIHByb3BlcnRpZXNcXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoIDwgJyArIG1pblByb3BlcnRpZXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pblByb3BlcnRpZXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIGZldyBwcm9wZXJ0aWVzXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogbWF4UHJvcGVydGllc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBvYmplY3QgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCBcIm1heFByb3BlcnRpZXNcIiBpZiBpdHMgbnVtYmVyIG9mXG4gICAgICogPiBwcm9wZXJ0aWVzIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSB2YWx1ZSBvZiB0aGlzIGtleXdvcmQuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS40LjFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21heFByb3BlcnRpZXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhQcm9wZXJ0aWVzKCkge1xuICAgICAgdmFyIG1heFByb3BlcnRpZXMgPSB0aGlzLnNjaGVtYS5tYXhQcm9wZXJ0aWVzLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyBtYXggcHJvcGVydGllc1xcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGggPiAnICsgbWF4UHJvcGVydGllcyArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4UHJvcGVydGllc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCd0b28gbWFueSBwcm9wZXJ0aWVzXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVwZW5kZW5jaWVzXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEZvciBhbGwgKG5hbWUsIHNjaGVtYSkgcGFpciBvZiBzY2hlbWEgZGVwZW5kZW5jaWVzLCBpZiB0aGUgaW5zdGFuY2UgaGFzXG4gICAgICogPiBhIHByb3BlcnR5IGJ5IHRoaXMgbmFtZSwgdGhlbiBpdCBtdXN0IGFsc28gdmFsaWRhdGUgc3VjY2Vzc2Z1bGx5IGFnYWluc3RcbiAgICAgKiA+IHRoZSBzY2hlbWEuXG4gICAgICogPlxuICAgICAqID4gTm90ZSB0aGF0IHRoaXMgaXMgdGhlIGluc3RhbmNlIGl0c2VsZiB3aGljaCBtdXN0IHZhbGlkYXRlIHN1Y2Nlc3NmdWxseSxcbiAgICAgKiA+IG5vdCB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIHRoZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqID5cbiAgICAgKiA+IEZvciBlYWNoIChuYW1lLCBwcm9wZXJ0eXNldCkgcGFpciBvZiBwcm9wZXJ0eSBkZXBlbmRlbmNpZXMsIGlmIHRoZVxuICAgICAqID4gaW5zdGFuY2UgaGFzIGEgcHJvcGVydHkgYnkgdGhpcyBuYW1lLCB0aGVuIGl0IG11c3QgYWxzbyBoYXZlIHByb3BlcnRpZXNcbiAgICAgKiA+IHdpdGggdGhlIHNhbWUgbmFtZXMgYXMgcHJvcGVydHlzZXQuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS40LjUuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVwZW5kZW5jaWVzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVwZW5kZW5jaWVzKCkge1xuICAgICAgdmFyIGRlcGVuZGVuY2llcyA9IHRoaXMuc2NoZW1hLmRlcGVuZGVuY2llcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHZhciBibG9jayA9IHRoaXMucHVzaCgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBkZXBlbmRlbmNpZXMgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGRlcGVuZGVuY2llcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBPYmplY3Qua2V5cyhkZXBlbmRlbmNpZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2tleV07XG4gICAgICAgICAgdmFyIGNvbmRpdGlvbnMgPSBbXTtcblxuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRlcGVuZGVuY3kpKSB7XG4gICAgICAgICAgICBkZXBlbmRlbmN5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgICAgY29uZGl0aW9ucy5wdXNoKCdjb250YWluZXJbXFwnJyArIGl0ZW0gKyAnXFwnXSA9PT0gdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICAgIGlmIChjb250YWluZXJbXFwnJyArIGtleSArICdcXCddICE9PSB1bmRlZmluZWQgJiYgKCcgKyBjb25kaXRpb25zLmpvaW4oJyB8fCAnKSArICcpKSB7XFxuICAgICAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFxcJ2RlcGVuZGVuY2llc1xcJyxcXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXFwndW5tZXQgZGVwZW5kZW5jaWVzXFwnXFxuICAgICAgICAgICAgICB9KVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgJztcbiAgICAgICAgICB9IGVsc2UgaWYgKCh0eXBlb2YgZGVwZW5kZW5jeSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoZGVwZW5kZW5jeSkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdmFyIHN1YnNjaGVtYSA9IGRlcGVuZGVuY3k7XG4gICAgICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEsIHsgYWRkcmVzczogYWRkcmVzcyB9KTtcblxuICAgICAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgICAgIGlmIChjb250YWluZXJbXFwnJyArIGtleSArICdcXCddICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICcgKyB2YWxpZGF0b3IuY29tcGlsZSgpICsgJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBibG9jayArPSB0aGlzLnBvcCgpO1xuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVxdWlyZWRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQW4gb2JqZWN0IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgdGhpcyBrZXl3b3JkIGlmIGl0cyBwcm9wZXJ0eSBzZXRcbiAgICAgKiA+IGNvbnRhaW5zIGFsbCBlbGVtZW50cyBpbiB0aGlzIGtleXdvcmQncyBhcnJheSB2YWx1ZS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjQuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAncmVxdWlyZWQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1aXJlZCgpIHtcbiAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5zY2hlbWEucHJvcGVydGllcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgIC8vIHZhbGlkYXRlICcgKyBhZGRyZXNzICsgJyBwcmVzZW5jZVxcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgIGtleXdvcmQ6IFxcJ3JlcXVpcmVkXFwnLFxcbiAgICAgICAgICBtZXNzYWdlOiBcXCdpcyByZXF1aXJlZFxcJ1xcbiAgICAgICAgfSlcXG4gICAgICB9XFxuICAgICc7XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBhZGRpdGlvbmFsSXRlbXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIG9mIGFuIGFycmF5IGluc3RhbmNlIHdpdGggcmVnYXJkcyB0byB0aGVzZSB0d29cbiAgICAgKiA+IGtleXdvcmRzIGlzIGRldGVybWluZWQgYXMgZm9sbG93czogaWYgXCJpdGVtc1wiIGlzIG5vdCBwcmVzZW50LCBvciBpdHNcbiAgICAgKiA+IHZhbHVlIGlzIGFuIG9iamVjdCwgdmFsaWRhdGlvbiBvZiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzLFxuICAgICAqID4gcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIjsgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogPiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGJvb2xlYW4gdmFsdWUgdHJ1ZSBvciBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2ZcbiAgICAgKiA+IHRoZSBpbnN0YW5jZSBhbHdheXMgc3VjY2VlZHM7IGlmIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzXG4gICAgICogPiBib29sZWFuIHZhbHVlIGZhbHNlIGFuZCB0aGUgdmFsdWUgb2YgXCJpdGVtc1wiIGlzIGFuIGFycmF5LCB0aGVcbiAgICAgKiA+IGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplXG4gICAgICogPiBvZiBcIml0ZW1zXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4zLjFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2FkZGl0aW9uYWxJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZGl0aW9uYWxJdGVtcygpIHtcbiAgICAgIHZhciBfc2NoZW1hMiA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIGl0ZW1zID0gX3NjaGVtYTIuaXRlbXMsXG4gICAgICAgICAgYWRkaXRpb25hbEl0ZW1zID0gX3NjaGVtYTIuYWRkaXRpb25hbEl0ZW1zLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBibG9jayA9ICcnO1xuXG4gICAgICBpZiAoYWRkaXRpb25hbEl0ZW1zID09PSBmYWxzZSAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAvLyBkb25cXCd0IGFsbG93IGFkZGl0aW9uYWwgaXRlbXNcXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAnICsgaXRlbXMubGVuZ3RoICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdhZGRpdGlvbmFsSXRlbXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwnYWRkaXRpb25hbCBpdGVtcyBub3QgYWxsb3dlZFxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIGlmICgodHlwZW9mIGFkZGl0aW9uYWxJdGVtcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoYWRkaXRpb25hbEl0ZW1zKSkgPT09ICdvYmplY3QnICYmIGFkZGl0aW9uYWxJdGVtcyAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gYWRkaXRpb25hbEl0ZW1zO1xuICAgICAgICB2YXIgdmFsaWRhdG9yID0gbmV3IFZhbGlkYXRvcihzdWJzY2hlbWEpO1xuICAgICAgICB2YXIgY291bnRlciA9IFZhbGlkYXRvci5jb3VudGVyO1xuXG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIGFkZGl0aW9uYWwgaXRlbXNcXG4gICAgICAgICcgKyB0aGlzLnB1c2goKSArICdcXG5cXG4gICAgICAgIGZvciAodmFyIGknICsgY291bnRlciArICcgPSAnICsgaXRlbXMubGVuZ3RoICsgJzsgaScgKyBjb3VudGVyICsgJyA8PSBjb250YWluZXIubGVuZ3RoOyBpJyArIGNvdW50ZXIgKyAnKyspIHtcXG4gICAgICAgICAgdmFsdWUgPSBjb250YWluZXJbaScgKyBjb3VudGVyICsgJ11cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICB9XFxuXFxuICAgICAgICAnICsgdGhpcy5wb3AoKSArICdcXG4gICAgICAnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYmxvY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlbXNcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIG9mIGFuIGFycmF5IGluc3RhbmNlIHdpdGggcmVnYXJkcyB0byB0aGVzZSB0d29cbiAgICAgKiA+IGtleXdvcmRzIGlzIGRldGVybWluZWQgYXMgZm9sbG93czogaWYgXCJpdGVtc1wiIGlzIG5vdCBwcmVzZW50LCBvciBpdHNcbiAgICAgKiA+IHZhbHVlIGlzIGFuIG9iamVjdCwgdmFsaWRhdGlvbiBvZiB0aGUgaW5zdGFuY2UgYWx3YXlzIHN1Y2NlZWRzLFxuICAgICAqID4gcmVnYXJkbGVzcyBvZiB0aGUgdmFsdWUgb2YgXCJhZGRpdGlvbmFsSXRlbXNcIjsgaWYgdGhlIHZhbHVlIG9mXG4gICAgICogPiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGJvb2xlYW4gdmFsdWUgdHJ1ZSBvciBhbiBvYmplY3QsIHZhbGlkYXRpb24gb2ZcbiAgICAgKiA+IHRoZSBpbnN0YW5jZSBhbHdheXMgc3VjY2VlZHM7IGlmIHRoZSB2YWx1ZSBvZiBcImFkZGl0aW9uYWxJdGVtc1wiIGlzXG4gICAgICogPiBib29sZWFuIHZhbHVlIGZhbHNlIGFuZCB0aGUgdmFsdWUgb2YgXCJpdGVtc1wiIGlzIGFuIGFycmF5LCB0aGVcbiAgICAgKiA+IGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0cyBzaXplIGlzIGxlc3MgdGhhbiwgb3IgZXF1YWwgdG8sIHRoZSBzaXplXG4gICAgICogPiBvZiBcIml0ZW1zXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4zLjFcbiAgICAgKlxuICAgICAqIENvZGUgdG8gZ2VuZXJhdGVcbiAgICAgKlxuICAgICAqICAgICAvLyB0aGlzIG91dGVyIGNvbmRpdGlvbmFsIGlzIGdlbmVyYXRlZCBieSB0aGlzLmFycmF5KClcbiAgICAgKiAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHtcbiAgICAgKiAgICAgICBsZXQgcGFyZW50ID0gdmFsdWVcbiAgICAgKiAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmVudC5sZW5ndGg7IGkrKykge1xuICAgICAqICAgICAgICAgdmFsdWUgPSBwYXJlbnRbaV1cbiAgICAgKiAgICAgICAgIC8vIG90aGVyIHZhbGlkYXRpb24gY29kZSBkZXBlbmRpbmcgb24gdmFsdWUgaGVyZVxuICAgICAqICAgICAgIH1cbiAgICAgKiAgICAgICB2YWx1ZSA9IHBhcmVudFxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2l0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXRlbXMoKSB7XG4gICAgICB2YXIgaXRlbXMgPSB0aGlzLnNjaGVtYS5pdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgLy8gaWYgaXRlbXMgaXMgYW4gYXJyYXlcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICBibG9jayArPSB0aGlzLnB1c2goKTtcblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgICAgIHZhciBzdWJzY2hlbWEgPSBpdGVtO1xuICAgICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSwgeyBhZGRyZXNzOiBhZGRyZXNzICsgJ1snICsgaW5kZXggKyAnXScgfSk7XG5cbiAgICAgICAgICBibG9jayArPSAnXFxuICAgICAgICAgIC8vIGl0ZW0gIycgKyBpbmRleCArICdcXG4gICAgICAgICAgdmFsdWUgPSBjb250YWluZXJbJyArIGluZGV4ICsgJ11cXG4gICAgICAgICAgJyArIHZhbGlkYXRvci5jb21waWxlKCkgKyAnXFxuICAgICAgICAnO1xuICAgICAgICB9KTtcblxuICAgICAgICBibG9jayArPSB0aGlzLnBvcCgpO1xuXG4gICAgICAgIC8vIGlmIGl0ZW1zIGlzIGFuIG9iamVjdFxuICAgICAgfSBlbHNlIGlmICgodHlwZW9mIGl0ZW1zID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihpdGVtcykpID09PSAnb2JqZWN0JyAmJiBpdGVtcyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgc3Vic2NoZW1hID0gaXRlbXM7XG4gICAgICAgIHZhciB2YWxpZGF0b3IgPSBuZXcgVmFsaWRhdG9yKHN1YnNjaGVtYSk7XG4gICAgICAgIHZhciBjb3VudGVyID0gVmFsaWRhdG9yLmNvdW50ZXI7XG5cbiAgICAgICAgYmxvY2sgKz0gJ1xcbiAgICAgICAgLy8gaXRlbXNcXG4gICAgICAgICcgKyB0aGlzLnB1c2goKSArICdcXG5cXG4gICAgICAgIGZvciAodmFyIGknICsgY291bnRlciArICcgPSAwOyBpJyArIGNvdW50ZXIgKyAnIDwgY29udGFpbmVyLmxlbmd0aDsgaScgKyBjb3VudGVyICsgJysrKSB7XFxuICAgICAgICAgIC8vIHJlYWQgYXJyYXkgZWxlbWVudFxcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRhaW5lcltpJyArIGNvdW50ZXIgKyAnXVxcbiAgICAgICAgICAnICsgdmFsaWRhdG9yLmNvbXBpbGUoKSArICdcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICcgKyB0aGlzLnBvcCgpICsgJ1xcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW5JdGVtc1xuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBbiBhcnJheSBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IFwibWluSXRlbXNcIiBpZiBpdHMgc2l6ZSBpcyBncmVhdGVyXG4gICAgICogPiB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjMuM1xuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWluSXRlbXMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5JdGVtcygpIHtcbiAgICAgIHZhciBtaW5JdGVtcyA9IHRoaXMuc2NoZW1hLm1pbkl0ZW1zLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyBtaW4gaXRlbXNcXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPCAnICsgbWluSXRlbXMgKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pbkl0ZW1zXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBmZXcgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heEl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEFuIGFycmF5IGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtYXhJdGVtc1wiIGlmIGl0cyBzaXplIGlzIGxlc3NcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhJdGVtcycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG1heEl0ZW1zKCkge1xuICAgICAgdmFyIG1heEl0ZW1zID0gdGhpcy5zY2hlbWEubWF4SXRlbXMsXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIG1heCBpdGVtc1xcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+ICcgKyBtYXhJdGVtcyArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWF4SXRlbXNcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIG1hbnkgcHJvcGVydGllc1xcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVuaXF1ZUl0ZW1zXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IElmIHRoaXMga2V5d29yZCBoYXMgYm9vbGVhbiB2YWx1ZSBmYWxzZSwgdGhlIGluc3RhbmNlIHZhbGlkYXRlc1xuICAgICAqID4gc3VjY2Vzc2Z1bGx5LiBJZiBpdCBoYXMgYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgdmFsaWRhdGVzXG4gICAgICogPiBzdWNjZXNzZnVsbHkgaWYgYWxsIG9mIGl0cyBlbGVtZW50cyBhcmUgdW5pcXVlLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMy40XG4gICAgICpcbiAgICAgKiBUT0RPXG4gICAgICogb3B0aW1pemVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3VuaXF1ZUl0ZW1zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5pcXVlSXRlbXMoKSB7XG4gICAgICB2YXIgdW5pcXVlSXRlbXMgPSB0aGlzLnNjaGVtYS51bmlxdWVJdGVtcyxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG4gICAgICB2YXIgYmxvY2sgPSAnJztcblxuICAgICAgaWYgKHVuaXF1ZUl0ZW1zID09PSB0cnVlKSB7XG4gICAgICAgIGJsb2NrICs9ICdcXG4gICAgICAgIC8vIHZhbGlkYXRlICcgKyBhZGRyZXNzICsgJyB1bmlxdWUgaXRlbXNcXG4gICAgICAgIGxldCB2YWx1ZXMgPSB2YWx1ZS5tYXAodiA9PiBKU09OLnN0cmluZ2lmeSh2KSkgLy8gVE9ETzogb3B0aW1pemVcXG4gICAgICAgIGxldCBzZXQgPSBuZXcgU2V0KHZhbHVlcylcXG4gICAgICAgIGlmICh2YWx1ZXMubGVuZ3RoICE9PSBzZXQuc2l6ZSkge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCd1bmlxdWVJdGVtc1xcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCdpdGVtcyBtdXN0IGJlIHVuaXF1ZVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAgICc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBibG9jaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBtaW5MZW5ndGhcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQSBzdHJpbmcgaW5zdGFuY2UgaXMgdmFsaWQgYWdhaW5zdCB0aGlzIGtleXdvcmQgaWYgaXRzIGxlbmd0aCBpc1xuICAgICAqID4gZ3JlYXRlciB0aGFuLCBvciBlcXVhbCB0bywgdGhlIHZhbHVlIG9mIHRoaXMga2V5d29yZC4gVGhlIGxlbmd0aCBvZlxuICAgICAqID4gYSBzdHJpbmcgaW5zdGFuY2UgaXMgZGVmaW5lZCBhcyB0aGUgbnVtYmVyIG9mIGl0cyBjaGFyYWN0ZXJzIGFzXG4gICAgICogPiBkZWZpbmVkIGJ5IFJGQyA0NjI3IFtSRkM0NjI3XS5cbiAgICAgKiA+IEpTT04gU2NoZW1hIFZhbGlkYXRpb24gU2VjdGlvbiA1LjIuMlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnbWluTGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWluTGVuZ3RoKCkge1xuICAgICAgdmFyIG1pbkxlbmd0aCA9IHRoaXMuc2NoZW1hLm1pbkxlbmd0aCxcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgbWluTGVuZ3RoXFxuICAgICAgICBpZiAoQXJyYXkuZnJvbSh2YWx1ZSkubGVuZ3RoIDwgJyArIG1pbkxlbmd0aCArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbWluTGVuZ3RoXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBzaG9ydFxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG1heExlbmd0aFxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBBIHN0cmluZyBpbnN0YW5jZSBpcyB2YWxpZCBhZ2FpbnN0IHRoaXMga2V5d29yZCBpZiBpdHMgbGVuZ3RoIGlzIGxlc3NcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgdGhpcyBrZXl3b3JkLiBUaGUgbGVuZ3RoIG9mIGEgc3RyaW5nXG4gICAgICogPiBpbnN0YW5jZSBpcyBkZWZpbmVkIGFzIHRoZSBudW1iZXIgb2YgaXRzIGNoYXJhY3RlcnMgYXMgZGVmaW5lZCBieVxuICAgICAqID4gUkZDIDQ2MjcgW1JGQzQ2MjddLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMi4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhMZW5ndGgnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtYXhMZW5ndGgoKSB7XG4gICAgICB2YXIgbWF4TGVuZ3RoID0gdGhpcy5zY2hlbWEubWF4TGVuZ3RoLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cblxuICAgICAgcmV0dXJuICdcXG4gICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBtYXhMZW5ndGhcXG4gICAgICAgIGlmIChBcnJheS5mcm9tKHZhbHVlKS5sZW5ndGggPiAnICsgbWF4TGVuZ3RoICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtYXhMZW5ndGhcXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIGxvbmdcXCdcXG4gICAgICAgICAgfSlcXG4gICAgICAgIH1cXG4gICAgJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXR0ZXJuXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiA+IEEgc3RyaW5nIGluc3RhbmNlIGlzIGNvbnNpZGVyZWQgdmFsaWQgaWYgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICAqID4gbWF0Y2hlcyB0aGUgaW5zdGFuY2Ugc3VjY2Vzc2Z1bGx5LlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMi4zXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdwYXR0ZXJuJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGF0dGVybigpIHtcbiAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5zY2hlbWEucGF0dGVybixcbiAgICAgICAgICBhZGRyZXNzID0gdGhpcy5hZGRyZXNzO1xuXG5cbiAgICAgIGlmIChwYXR0ZXJuKSB7XG4gICAgICAgIHJldHVybiAnXFxuICAgICAgICAgIC8vICcgKyBhZGRyZXNzICsgJyB2YWxpZGF0ZSBwYXR0ZXJuXFxuICAgICAgICAgIGlmICghdmFsdWUubWF0Y2gobmV3IFJlZ0V4cChcXCcnICsgcGF0dGVybiArICdcXCcpKSkge1xcbiAgICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAgICBrZXl3b3JkOiBcXCdwYXR0ZXJuXFwnLFxcbiAgICAgICAgICAgICAgbWVzc2FnZTogXFwnZG9lcyBub3QgbWF0Y2ggdGhlIHJlcXVpcmVkIHBhdHRlcm5cXCdcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3RydWN0dXJhbCB2YWxpZGF0aW9uIGFsb25lIG1heSBiZSBpbnN1ZmZpY2llbnQgdG8gdmFsaWRhdGUgdGhhdFxuICAgICAqID4gYW4gaW5zdGFuY2UgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgb2YgYW4gYXBwbGljYXRpb24uIFRoZVxuICAgICAqID4gXCJmb3JtYXRcIiBrZXl3b3JkIGlzIGRlZmluZWQgdG8gYWxsb3cgaW50ZXJvcGVyYWJsZSBzZW1hbnRpY1xuICAgICAqID4gdmFsaWRhdGlvbiBmb3IgYSBmaXhlZCBzdWJzZXQgb2YgdmFsdWVzIHdoaWNoIGFyZSBhY2N1cmF0ZWx5XG4gICAgICogPiBkZXNjcmliZWQgYnkgYXV0aG9yaXRhdGl2ZSByZXNvdXJjZXMsIGJlIHRoZXkgUkZDcyBvciBvdGhlclxuICAgICAqID4gZXh0ZXJuYWwgc3BlY2lmaWNhdGlvbnMuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNy4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdmb3JtYXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmb3JtYXQoKSB7XG4gICAgICB2YXIgZm9ybWF0ID0gdGhpcy5zY2hlbWEuZm9ybWF0LFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBtYXRjaGVyID0gZm9ybWF0cy5yZXNvbHZlKGZvcm1hdCk7XG5cbiAgICAgIGlmIChtYXRjaGVyKSB7XG4gICAgICAgIHJldHVybiAnXFxuICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIGZvcm1hdFxcbiAgICAgIGlmICghdmFsdWUubWF0Y2goJyArIG1hdGNoZXIgKyAnKSkge1xcbiAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICBrZXl3b3JkOiBcXCdmb3JtYXRcXCcsXFxuICAgICAgICAgIG1lc3NhZ2U6IFxcJ2lzIG5vdCBcIicgKyBmb3JtYXQgKyAnXCIgZm9ybWF0XFwnXFxuICAgICAgICB9KVxcbiAgICAgIH1cXG4gICAgICAnO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pbmltdW1cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gU3VjY2Vzc2Z1bCB2YWxpZGF0aW9uIGRlcGVuZHMgb24gdGhlIHByZXNlbmNlIGFuZCB2YWx1ZSBvZlxuICAgICAqID4gXCJleGNsdXNpdmVNaW5pbXVtXCI6IGlmIFwiZXhjbHVzaXZlTWluaW11bVwiIGlzIG5vdCBwcmVzZW50LCBvciBoYXNcbiAgICAgKiA+IGJvb2xlYW4gdmFsdWUgZmFsc2UsIHRoZW4gdGhlIGluc3RhbmNlIGlzIHZhbGlkIGlmIGl0IGlzIGdyZWF0ZXJcbiAgICAgKiA+IHRoYW4sIG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgXCJtaW5pbXVtXCI7IGlmIFwiZXhjbHVzaXZlTWluaW11bVwiIGlzXG4gICAgICogPiBwcmVzZW50IGFuZCBoYXMgYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXNcbiAgICAgKiA+IHN0cmljdGx5IGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgXCJtaW5pbXVtXCIuXG4gICAgICogPiBKU09OIFNjaGVtYSBWYWxpZGF0aW9uIFNlY3Rpb24gNS4xLjNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ21pbmltdW0nLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtaW5pbXVtKCkge1xuICAgICAgdmFyIF9zY2hlbWEzID0gdGhpcy5zY2hlbWEsXG4gICAgICAgICAgbWluaW11bSA9IF9zY2hlbWEzLm1pbmltdW0sXG4gICAgICAgICAgZXhjbHVzaXZlTWluaW11bSA9IF9zY2hlbWEzLmV4Y2x1c2l2ZU1pbmltdW0sXG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuYWRkcmVzcztcblxuICAgICAgdmFyIG9wZXJhdG9yID0gZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSA/ICc8PScgOiAnPCc7XG5cbiAgICAgIHJldHVybiAnXFxuICAgICAgICAvLyAnICsgYWRkcmVzcyArICcgdmFsaWRhdGUgbWluaW11bVxcbiAgICAgICAgaWYgKHZhbHVlICcgKyBvcGVyYXRvciArICcgJyArIG1pbmltdW0gKyAnKSB7XFxuICAgICAgICAgIHZhbGlkID0gZmFsc2VcXG4gICAgICAgICAgZXJyb3JzLnB1c2goe1xcbiAgICAgICAgICAgIGtleXdvcmQ6IFxcJ21pbmltdW1cXCcsXFxuICAgICAgICAgICAgbWVzc2FnZTogXFwndG9vIHNtYWxsXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWF4aW11bVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogPiBTdWNjZXNzZnVsIHZhbGlkYXRpb24gZGVwZW5kcyBvbiB0aGUgcHJlc2VuY2UgYW5kIHZhbHVlIG9mXG4gICAgICogPiBcImV4Y2x1c2l2ZU1heGltdW1cIjogaWYgXCJleGNsdXNpdmVNYXhpbXVtXCIgaXMgbm90IHByZXNlbnQsIG9yIGhhc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSBmYWxzZSwgdGhlbiB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXMgbG93ZXIgdGhhbixcbiAgICAgKiA+IG9yIGVxdWFsIHRvLCB0aGUgdmFsdWUgb2YgXCJtYXhpbXVtXCI7IGlmIFwiZXhjbHVzaXZlTWF4aW11bVwiIGhhc1xuICAgICAqID4gYm9vbGVhbiB2YWx1ZSB0cnVlLCB0aGUgaW5zdGFuY2UgaXMgdmFsaWQgaWYgaXQgaXMgc3RyaWN0bHkgbG93ZXJcbiAgICAgKiA+IHRoYW4gdGhlIHZhbHVlIG9mIFwibWF4aW11bVwiLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMS4yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtYXhpbXVtJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbWF4aW11bSgpIHtcbiAgICAgIHZhciBfc2NoZW1hNCA9IHRoaXMuc2NoZW1hLFxuICAgICAgICAgIG1heGltdW0gPSBfc2NoZW1hNC5tYXhpbXVtLFxuICAgICAgICAgIGV4Y2x1c2l2ZU1heGltdW0gPSBfc2NoZW1hNC5leGNsdXNpdmVNYXhpbXVtLFxuICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmFkZHJlc3M7XG5cbiAgICAgIHZhciBvcGVyYXRvciA9IGV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUgPyAnPj0nIDogJz4nO1xuXG4gICAgICByZXR1cm4gJ1xcbiAgICAgICAgLy8gJyArIGFkZHJlc3MgKyAnIHZhbGlkYXRlIG1heGltdW1cXG4gICAgICAgIGlmICh2YWx1ZSAnICsgb3BlcmF0b3IgKyAnICcgKyBtYXhpbXVtICsgJykge1xcbiAgICAgICAgICB2YWxpZCA9IGZhbHNlXFxuICAgICAgICAgIGVycm9ycy5wdXNoKHtcXG4gICAgICAgICAgICBrZXl3b3JkOiBcXCdtYXhpbXVtXFwnLFxcbiAgICAgICAgICAgIG1lc3NhZ2U6IFxcJ3RvbyBsYXJnZVxcJ1xcbiAgICAgICAgICB9KVxcbiAgICAgICAgfVxcbiAgICAnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG11bHRpcGxlT2ZcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqID4gQSBudW1lcmljIGluc3RhbmNlIGlzIHZhbGlkIGFnYWluc3QgXCJtdWx0aXBsZU9mXCIgaWYgdGhlIHJlc3VsdCBvZlxuICAgICAqID4gdGhlIGRpdmlzaW9uIG9mIHRoZSBpbnN0YW5jZSBieSB0aGlzIGtleXdvcmQncyB2YWx1ZSBpcyBhbiBpbnRlZ2VyLlxuICAgICAqID4gSlNPTiBTY2hlbWEgVmFsaWRhdGlvbiBTZWN0aW9uIDUuMS4xXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdtdWx0aXBsZU9mJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gbXVsdGlwbGVPZigpIHtcbiAgICAgIHZhciBtdWx0aXBsZU9mID0gdGhpcy5zY2hlbWEubXVsdGlwbGVPZjtcblxuICAgICAgdmFyIGJsb2NrID0gJyc7XG5cbiAgICAgIGlmICh0eXBlb2YgbXVsdGlwbGVPZiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IG11bHRpcGxlT2YudG9TdHJpbmcoKS5sZW5ndGg7XG4gICAgICAgIHZhciBkZWNpbWFscyA9IGxlbmd0aCAtIG11bHRpcGxlT2YudG9GaXhlZCgwKS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgcG93ID0gZGVjaW1hbHMgPiAwID8gTWF0aC5wb3coMTAsIGRlY2ltYWxzKSA6IDE7XG4gICAgICAgIHZhciBjb25kaXRpb24gPSB2b2lkIDA7XG5cbiAgICAgICAgaWYgKGRlY2ltYWxzID4gMCkge1xuICAgICAgICAgIGNvbmRpdGlvbiA9ICcodmFsdWUgKiAnICsgcG93ICsgJykgJSAnICsgbXVsdGlwbGVPZiAqIHBvdyArICcgIT09IDAnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbmRpdGlvbiA9ICd2YWx1ZSAlICcgKyBtdWx0aXBsZU9mICsgJyAhPT0gMCc7XG4gICAgICAgIH1cblxuICAgICAgICBibG9jayArPSAnXFxuICAgICAgICBpZiAoJyArIGNvbmRpdGlvbiArICcpIHtcXG4gICAgICAgICAgdmFsaWQgPSBmYWxzZVxcbiAgICAgICAgICBlcnJvcnMucHVzaCh7XFxuICAgICAgICAgICAga2V5d29yZDogXFwnbXVsdGlwbGVPZlxcJyxcXG4gICAgICAgICAgICBtZXNzYWdlOiBcXCdtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJyArIG11bHRpcGxlT2YgKyAnXFwnXFxuICAgICAgICAgIH0pXFxuICAgICAgICB9XFxuICAgICAgJztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJsb2NrO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBWYWxpZGF0b3I7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFZhbGlkYXRvcjtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIEBtb2R1bGUgSlNPTiBPYmplY3QgU2lnbmluZyBhbmQgRW5jcnlwdGlvbiAoSk9TRSlcbiAqL1xudmFyIEpXQSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xudmFyIEpXSyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xudmFyIEpXS1NldCA9IF9fd2VicGFja19yZXF1aXJlX18oNjApO1xudmFyIEpXVCA9IF9fd2VicGFja19yZXF1aXJlX18oNjIpO1xudmFyIEpXUyA9IF9fd2VicGFja19yZXF1aXJlX18oNjcpO1xudmFyIEJhc2U2NFVSTFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcbnZhciBKV0tTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU4KTtcbnZhciBKV0tTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKTtcbnZhciBKV1RDbGFpbXNTZXRTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY1KTtcbnZhciBKV1RTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEpXQTogSldBLFxuICBKV0s6IEpXSyxcbiAgSldLU2V0OiBKV0tTZXQsXG4gIEpXVDogSldULFxuICBKV1M6IEpXUyxcbiAgQmFzZTY0VVJMU2NoZW1hOiBCYXNlNjRVUkxTY2hlbWEsXG4gIEpPU0VIZWFkZXJTY2hlbWE6IEpPU0VIZWFkZXJTY2hlbWEsXG4gIEpXS1NjaGVtYTogSldLU2NoZW1hLFxuICBKV0tTZXRTY2hlbWE6IEpXS1NldFNjaGVtYSxcbiAgSldUQ2xhaW1zU2V0U2NoZW1hOiBKV1RDbGFpbXNTZXRTY2hlbWEsXG4gIEpXVFNjaGVtYTogSldUU2NoZW1hXG59O1xuXG4vKioqLyB9KSxcbi8qIDM4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKlxuICogVE9ET1xuICogLSBzd2l0Y2ggYmV0d2VlbiBOb2RlLmpzIHdlYmNyeXB0byBwYWNrYWdlIGFuZCBicm93c2VyIGltcGxlbWVudGF0aW9uXG4gKi9cbnZhciBiYXNlNjR1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcbnZhciBzdXBwb3J0ZWRBbGdvcml0aG1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0Nik7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLFxuICAgIE5vdFN1cHBvcnRlZEVycm9yID0gX3JlcXVpcmUuTm90U3VwcG9ydGVkRXJyb3I7XG5cbi8qKlxuICogSldBXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOFxuICovXG5cblxudmFyIEpXQSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gSldBKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV0EpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpXQSwgbnVsbCwgW3tcbiAgICBrZXk6ICdzaWduJyxcblxuXG4gICAgLyoqXG4gICAgICogU2lnblxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogQ3JlYXRlIGEgZGlnaXRhbCBzaWduYXR1cmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYWxnXG4gICAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gZGF0YVxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihhbGcsIGtleSwgZGF0YSkge1xuICAgICAgLy8gbm9ybWFsaXplIHRoZSBhbGdvcml0aG1cbiAgICAgIHZhciBub3JtYWxpemVkQWxnb3JpdGhtID0gc3VwcG9ydGVkQWxnb3JpdGhtcy5ub3JtYWxpemUoJ3NpZ24nLCBhbGcpO1xuXG4gICAgICAvLyB2YWxpZGF0ZSBhbGdvcml0aG0gaXMgc3VwcG9ydGVkXG4gICAgICBpZiAobm9ybWFsaXplZEFsZ29yaXRobSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgTm90U3VwcG9ydGVkRXJyb3IoYWxnKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkYXRlIHR5cGUgb2Yga2V5XG4gICAgICAvLyBUT0RPXG4gICAgICAvLyAgLSBpcyB0aGUga2V5IHN1aXRhYmxlIGZvciB0aGUgYWxnb3JpdGhtP1xuICAgICAgLy8gIC0gZG9lcyB0aGF0IGdldCB2YWxpZGF0ZWQgaW4gd2ViY3J5cHRvP1xuICAgICAgLy9pZiAoa2V5IGluc3RhbmNlb2YgQ3J5cHRvS2V5KSB7XG4gICAgICAvLyAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBJbnZhbGlkS2V5RXJyb3IoKSlcbiAgICAgIC8vfVxuXG4gICAgICAvLyBzaWduIHRoZSBkYXRhXG4gICAgICByZXR1cm4gbm9ybWFsaXplZEFsZ29yaXRobS5zaWduKGtleSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkaWdpdGFsIHNpZ25hdHVyZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhbGdcbiAgICAgKiBAcGFyYW0ge0NyeXB0b0tleX0gcHJpdmF0ZUtleVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEJ1ZmZlcn0gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd8QnVmZmVyfSBkYXRhXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoYWxnLCBrZXksIHNpZ25hdHVyZSwgZGF0YSkge1xuICAgICAgdmFyIG5vcm1hbGl6ZWRBbGdvcml0aG0gPSBzdXBwb3J0ZWRBbGdvcml0aG1zLm5vcm1hbGl6ZSgndmVyaWZ5JywgYWxnKTtcblxuICAgICAgaWYgKG5vcm1hbGl6ZWRBbGdvcml0aG0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IE5vdFN1cHBvcnRlZEVycm9yKGFsZykpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyB2YWxpZGF0ZSBwdWJsaWNLZXlcblxuICAgICAgLy8gdmVyaWZ5IHRoZSBzaWduYXR1cmVcbiAgICAgIHJldHVybiBub3JtYWxpemVkQWxnb3JpdGhtLnZlcmlmeShrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5jcnlwdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRGVjcnlwdFxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogSW1wb3J0XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShrZXkpIHtcbiAgICAgIHZhciBub3JtYWxpemVkQWxnb3JpdGhtID0gc3VwcG9ydGVkQWxnb3JpdGhtcy5ub3JtYWxpemUoJ2ltcG9ydEtleScsIGtleS5hbGcpO1xuICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBbGdvcml0aG0uaW1wb3J0S2V5KGtleSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpXQTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSldBO1xuXG4vKioqLyB9KSxcbi8qIDM5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MCkuZGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBtb2R1bGUuZXhwb3J0cztcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKEJ1ZmZlcikge1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHBhZF9zdHJpbmdfMSA9IF9fd2VicGFja19yZXF1aXJlX18oNDUpO1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0LCBlbmNvZGluZykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gdm9pZCAwKSB7IGVuY29kaW5nID0gXCJ1dGY4XCI7IH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGlucHV0KSkge1xuICAgICAgICByZXR1cm4gZnJvbUJhc2U2NChpbnB1dC50b1N0cmluZyhcImJhc2U2NFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBmcm9tQmFzZTY0KEJ1ZmZlci5mcm9tKGlucHV0LCBlbmNvZGluZykudG9TdHJpbmcoXCJiYXNlNjRcIikpO1xufVxuO1xuZnVuY3Rpb24gZGVjb2RlKGJhc2U2NHVybCwgZW5jb2RpbmcpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09IHZvaWQgMCkgeyBlbmNvZGluZyA9IFwidXRmOFwiOyB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRvQmFzZTY0KGJhc2U2NHVybCksIFwiYmFzZTY0XCIpLnRvU3RyaW5nKGVuY29kaW5nKTtcbn1cbmZ1bmN0aW9uIHRvQmFzZTY0KGJhc2U2NHVybCkge1xuICAgIGJhc2U2NHVybCA9IGJhc2U2NHVybC50b1N0cmluZygpO1xuICAgIHJldHVybiBwYWRfc3RyaW5nXzEuZGVmYXVsdChiYXNlNjR1cmwpXG4gICAgICAgIC5yZXBsYWNlKC9cXC0vZywgXCIrXCIpXG4gICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbn1cbmZ1bmN0aW9uIGZyb21CYXNlNjQoYmFzZTY0KSB7XG4gICAgcmV0dXJuIGJhc2U2NFxuICAgICAgICAucmVwbGFjZSgvPS9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvXFwrL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXFwvL2csIFwiX1wiKTtcbn1cbmZ1bmN0aW9uIHRvQnVmZmVyKGJhc2U2NHVybCkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh0b0Jhc2U2NChiYXNlNjR1cmwpLCBcImJhc2U2NFwiKTtcbn1cbnZhciBiYXNlNjR1cmwgPSBlbmNvZGU7XG5iYXNlNjR1cmwuZW5jb2RlID0gZW5jb2RlO1xuYmFzZTY0dXJsLmRlY29kZSA9IGRlY29kZTtcbmJhc2U2NHVybC50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuYmFzZTY0dXJsLmZyb21CYXNlNjQgPSBmcm9tQmFzZTY0O1xuYmFzZTY0dXJsLnRvQnVmZmVyID0gdG9CdWZmZXI7XG5leHBvcnRzLmRlZmF1bHQgPSBiYXNlNjR1cmw7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDQxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cblxuXG52YXIgYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MilcbnZhciBpZWVlNzU0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0MylcbnZhciBpc0FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NClcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBEdWUgdG8gdmFyaW91cyBicm93c2VyIGJ1Z3MsIHNvbWV0aW1lcyB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uIHdpbGwgYmUgdXNlZCBldmVuXG4gKiB3aGVuIHRoZSBicm93c2VyIHN1cHBvcnRzIHR5cGVkIGFycmF5cy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqICAgLSBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsXG4gKiAgICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogICAtIENocm9tZSA5LTEwIGlzIG1pc3NpbmcgdGhlIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24uXG4gKlxuICogICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cblxuICogV2UgZGV0ZWN0IHRoZXNlIGJ1Z2d5IGJyb3dzZXJzIGFuZCBzZXQgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXlcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IGJlaGF2ZXMgY29ycmVjdGx5LlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUICE9PSB1bmRlZmluZWRcbiAgPyBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVFxuICA6IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuLypcbiAqIEV4cG9ydCBrTWF4TGVuZ3RoIGFmdGVyIHR5cGVkIGFycmF5IHN1cHBvcnQgaXMgZGV0ZXJtaW5lZC5cbiAqL1xuZXhwb3J0cy5rTWF4TGVuZ3RoID0ga01heExlbmd0aCgpXG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MiAmJiAvLyB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZFxuICAgICAgICB0eXBlb2YgYXJyLnN1YmFycmF5ID09PSAnZnVuY3Rpb24nICYmIC8vIGNocm9tZSA5LTEwIGxhY2sgYHN1YmFycmF5YFxuICAgICAgICBhcnIuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24ga01heExlbmd0aCAoKSB7XG4gIHJldHVybiBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVFxuICAgID8gMHg3ZmZmZmZmZlxuICAgIDogMHgzZmZmZmZmZlxufVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKHRoYXQsIGxlbmd0aCkge1xuICBpZiAoa01heExlbmd0aCgpIDwgbGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcbiAgfVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICBpZiAodGhhdCA9PT0gbnVsbCkge1xuICAgICAgdGhhdCA9IG5ldyBCdWZmZXIobGVuZ3RoKVxuICAgIH1cbiAgICB0aGF0Lmxlbmd0aCA9IGxlbmd0aFxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSkge1xuICAgIHJldHVybiBuZXcgQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUodGhpcywgYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKHRoaXMsIGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuLy8gVE9ETzogTGVnYWN5LCBub3QgbmVlZGVkIGFueW1vcmUuIFJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb24uXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gZnJvbSAodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHRoYXQsIHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKG51bGwsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbmlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICBCdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG4gIEJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gICAgLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgICAgdmFsdWU6IG51bGwsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAodGhhdCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2MobnVsbCwgc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlICh0aGF0LCBzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgKytpKSB7XG4gICAgICB0aGF0W2ldID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKG51bGwsIHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHRoYXQsIHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJlbmNvZGluZ1wiIG11c3QgYmUgYSB2YWxpZCBzdHJpbmcgZW5jb2RpbmcnKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSB0aGF0LndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICB0aGF0ID0gdGhhdC5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlICh0aGF0LCBhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgdGhhdFtpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyICh0aGF0LCBhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGFycmF5LmJ5dGVMZW5ndGggLy8gdGhpcyB0aHJvd3MgaWYgYGFycmF5YCBpcyBub3QgYSB2YWxpZCBBcnJheUJ1ZmZlclxuXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdvZmZzZXRcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ2xlbmd0aFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSwgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICB0aGF0ID0gYXJyYXlcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgdGhhdCA9IGZyb21BcnJheUxpa2UodGhhdCwgYXJyYXkpXG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAodGhhdCwgb2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgbGVuKVxuXG4gICAgaWYgKHRoYXQubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhhdFxuICAgIH1cblxuICAgIG9iai5jb3B5KHRoYXQsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gdGhhdFxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBpc25hbihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBrTWF4TGVuZ3RoKClgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0ga01heExlbmd0aCgpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIGtNYXhMZW5ndGgoKS50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuICEhKGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlcilcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIWlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IHN0cmluZyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAobGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoZSBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIGFuZCBgaXMtYnVmZmVyYCAoaW4gU2FmYXJpIDUtNykgdG8gZGV0ZWN0XG4vLyBCdWZmZXIgaW5zdGFuY2VzLlxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aCB8IDBcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAoaXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJlxuICAgICAgICB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKGlzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCB8IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICAvLyBsZWdhY3kgd3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0LCBsZW5ndGgpIC0gcmVtb3ZlIGluIHYwLjEzXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2kgKyAxXSAqIDI1NilcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICB2YXIgbmV3QnVmXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIHZhciBzbGljZUxlbiA9IGVuZCAtIHN0YXJ0XG4gICAgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47ICsraSkge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDIpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbmZ1bmN0aW9uIG9iamVjdFdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbikge1xuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCA0KTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSA+Pj4gKGxpdHRsZUVuZGlhbiA/IGkgOiAzIC0gaSkgKiA4KSAmIDB4ZmZcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB2YWx1ZSA9IE1hdGguZmxvb3IodmFsdWUpXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcbiAgdmFyIGlcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSBpZiAobGVuIDwgMTAwMCB8fCAhQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiB1dGY4VG9CeXRlcyhuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiBzdHJpbmd0cmltIChzdHIpIHtcbiAgaWYgKHN0ci50cmltKSByZXR1cm4gc3RyLnRyaW0oKVxuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKVxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIGlzbmFuICh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdmFsIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSkpXG5cbi8qKiovIH0pLFxuLyogNDIgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIHBhZFN0cmluZyhpbnB1dCkge1xuICAgIHZhciBzZWdtZW50TGVuZ3RoID0gNDtcbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIHZhciBkaWZmID0gc3RyaW5nTGVuZ3RoICUgc2VnbWVudExlbmd0aDtcbiAgICBpZiAoIWRpZmYpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICB2YXIgcG9zaXRpb24gPSBzdHJpbmdMZW5ndGg7XG4gICAgdmFyIHBhZExlbmd0aCA9IHNlZ21lbnRMZW5ndGggLSBkaWZmO1xuICAgIHZhciBwYWRkZWRTdHJpbmdMZW5ndGggPSBzdHJpbmdMZW5ndGggKyBwYWRMZW5ndGg7XG4gICAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhwYWRkZWRTdHJpbmdMZW5ndGgpO1xuICAgIGJ1ZmZlci53cml0ZShpbnB1dCk7XG4gICAgd2hpbGUgKHBhZExlbmd0aC0tKSB7XG4gICAgICAgIGJ1ZmZlci53cml0ZShcIj1cIiwgcG9zaXRpb24rKyk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXIudG9TdHJpbmcoKTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IHBhZFN0cmluZztcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xudmFyIE5vbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KTtcbnZhciBITUFDID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OCk7XG52YXIgUlNBU1NBX1BLQ1MxX3YxXzUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUyKTtcbnZhciBTdXBwb3J0ZWRBbGdvcml0aG1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Myk7XG5cbi8qKlxuICogUmVnaXN0ZXIgU3VwcG9ydGVkIEFsZ29yaXRobXNcbiAqL1xudmFyIHN1cHBvcnRlZEFsZ29yaXRobXMgPSBuZXcgU3VwcG9ydGVkQWxnb3JpdGhtcygpO1xuXG4vKipcbiAqIFNpZ25cbiAqL1xuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMjU2JywgJ3NpZ24nLCBuZXcgSE1BQyh7XG4gIG5hbWU6ICdITUFDJyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdIUzM4NCcsICdzaWduJywgbmV3IEhNQUMoe1xuICBuYW1lOiAnSE1BQycsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTM4NCdcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnSFM1MTInLCAnc2lnbicsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMjU2JywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0yNTYnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMzg0JywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTNTEyJywgJ3NpZ24nLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMjU2JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMzg0JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTNTEyJywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMjU2JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMzg0JywgJ3NpZ24nLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTNTEyJywgJ3NpZ24nLCB7fSlcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ25vbmUnLCAnc2lnbicsIG5ldyBOb25lKHtcbiAgLy8gbm90aGluZyBnb2VzIGhlcmVcbn0pKTtcblxuLyoqXG4gKiBWZXJpZnlcbiAqL1xuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMjU2JywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0yNTYnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTMzg0JywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0hTNTEyJywgJ3ZlcmlmeScsIG5ldyBITUFDKHtcbiAgbmFtZTogJ0hNQUMnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTMjU2JywgJ3ZlcmlmeScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTI1NidcbiAgfVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlMzODQnLCAndmVyaWZ5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMzg0J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzUxMicsICd2ZXJpZnknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS01MTInXG4gIH1cbn0pKTtcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ0VTMjU2JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnRVMzODQnLCAndmVyaWZ5Jywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdFUzUxMicsICd2ZXJpZnknLCB7fSlcbi8vc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1BTMjU2JywgJ3ZlcmlmeScsIHt9KVxuLy9zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUFMzODQnLCAndmVyaWZ5Jywge30pXG4vL3N1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdQUzUxMicsICd2ZXJpZnknLCB7fSlcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ25vbmUnLCAndmVyaWZ5JywgbmV3IE5vbmUoe1xuICAvLyBub3RoaW5nIGdvZXMgaGVyZVxufSkpO1xuXG5zdXBwb3J0ZWRBbGdvcml0aG1zLmRlZmluZSgnUlMyNTYnLCAnaW1wb3J0S2V5JywgbmV3IFJTQVNTQV9QS0NTMV92MV81KHtcbiAgbmFtZTogJ1JTQVNTQS1QS0NTMS12MV81JyxcbiAgaGFzaDoge1xuICAgIG5hbWU6ICdTSEEtMjU2J1xuICB9XG59KSk7XG5cbnN1cHBvcnRlZEFsZ29yaXRobXMuZGVmaW5lKCdSUzM4NCcsICdpbXBvcnRLZXknLCBuZXcgUlNBU1NBX1BLQ1MxX3YxXzUoe1xuICBuYW1lOiAnUlNBU1NBLVBLQ1MxLXYxXzUnLFxuICBoYXNoOiB7XG4gICAgbmFtZTogJ1NIQS0zODQnXG4gIH1cbn0pKTtcblxuc3VwcG9ydGVkQWxnb3JpdGhtcy5kZWZpbmUoJ1JTNTEyJywgJ2ltcG9ydEtleScsIG5ldyBSU0FTU0FfUEtDUzFfdjFfNSh7XG4gIG5hbWU6ICdSU0FTU0EtUEtDUzEtdjFfNScsXG4gIGhhc2g6IHtcbiAgICBuYW1lOiAnU0hBLTUxMidcbiAgfVxufSkpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRlZEFsZ29yaXRobXM7XG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBOb25lXG4gKi9cbnZhciBOb25lID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBOb25lKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb25lKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhOb25lLCBbe1xuICAgIGtleTogJ3NpZ24nLFxuXG4gICAgLyoqXG4gICAgICogc2lnblxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBzaWduKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBnZXQgY2FsbGVkLiBidXQgeW91IGxvb2tlZC5cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gTm9uZTtcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gTm9uZTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgVGV4dEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxuLyoqXG4gKiBITUFDIHdpdGggU0hBLTIgRnVuY3Rpb25zXG4gKi9cblxudmFyIEhNQUMgPSBmdW5jdGlvbiAoKSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBiaXRsZW5ndGhcbiAgICovXG4gIGZ1bmN0aW9uIEhNQUMocGFyYW1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEhNQUMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogU2lnblxuICAgKlxuICAgKiBAZGVzY3JpcHRpb25cbiAgICogR2VuZXJhdGUgYSBoYXNoLWJhc2VkIG1lc3NhZ2UgYXV0aGVudGljYXRpb24gY29kZSBmb3IgYVxuICAgKiBnaXZlbiBpbnB1dCBhbmQga2V5LiBFbmZvcmNlIHRoZSBrZXkgbGVuZ3RoIGlzIGVxdWFsIHRvXG4gICAqIG9yIGdyZWF0ZXIgdGhhbiB0aGUgYml0bGVuZ3RoLlxuICAgKlxuICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKEhNQUMsIFt7XG4gICAga2V5OiAnc2lnbicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oa2V5LCBkYXRhKSB7XG4gICAgICB2YXIgYWxnb3JpdGhtID0gdGhpcy5wYXJhbXM7XG5cbiAgICAgIC8vIFRPRE86IHZhbGlkYXRlIGtleSBsZW5ndGhcblxuICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkudGhlbihmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjR1cmwoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBWZXJpZnlcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZlcmlmeSBhIGRpZ2l0YWwgc2lnbmF0dXJlIGZvciBhIGdpdmVuIGlucHV0IGFuZCBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IFVpbnQ4QXJyYXkuZnJvbShiYXNlNjR1cmwudG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwga2V5LCBzaWduYXR1cmUsIGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2VydCBTdWZmaWNpZW50IEtleSBMZW5ndGhcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBc3NlcnQgdGhhdCB0aGUga2V5IGxlbmd0aCBpcyBzdWZmaWNpZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdhc3NlcnRTdWZmaWNpZW50S2V5TGVuZ3RoJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXNzZXJ0U3VmZmljaWVudEtleUxlbmd0aChrZXkpIHtcbiAgICAgIGlmIChrZXkubGVuZ3RoIDwgdGhpcy5iaXRsZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUga2V5IGlzIHRvbyBzaG9ydC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSE1BQztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSE1BQztcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKS5CdWZmZXIpKVxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJjcnlwdG9cIl07IH0oKSk7XG5cbi8qKiovIH0pLFxuLyogNTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5cbnZhciBUZXh0RW5jb2RlciA9IGdsb2JhbC5UZXh0RW5jb2RlciA/IGdsb2JhbC5UZXh0RW5jb2RlciAvLyBicm93c2VyXG46IF9fd2VicGFja19yZXF1aXJlX18oNTEpLlRleHRFbmNvZGVyOyAvLyBub2RlIHNoaW1cbm1vZHVsZS5leHBvcnRzID0gVGV4dEVuY29kZXI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpKVxuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbihmdW5jdGlvbigpIHsgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dbXCJUZXh0RW5jb2RlclwiXTsgfSgpKTtcblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHtcblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0OSk7XG52YXIgVGV4dEVuY29kZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKTtcblxuLyoqXG4gKiBSU0FTU0EtUEtDUzEtdjFfNVxuICovXG5cbnZhciBSU0FTU0FfUEtDUzFfdjFfNSA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogY29uc3RydWN0b3JcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJpdGxlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gUlNBU1NBX1BLQ1MxX3YxXzUocGFyYW1zKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJTQVNTQV9QS0NTMV92MV81KTtcblxuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIHNpZ25cbiAgICpcbiAgICogQGRlc2NyaXB0aW9uXG4gICAqIEdlbmVyYXRlIGEgZGlnaXRhbCBzaWduYXR1cmUgZm9yIGEgZ2l2ZW4gaW5wdXQgYW5kIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge0NyeXB0b0tleX0ga2V5XG4gICAqIEBwYXJhbSB7QnVmZmVyU291cmNlfSBkYXRhXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIF9jcmVhdGVDbGFzcyhSU0FTU0FfUEtDUzFfdjFfNSwgW3tcbiAgICBrZXk6ICdzaWduJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbihrZXksIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgLy8gVE9ET1xuICAgICAgLy9pZiAoIXRoaXMuc3VmZmljaWVudEtleVNpemUoKSkge1xuICAgICAgLy8gIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgIC8vICAgIG5ldyBFcnJvcihcbiAgICAgIC8vICAgICAgJ0Ega2V5IHNpemUgb2YgMjA0OCBiaXRzIG9yIGxhcmdlciBtdXN0IGJlIHVzZWQgd2l0aCBSU0FTU0EtUEtDUzEtdjFfNSdcbiAgICAgIC8vICAgIClcbiAgICAgIC8vICApXG4gICAgICAvL31cblxuICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuc2lnbihhbGdvcml0aG0sIGtleSwgZGF0YSkudGhlbihmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjR1cmwoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIFZlcmlmeSBhIGRpZ2l0YWwgc2lnbmF0dXJlIGZvciBhIGdpdmVuIGlucHV0IGFuZCBwcml2YXRlIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge0J1ZmZlclNvdXJjZX0gc2lnbmF0dXJlXG4gICAgICogQHBhcmFtIHtCdWZmZXJTb3VyY2V9IGRhdGFcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCBzaWduYXR1cmUsIGRhdGEpIHtcbiAgICAgIHZhciBhbGdvcml0aG0gPSB0aGlzLnBhcmFtcztcblxuICAgICAgaWYgKHR5cGVvZiBzaWduYXR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHNpZ25hdHVyZSA9IFVpbnQ4QXJyYXkuZnJvbShiYXNlNjR1cmwudG9CdWZmZXIoc2lnbmF0dXJlKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShkYXRhKTtcbiAgICAgIH1cbiAgICAgIC8vIC4uLlxuXG4gICAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS52ZXJpZnkoYWxnb3JpdGhtLCBrZXksIHNpZ25hdHVyZSwgZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogaW1wb3J0S2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pXS30ga2V5XG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2ltcG9ydEtleScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShrZXkpIHtcbiAgICAgIHZhciBqd2sgPSBPYmplY3QuYXNzaWduKHt9LCBrZXkpO1xuICAgICAgdmFyIGFsZ29yaXRobSA9IHRoaXMucGFyYW1zO1xuICAgICAgdmFyIHVzYWdlcyA9IGtleVsna2V5X29wcyddIHx8IFtdO1xuXG4gICAgICBpZiAoa2V5LnVzZSA9PT0gJ3NpZycpIHtcbiAgICAgICAgdXNhZ2VzLnB1c2goJ3ZlcmlmeScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5LnVzZSA9PT0gJ2VuYycpIHtcbiAgICAgICAgLy8gVE9ETzogaGFuZGxlIGVuY3J5cHRpb24ga2V5c1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGtleSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChrZXkua2V5X29wcykge1xuICAgICAgICB1c2FnZXMgPSBrZXkua2V5X29wcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdqd2snLCBqd2ssIGFsZ29yaXRobSwgdHJ1ZSwgdXNhZ2VzKS50aGVuKGZ1bmN0aW9uIChjcnlwdG9LZXkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGp3aywgJ2NyeXB0b0tleScsIHtcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZTogY3J5cHRvS2V5XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBqd2s7XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUlNBU1NBX1BLQ1MxX3YxXzU7XG59KCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IFJTQVNTQV9QS0NTMV92MV81O1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIE5vdFN1cHBvcnRlZEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1NCk7XG5cbi8qKlxuICogT3BlcmF0aW9uc1xuICovXG52YXIgb3BlcmF0aW9ucyA9IFsnc2lnbicsICd2ZXJpZnknLCAnZW5jcnlwdCcsICdkZWNyeXB0JywgJ2ltcG9ydEtleSddO1xuXG4vKipcbiAqIFN1cHBvcnRlZEFsZ29yaXRobXNcbiAqL1xuXG52YXIgU3VwcG9ydGVkQWxnb3JpdGhtcyA9IGZ1bmN0aW9uICgpIHtcblxuICAvKipcbiAgICogY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFN1cHBvcnRlZEFsZ29yaXRobXMoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdXBwb3J0ZWRBbGdvcml0aG1zKTtcblxuICAgIG9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHtcbiAgICAgIF90aGlzW29wXSA9IHt9O1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN1cHBvcnRlZCBPcGVyYXRpb25zXG4gICAqL1xuXG5cbiAgX2NyZWF0ZUNsYXNzKFN1cHBvcnRlZEFsZ29yaXRobXMsIFt7XG4gICAga2V5OiAnZGVmaW5lJyxcblxuXG4gICAgLyoqXG4gICAgICogZGVmaW5lXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBSZWdpc3RlciBXZWIgQ3J5cHRvIEFQSSBhbGdvcml0aG0gcGFyYW1ldGVyIGZvciBhbiBhbGdvcml0aG1cbiAgICAgKiBhbmQgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcmd1bWVudFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZpbmUoYWxnLCBvcCwgYXJndW1lbnQpIHtcbiAgICAgIHZhciByZWdpc3RlcmVkQWxnb3JpdGhtcyA9IHRoaXNbb3BdO1xuICAgICAgcmVnaXN0ZXJlZEFsZ29yaXRobXNbYWxnXSA9IGFyZ3VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5vcm1hbGl6ZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogTWFwIEpXQSBhbGcgbmFtZSB0byBXZWIgQ3J5cHRvIEFQSSBhbGdvcml0aG0gcGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWxnXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdub3JtYWxpemUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub3JtYWxpemUob3AsIGFsZykge1xuICAgICAgdmFyIHJlZ2lzdGVyZWRBbGdvcml0aG1zID0gdGhpc1tvcF07XG5cbiAgICAgIGlmICghcmVnaXN0ZXJlZEFsZ29yaXRobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcigpOyAvLyB3aGF0IGtpbmQgb2YgZXJyb3Igc2hvdWxkIHRoaXMgYmU/XG4gICAgICB9XG5cbiAgICAgIHZhciBhcmd1bWVudCA9IHJlZ2lzdGVyZWRBbGdvcml0aG1zW2FsZ107XG5cbiAgICAgIGlmICghYXJndW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb3RTdXBwb3J0ZWRFcnJvcihhbGcpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJndW1lbnQ7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6ICdvcGVyYXRpb25zJyxcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiBvcGVyYXRpb25zO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTdXBwb3J0ZWRBbGdvcml0aG1zO1xufSgpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBTdXBwb3J0ZWRBbGdvcml0aG1zO1xuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBOb3RTdXBwb3J0ZWRFcnJvclxuICovXG52YXIgTm90U3VwcG9ydGVkRXJyb3IgPSBmdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhOb3RTdXBwb3J0ZWRFcnJvciwgX0Vycm9yKTtcblxuICBmdW5jdGlvbiBOb3RTdXBwb3J0ZWRFcnJvcihhbGcpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm90U3VwcG9ydGVkRXJyb3IpO1xuXG4gICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE5vdFN1cHBvcnRlZEVycm9yLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTm90U3VwcG9ydGVkRXJyb3IpKS5jYWxsKHRoaXMpKTtcblxuICAgIF90aGlzLm1lc3NhZ2UgPSBhbGcgKyBcIiBpcyBub3QgYSBzdXBwb3J0ZWQgYWxnb3JpdGhtXCI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgcmV0dXJuIE5vdFN1cHBvcnRlZEVycm9yO1xufShFcnJvcik7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IE5vdFN1cHBvcnRlZEVycm9yO1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBEYXRhRXJyb3I6IF9fd2VicGFja19yZXF1aXJlX18oNTYpLFxuICBOb3RTdXBwb3J0ZWRFcnJvcjogX193ZWJwYWNrX3JlcXVpcmVfXyg1NClcbn07XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmOyB9XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyhzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBpZiAodHlwZW9mIHN1cGVyQ2xhc3MgIT09IFwiZnVuY3Rpb25cIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxuXG4vKipcbiAqIERhdGFFcnJvclxuICovXG52YXIgRGF0YUVycm9yID0gZnVuY3Rpb24gKF9FcnJvcikge1xuICBfaW5oZXJpdHMoRGF0YUVycm9yLCBfRXJyb3IpO1xuXG4gIGZ1bmN0aW9uIERhdGFFcnJvcihtZXNzYWdlKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERhdGFFcnJvcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKERhdGFFcnJvci5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKERhdGFFcnJvcikpLmNhbGwodGhpcywgbWVzc2FnZSkpO1xuICB9XG5cbiAgcmV0dXJuIERhdGFFcnJvcjtcbn0oRXJyb3IpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhRXJyb3I7XG5cbi8qKiovIH0pLFxuLyogNTcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqIEBpZ25vcmVcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05Eb2N1bWVudCA9IF9yZXF1aXJlLkpTT05Eb2N1bWVudDtcblxudmFyIEpXS1NjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNTgpO1xudmFyIEpXQSA9IF9fd2VicGFja19yZXF1aXJlX18oMzgpO1xuXG4vKipcbiAqIEpXSyBDbGFzc1xuICovXG5cbnZhciBKV0sgPSBmdW5jdGlvbiAoX0pTT05Eb2N1bWVudCkge1xuICBfaW5oZXJpdHMoSldLLCBfSlNPTkRvY3VtZW50KTtcblxuICBmdW5jdGlvbiBKV0soKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEpXSyk7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKEpXSy5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKEpXSykpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEpXSywgbnVsbCwgW3tcbiAgICBrZXk6ICdpbXBvcnRLZXknLFxuXG5cbiAgICAvKipcbiAgICAgKiBpbXBvcnRLZXlcbiAgICAgKlxuICAgICAqIFRPRE86XG4gICAgICogLSBzaG91bGQgdGhpcyBiZSBvbiBKV0E/XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGltcG9ydEtleShqd2spIHtcbiAgICAgIHJldHVybiBKV0EuaW1wb3J0S2V5KGp3ayk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NoZW1hJyxcblxuXG4gICAgLyoqXG4gICAgICogU2NoZW1hXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSldLU2NoZW1hO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV0s7XG59KEpTT05Eb2N1bWVudCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXSztcblxuLyoqKi8gfSksXG4vKiA1OCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICogQGlnbm9yZVxuICovXG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG52YXIgX3JlcXVpcmUyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OSksXG4gICAgQkFTRTY0X1JFR0VYUCA9IF9yZXF1aXJlMi5CQVNFNjRfUkVHRVhQO1xuXG4vKipcbiAqIEpXSyBTY2hlbWFcbiAqL1xuXG5cbnZhciBKV0tTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICBrdHk6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgLy9mb3JtYXQ6ICdjYXNlLXNlbnNpdGl2ZScsXG4gICAgICBlbnVtOiBbJ1JTQScsICdFQycsICdvY3QnXSAvLyBvdGhlciB2YWx1ZXMgTUFZIGJlIHVzZWRcbiAgICB9LFxuXG4gICAgdXNlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIC8vZm9ybWF0OiAnY2FzZS1zZW5zaXRpdmUnLFxuICAgICAgZW51bTogWydzaWcnLCAnZW5jJ10gLy8gb3RoZXIgdmFsdWVzIE1BWSBiZSB1c2VkXG4gICAgfSxcblxuICAgIGtleV9vcHM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAvL2Zvcm1hdDogJ2Nhc2Utc2Vuc2l0aXZlJyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIGVudW06IFsnc2lnbicsICd2ZXJpZnknLCAnZW5jcnlwdCcsICdkZWNyeXB0JywgJ3dyYXBLZXknLCAndW53cmFwS2V5JywgJ2Rlcml2ZUtleScsICdkZXJpdmVCaXRzJ10gLy8gb3RoZXIgdmFsdWVzIE1BWSBiZSB1c2VkXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFsZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAvL2Zvcm1hdDogJ2Nhc2Utc2Vuc2l0aXZlJyxcbiAgICAgIGVudW06IFsnSFMyNTYnLCAnSFMzODQnLCAnSFM1MTInLCAnUlMyNTYnLCAnUlMzODQnLCAnUlM1MTInLCAnRVMyNTYnLCAnRVMzODQnLCAnRVM1MTInLCAnUFMyNTYnLCAnUFMzODQnLCAnUFM1MTInLCAnbm9uZSddIC8vIG90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZFxuICAgIH0sXG5cbiAgICBraWQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIHg1dToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIC8vZm9ybWF0OiAndXJsJ1xuICAgIH0sXG5cbiAgICB4NWM6IHtcbiAgICAgIHR5cGU6ICdhcnJheSdcbiAgICAgIC8vZm9ybWF0OiBCQVNFNjRfUkVHRVhQXG4gICAgfSxcblxuICAgIHg1dDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIC8vZm9ybWF0OiBCQVNFNjRfUkVHRVhQXG4gICAgfVxuXG4gICAgLy8neDV0I1MyNTYnOiB7XG4gICAgLy8gIHR5cGU6ICdzdHJpbmcnLFxuICAgIC8vICAvL2Zvcm1hdDogQkFTRTY0X1JFR0VYUFxuICAgIC8vfVxuICB9XG59KTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBKV0tTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBQYWNrYWdlIGRlcGVuZGVuY2llc1xuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBGb3JtYXRzID0gX3JlcXVpcmUuRm9ybWF0cztcblxuLyoqXG4gKiBGb3JtYXQgZXh0ZW5zaW9uc1xuICovXG5cblxuRm9ybWF0cy5yZWdpc3RlcignU3RyaW5nT3JVUkknLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignTnVtZXJpY0RhdGUnLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignVVJJJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ3VybCcsIG5ldyBSZWdFeHAoKSk7XG5Gb3JtYXRzLnJlZ2lzdGVyKCdiYXNlNjQnLCBuZXcgUmVnRXhwKCkpO1xuRm9ybWF0cy5yZWdpc3RlcignYmFzZTY0dXJsJywgbmV3IFJlZ0V4cCgpKTtcbkZvcm1hdHMucmVnaXN0ZXIoJ01lZGlhVHlwZScsIG5ldyBSZWdFeHAoKSk7XG5cbi8qKiovIH0pLFxuLyogNjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7IH0gcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7IH1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXCIgKyB0eXBlb2Ygc3VwZXJDbGFzcyk7IH0gc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiB7IHZhbHVlOiBzdWJDbGFzcywgZW51bWVyYWJsZTogZmFsc2UsIHdyaXRhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfSB9KTsgaWYgKHN1cGVyQ2xhc3MpIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcykgOiBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05Eb2N1bWVudCA9IF9yZXF1aXJlLkpTT05Eb2N1bWVudDtcblxudmFyIEpXS1NldFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjEpO1xudmFyIEpXSyA9IF9fd2VicGFja19yZXF1aXJlX18oNTcpO1xuXG4vKipcbiAqIEpXS1NldFxuICpcbiAqIEBjbGFzc1xuICogSldLU2V0IHJlcHJlc2VudHMgYSBKU09OIFdlYiBLZXkgU2V0IGFzIGRlc2NyaWJlZCBpbiBTZWN0aW9uIDUgb2YgUkZDIDc1MTc6XG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNyNzZWN0aW9uLTVcbiAqL1xuXG52YXIgSldLU2V0ID0gZnVuY3Rpb24gKF9KU09ORG9jdW1lbnQpIHtcbiAgX2luaGVyaXRzKEpXS1NldCwgX0pTT05Eb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gSldLU2V0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV0tTZXQpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChKV0tTZXQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKV0tTZXQpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV0tTZXQsIG51bGwsIFt7XG4gICAga2V5OiAnaW1wb3J0S2V5cycsXG5cblxuICAgIC8qKlxuICAgICAqIGltcG9ydEtleXNcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gaW1wb3J0S2V5cyhqd2tzKSB7XG4gICAgICB2YXIgdmFsaWRhdGlvbiA9IHRoaXMuc2NoZW1hLnZhbGlkYXRlKGp3a3MpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignSW52YWxpZCBKV0tTZXQ6ICcgKyBKU09OLnN0cmluZ2lmeSh2YWxpZGF0aW9uLCBudWxsLCAyKSkpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWp3a3Mua2V5cykge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDYW5ub3QgaW1wb3J0IEpXS1NldDoga2V5cyBwcm9wZXJ0eSBpcyBlbXB0eScpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGltcG9ydGVkID0gdm9pZCAwLFxuICAgICAgICAgIGltcG9ydGluZyA9IHZvaWQgMDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaW1wb3J0ZWQgPSBuZXcgSldLU2V0KGp3a3MpO1xuICAgICAgICBpbXBvcnRpbmcgPSBqd2tzLmtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gSldLLmltcG9ydEtleShrZXkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGltcG9ydGluZykudGhlbihmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICBpbXBvcnRlZC5rZXlzID0ga2V5cztcbiAgICAgICAgcmV0dXJuIGltcG9ydGVkO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnc2NoZW1hJyxcblxuXG4gICAgLyoqXG4gICAgICogc2NoZW1hXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gSldLU2V0U2NoZW1hO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBKV0tTZXQ7XG59KEpTT05Eb2N1bWVudCk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEpXS1NldDtcblxuLyoqKi8gfSksXG4vKiA2MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG52YXIgSldLU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbi8qKlxuICogSldLU2V0U2NoZW1hXG4gKi9cbnZhciBKV0tTZXRTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAga2V5czoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiBKV0tTY2hlbWFcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpXS1NldFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07XG5cbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHsgaWYgKCFzZWxmKSB7IHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikgPyBjYWxsIDogc2VsZjsgfVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIGJhc2U2NHVybCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09ORG9jdW1lbnQgPSBfcmVxdWlyZS5KU09ORG9jdW1lbnQ7XG5cbnZhciBKV1RTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYzKTtcbnZhciBKV1MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KTtcbnZhciBEYXRhRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDU2KTtcblxuLyoqXG4gKiBKV1RcbiAqL1xuXG52YXIgSldUID0gZnVuY3Rpb24gKF9KU09ORG9jdW1lbnQpIHtcbiAgX2luaGVyaXRzKEpXVCwgX0pTT05Eb2N1bWVudCk7XG5cbiAgZnVuY3Rpb24gSldUKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBKV1QpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChKV1QuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZihKV1QpKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV1QsIFt7XG4gICAga2V5OiAnaXNKV0UnLFxuXG5cbiAgICAvKipcbiAgICAgKiBpc0pXRVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0pXRSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuaGVhZGVyLmVuYztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiByZXNvbHZlS2V5c1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZXNvbHZlS2V5cycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVLZXlzKGp3a3MpIHtcbiAgICAgIHZhciBraWQgPSB0aGlzLmhlYWRlci5raWQ7XG4gICAgICB2YXIga2V5cyA9IHZvaWQgMCxcbiAgICAgICAgICBtYXRjaCA9IHZvaWQgMDtcblxuICAgICAgLy8gdHJlYXQgYW4gYXJyYXkgYXMgdGhlIFwia2V5c1wiIHByb3BlcnR5IG9mIGEgSldLIFNldFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoandrcykpIHtcbiAgICAgICAga2V5cyA9IGp3a3M7XG4gICAgICB9XG5cbiAgICAgIC8vIHByZXNlbmNlIG9mIGtleXMgaW5kaWNhdGVzIG9iamVjdCBpcyBhIEpXSyBTZXRcbiAgICAgIGlmIChqd2tzLmtleXMpIHtcbiAgICAgICAga2V5cyA9IGp3a3Mua2V5cztcbiAgICAgIH1cblxuICAgICAgLy8gd3JhcCBhIHBsYWluIG9iamVjdCB0aGV5IGlzIG5vdCBhIEpXSyBTZXQgaW4gQXJyYXlcbiAgICAgIGlmICghandrcy5rZXlzICYmICh0eXBlb2YgandrcyA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoandrcykpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBrZXlzID0gW2p3a3NdO1xuICAgICAgfVxuXG4gICAgICAvLyBlbnN1cmUgdGhlcmUgYXJlIGtleXMgdG8gc2VhcmNoXG4gICAgICBpZiAoIWtleXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERhdGFFcnJvcignSW52YWxpZCBKV0sgYXJndW1lbnQnKTtcbiAgICAgIH1cblxuICAgICAgLy8gbWF0Y2ggYnkgXCJraWRcIiBvciBcInVzZVwiIGhlYWRlclxuICAgICAgaWYgKGtpZCkge1xuICAgICAgICBtYXRjaCA9IGtleXMuZmluZChmdW5jdGlvbiAoandrKSB7XG4gICAgICAgICAgcmV0dXJuIGp3ay5raWQgPT09IGtpZDtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXRjaCA9IGtleXMuZmluZChmdW5jdGlvbiAoandrKSB7XG4gICAgICAgICAgcmV0dXJuIGp3ay51c2UgPT09ICdzaWcnO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYXNzaWduIG1hdGNoaW5nIGtleSB0byBKV1QgYW5kIHJldHVybiBhIGJvb2xlYW5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB0aGlzLmtleSA9IG1hdGNoLmNyeXB0b0tleTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW5jb2RlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBFbmNvZGUgYSBKV1QgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbmNvZGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBlbmNvZGUoKSB7XG4gICAgICAvLyB2YWxpZGF0ZVxuICAgICAgdmFyIHZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKCk7XG5cbiAgICAgIGlmICghdmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QodmFsaWRhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b2tlbiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLmlzSldFKCkpIHtcbiAgICAgICAgcmV0dXJuIEpXRS5lbmNyeXB0KHRva2VuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBKV1Muc2lnbih0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBWZXJpZnkgYSBkZWNvZGVkIEpXVCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ3ZlcmlmeScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZlcmlmeSgpIHtcbiAgICAgIHZhciB2YWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZSgpO1xuXG4gICAgICBpZiAoIXZhbGlkYXRpb24udmFsaWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHZhbGlkYXRpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gSldTLnZlcmlmeSh0aGlzKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogJ2RlY29kZScsXG5cblxuICAgIC8qKlxuICAgICAqIGRlY29kZVxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICogRGVjb2RlIGEgSlNPTiBXZWIgVG9rZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhXG4gICAgICogQHJldHVybnMge0pXVH1cbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlKGRhdGEpIHtcbiAgICAgIHZhciBFeHRlbmRlZEpXVCA9IHRoaXM7XG4gICAgICB2YXIgand0ID0gdm9pZCAwO1xuXG4gICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0pXVCBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEpTT04gb2YgRmxhdHRlbmVkIEpTT04gU2VyaWFsaXphdGlvblxuICAgICAgaWYgKGRhdGEuc3RhcnRzV2l0aCgneycpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSwgZnVuY3Rpb24gKCkge30pO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0ludmFsaWQgSldUIHNlcmlhbGl6YXRpb24nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLnNpZ25hdHVyZXMgfHwgZGF0YS5yZWNpcGllbnRzKSB7XG4gICAgICAgICAgZGF0YS5zZXJpYWxpemF0aW9uID0gJ2pzb24nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuc2VyaWFsaXphdGlvbiA9ICdmbGF0dGVuZWQnO1xuICAgICAgICB9XG5cbiAgICAgICAgand0ID0gbmV3IEV4dGVuZGVkSldUKGRhdGEsIHsgZmlsdGVyOiBmYWxzZSB9KTtcblxuICAgICAgICAvLyBDb21wYWN0IFNlcmlhbGl6YXRpb25cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIHNlcmlhbGl6YXRpb24gPSAnY29tcGFjdCc7XG4gICAgICAgICAgdmFyIHNlZ21lbnRzID0gZGF0YS5zcGxpdCgnLicpO1xuICAgICAgICAgIHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgICAgICAgICBpZiAobGVuZ3RoICE9PSAzICYmIGxlbmd0aCAhPT0gNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYWxmb3JtZWQgSldUJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGhlYWRlciA9IEpTT04ucGFyc2UoYmFzZTY0dXJsLmRlY29kZShzZWdtZW50c1swXSkpO1xuXG4gICAgICAgICAgLy8gSlNPTiBXZWIgU2lnbmF0dXJlXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSAnSldTJztcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShiYXNlNjR1cmwuZGVjb2RlKHNlZ21lbnRzWzFdKSk7XG4gICAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gc2VnbWVudHNbMl07XG5cbiAgICAgICAgICAgIGp3dCA9IG5ldyBFeHRlbmRlZEpXVCh7IHR5cGU6IHR5cGUsIHNlZ21lbnRzOiBzZWdtZW50cywgaGVhZGVyOiBoZWFkZXIsIHBheWxvYWQ6IHBheWxvYWQsIHNpZ25hdHVyZTogc2lnbmF0dXJlLCBzZXJpYWxpemF0aW9uOiBzZXJpYWxpemF0aW9uIH0sIHsgZmlsdGVyOiBmYWxzZSB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBKU09OIFdlYiBFbmNyeXB0aW9uXG4gICAgICAgICAgaWYgKGxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgICAgLy9sZXQgdHlwZSA9ICdKV0UnXG4gICAgICAgICAgICAvL2xldCBbcHJvdGVjdGVkLCBlbmNyeXB0aW9uX2tleSwgaXYsIGNpcGhlcnRleHQsIHRhZ10gPSBzZWdtZW50c1xuXG4gICAgICAgICAgICAvL2p3dCA9IG5ldyBFeHRlbmRlZEpXVCh7XG4gICAgICAgICAgICAvLyAgdHlwZSxcbiAgICAgICAgICAgIC8vICBwcm90ZWN0ZWQ6IGJhc2U2NHVybC5kZWNvZGUoSlNPTi5wYXJzZShwcm90ZWN0ZWQpKSxcbiAgICAgICAgICAgIC8vICBlbmNyeXB0aW9uX2tleSxcbiAgICAgICAgICAgIC8vICBpdixcbiAgICAgICAgICAgIC8vICBjaXBoZXJ0ZXh0LFxuICAgICAgICAgICAgLy8gIHRhZyxcbiAgICAgICAgICAgIC8vICBzZXJpYWxpemF0aW9uXG4gICAgICAgICAgICAvL30pXG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHRocm93IG5ldyBEYXRhRXJyb3IoJ0ludmFsaWQgSldUIGNvbXBhY3Qgc2VyaWFsaXphdGlvbicpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBqd3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogZW5jb2RlXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKiBFbmNvZGUgYSBKU09OIFdlYiBUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtDcnlwdG9LZXl9IGtleVxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2VuY29kZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZShoZWFkZXIsIHBheWxvYWQsIGtleSkge1xuICAgICAgdmFyIGp3dCA9IG5ldyBKV1QoaGVhZGVyLCBwYXlsb2FkKTtcbiAgICAgIHJldHVybiBqd3QuZW5jb2RlKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdmVyaWZ5XG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q3J5cHRvS2V5fSBrZXlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICd2ZXJpZnknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2ZXJpZnkoa2V5LCB0b2tlbikge1xuICAgICAgdmFyIGp3dCA9IEpXVC5kZWNvZGUodG9rZW4pO1xuICAgICAgand0LmtleSA9IGtleTtcbiAgICAgIHJldHVybiBqd3QudmVyaWZ5KCkudGhlbihmdW5jdGlvbiAodmVyaWZpZWQpIHtcbiAgICAgICAgcmV0dXJuIGp3dDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ3NjaGVtYScsXG5cblxuICAgIC8qKlxuICAgICAqIHNjaGVtYVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIEpXVFNjaGVtYTtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gSldUO1xufShKU09ORG9jdW1lbnQpO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBKV1Q7XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuLyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xudmFyIEJhc2U2NFVSTFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjQpO1xudmFyIEpXVENsYWltc1NldFNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNjUpO1xudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KTtcblxudmFyIF9yZXF1aXJlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyOCksXG4gICAgSlNPTlNjaGVtYSA9IF9yZXF1aXJlLkpTT05TY2hlbWE7XG5cbi8qKlxuICogSldUU2NoZW1hXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBUaGlzIHNjaGVtYSByZXByZXNlbnRzIGFsbCB0aGUgdGhpbmdzIGEgZGVzZXJpYWxpemVkIEpXVCBjYW4gYmUsIGkuZS4sXG4gKiBlaXRoZXIgYSBKV1Mgb3IgSldFLCBhbmQgYW55IHNlcmlhbGl6YXRpb24gb2YgdGhlbS4gVmFsaWRhdGlvbiBvZiB3ZWxsLVxuICogZm9ybWVkbmVzcyBmb3IgYSBnaXZlbiBzZXJpYWxpemF0aW9uIGlzIGFjY29tcGxpc2hlZCBhdCB0aGUgdGltZSBvZlxuICogZW5jb2RpbmcuXG4gKi9cblxuXG52YXIgSldUU2NoZW1hID0gbmV3IEpTT05TY2hlbWEoe1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogdHlwZVxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydKV1MnLCAnSldFJ11cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogc2VnbWVudHNcbiAgICAgKi9cbiAgICBzZWdtZW50czoge1xuICAgICAgdHlwZTogJ2FycmF5J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBoZWFkZXJcbiAgICAgKi9cbiAgICBoZWFkZXI6IEpPU0VIZWFkZXJTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQ6IEpPU0VIZWFkZXJTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiB1bnByb3RlY3RlZFxuICAgICAqL1xuICAgIHVucHJvdGVjdGVkOiBKT1NFSGVhZGVyU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogaXZcbiAgICAgKi9cbiAgICBpdjogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogYWFkXG4gICAgICovXG4gICAgYWFkOiBCYXNlNjRVUkxTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBjaXBoZXJ0ZXh0XG4gICAgICovXG4gICAgY2lwaGVydGV4dDogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogdGFnXG4gICAgICovXG4gICAgdGFnOiBCYXNlNjRVUkxTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiByZWNpcGllbnRzXG4gICAgICovXG4gICAgcmVjaXBpZW50czoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgaGVhZGVyOiBKT1NFSGVhZGVyU2NoZW1hLFxuICAgICAgICAgIGVuY3J5cHRlZF9rZXk6IEJhc2U2NFVSTFNjaGVtYVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBheWxvYWRcbiAgICAgKi9cbiAgICBwYXlsb2FkOiBKV1RDbGFpbXNTZXRTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBzaWduYXR1cmVzXG4gICAgICovXG4gICAgc2lnbmF0dXJlczoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgcHJvdGVjdGVkOiBKT1NFSGVhZGVyU2NoZW1hLFxuICAgICAgICAgIGhlYWRlcjogSk9TRUhlYWRlclNjaGVtYSxcbiAgICAgICAgICBzaWduYXR1cmU6IEJhc2U2NFVSTFNjaGVtYSxcbiAgICAgICAgICBrZXk6IHsgdHlwZTogJ29iamVjdCcgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIHNpZ25hdHVyZTogQmFzZTY0VVJMU2NoZW1hLFxuXG4gICAgLyoqXG4gICAgICogdmVyaWZpZWRcbiAgICAgKi9cbiAgICB2ZXJpZmllZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICoga2V5XG4gICAgICovXG4gICAga2V5OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0J1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBzZXJpYWxpemF0aW9uXG4gICAgICovXG4gICAgc2VyaWFsaXphdGlvbjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NvbXBhY3QnLCAnanNvbicsICdmbGF0dGVuZWQnXSxcbiAgICAgIGRlZmF1bHQ6ICdjb21wYWN0J1xuICAgIH1cbiAgfVxufSk7XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gSldUU2NoZW1hO1xuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG4vKipcbiAqIEJhc2U2NFVSTFNjaGVtYVxuICovXG5cblxudmFyIEJhc2U2NFVSTFNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGZvcm1hdDogJ2Jhc2U2NHVybCdcbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEJhc2U2NFVSTFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgX3JlcXVpcmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KSxcbiAgICBKU09OU2NoZW1hID0gX3JlcXVpcmUuSlNPTlNjaGVtYTtcblxuLyoqXG4gKiBKV1RDbGFpbXNTZXRTY2hlbWFcbiAqXG4gKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00XG4gKlxuICogNC4gIEpXVCBDbGFpbXNcbiAqXG4gKiAgIFRoZSBKV1QgQ2xhaW1zIFNldCByZXByZXNlbnRzIGEgSlNPTiBvYmplY3Qgd2hvc2UgbWVtYmVycyBhcmUgdGhlXG4gKiAgIGNsYWltcyBjb252ZXllZCBieSB0aGUgSldULiAgVGhlIENsYWltIE5hbWVzIHdpdGhpbiBhIEpXVCBDbGFpbXMgU2V0XG4gKiAgIE1VU1QgYmUgdW5pcXVlOyBKV1QgcGFyc2VycyBNVVNUIGVpdGhlciByZWplY3QgSldUcyB3aXRoIGR1cGxpY2F0ZVxuICogICBDbGFpbSBOYW1lcyBvciB1c2UgYSBKU09OIHBhcnNlciB0aGF0IHJldHVybnMgb25seSB0aGUgbGV4aWNhbGx5IGxhc3RcbiAqICAgZHVwbGljYXRlIG1lbWJlciBuYW1lLCBhcyBzcGVjaWZpZWQgaW4gU2VjdGlvbiAxNS4xMiAoXCJUaGUgSlNPTlxuICogICBPYmplY3RcIikgb2YgRUNNQVNjcmlwdCA1LjEgW0VDTUFTY3JpcHRdLlxuICpcbiAqICAgVGhlIHNldCBvZiBjbGFpbXMgdGhhdCBhIEpXVCBtdXN0IGNvbnRhaW4gdG8gYmUgY29uc2lkZXJlZCB2YWxpZCBpc1xuICogICBjb250ZXh0IGRlcGVuZGVudCBhbmQgaXMgb3V0c2lkZSB0aGUgc2NvcGUgb2YgdGhpcyBzcGVjaWZpY2F0aW9uLlxuICogICBTcGVjaWZpYyBhcHBsaWNhdGlvbnMgb2YgSldUcyB3aWxsIHJlcXVpcmUgaW1wbGVtZW50YXRpb25zIHRvXG4gKiAgIHVuZGVyc3RhbmQgYW5kIHByb2Nlc3Mgc29tZSBjbGFpbXMgaW4gcGFydGljdWxhciB3YXlzLiAgSG93ZXZlciwgaW5cbiAqICAgdGhlIGFic2VuY2Ugb2Ygc3VjaCByZXF1aXJlbWVudHMsIGFsbCBjbGFpbXMgdGhhdCBhcmUgbm90IHVuZGVyc3Rvb2RcbiAqICAgYnkgaW1wbGVtZW50YXRpb25zIE1VU1QgYmUgaWdub3JlZC5cbiAqXG4gKiAgIFRoZXJlIGFyZSB0aHJlZSBjbGFzc2VzIG9mIEpXVCBDbGFpbSBOYW1lczogUmVnaXN0ZXJlZCBDbGFpbSBOYW1lcyxcbiAqICAgUHVibGljIENsYWltIE5hbWVzLCBhbmQgUHJpdmF0ZSBDbGFpbSBOYW1lcy5cbiAqL1xuXG5cbnZhciBKV1RDbGFpbXNTZXRTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjFcbiAgICAgKlxuICAgICAqIDQuMS4gIFJlZ2lzdGVyZWQgQ2xhaW0gTmFtZXNcbiAgICAgKlxuICAgICAqICAgVGhlIGZvbGxvd2luZyBDbGFpbSBOYW1lcyBhcmUgcmVnaXN0ZXJlZCBpbiB0aGUgSUFOQSBcIkpTT04gV2ViIFRva2VuXG4gICAgICogICBDbGFpbXNcIiByZWdpc3RyeSBlc3RhYmxpc2hlZCBieSBTZWN0aW9uIDEwLjEuICBOb25lIG9mIHRoZSBjbGFpbXNcbiAgICAgKiAgIGRlZmluZWQgYmVsb3cgYXJlIGludGVuZGVkIHRvIGJlIG1hbmRhdG9yeSB0byB1c2Ugb3IgaW1wbGVtZW50IGluIGFsbFxuICAgICAqICAgY2FzZXMsIGJ1dCByYXRoZXIgdGhleSBwcm92aWRlIGEgc3RhcnRpbmcgcG9pbnQgZm9yIGEgc2V0IG9mIHVzZWZ1bCxcbiAgICAgKiAgIGludGVyb3BlcmFibGUgY2xhaW1zLiAgQXBwbGljYXRpb25zIHVzaW5nIEpXVHMgc2hvdWxkIGRlZmluZSB3aGljaFxuICAgICAqICAgc3BlY2lmaWMgY2xhaW1zIHRoZXkgdXNlIGFuZCB3aGVuIHRoZXkgYXJlIHJlcXVpcmVkIG9yIG9wdGlvbmFsLiAgQWxsXG4gICAgICogICB0aGUgbmFtZXMgYXJlIHNob3J0IGJlY2F1c2UgYSBjb3JlIGdvYWwgb2YgSldUcyBpcyBmb3IgdGhlXG4gICAgICogICByZXByZXNlbnRhdGlvbiB0byBiZSBjb21wYWN0LlxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogaXNzXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xLjFcbiAgICAgKlxuICAgICAqIDQuMS4xLiAgXCJpc3NcIiAoSXNzdWVyKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJpc3NcIiAoaXNzdWVyKSBjbGFpbSBpZGVudGlmaWVzIHRoZSBwcmluY2lwYWwgdGhhdCBpc3N1ZWQgdGhlXG4gICAgICogICBKV1QuICBUaGUgcHJvY2Vzc2luZyBvZiB0aGlzIGNsYWltIGlzIGdlbmVyYWxseSBhcHBsaWNhdGlvbiBzcGVjaWZpYy5cbiAgICAgKiAgIFRoZSBcImlzc1wiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSVxuICAgICAqICAgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBpc3M6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHN1YlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwic3ViXCIgKFN1YmplY3QpIENsYWltXG4gICAgICpcbiAgICAgKiAgIFRoZSBcInN1YlwiIChzdWJqZWN0KSBjbGFpbSBpZGVudGlmaWVzIHRoZSBwcmluY2lwYWwgdGhhdCBpcyB0aGVcbiAgICAgKiAgIHN1YmplY3Qgb2YgdGhlIEpXVC4gIFRoZSBjbGFpbXMgaW4gYSBKV1QgYXJlIG5vcm1hbGx5IHN0YXRlbWVudHNcbiAgICAgKiAgIGFib3V0IHRoZSBzdWJqZWN0LiAgVGhlIHN1YmplY3QgdmFsdWUgTVVTVCBlaXRoZXIgYmUgc2NvcGVkIHRvIGJlXG4gICAgICogICBsb2NhbGx5IHVuaXF1ZSBpbiB0aGUgY29udGV4dCBvZiB0aGUgaXNzdWVyIG9yIGJlIGdsb2JhbGx5IHVuaXF1ZS5cbiAgICAgKiAgIFRoZSBwcm9jZXNzaW5nIG9mIHRoaXMgY2xhaW0gaXMgZ2VuZXJhbGx5IGFwcGxpY2F0aW9uIHNwZWNpZmljLiAgVGhlXG4gICAgICogICBcInN1YlwiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgc3RyaW5nIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSVxuICAgICAqICAgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBzdWI6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnU3RyaW5nT3JVUkknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGF1ZFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS4zXG4gICAgICpcbiAgICAgKiA0LjEuMy4gIFwiYXVkXCIgKEF1ZGllbmNlKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJhdWRcIiAoYXVkaWVuY2UpIGNsYWltIGlkZW50aWZpZXMgdGhlIHJlY2lwaWVudHMgdGhhdCB0aGUgSldUIGlzXG4gICAgICogICBpbnRlbmRlZCBmb3IuICBFYWNoIHByaW5jaXBhbCBpbnRlbmRlZCB0byBwcm9jZXNzIHRoZSBKV1QgTVVTVFxuICAgICAqICAgaWRlbnRpZnkgaXRzZWxmIHdpdGggYSB2YWx1ZSBpbiB0aGUgYXVkaWVuY2UgY2xhaW0uICBJZiB0aGUgcHJpbmNpcGFsXG4gICAgICogICBwcm9jZXNzaW5nIHRoZSBjbGFpbSBkb2VzIG5vdCBpZGVudGlmeSBpdHNlbGYgd2l0aCBhIHZhbHVlIGluIHRoZVxuICAgICAqICAgXCJhdWRcIiBjbGFpbSB3aGVuIHRoaXMgY2xhaW0gaXMgcHJlc2VudCwgdGhlbiB0aGUgSldUIE1VU1QgYmVcbiAgICAgKiAgIHJlamVjdGVkLiAgSW4gdGhlIGdlbmVyYWwgY2FzZSwgdGhlIFwiYXVkXCIgdmFsdWUgaXMgYW4gYXJyYXkgb2YgY2FzZS1cbiAgICAgKiAgIHNlbnNpdGl2ZSBzdHJpbmdzLCBlYWNoIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSSB2YWx1ZS4gIEluIHRoZVxuICAgICAqICAgc3BlY2lhbCBjYXNlIHdoZW4gdGhlIEpXVCBoYXMgb25lIGF1ZGllbmNlLCB0aGUgXCJhdWRcIiB2YWx1ZSBNQVkgYmUgYVxuICAgICAqICAgc2luZ2xlIGNhc2Utc2Vuc2l0aXZlIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuICBUaGVcbiAgICAgKiAgIGludGVycHJldGF0aW9uIG9mIGF1ZGllbmNlIHZhbHVlcyBpcyBnZW5lcmFsbHkgYXBwbGljYXRpb24gc3BlY2lmaWMuXG4gICAgICogICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBhdWQ6IHtcbiAgICAgIHR5cGU6IFsnYXJyYXknLCAnc3RyaW5nJ10sXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSScsXG4gICAgICBpdGVtczoge1xuICAgICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogZXhwXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE5I3NlY3Rpb24tNC4xLjRcbiAgICAgKlxuICAgICAqIDQuMS40LiAgXCJleHBcIiAoRXhwaXJhdGlvbiBUaW1lKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKSBjbGFpbSBpZGVudGlmaWVzIHRoZSBleHBpcmF0aW9uIHRpbWUgb25cbiAgICAgKiAgIG9yIGFmdGVyIHdoaWNoIHRoZSBKV1QgTVVTVCBOT1QgYmUgYWNjZXB0ZWQgZm9yIHByb2Nlc3NpbmcuICBUaGVcbiAgICAgKiAgIHByb2Nlc3Npbmcgb2YgdGhlIFwiZXhwXCIgY2xhaW0gcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlL3RpbWVcbiAgICAgKiAgIE1VU1QgYmUgYmVmb3JlIHRoZSBleHBpcmF0aW9uIGRhdGUvdGltZSBsaXN0ZWQgaW4gdGhlIFwiZXhwXCIgY2xhaW0uXG4gICAgICpcbiAgICAgKiAgIEltcGxlbWVudGVycyBNQVkgcHJvdmlkZSBmb3Igc29tZSBzbWFsbCBsZWV3YXksIHVzdWFsbHkgbm8gbW9yZSB0aGFuXG4gICAgICogICBhIGZldyBtaW51dGVzLCB0byBhY2NvdW50IGZvciBjbG9jayBza2V3LiAgSXRzIHZhbHVlIE1VU1QgYmUgYSBudW1iZXJcbiAgICAgKiAgIGNvbnRhaW5pbmcgYSBOdW1lcmljRGF0ZSB2YWx1ZS4gIFVzZSBvZiB0aGlzIGNsYWltIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICovXG4gICAgZXhwOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGZvcm1hdDogJ051bWVyaWNEYXRlJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBuYmZcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi00LjEuNVxuICAgICAqXG4gICAgICogNC4xLjUuICBcIm5iZlwiIChOb3QgQmVmb3JlKSBDbGFpbVxuICAgICAqXG4gICAgICogICBUaGUgXCJuYmZcIiAobm90IGJlZm9yZSkgY2xhaW0gaWRlbnRpZmllcyB0aGUgdGltZSBiZWZvcmUgd2hpY2ggdGhlIEpXVFxuICAgICAqICAgTVVTVCBOT1QgYmUgYWNjZXB0ZWQgZm9yIHByb2Nlc3NpbmcuICBUaGUgcHJvY2Vzc2luZyBvZiB0aGUgXCJuYmZcIlxuICAgICAqICAgY2xhaW0gcmVxdWlyZXMgdGhhdCB0aGUgY3VycmVudCBkYXRlL3RpbWUgTVVTVCBiZSBhZnRlciBvciBlcXVhbCB0b1xuICAgICAqICAgdGhlIG5vdC1iZWZvcmUgZGF0ZS90aW1lIGxpc3RlZCBpbiB0aGUgXCJuYmZcIiBjbGFpbS4gIEltcGxlbWVudGVycyBNQVlcbiAgICAgKiAgIHByb3ZpZGUgZm9yIHNvbWUgc21hbGwgbGVld2F5LCB1c3VhbGx5IG5vIG1vcmUgdGhhbiBhIGZldyBtaW51dGVzLCB0b1xuICAgICAqICAgYWNjb3VudCBmb3IgY2xvY2sgc2tldy4gIEl0cyB2YWx1ZSBNVVNUIGJlIGEgbnVtYmVyIGNvbnRhaW5pbmcgYVxuICAgICAqICAgTnVtZXJpY0RhdGUgdmFsdWUuICBVc2Ugb2YgdGhpcyBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBuYmY6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGlhdFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS42XG4gICAgICpcbiAgICAgKiA0LjEuNi4gIFwiaWF0XCIgKElzc3VlZCBBdCkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwiaWF0XCIgKGlzc3VlZCBhdCkgY2xhaW0gaWRlbnRpZmllcyB0aGUgdGltZSBhdCB3aGljaCB0aGUgSldUIHdhc1xuICAgICAqICAgaXNzdWVkLiAgVGhpcyBjbGFpbSBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFnZSBvZiB0aGUgSldULiAgSXRzXG4gICAgICogICB2YWx1ZSBNVVNUIGJlIGEgbnVtYmVyIGNvbnRhaW5pbmcgYSBOdW1lcmljRGF0ZSB2YWx1ZS4gIFVzZSBvZiB0aGlzXG4gICAgICogICBjbGFpbSBpcyBPUFRJT05BTC5cbiAgICAgKi9cbiAgICBpYXQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGp0aVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTQuMS43XG4gICAgICpcbiAgICAgKiA0LjEuNy4gIFwianRpXCIgKEpXVCBJRCkgQ2xhaW1cbiAgICAgKlxuICAgICAqICAgVGhlIFwianRpXCIgKEpXVCBJRCkgY2xhaW0gcHJvdmlkZXMgYSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIEpXVC5cbiAgICAgKiAgIFRoZSBpZGVudGlmaWVyIHZhbHVlIE1VU1QgYmUgYXNzaWduZWQgaW4gYSBtYW5uZXIgdGhhdCBlbnN1cmVzIHRoYXRcbiAgICAgKiAgIHRoZXJlIGlzIGEgbmVnbGlnaWJsZSBwcm9iYWJpbGl0eSB0aGF0IHRoZSBzYW1lIHZhbHVlIHdpbGwgYmVcbiAgICAgKiAgIGFjY2lkZW50YWxseSBhc3NpZ25lZCB0byBhIGRpZmZlcmVudCBkYXRhIG9iamVjdDsgaWYgdGhlIGFwcGxpY2F0aW9uXG4gICAgICogICB1c2VzIG11bHRpcGxlIGlzc3VlcnMsIGNvbGxpc2lvbnMgTVVTVCBiZSBwcmV2ZW50ZWQgYW1vbmcgdmFsdWVzXG4gICAgICogICBwcm9kdWNlZCBieSBkaWZmZXJlbnQgaXNzdWVycyBhcyB3ZWxsLiAgVGhlIFwianRpXCIgY2xhaW0gY2FuIGJlIHVzZWRcbiAgICAgKiAgIHRvIHByZXZlbnQgdGhlIEpXVCBmcm9tIGJlaW5nIHJlcGxheWVkLiAgVGhlIFwianRpXCIgdmFsdWUgaXMgYSBjYXNlLVxuICAgICAqICAgc2Vuc2l0aXZlIHN0cmluZy4gIFVzZSBvZiB0aGlzIGNsYWltIGlzIE9QVElPTkFMLlxuICAgICAqL1xuICAgIGp0aToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpXVENsYWltc1NldFNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgSldLU2NoZW1hID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1OCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpLFxuICAgIEpTT05TY2hlbWEgPSBfcmVxdWlyZS5KU09OU2NoZW1hO1xuXG4vKipcbiAqIEpPU0VIZWFkZXJTY2hlbWFcbiAqXG4gKiBKU09OIFdlYiBUb2tlbiAoSldUKVxuICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi01XG4gKlxuICogNS4gIEpPU0UgSGVhZGVyXG4gKlxuICogICBGb3IgYSBKV1Qgb2JqZWN0LCB0aGUgbWVtYmVycyBvZiB0aGUgSlNPTiBvYmplY3QgcmVwcmVzZW50ZWQgYnkgdGhlXG4gKiAgIEpPU0UgSGVhZGVyIGRlc2NyaWJlIHRoZSBjcnlwdG9ncmFwaGljIG9wZXJhdGlvbnMgYXBwbGllZCB0byB0aGUgSldUXG4gKiAgIGFuZCBvcHRpb25hbGx5LCBhZGRpdGlvbmFsIHByb3BlcnRpZXMgb2YgdGhlIEpXVC4gIERlcGVuZGluZyB1cG9uXG4gKiAgIHdoZXRoZXIgdGhlIEpXVCBpcyBhIEpXUyBvciBKV0UsIHRoZSBjb3JyZXNwb25kaW5nIHJ1bGVzIGZvciB0aGUgSk9TRVxuICogICBIZWFkZXIgdmFsdWVzIGFwcGx5LlxuICovXG5cblxudmFyIEpPU0VIZWFkZXJTY2hlbWEgPSBuZXcgSlNPTlNjaGVtYSh7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiB0eXBcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFRva2VuIChKV1QpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTkjc2VjdGlvbi01LjFcbiAgICAgKlxuICAgICAqIDUuMS4gIFwidHlwXCIgKFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwidHlwXCIgKHR5cGUpIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBieSBbSldTXSBhbmQgW0pXRV0gaXMgdXNlZFxuICAgICAqICAgYnkgSldUIGFwcGxpY2F0aW9ucyB0byBkZWNsYXJlIHRoZSBtZWRpYSB0eXBlIFtJQU5BLk1lZGlhVHlwZXNdIG9mXG4gICAgICogICB0aGlzIGNvbXBsZXRlIEpXVC4gIFRoaXMgaXMgaW50ZW5kZWQgZm9yIHVzZSBieSB0aGUgSldUIGFwcGxpY2F0aW9uXG4gICAgICogICB3aGVuIHZhbHVlcyB0aGF0IGFyZSBub3QgSldUcyBjb3VsZCBhbHNvIGJlIHByZXNlbnQgaW4gYW4gYXBwbGljYXRpb25cbiAgICAgKiAgIGRhdGEgc3RydWN0dXJlIHRoYXQgY2FuIGNvbnRhaW4gYSBKV1Qgb2JqZWN0OyB0aGUgYXBwbGljYXRpb24gY2FuIHVzZVxuICAgICAqICAgdGhpcyB2YWx1ZSB0byBkaXNhbWJpZ3VhdGUgYW1vbmcgdGhlIGRpZmZlcmVudCBraW5kcyBvZiBvYmplY3RzIHRoYXRcbiAgICAgKiAgIG1pZ2h0IGJlIHByZXNlbnQuICBJdCB3aWxsIHR5cGljYWxseSBub3QgYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMgd2hlblxuICAgICAqICAgaXQgaXMgYWxyZWFkeSBrbm93biB0aGF0IHRoZSBvYmplY3QgaXMgYSBKV1QuICBUaGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgaWdub3JlZCBieSBKV1QgaW1wbGVtZW50YXRpb25zOyBhbnkgcHJvY2Vzc2luZyBvZiB0aGlzIHBhcmFtZXRlciBpc1xuICAgICAqICAgcGVyZm9ybWVkIGJ5IHRoZSBKV1QgYXBwbGljYXRpb24uICBJZiBwcmVzZW50LCBpdCBpcyBSRUNPTU1FTkRFRCB0aGF0XG4gICAgICogICBpdHMgdmFsdWUgYmUgXCJKV1RcIiB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgb2JqZWN0IGlzIGEgSldULiAgV2hpbGVcbiAgICAgKiAgIG1lZGlhIHR5cGUgbmFtZXMgYXJlIG5vdCBjYXNlIHNlbnNpdGl2ZSwgaXQgaXMgUkVDT01NRU5ERUQgdGhhdCBcIkpXVFwiXG4gICAgICogICBhbHdheXMgYmUgc3BlbGxlZCB1c2luZyB1cHBlcmNhc2UgY2hhcmFjdGVycyBmb3IgY29tcGF0aWJpbGl0eSB3aXRoXG4gICAgICogICBsZWdhY3kgaW1wbGVtZW50YXRpb25zLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjlcbiAgICAgKlxuICAgICAqIDQuMS45LiAgXCJ0eXBcIiAoVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ0eXBcIiAodHlwZSkgSGVhZGVyIFBhcmFtZXRlciBpcyB1c2VkIGJ5IEpXUyBhcHBsaWNhdGlvbnMgdG9cbiAgICAgKiAgIGRlY2xhcmUgdGhlIG1lZGlhIHR5cGUgW0lBTkEuTWVkaWFUeXBlc10gb2YgdGhpcyBjb21wbGV0ZSBKV1MuICBUaGlzXG4gICAgICogICBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IHRoZSBhcHBsaWNhdGlvbiB3aGVuIG1vcmUgdGhhbiBvbmUga2luZCBvZlxuICAgICAqICAgb2JqZWN0IGNvdWxkIGJlIHByZXNlbnQgaW4gYW4gYXBwbGljYXRpb24gZGF0YSBzdHJ1Y3R1cmUgdGhhdCBjYW5cbiAgICAgKiAgIGNvbnRhaW4gYSBKV1M7IHRoZSBhcHBsaWNhdGlvbiBjYW4gdXNlIHRoaXMgdmFsdWUgdG8gZGlzYW1iaWd1YXRlXG4gICAgICogICBhbW9uZyB0aGUgZGlmZmVyZW50IGtpbmRzIG9mIG9iamVjdHMgdGhhdCBtaWdodCBiZSBwcmVzZW50LiAgSXQgd2lsbFxuICAgICAqICAgdHlwaWNhbGx5IG5vdCBiZSB1c2VkIGJ5IGFwcGxpY2F0aW9ucyB3aGVuIHRoZSBraW5kIG9mIG9iamVjdCBpc1xuICAgICAqICAgYWxyZWFkeSBrbm93bi4gIFRoaXMgcGFyYW1ldGVyIGlzIGlnbm9yZWQgYnkgSldTIGltcGxlbWVudGF0aW9uczsgYW55XG4gICAgICogICBwcm9jZXNzaW5nIG9mIHRoaXMgcGFyYW1ldGVyIGlzIHBlcmZvcm1lZCBieSB0aGUgSldTIGFwcGxpY2F0aW9uLlxuICAgICAqICAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqICAgUGVyIFJGQyAyMDQ1IFtSRkMyMDQ1XSwgYWxsIG1lZGlhIHR5cGUgdmFsdWVzLCBzdWJ0eXBlIHZhbHVlcywgYW5kXG4gICAgICogICBwYXJhbWV0ZXIgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuICBIb3dldmVyLCBwYXJhbWV0ZXIgdmFsdWVzIGFyZVxuICAgICAqICAgY2FzZSBzZW5zaXRpdmUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQgZm9yIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiAgIFRvIGtlZXAgbWVzc2FnZXMgY29tcGFjdCBpbiBjb21tb24gc2l0dWF0aW9ucywgaXQgaXMgUkVDT01NRU5ERUQgdGhhdFxuICAgICAqICAgcHJvZHVjZXJzIG9taXQgYW4gXCJhcHBsaWNhdGlvbi9cIiBwcmVmaXggb2YgYSBtZWRpYSB0eXBlIHZhbHVlIGluIGFcbiAgICAgKiAgIFwidHlwXCIgSGVhZGVyIFBhcmFtZXRlciB3aGVuIG5vIG90aGVyICcvJyBhcHBlYXJzIGluIHRoZSBtZWRpYSB0eXBlXG4gICAgICogICB2YWx1ZS4gIEEgcmVjaXBpZW50IHVzaW5nIHRoZSBtZWRpYSB0eXBlIHZhbHVlIE1VU1QgdHJlYXQgaXQgYXMgaWZcbiAgICAgKiAgIFwiYXBwbGljYXRpb24vXCIgd2VyZSBwcmVwZW5kZWQgdG8gYW55IFwidHlwXCIgdmFsdWUgbm90IGNvbnRhaW5pbmcgYVxuICAgICAqICAgJy8nLiAgRm9yIGluc3RhbmNlLCBhIFwidHlwXCIgdmFsdWUgb2YgXCJleGFtcGxlXCIgU0hPVUxEIGJlIHVzZWQgdG9cbiAgICAgKiAgIHJlcHJlc2VudCB0aGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlXCIgbWVkaWEgdHlwZSwgd2hlcmVhcyB0aGUgbWVkaWFcbiAgICAgKiAgIHR5cGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlO3BhcnQ9XCIxLzJcIlwiIGNhbm5vdCBiZSBzaG9ydGVuZWQgdG9cbiAgICAgKiAgIFwiZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIi5cbiAgICAgKlxuICAgICAqICAgVGhlIFwidHlwXCIgdmFsdWUgXCJKT1NFXCIgY2FuIGJlIHVzZWQgYnkgYXBwbGljYXRpb25zIHRvIGluZGljYXRlIHRoYXRcbiAgICAgKiAgIHRoaXMgb2JqZWN0IGlzIGEgSldTIG9yIEpXRSB1c2luZyB0aGUgSldTIENvbXBhY3QgU2VyaWFsaXphdGlvbiBvclxuICAgICAqICAgdGhlIEpXRSBDb21wYWN0IFNlcmlhbGl6YXRpb24uICBUaGUgXCJ0eXBcIiB2YWx1ZSBcIkpPU0UrSlNPTlwiIGNhbiBiZVxuICAgICAqICAgdXNlZCBieSBhcHBsaWNhdGlvbnMgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIG9iamVjdCBpcyBhIEpXUyBvciBKV0VcbiAgICAgKiAgIHVzaW5nIHRoZSBKV1MgSlNPTiBTZXJpYWxpemF0aW9uIG9yIHRoZSBKV0UgSlNPTiBTZXJpYWxpemF0aW9uLlxuICAgICAqICAgT3RoZXIgdHlwZSB2YWx1ZXMgY2FuIGFsc28gYmUgdXNlZCBieSBhcHBsaWNhdGlvbnMuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTFcbiAgICAgKlxuICAgICAqIDQuMS4xMS4gIFwidHlwXCIgKFR5cGUpIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcInR5cFwiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS45IG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIHR5cGUgaXMgdGhhdCBvZiB0aGlzIGNvbXBsZXRlIEpXRS5cbiAgICAgKi9cbiAgICB0eXA6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGN0eVxuICAgICAqXG4gICAgICogSlNPTiBXZWIgVG9rZW4gKEpXVClcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxOSNzZWN0aW9uLTUuMlxuICAgICAqXG4gICAgICogNS4yLiAgXCJjdHlcIiAoQ29udGVudCBUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImN0eVwiIChjb250ZW50IHR5cGUpIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBieSBbSldTXSBhbmQgW0pXRV1cbiAgICAgKiAgIGlzIHVzZWQgYnkgdGhpcyBzcGVjaWZpY2F0aW9uIHRvIGNvbnZleSBzdHJ1Y3R1cmFsIGluZm9ybWF0aW9uIGFib3V0XG4gICAgICogICB0aGUgSldULlxuICAgICAqXG4gICAgICogICBJbiB0aGUgbm9ybWFsIGNhc2UgaW4gd2hpY2ggbmVzdGVkIHNpZ25pbmcgb3IgZW5jcnlwdGlvbiBvcGVyYXRpb25zXG4gICAgICogICBhcmUgbm90IGVtcGxveWVkLCB0aGUgdXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBOT1RcbiAgICAgKiAgIFJFQ09NTUVOREVELiAgSW4gdGhlIGNhc2UgdGhhdCBuZXN0ZWQgc2lnbmluZyBvciBlbmNyeXB0aW9uIGlzXG4gICAgICogICBlbXBsb3llZCwgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmUgcHJlc2VudDsgaW4gdGhpcyBjYXNlLCB0aGVcbiAgICAgKiAgIHZhbHVlIE1VU1QgYmUgXCJKV1RcIiwgdG8gaW5kaWNhdGUgdGhhdCBhIE5lc3RlZCBKV1QgaXMgY2FycmllZCBpbiB0aGlzXG4gICAgICogICBKV1QuICBXaGlsZSBtZWRpYSB0eXBlIG5hbWVzIGFyZSBub3QgY2FzZSBzZW5zaXRpdmUsIGl0IGlzXG4gICAgICogICBSRUNPTU1FTkRFRCB0aGF0IFwiSldUXCIgYWx3YXlzIGJlIHNwZWxsZWQgdXNpbmcgdXBwZXJjYXNlIGNoYXJhY3RlcnNcbiAgICAgKiAgIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbGVnYWN5IGltcGxlbWVudGF0aW9ucy4gIFNlZSBBcHBlbmRpeCBBLjIgZm9yXG4gICAgICogICBhbiBleGFtcGxlIG9mIGEgTmVzdGVkIEpXVC5cbiAgICAgKlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMTBcbiAgICAgKlxuICAgICAqIDQuMS4xMC4gIFwiY3R5XCIgKENvbnRlbnQgVHlwZSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJjdHlcIiAoY29udGVudCB0eXBlKSBIZWFkZXIgUGFyYW1ldGVyIGlzIHVzZWQgYnkgSldTIGFwcGxpY2F0aW9uc1xuICAgICAqICAgdG8gZGVjbGFyZSB0aGUgbWVkaWEgdHlwZSBbSUFOQS5NZWRpYVR5cGVzXSBvZiB0aGUgc2VjdXJlZCBjb250ZW50XG4gICAgICogICAodGhlIHBheWxvYWQpLiAgVGhpcyBpcyBpbnRlbmRlZCBmb3IgdXNlIGJ5IHRoZSBhcHBsaWNhdGlvbiB3aGVuIG1vcmVcbiAgICAgKiAgIHRoYW4gb25lIGtpbmQgb2Ygb2JqZWN0IGNvdWxkIGJlIHByZXNlbnQgaW4gdGhlIEpXUyBQYXlsb2FkOyB0aGVcbiAgICAgKiAgIGFwcGxpY2F0aW9uIGNhbiB1c2UgdGhpcyB2YWx1ZSB0byBkaXNhbWJpZ3VhdGUgYW1vbmcgdGhlIGRpZmZlcmVudFxuICAgICAqICAga2luZHMgb2Ygb2JqZWN0cyB0aGF0IG1pZ2h0IGJlIHByZXNlbnQuICBJdCB3aWxsIHR5cGljYWxseSBub3QgYmVcbiAgICAgKiAgIHVzZWQgYnkgYXBwbGljYXRpb25zIHdoZW4gdGhlIGtpbmQgb2Ygb2JqZWN0IGlzIGFscmVhZHkga25vd24uICBUaGlzXG4gICAgICogICBwYXJhbWV0ZXIgaXMgaWdub3JlZCBieSBKV1MgaW1wbGVtZW50YXRpb25zOyBhbnkgcHJvY2Vzc2luZyBvZiB0aGlzXG4gICAgICogICBwYXJhbWV0ZXIgaXMgcGVyZm9ybWVkIGJ5IHRoZSBKV1MgYXBwbGljYXRpb24uICBVc2Ugb2YgdGhpcyBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqICAgUGVyIFJGQyAyMDQ1IFtSRkMyMDQ1XSwgYWxsIG1lZGlhIHR5cGUgdmFsdWVzLCBzdWJ0eXBlIHZhbHVlcywgYW5kXG4gICAgICogICBwYXJhbWV0ZXIgbmFtZXMgYXJlIGNhc2UgaW5zZW5zaXRpdmUuICBIb3dldmVyLCBwYXJhbWV0ZXIgdmFsdWVzIGFyZVxuICAgICAqICAgY2FzZSBzZW5zaXRpdmUgdW5sZXNzIG90aGVyd2lzZSBzcGVjaWZpZWQgZm9yIHRoZSBzcGVjaWZpYyBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiAgIFRvIGtlZXAgbWVzc2FnZXMgY29tcGFjdCBpbiBjb21tb24gc2l0dWF0aW9ucywgaXQgaXMgUkVDT01NRU5ERUQgdGhhdFxuICAgICAqICAgcHJvZHVjZXJzIG9taXQgYW4gXCJhcHBsaWNhdGlvbi9cIiBwcmVmaXggb2YgYSBtZWRpYSB0eXBlIHZhbHVlIGluIGFcbiAgICAgKiAgIFwiY3R5XCIgSGVhZGVyIFBhcmFtZXRlciB3aGVuIG5vIG90aGVyICcvJyBhcHBlYXJzIGluIHRoZSBtZWRpYSB0eXBlXG4gICAgICogICB2YWx1ZS4gIEEgcmVjaXBpZW50IHVzaW5nIHRoZSBtZWRpYSB0eXBlIHZhbHVlIE1VU1QgdHJlYXQgaXQgYXMgaWZcbiAgICAgKiAgIFwiYXBwbGljYXRpb24vXCIgd2VyZSBwcmVwZW5kZWQgdG8gYW55IFwiY3R5XCIgdmFsdWUgbm90IGNvbnRhaW5pbmcgYVxuICAgICAqICAgJy8nLiAgRm9yIGluc3RhbmNlLCBhIFwiY3R5XCIgdmFsdWUgb2YgXCJleGFtcGxlXCIgU0hPVUxEIGJlIHVzZWQgdG9cbiAgICAgKiAgIHJlcHJlc2VudCB0aGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlXCIgbWVkaWEgdHlwZSwgd2hlcmVhcyB0aGUgbWVkaWFcbiAgICAgKiAgIHR5cGUgXCJhcHBsaWNhdGlvbi9leGFtcGxlO3BhcnQ9XCIxLzJcIlwiIGNhbm5vdCBiZSBzaG9ydGVuZWQgdG9cbiAgICAgKiAgIFwiZXhhbXBsZTtwYXJ0PVwiMS8yXCJcIi5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4xMlxuICAgICAqXG4gICAgICogNC4xLjEyLiAgXCJjdHlcIiAoQ29udGVudCBUeXBlKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJjdHlcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuMTAgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUgdHlwZSBpcyB0aGF0IG9mIHRoZSBzZWN1cmVkIGNvbnRlbnQgKHRoZSBwbGFpbnRleHQpLlxuICAgICAqL1xuICAgIGN0eToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ0pXVCddXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIGFsZ1xuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMVxuICAgICAqXG4gICAgICogNC4xLjEuICBcImFsZ1wiIChBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiYWxnXCIgKGFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlciBpZGVudGlmaWVzIHRoZSBjcnlwdG9ncmFwaGljXG4gICAgICogICBhbGdvcml0aG0gdXNlZCB0byBzZWN1cmUgdGhlIEpXUy4gIFRoZSBKV1MgU2lnbmF0dXJlIHZhbHVlIGlzIG5vdFxuICAgICAqICAgdmFsaWQgaWYgdGhlIFwiYWxnXCIgdmFsdWUgZG9lcyBub3QgcmVwcmVzZW50IGEgc3VwcG9ydGVkIGFsZ29yaXRobSBvclxuICAgICAqICAgaWYgdGhlcmUgaXMgbm90IGEga2V5IGZvciB1c2Ugd2l0aCB0aGF0IGFsZ29yaXRobSBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICBwYXJ0eSB0aGF0IGRpZ2l0YWxseSBzaWduZWQgb3IgTUFDZWQgdGhlIGNvbnRlbnQuICBcImFsZ1wiIHZhbHVlc1xuICAgICAqICAgc2hvdWxkIGVpdGhlciBiZSByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZFxuICAgICAqICAgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWQgYnkgW0pXQV0gb3IgYmUgYSB2YWx1ZVxuICAgICAqICAgdGhhdCBjb250YWlucyBhIENvbGxpc2lvbi1SZXNpc3RhbnQgTmFtZS4gIFRoZSBcImFsZ1wiIHZhbHVlIGlzIGEgY2FzZS1cbiAgICAgKiAgIHNlbnNpdGl2ZSBBU0NJSSBzdHJpbmcgY29udGFpbmluZyBhIFN0cmluZ09yVVJJIHZhbHVlLiAgVGhpcyBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBNVVNUIGJlIHByZXNlbnQgYW5kIE1VU1QgYmUgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkIGJ5XG4gICAgICogICBpbXBsZW1lbnRhdGlvbnMuXG4gICAgICpcbiAgICAgKiAgIEEgbGlzdCBvZiBkZWZpbmVkIFwiYWxnXCIgdmFsdWVzIGZvciB0aGlzIHVzZSBjYW4gYmUgZm91bmQgaW4gdGhlIElBTkFcbiAgICAgKiAgIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZCBFbmNyeXB0aW9uIEFsZ29yaXRobXNcIiByZWdpc3RyeSBlc3RhYmxpc2hlZFxuICAgICAqICAgYnkgW0pXQV07IHRoZSBpbml0aWFsIGNvbnRlbnRzIG9mIHRoaXMgcmVnaXN0cnkgYXJlIHRoZSB2YWx1ZXNcbiAgICAgKiAgIGRlZmluZWQgaW4gU2VjdGlvbiAzLjEgb2YgW0pXQV0uXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMVxuICAgICAqXG4gICAgICogNC4xLjEuICBcImFsZ1wiIChBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcImFsZ1wiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS4xIG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIEhlYWRlciBQYXJhbWV0ZXIgaWRlbnRpZmllcyB0aGUgY3J5cHRvZ3JhcGhpYyBhbGdvcml0aG0gdXNlZFxuICAgICAqICAgdG8gZW5jcnlwdCBvciBkZXRlcm1pbmUgdGhlIHZhbHVlIG9mIHRoZSBDRUsuICBUaGUgZW5jcnlwdGVkIGNvbnRlbnRcbiAgICAgKiAgIGlzIG5vdCB1c2FibGUgaWYgdGhlIFwiYWxnXCIgdmFsdWUgZG9lcyBub3QgcmVwcmVzZW50IGEgc3VwcG9ydGVkXG4gICAgICogICBhbGdvcml0aG0sIG9yIGlmIHRoZSByZWNpcGllbnQgZG9lcyBub3QgaGF2ZSBhIGtleSB0aGF0IGNhbiBiZSB1c2VkXG4gICAgICogICB3aXRoIHRoYXQgYWxnb3JpdGhtLlxuICAgICAqXG4gICAgICogICBBIGxpc3Qgb2YgZGVmaW5lZCBcImFsZ1wiIHZhbHVlcyBmb3IgdGhpcyB1c2UgY2FuIGJlIGZvdW5kIGluIHRoZSBJQU5BXG4gICAgICogICBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWRcbiAgICAgKiAgIGJ5IFtKV0FdOyB0aGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0aGUgdmFsdWVzXG4gICAgICogICBkZWZpbmVkIGluIFNlY3Rpb24gNC4xIG9mIFtKV0FdLlxuICAgICAqL1xuICAgIGFsZzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogamt1XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwiamt1XCIgKEpXSyBTZXQgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIChKV1MpXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImprdVwiIChKV0sgU2V0IFVSTCkgSGVhZGVyIFBhcmFtZXRlciBpcyBhIFVSSSBbUkZDMzk4Nl0gdGhhdFxuICAgICAqICAgcmVmZXJzIHRvIGEgcmVzb3VyY2UgZm9yIGEgc2V0IG9mIEpTT04tZW5jb2RlZCBwdWJsaWMga2V5cywgb25lIG9mXG4gICAgICogICB3aGljaCBjb3JyZXNwb25kcyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIFRoZVxuICAgICAqICAga2V5cyBNVVNUIGJlIGVuY29kZWQgYXMgYSBKV0sgU2V0IFtKV0tdLiAgVGhlIHByb3RvY29sIHVzZWQgdG9cbiAgICAgKiAgIGFjcXVpcmUgdGhlIHJlc291cmNlIE1VU1QgcHJvdmlkZSBpbnRlZ3JpdHkgcHJvdGVjdGlvbjsgYW4gSFRUUCBHRVRcbiAgICAgKiAgIHJlcXVlc3QgdG8gcmV0cmlldmUgdGhlIEpXSyBTZXQgTVVTVCB1c2UgVHJhbnNwb3J0IExheWVyIFNlY3VyaXR5XG4gICAgICogICAoVExTKSBbUkZDMjgxOF0gW1JGQzUyNDZdOyBhbmQgdGhlIGlkZW50aXR5IG9mIHRoZSBzZXJ2ZXIgTVVTVCBiZVxuICAgICAqICAgdmFsaWRhdGVkLCBhcyBwZXIgU2VjdGlvbiA2IG9mIFJGQyA2MTI1IFtSRkM2MTI1XS4gIEFsc28sIHNlZVxuICAgICAqICAgU2VjdGlvbiA4IG9uIFRMUyByZXF1aXJlbWVudHMuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzXG4gICAgICogICBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS40XG4gICAgICpcbiAgICAgKiA0LjEuNC4gIFwiamt1XCIgKEpXSyBTZXQgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIChKV0UpXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJqa3VcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuMiBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBKV0sgU2V0IHJlc291cmNlIGNvbnRhaW5zIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0VcbiAgICAgKiAgIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWRcbiAgICAgKiAgIHRvIGRlY3J5cHQgdGhlIEpXRS5cbiAgICAgKi9cbiAgICBqa3U6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnVVJJJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBqd2tcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjNcbiAgICAgKlxuICAgICAqIDQuMS4zLiAgXCJqd2tcIiAoSlNPTiBXZWIgS2V5KSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImp3a1wiIChKU09OIFdlYiBLZXkpIEhlYWRlciBQYXJhbWV0ZXIgaXMgdGhlIHB1YmxpYyBrZXkgdGhhdFxuICAgICAqICAgY29ycmVzcG9uZHMgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZSBKV1MuICBUaGlzIGtleSBpc1xuICAgICAqICAgcmVwcmVzZW50ZWQgYXMgYSBKU09OIFdlYiBLZXkgW0pXS10uICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzXG4gICAgICogICBPUFRJT05BTC5cbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS41XG4gICAgICpcbiAgICAgKiA0LjEuNS4gIFwiandrXCIgKEpTT04gV2ViIEtleSkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwiandrXCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjMgb2YgW0pXU10sIGV4Y2VwdFxuICAgICAqICAgdGhhdCB0aGUga2V5IGlzIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0Ugd2FzIGVuY3J5cHRlZDsgdGhpc1xuICAgICAqICAgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWQgdG8gZGVjcnlwdCB0aGUgSldFLlxuICAgICAqL1xuICAgIC8vandrOiBKV0tTY2hlbWEsXG5cbiAgICAvKipcbiAgICAgKiBraWRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjRcbiAgICAgKlxuICAgICAqIDQuMS40LiAgXCJraWRcIiAoS2V5IElEKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImtpZFwiIChrZXkgSUQpIEhlYWRlciBQYXJhbWV0ZXIgaXMgYSBoaW50IGluZGljYXRpbmcgd2hpY2gga2V5XG4gICAgICogICB3YXMgdXNlZCB0byBzZWN1cmUgdGhlIEpXUy4gIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBvcmlnaW5hdG9ycyB0b1xuICAgICAqICAgZXhwbGljaXRseSBzaWduYWwgYSBjaGFuZ2Ugb2Yga2V5IHRvIHJlY2lwaWVudHMuICBUaGUgc3RydWN0dXJlIG9mXG4gICAgICogICB0aGUgXCJraWRcIiB2YWx1ZSBpcyB1bnNwZWNpZmllZC4gIEl0cyB2YWx1ZSBNVVNUIGJlIGEgY2FzZS1zZW5zaXRpdmVcbiAgICAgKiAgIHN0cmluZy4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiAgIFdoZW4gdXNlZCB3aXRoIGEgSldLLCB0aGUgXCJraWRcIiB2YWx1ZSBpcyB1c2VkIHRvIG1hdGNoIGEgSldLIFwia2lkXCJcbiAgICAgKiAgIHBhcmFtZXRlciB2YWx1ZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjZcbiAgICAgKlxuICAgICAqIDQuMS42LiAgXCJraWRcIiAoS2V5IElEKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJraWRcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNCBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBrZXkgaGludCByZWZlcmVuY2VzIHRoZSBwdWJsaWMga2V5IHRvIHdoaWNoIHRoZSBKV0Ugd2FzXG4gICAgICogICBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZSBwcml2YXRlIGtleSBuZWVkZWQgdG9cbiAgICAgKiAgIGRlY3J5cHQgdGhlIEpXRS4gIFRoaXMgcGFyYW1ldGVyIGFsbG93cyBvcmlnaW5hdG9ycyB0byBleHBsaWNpdGx5XG4gICAgICogICBzaWduYWwgYSBjaGFuZ2Ugb2Yga2V5IHRvIEpXRSByZWNpcGllbnRzLlxuICAgICAqL1xuICAgIGtpZDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDV1XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS41XG4gICAgICpcbiAgICAgKiA0LjEuNS4gIFwieDV1XCIgKFguNTA5IFVSTCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ4NXVcIiAoWC41MDkgVVJMKSBIZWFkZXIgUGFyYW1ldGVyIGlzIGEgVVJJIFtSRkMzOTg2XSB0aGF0IHJlZmVyc1xuICAgICAqICAgdG8gYSByZXNvdXJjZSBmb3IgdGhlIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGVcbiAgICAgKiAgIGNoYWluIFtSRkM1MjgwXSBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGVcbiAgICAgKiAgIEpXUy4gIFRoZSBpZGVudGlmaWVkIHJlc291cmNlIE1VU1QgcHJvdmlkZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZVxuICAgICAqICAgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gdGhhdCBjb25mb3JtcyB0byBSRkMgNTI4MCBbUkZDNTI4MF1cbiAgICAgKiAgIGluIFBFTS1lbmNvZGVkIGZvcm0sIHdpdGggZWFjaCBjZXJ0aWZpY2F0ZSBkZWxpbWl0ZWQgYXMgc3BlY2lmaWVkIGluXG4gICAgICogICBTZWN0aW9uIDYuMSBvZiBSRkMgNDk0NSBbUkZDNDk0NV0uICBUaGUgY2VydGlmaWNhdGUgY29udGFpbmluZyB0aGVcbiAgICAgKiAgIHB1YmxpYyBrZXkgY29ycmVzcG9uZGluZyB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXU1xuICAgICAqICAgTVVTVCBiZSB0aGUgZmlyc3QgY2VydGlmaWNhdGUuICBUaGlzIE1BWSBiZSBmb2xsb3dlZCBieSBhZGRpdGlvbmFsXG4gICAgICogICBjZXJ0aWZpY2F0ZXMsIHdpdGggZWFjaCBzdWJzZXF1ZW50IGNlcnRpZmljYXRlIGJlaW5nIHRoZSBvbmUgdXNlZCB0b1xuICAgICAqICAgY2VydGlmeSB0aGUgcHJldmlvdXMgb25lLiAgVGhlIHByb3RvY29sIHVzZWQgdG8gYWNxdWlyZSB0aGUgcmVzb3VyY2VcbiAgICAgKiAgIE1VU1QgcHJvdmlkZSBpbnRlZ3JpdHkgcHJvdGVjdGlvbjsgYW4gSFRUUCBHRVQgcmVxdWVzdCB0byByZXRyaWV2ZVxuICAgICAqICAgdGhlIGNlcnRpZmljYXRlIE1VU1QgdXNlIFRMUyBbUkZDMjgxOF0gW1JGQzUyNDZdOyBhbmQgdGhlIGlkZW50aXR5IG9mXG4gICAgICogICB0aGUgc2VydmVyIE1VU1QgYmUgdmFsaWRhdGVkLCBhcyBwZXIgU2VjdGlvbiA2IG9mIFJGQyA2MTI1IFtSRkM2MTI1XS5cbiAgICAgKiAgIEFsc28sIHNlZSBTZWN0aW9uIDggb24gVExTIHJlcXVpcmVtZW50cy4gIFVzZSBvZiB0aGlzIEhlYWRlclxuICAgICAqICAgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjdcbiAgICAgKlxuICAgICAqIDQuMS43LiAgXCJ4NXVcIiAoWC41MDkgVVJMKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ4NXVcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNSBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBYLjUwOSBwdWJsaWMga2V5IGNlcnRpZmljYXRlIG9yIGNlcnRpZmljYXRlIGNoYWluIFtSRkM1MjgwXVxuICAgICAqICAgY29udGFpbnMgdGhlIHB1YmxpYyBrZXkgdG8gd2hpY2ggdGhlIEpXRSB3YXMgZW5jcnlwdGVkOyB0aGlzIGNhbiBiZVxuICAgICAqICAgdXNlZCB0byBkZXRlcm1pbmUgdGhlIHByaXZhdGUga2V5IG5lZWRlZCB0byBkZWNyeXB0IHRoZSBKV0UuXG4gICAgICovXG4gICAgeDV1OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGZvcm1hdDogJ1VSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogeDVjXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBTaWduYXR1cmUgKEpXUylcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNSNzZWN0aW9uLTQuMS42XG4gICAgICpcbiAgICAgKiA0LjEuNi4gIFwieDVjXCIgKFguNTA5IENlcnRpZmljYXRlIENoYWluKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcIng1Y1wiIChYLjUwOSBjZXJ0aWZpY2F0ZSBjaGFpbikgSGVhZGVyIFBhcmFtZXRlciBjb250YWlucyB0aGVcbiAgICAgKiAgIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gW1JGQzUyODBdXG4gICAgICogICBjb3JyZXNwb25kaW5nIHRvIHRoZSBrZXkgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGUgSldTLiAgVGhlXG4gICAgICogICBjZXJ0aWZpY2F0ZSBvciBjZXJ0aWZpY2F0ZSBjaGFpbiBpcyByZXByZXNlbnRlZCBhcyBhIEpTT04gYXJyYXkgb2ZcbiAgICAgKiAgIGNlcnRpZmljYXRlIHZhbHVlIHN0cmluZ3MuICBFYWNoIHN0cmluZyBpbiB0aGUgYXJyYXkgaXMgYVxuICAgICAqICAgYmFzZTY0LWVuY29kZWQgKFNlY3Rpb24gNCBvZiBbUkZDNDY0OF0gLS0gbm90IGJhc2U2NHVybC1lbmNvZGVkKSBERVJcbiAgICAgKiAgIFtJVFUuWDY5MC4yMDA4XSBQS0lYIGNlcnRpZmljYXRlIHZhbHVlLiAgVGhlIGNlcnRpZmljYXRlIGNvbnRhaW5pbmdcbiAgICAgKiAgIHRoZSBwdWJsaWMga2V5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleSB1c2VkIHRvIGRpZ2l0YWxseSBzaWduIHRoZVxuICAgICAqICAgSldTIE1VU1QgYmUgdGhlIGZpcnN0IGNlcnRpZmljYXRlLiAgVGhpcyBNQVkgYmUgZm9sbG93ZWQgYnlcbiAgICAgKiAgIGFkZGl0aW9uYWwgY2VydGlmaWNhdGVzLCB3aXRoIGVhY2ggc3Vic2VxdWVudCBjZXJ0aWZpY2F0ZSBiZWluZyB0aGVcbiAgICAgKiAgIG9uZSB1c2VkIHRvIGNlcnRpZnkgdGhlIHByZXZpb3VzIG9uZS4gIFRoZSByZWNpcGllbnQgTVVTVCB2YWxpZGF0ZVxuICAgICAqICAgdGhlIGNlcnRpZmljYXRlIGNoYWluIGFjY29yZGluZyB0byBSRkMgNTI4MCBbUkZDNTI4MF0gYW5kIGNvbnNpZGVyXG4gICAgICogICB0aGUgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gdG8gYmUgaW52YWxpZCBpZiBhbnkgdmFsaWRhdGlvblxuICAgICAqICAgZmFpbHVyZSBvY2N1cnMuICBVc2Ugb2YgdGhpcyBIZWFkZXIgUGFyYW1ldGVyIGlzIE9QVElPTkFMLlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgRW5jcnlwdGlvbiAoSldFKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE2I3NlY3Rpb24tNC4xLjhcbiAgICAgKlxuICAgICAqIDQuMS44LiAgXCJ4NWNcIiAoWC41MDkgQ2VydGlmaWNhdGUgQ2hhaW4pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhpcyBwYXJhbWV0ZXIgaGFzIHRoZSBzYW1lIG1lYW5pbmcsIHN5bnRheCwgYW5kIHByb2Nlc3NpbmcgcnVsZXMgYXNcbiAgICAgKiAgIHRoZSBcIng1Y1wiIEhlYWRlciBQYXJhbWV0ZXIgZGVmaW5lZCBpbiBTZWN0aW9uIDQuMS42IG9mIFtKV1NdLCBleGNlcHRcbiAgICAgKiAgIHRoYXQgdGhlIFguNTA5IHB1YmxpYyBrZXkgY2VydGlmaWNhdGUgb3IgY2VydGlmaWNhdGUgY2hhaW4gW1JGQzUyODBdXG4gICAgICogICBjb250YWlucyB0aGUgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlXG4gICAgICogICB1c2VkIHRvIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS5cbiAgICAgKi9cbiAgICB4NWM6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZm9ybWF0OiAnYmFzZTY0J1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB4NXRcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIFNpZ25hdHVyZSAoSldTKVxuICAgICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NTE1I3NlY3Rpb24tNC4xLjdcbiAgICAgKlxuICAgICAqIDQuMS43LiAgXCJ4NXRcIiAoWC41MDkgQ2VydGlmaWNhdGUgU0hBLTEgVGh1bWJwcmludCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJ4NXRcIiAoWC41MDkgY2VydGlmaWNhdGUgU0hBLTEgdGh1bWJwcmludCkgSGVhZGVyIFBhcmFtZXRlciBpcyBhXG4gICAgICogICBiYXNlNjR1cmwtZW5jb2RlZCBTSEEtMSB0aHVtYnByaW50IChhLmsuYS4gZGlnZXN0KSBvZiB0aGUgREVSXG4gICAgICogICBlbmNvZGluZyBvZiB0aGUgWC41MDkgY2VydGlmaWNhdGUgW1JGQzUyODBdIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGtleVxuICAgICAqICAgdXNlZCB0byBkaWdpdGFsbHkgc2lnbiB0aGUgSldTLiAgTm90ZSB0aGF0IGNlcnRpZmljYXRlIHRodW1icHJpbnRzXG4gICAgICogICBhcmUgYWxzbyBzb21ldGltZXMga25vd24gYXMgY2VydGlmaWNhdGUgZmluZ2VycHJpbnRzLiAgVXNlIG9mIHRoaXNcbiAgICAgKiAgIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuOVxuICAgICAqXG4gICAgICogNC4xLjkuICBcIng1dFwiIChYLjUwOSBDZXJ0aWZpY2F0ZSBTSEEtMSBUaHVtYnByaW50KSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJ4NXRcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuNyBvZiBbSldTXSwgZXhjZXB0XG4gICAgICogICB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSByZWZlcmVuY2VkIGJ5IHRoZSB0aHVtYnByaW50IGNvbnRhaW5zIHRoZSBwdWJsaWNcbiAgICAgKiAgIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIHRoZVxuICAgICAqICAgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS4gIE5vdGUgdGhhdCBjZXJ0aWZpY2F0ZVxuICAgICAqICAgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlIGZpbmdlcnByaW50cy5cbiAgICAgKi9cbiAgICB4NXQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZm9ybWF0OiAnYmFzZTY0dXJsJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiB4NXQjUzI1NlxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuOFxuICAgICAqXG4gICAgICogNC4xLjguICBcIng1dCNTMjU2XCIgKFguNTA5IENlcnRpZmljYXRlIFNIQS0yNTYgVGh1bWJwcmludCkgSGVhZGVyXG4gICAgICogICAgICAgICBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwieDV0I1MyNTZcIiAoWC41MDkgY2VydGlmaWNhdGUgU0hBLTI1NiB0aHVtYnByaW50KSBIZWFkZXJcbiAgICAgKiAgIFBhcmFtZXRlciBpcyBhIGJhc2U2NHVybC1lbmNvZGVkIFNIQS0yNTYgdGh1bWJwcmludCAoYS5rLmEuIGRpZ2VzdClcbiAgICAgKiAgIG9mIHRoZSBERVIgZW5jb2Rpbmcgb2YgdGhlIFguNTA5IGNlcnRpZmljYXRlIFtSRkM1MjgwXSBjb3JyZXNwb25kaW5nXG4gICAgICogICB0byB0aGUga2V5IHVzZWQgdG8gZGlnaXRhbGx5IHNpZ24gdGhlIEpXUy4gIE5vdGUgdGhhdCBjZXJ0aWZpY2F0ZVxuICAgICAqICAgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlIGZpbmdlcnByaW50cy5cbiAgICAgKiAgIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4xMFxuICAgICAqXG4gICAgICogNC4xLjEwLiAgXCJ4NXQjUzI1NlwiIChYLjUwOSBDZXJ0aWZpY2F0ZSBTSEEtMjU2IFRodW1icHJpbnQpIEhlYWRlclxuICAgICAqICAgICAgICAgIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGlzIHBhcmFtZXRlciBoYXMgdGhlIHNhbWUgbWVhbmluZywgc3ludGF4LCBhbmQgcHJvY2Vzc2luZyBydWxlcyBhc1xuICAgICAqICAgdGhlIFwieDV0I1MyNTZcIiBIZWFkZXIgUGFyYW1ldGVyIGRlZmluZWQgaW4gU2VjdGlvbiA0LjEuOCBvZiBbSldTXSxcbiAgICAgKiAgIGV4Y2VwdCB0aGF0IHRoZSBjZXJ0aWZpY2F0ZSByZWZlcmVuY2VkIGJ5IHRoZSB0aHVtYnByaW50IGNvbnRhaW5zIHRoZVxuICAgICAqICAgcHVibGljIGtleSB0byB3aGljaCB0aGUgSldFIHdhcyBlbmNyeXB0ZWQ7IHRoaXMgY2FuIGJlIHVzZWQgdG9cbiAgICAgKiAgIGRldGVybWluZSB0aGUgcHJpdmF0ZSBrZXkgbmVlZGVkIHRvIGRlY3J5cHQgdGhlIEpXRS4gIE5vdGUgdGhhdFxuICAgICAqICAgY2VydGlmaWNhdGUgdGh1bWJwcmludHMgYXJlIGFsc28gc29tZXRpbWVzIGtub3duIGFzIGNlcnRpZmljYXRlXG4gICAgICogICBmaW5nZXJwcmludHMuXG4gICAgICovXG4gICAgLy8neDV0I1MyNTYnOiB7XG4gICAgLy8gIHR5cGU6ICdzdHJpbmcnLFxuICAgIC8vICBmb3JtYXQ6ICdiYXNlNjR1cmwnXG4gICAgLy99LFxuXG4gICAgLyoqXG4gICAgICogY3JpdFxuICAgICAqXG4gICAgICogSlNPTiBXZWIgU2lnbmF0dXJlIChKV1MpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTUjc2VjdGlvbi00LjEuMTFcbiAgICAgKlxuICAgICAqIDQuMS4xMS4gIFwiY3JpdFwiIChDcml0aWNhbCkgSGVhZGVyIFBhcmFtZXRlclxuICAgICAqXG4gICAgICogICBUaGUgXCJjcml0XCIgKGNyaXRpY2FsKSBIZWFkZXIgUGFyYW1ldGVyIGluZGljYXRlcyB0aGF0IGV4dGVuc2lvbnMgdG9cbiAgICAgKiAgIHRoaXMgc3BlY2lmaWNhdGlvbiBhbmQvb3IgW0pXQV0gYXJlIGJlaW5nIHVzZWQgdGhhdCBNVVNUIGJlXG4gICAgICogICB1bmRlcnN0b29kIGFuZCBwcm9jZXNzZWQuICBJdHMgdmFsdWUgaXMgYW4gYXJyYXkgbGlzdGluZyB0aGUgSGVhZGVyXG4gICAgICogICBQYXJhbWV0ZXIgbmFtZXMgcHJlc2VudCBpbiB0aGUgSk9TRSBIZWFkZXIgdGhhdCB1c2UgdGhvc2UgZXh0ZW5zaW9ucy5cbiAgICAgKiAgIElmIGFueSBvZiB0aGUgbGlzdGVkIGV4dGVuc2lvbiBIZWFkZXIgUGFyYW1ldGVycyBhcmUgbm90IHVuZGVyc3Rvb2RcbiAgICAgKiAgIGFuZCBzdXBwb3J0ZWQgYnkgdGhlIHJlY2lwaWVudCwgdGhlbiB0aGUgSldTIGlzIGludmFsaWQuICBQcm9kdWNlcnNcbiAgICAgKiAgIE1VU1QgTk9UIGluY2x1ZGUgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyBkZWZpbmVkIGJ5IHRoaXMgc3BlY2lmaWNhdGlvblxuICAgICAqICAgb3IgW0pXQV0gZm9yIHVzZSB3aXRoIEpXUywgZHVwbGljYXRlIG5hbWVzLCBvciBuYW1lcyB0aGF0IGRvIG5vdFxuICAgICAqICAgb2NjdXIgYXMgSGVhZGVyIFBhcmFtZXRlciBuYW1lcyB3aXRoaW4gdGhlIEpPU0UgSGVhZGVyIGluIHRoZSBcImNyaXRcIlxuICAgICAqICAgbGlzdC4gIFByb2R1Y2VycyBNVVNUIE5PVCB1c2UgdGhlIGVtcHR5IGxpc3QgXCJbXVwiIGFzIHRoZSBcImNyaXRcIlxuICAgICAqICAgdmFsdWUuICBSZWNpcGllbnRzIE1BWSBjb25zaWRlciB0aGUgSldTIHRvIGJlIGludmFsaWQgaWYgdGhlIGNyaXRpY2FsXG4gICAgICogICBsaXN0IGNvbnRhaW5zIGFueSBIZWFkZXIgUGFyYW1ldGVyIG5hbWVzIGRlZmluZWQgYnkgdGhpc1xuICAgICAqICAgc3BlY2lmaWNhdGlvbiBvciBbSldBXSBmb3IgdXNlIHdpdGggSldTIG9yIGlmIGFueSBvdGhlciBjb25zdHJhaW50c1xuICAgICAqICAgb24gaXRzIHVzZSBhcmUgdmlvbGF0ZWQuICBXaGVuIHVzZWQsIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlXG4gICAgICogICBpbnRlZ3JpdHkgcHJvdGVjdGVkOyB0aGVyZWZvcmUsIGl0IE1VU1Qgb2NjdXIgb25seSB3aXRoaW4gdGhlIEpXU1xuICAgICAqICAgUHJvdGVjdGVkIEhlYWRlci4gIFVzZSBvZiB0aGlzIEhlYWRlciBQYXJhbWV0ZXIgaXMgT1BUSU9OQUwuICBUaGlzXG4gICAgICogICBIZWFkZXIgUGFyYW1ldGVyIE1VU1QgYmUgdW5kZXJzdG9vZCBhbmQgcHJvY2Vzc2VkIGJ5IGltcGxlbWVudGF0aW9ucy5cbiAgICAgKlxuICAgICAqICAgQW4gZXhhbXBsZSB1c2UsIGFsb25nIHdpdGggYSBoeXBvdGhldGljYWwgXCJleHBcIiAoZXhwaXJhdGlvbiB0aW1lKVxuICAgICAqICAgZmllbGQgaXM6XG4gICAgICpcbiAgICAgKiAgICAge1wiYWxnXCI6XCJFUzI1NlwiLFxuICAgICAqICAgICBcImNyaXRcIjpbXCJleHBcIl0sXG4gICAgICogICAgIFwiZXhwXCI6MTM2MzI4NDAwMFxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuMTNcbiAgICAgKlxuICAgICAqICAgNC4xLjEzLiAgXCJjcml0XCIgKENyaXRpY2FsKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoaXMgcGFyYW1ldGVyIGhhcyB0aGUgc2FtZSBtZWFuaW5nLCBzeW50YXgsIGFuZCBwcm9jZXNzaW5nIHJ1bGVzIGFzXG4gICAgICogICB0aGUgXCJjcml0XCIgSGVhZGVyIFBhcmFtZXRlciBkZWZpbmVkIGluIFNlY3Rpb24gNC4xLjExIG9mIFtKV1NdLFxuICAgICAqICAgZXhjZXB0IHRoYXQgSGVhZGVyIFBhcmFtZXRlcnMgZm9yIGEgSldFIGFyZSBiZWluZyByZWZlcnJlZCB0bywgcmF0aGVyXG4gICAgICogICB0aGFuIEhlYWRlciBQYXJhbWV0ZXJzIGZvciBhIEpXUy5cbiAgICAgKi9cbiAgICBjcml0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgIH0sXG4gICAgICBtaW5JdGVtczogMVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBlbmNcbiAgICAgKlxuICAgICAqIEpTT04gV2ViIEVuY3J5cHRpb24gKEpXRSlcbiAgICAgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzUxNiNzZWN0aW9uLTQuMS4yXG4gICAgICpcbiAgICAgKiA0LjEuMi4gIFwiZW5jXCIgKEVuY3J5cHRpb24gQWxnb3JpdGhtKSBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICpcbiAgICAgKiAgIFRoZSBcImVuY1wiIChlbmNyeXB0aW9uIGFsZ29yaXRobSkgSGVhZGVyIFBhcmFtZXRlciBpZGVudGlmaWVzIHRoZVxuICAgICAqICAgY29udGVudCBlbmNyeXB0aW9uIGFsZ29yaXRobSB1c2VkIHRvIHBlcmZvcm0gYXV0aGVudGljYXRlZCBlbmNyeXB0aW9uXG4gICAgICogICBvbiB0aGUgcGxhaW50ZXh0IHRvIHByb2R1Y2UgdGhlIGNpcGhlcnRleHQgYW5kIHRoZSBBdXRoZW50aWNhdGlvblxuICAgICAqICAgVGFnLiAgVGhpcyBhbGdvcml0aG0gTVVTVCBiZSBhbiBBRUFEIGFsZ29yaXRobSB3aXRoIGEgc3BlY2lmaWVkIGtleVxuICAgICAqICAgbGVuZ3RoLiAgVGhlIGVuY3J5cHRlZCBjb250ZW50IGlzIG5vdCB1c2FibGUgaWYgdGhlIFwiZW5jXCIgdmFsdWUgZG9lc1xuICAgICAqICAgbm90IHJlcHJlc2VudCBhIHN1cHBvcnRlZCBhbGdvcml0aG0uICBcImVuY1wiIHZhbHVlcyBzaG91bGQgZWl0aGVyIGJlXG4gICAgICogICByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgU2lnbmF0dXJlIGFuZCBFbmNyeXB0aW9uIEFsZ29yaXRobXNcIlxuICAgICAqICAgcmVnaXN0cnkgZXN0YWJsaXNoZWQgYnkgW0pXQV0gb3IgYmUgYSB2YWx1ZSB0aGF0IGNvbnRhaW5zIGFcbiAgICAgKiAgIENvbGxpc2lvbi1SZXNpc3RhbnQgTmFtZS4gIFRoZSBcImVuY1wiIHZhbHVlIGlzIGEgY2FzZS1zZW5zaXRpdmUgQVNDSUlcbiAgICAgKiAgIHN0cmluZyBjb250YWluaW5nIGEgU3RyaW5nT3JVUkkgdmFsdWUuICBUaGlzIEhlYWRlciBQYXJhbWV0ZXIgTVVTVCBiZVxuICAgICAqICAgcHJlc2VudCBhbmQgTVVTVCBiZSB1bmRlcnN0b29kIGFuZCBwcm9jZXNzZWQgYnkgaW1wbGVtZW50YXRpb25zLlxuICAgICAqXG4gICAgICogICBBIGxpc3Qgb2YgZGVmaW5lZCBcImVuY1wiIHZhbHVlcyBmb3IgdGhpcyB1c2UgY2FuIGJlIGZvdW5kIGluIHRoZSBJQU5BXG4gICAgICogICBcIkpTT04gV2ViIFNpZ25hdHVyZSBhbmQgRW5jcnlwdGlvbiBBbGdvcml0aG1zXCIgcmVnaXN0cnkgZXN0YWJsaXNoZWRcbiAgICAgKiAgIGJ5IFtKV0FdOyB0aGUgaW5pdGlhbCBjb250ZW50cyBvZiB0aGlzIHJlZ2lzdHJ5IGFyZSB0aGUgdmFsdWVzXG4gICAgICogICBkZWZpbmVkIGluIFNlY3Rpb24gNS4xIG9mIFtKV0FdLlxuICAgICAqL1xuICAgIGVuYzoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBmb3JtYXQ6ICdTdHJpbmdPclVSSSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogemlwXG4gICAgICpcbiAgICAgKiBKU09OIFdlYiBFbmNyeXB0aW9uIChKV0UpXG4gICAgICogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc1MTYjc2VjdGlvbi00LjEuM1xuICAgICAqXG4gICAgICogNC4xLjMuICBcInppcFwiIChDb21wcmVzc2lvbiBBbGdvcml0aG0pIEhlYWRlciBQYXJhbWV0ZXJcbiAgICAgKlxuICAgICAqICAgVGhlIFwiemlwXCIgKGNvbXByZXNzaW9uIGFsZ29yaXRobSkgYXBwbGllZCB0byB0aGUgcGxhaW50ZXh0IGJlZm9yZVxuICAgICAqICAgZW5jcnlwdGlvbiwgaWYgYW55LiAgVGhlIFwiemlwXCIgdmFsdWUgZGVmaW5lZCBieSB0aGlzIHNwZWNpZmljYXRpb25cbiAgICAgKiAgIGlzOlxuICAgICAqXG4gICAgICogICBvICBcIkRFRlwiIC0gQ29tcHJlc3Npb24gd2l0aCB0aGUgREVGTEFURSBbUkZDMTk1MV0gYWxnb3JpdGhtXG4gICAgICpcbiAgICAgKiAgIE90aGVyIHZhbHVlcyBNQVkgYmUgdXNlZC4gIENvbXByZXNzaW9uIGFsZ29yaXRobSB2YWx1ZXMgY2FuIGJlXG4gICAgICogICByZWdpc3RlcmVkIGluIHRoZSBJQU5BIFwiSlNPTiBXZWIgRW5jcnlwdGlvbiBDb21wcmVzc2lvbiBBbGdvcml0aG1zXCJcbiAgICAgKiAgIHJlZ2lzdHJ5IGVzdGFibGlzaGVkIGJ5IFtKV0FdLiAgVGhlIFwiemlwXCIgdmFsdWUgaXMgYSBjYXNlLXNlbnNpdGl2ZVxuICAgICAqICAgc3RyaW5nLiAgSWYgbm8gXCJ6aXBcIiBwYXJhbWV0ZXIgaXMgcHJlc2VudCwgbm8gY29tcHJlc3Npb24gaXMgYXBwbGllZFxuICAgICAqICAgdG8gdGhlIHBsYWludGV4dCBiZWZvcmUgZW5jcnlwdGlvbi4gIFdoZW4gdXNlZCwgdGhpcyBIZWFkZXIgUGFyYW1ldGVyXG4gICAgICogICBNVVNUIGJlIGludGVncml0eSBwcm90ZWN0ZWQ7IHRoZXJlZm9yZSwgaXQgTVVTVCBvY2N1ciBvbmx5IHdpdGhpbiB0aGVcbiAgICAgKiAgIEpXRSBQcm90ZWN0ZWQgSGVhZGVyLiAgVXNlIG9mIHRoaXMgSGVhZGVyIFBhcmFtZXRlciBpcyBPUFRJT05BTC5cbiAgICAgKiAgIFRoaXMgSGVhZGVyIFBhcmFtZXRlciBNVVNUIGJlIHVuZGVyc3Rvb2QgYW5kIHByb2Nlc3NlZCBieVxuICAgICAqICAgaW1wbGVtZW50YXRpb25zLlxuICAgICAqL1xuICAgIHppcDoge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn0pO1xuXG4vKipcbiAqIEV4cG9ydFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IEpPU0VIZWFkZXJTY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxudmFyIF9zbGljZWRUb0FycmF5ID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBzbGljZUl0ZXJhdG9yKGFyciwgaSkgeyB2YXIgX2FyciA9IFtdOyB2YXIgX24gPSB0cnVlOyB2YXIgX2QgPSBmYWxzZTsgdmFyIF9lID0gdW5kZWZpbmVkOyB0cnkgeyBmb3IgKHZhciBfaSA9IGFycltTeW1ib2wuaXRlcmF0b3JdKCksIF9zOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7IF9hcnIucHVzaChfcy52YWx1ZSk7IGlmIChpICYmIF9hcnIubGVuZ3RoID09PSBpKSBicmVhazsgfSB9IGNhdGNoIChlcnIpIHsgX2QgPSB0cnVlOyBfZSA9IGVycjsgfSBmaW5hbGx5IHsgdHJ5IHsgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSkgX2lbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKF9kKSB0aHJvdyBfZTsgfSB9IHJldHVybiBfYXJyOyB9IHJldHVybiBmdW5jdGlvbiAoYXJyLCBpKSB7IGlmIChBcnJheS5pc0FycmF5KGFycikpIHsgcmV0dXJuIGFycjsgfSBlbHNlIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gT2JqZWN0KGFycikpIHsgcmV0dXJuIHNsaWNlSXRlcmF0b3IoYXJyLCBpKTsgfSBlbHNlIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcIik7IH0gfTsgfSgpO1xuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG52YXIgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG52YXIgSldBID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOCk7XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oNTUpLFxuICAgIERhdGFFcnJvciA9IF9yZXF1aXJlLkRhdGFFcnJvcjtcblxuLyoqXG4gKiBKV1NcbiAqL1xuXG5cbnZhciBKV1MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEpXUygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSldTKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhKV1MsIG51bGwsIFt7XG4gICAga2V5OiAnc2lnbicsXG5cblxuICAgIC8qKlxuICAgICAqIHNpZ25cbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvblxuICAgICAqIEVuY29kZSBhIEpXVCBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRva2VuXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24odG9rZW4pIHtcbiAgICAgIHZhciBwYXlsb2FkID0gYmFzZTY0dXJsKEpTT04uc3RyaW5naWZ5KHRva2VuLnBheWxvYWQpKTtcblxuICAgICAgLy8gY29tcGFjdCBzZXJpYWxpemF0aW9uXG4gICAgICBpZiAodG9rZW4uc2VyaWFsaXphdGlvbiA9PT0gJ2NvbXBhY3QnKSB7XG4gICAgICAgIHZhciBrZXkgPSB0b2tlbi5rZXksXG4gICAgICAgICAgICBhbGcgPSB0b2tlbi5oZWFkZXIuYWxnO1xuXG4gICAgICAgIHZhciBoZWFkZXIgPSBiYXNlNjR1cmwoSlNPTi5zdHJpbmdpZnkodG9rZW4uaGVhZGVyKSk7XG4gICAgICAgIHZhciBkYXRhID0gaGVhZGVyICsgJy4nICsgcGF5bG9hZDtcblxuICAgICAgICByZXR1cm4gSldBLnNpZ24oYWxnLCBrZXksIGRhdGEpLnRoZW4oZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICAgIHJldHVybiBkYXRhICsgJy4nICsgc2lnbmF0dXJlO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gSlNPTiBzZXJpYWxpemF0aW9uXG4gICAgICBpZiAodG9rZW4uc2VyaWFsaXphdGlvbiA9PT0gJ2pzb24nKSB7fVxuXG4gICAgICAvLyBGbGF0dGVuZWQgc2VyaWFsaXphdGlvblxuICAgICAgaWYgKHRva2VuLnNlcmlhbGl6YXRpb24gPT09ICdmbGF0dGVuZWQnKSB7fVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERhdGFFcnJvcignVW5zdXBwb3J0ZWQgc2VyaWFsaXphdGlvbicpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB2ZXJpZnlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndmVyaWZ5JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5KGp3dCkge1xuICAgICAgLy8gbXVsdGlwbGUgc2lnbmF0dXJlc1xuICAgICAgaWYgKGp3dC5zaWduYXR1cmVzKSB7XG4gICAgICAgIC8vIC4uLlxuICAgICAgfVxuXG4gICAgICB2YXIga2V5ID0gand0LmtleSxcbiAgICAgICAgICBzaWduYXR1cmUgPSBqd3Quc2lnbmF0dXJlLFxuICAgICAgICAgIGFsZyA9IGp3dC5oZWFkZXIuYWxnO1xuXG4gICAgICAvLyBvbmUgc2lnbmF0dXJlXG5cbiAgICAgIGlmIChqd3Quc2lnbmF0dXJlKSB7XG4gICAgICAgIHZhciBfand0JHNlZ21lbnRzID0gX3NsaWNlZFRvQXJyYXkoand0LnNlZ21lbnRzLCAyKSxcbiAgICAgICAgICAgIGhlYWRlciA9IF9qd3Qkc2VnbWVudHNbMF0sXG4gICAgICAgICAgICBwYXlsb2FkID0gX2p3dCRzZWdtZW50c1sxXTtcblxuICAgICAgICB2YXIgZGF0YSA9IGhlYWRlciArICcuJyArIHBheWxvYWQ7XG5cbiAgICAgICAgaWYgKGFsZyA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ1NpZ25hdHVyZSBwcm92aWRlZCB0byB2ZXJpZnkgd2l0aCBhbGc6IG5vbmUnKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gSldBLnZlcmlmeShhbGcsIGtleSwgc2lnbmF0dXJlLCBkYXRhKS50aGVuKGZ1bmN0aW9uICh2ZXJpZmllZCkge1xuICAgICAgICAgIGp3dC52ZXJpZmllZCA9IHZlcmlmaWVkO1xuICAgICAgICAgIHJldHVybiB2ZXJpZmllZDtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGcgPT09ICdub25lJykge1xuICAgICAgICBpZiAoIWtleSAmJiAhc2lnbmF0dXJlKSB7XG4gICAgICAgICAgand0LnZlcmlmaWVkID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBEYXRhRXJyb3IoJ0tleSBwcm92aWRlZCB0byB2ZXJpZnkgc2lnbmF0dXJlIHdpdGggYWxnOiBub25lJykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIHNpZ25hdHVyZXMgdG8gdmVyaWZ5XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IERhdGFFcnJvcignTWlzc2luZyBzaWduYXR1cmUocyknKSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEpXUztcbn0oKTtcblxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSldTO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihCdWZmZXIpIHsvKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5jb25zdCBhc3NlcnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuY29uc3QgYmFzZTY0dXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXygzOSk7XG5cbmNvbnN0IGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5jb25zdCB7XG4gIEpXVFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuXG5jb25zdCBGb3JtVXJsRW5jb2RlZCA9IF9fd2VicGFja19yZXF1aXJlX18oNjkpO1xuXG5jb25zdCB7XG4gIFVSTFxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpO1xuLyoqXG4gKiBBdXRoZW50aWNhdGlvbiBSZXF1ZXN0XG4gKi9cblxuXG5jbGFzcyBBdXRoZW50aWNhdGlvblJlcXVlc3Qge1xuICAvKipcbiAgICogY3JlYXRlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBDcmVhdGUgYSBuZXcgYXV0aGVudGljYXRpb24gcmVxdWVzdCB3aXRoIGdlbmVyYXRlZCBzdGF0ZSBhbmQgbm9uY2UsXG4gICAqIHZhbGlkYXRlIHByZXNlbmNlIG9mIHJlcXVpcmVkIHBhcmFtZXRlcnMsIHNlcmlhbGl6ZSB0aGUgcmVxdWVzdCBkYXRhIGFuZFxuICAgKiBwZXJzaXN0IGl0IHRvIHRoZSBzZXNzaW9uLCBhbmQgcmV0dXJuIGEgcHJvbWlzZSBmb3IgYW4gYXV0aGVudGljYXRpb25cbiAgICogcmVxdWVzdCBVUkkuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVseWluZ1BhcnR5fSBycCDigJMgaW5zdGFuY2Ugb2YgUmVseWluZ1BhcnR5XG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb3B0aW9uYWwgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzZXNzaW9uIOKAkyByZWZlcmVuY2UgdG8gbG9jYWxTdG9yYWdlIG9yIG90aGVyIHNlc3Npb24gb2JqZWN0XG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZShycCwgb3B0aW9ucywgc2Vzc2lvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgZGVmYXVsdHMsXG4gICAgICByZWdpc3RyYXRpb25cbiAgICB9ID0gcnA7XG4gICAgbGV0IGlzc3VlciwgZW5kcG9pbnQsIGNsaWVudCwgcGFyYW1zO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAgIC8vIHZhbGlkYXRlIHByZXNlbmNlIG9mIE9QIGNvbmZpZ3VyYXRpb24sIFJQIGNsaWVudCByZWdpc3RyYXRpb24sXG4gICAgICAvLyBhbmQgZGVmYXVsdCBwYXJhbWV0ZXJzXG4gICAgICBhc3NlcnQocHJvdmlkZXIuY29uZmlndXJhdGlvbiwgJ1JlbHlpbmdQYXJ0eSBwcm92aWRlciBPcGVuSUQgQ29uZmlndXJhdGlvbiBpcyBtaXNzaW5nJyk7XG4gICAgICBhc3NlcnQoZGVmYXVsdHMuYXV0aGVudGljYXRlLCAnUmVseWluZ1BhcnR5IGRlZmF1bHQgYXV0aGVudGljYXRpb24gcGFyYW1ldGVycyBhcmUgbWlzc2luZycpO1xuICAgICAgYXNzZXJ0KHJlZ2lzdHJhdGlvbiwgJ1JlbHlpbmdQYXJ0eSBjbGllbnQgcmVnaXN0cmF0aW9uIGlzIG1pc3NpbmcnKTsgLy8gZGVmaW5lIGJhc2ljIGVsZW1lbnRzIG9mIHRoZSByZXF1ZXN0XG5cbiAgICAgIGlzc3VlciA9IHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24uaXNzdWVyO1xuICAgICAgZW5kcG9pbnQgPSBwcm92aWRlci5jb25maWd1cmF0aW9uLmF1dGhvcml6YXRpb25fZW5kcG9pbnQ7XG4gICAgICBjbGllbnQgPSB7XG4gICAgICAgIGNsaWVudF9pZDogcmVnaXN0cmF0aW9uLmNsaWVudF9pZFxuICAgICAgfTtcbiAgICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdHMuYXV0aGVudGljYXRlLCBjbGllbnQsIG9wdGlvbnMpOyAvLyB2YWxpZGF0ZSBwcmVzZW5jZSBvZiByZXF1aXJlZCBjb25maWd1cmF0aW9uIGFuZCBwYXJhbWV0ZXJzXG5cbiAgICAgIGFzc2VydChpc3N1ZXIsICdNaXNzaW5nIGlzc3VlciBpbiBwcm92aWRlciBPcGVuSUQgQ29uZmlndXJhdGlvbicpO1xuICAgICAgYXNzZXJ0KGVuZHBvaW50LCAnTWlzc2luZyBhdXRob3JpemF0aW9uX2VuZHBvaW50IGluIHByb3ZpZGVyIE9wZW5JRCBDb25maWd1cmF0aW9uJyk7XG4gICAgICBhc3NlcnQocGFyYW1zLnNjb3BlLCAnTWlzc2luZyBzY29wZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVxdWVzdCcpO1xuICAgICAgYXNzZXJ0KHBhcmFtcy5yZXNwb25zZV90eXBlLCAnTWlzc2luZyByZXNwb25zZV90eXBlIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7XG4gICAgICBhc3NlcnQocGFyYW1zLmNsaWVudF9pZCwgJ01pc3NpbmcgY2xpZW50X2lkIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7XG4gICAgICBhc3NlcnQocGFyYW1zLnJlZGlyZWN0X3VyaSwgJ01pc3NpbmcgcmVkaXJlY3RfdXJpIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXF1ZXN0Jyk7IC8vIGdlbmVyYXRlIHN0YXRlIGFuZCBub25jZSByYW5kb20gb2N0ZXRzXG5cbiAgICAgIHBhcmFtcy5zdGF0ZSA9IEFycmF5LmZyb20oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpKTtcbiAgICAgIHBhcmFtcy5ub25jZSA9IEFycmF5LmZyb20oY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDhBcnJheSgxNikpKTsgLy8gaGFzaCB0aGUgc3RhdGUgYW5kIG5vbmNlIHBhcmFtZXRlciB2YWx1ZXNcblxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgICAgfSwgbmV3IFVpbnQ4QXJyYXkocGFyYW1zLnN0YXRlKSksIGNyeXB0by5zdWJ0bGUuZGlnZXN0KHtcbiAgICAgICAgbmFtZTogJ1NIQS0yNTYnXG4gICAgICB9LCBuZXcgVWludDhBcnJheShwYXJhbXMubm9uY2UpKV0pO1xuICAgIH0pIC8vIHNlcmlhbGl6ZSB0aGUgcmVxdWVzdCB3aXRoIG9yaWdpbmFsIHZhbHVlcywgc3RvcmUgaW4gc2Vzc2lvbiBieVxuICAgIC8vIGVuY29kZWQgc3RhdGUgcGFyYW0sIGFuZCByZXBsYWNlIHN0YXRlL25vbmNlIG9jdGV0cyB3aXRoIGVuY29kZWRcbiAgICAvLyBkaWdlc3RzXG4gICAgLnRoZW4oZGlnZXN0cyA9PiB7XG4gICAgICBsZXQgc3RhdGUgPSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0c1swXSkpO1xuICAgICAgbGV0IG5vbmNlID0gYmFzZTY0dXJsKEJ1ZmZlci5mcm9tKGRpZ2VzdHNbMV0pKTtcbiAgICAgIGxldCBrZXkgPSBgJHtpc3N1ZXJ9L3JlcXVlc3RIaXN0b3J5LyR7c3RhdGV9YDsgLy8gc3RvcmUgdGhlIHJlcXVlc3QgcGFyYW1zIGZvciByZXNwb25zZSB2YWxpZGF0aW9uXG4gICAgICAvLyB3aXRoIHNlcmlhbGl6ZWQgb2N0ZXQgdmFsdWVzIGZvciBzdGF0ZSBhbmQgbm9uY2VcblxuICAgICAgc2Vzc2lvbltrZXldID0gSlNPTi5zdHJpbmdpZnkocGFyYW1zKTsgLy8gcmVwbGFjZSBzdGF0ZSBhbmQgbm9uY2Ugb2N0ZXRzIHdpdGggYmFzZTY0dXJsIGVuY29kZWQgZGlnZXN0c1xuXG4gICAgICBwYXJhbXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIHBhcmFtcy5ub25jZSA9IG5vbmNlO1xuICAgIH0pLnRoZW4oKCkgPT4gQXV0aGVudGljYXRpb25SZXF1ZXN0LmdlbmVyYXRlU2Vzc2lvbktleXMoKSkudGhlbihzZXNzaW9uS2V5cyA9PiB7XG4gICAgICBBdXRoZW50aWNhdGlvblJlcXVlc3Quc3RvcmVTZXNzaW9uS2V5cyhzZXNzaW9uS2V5cywgcGFyYW1zLCBzZXNzaW9uKTtcbiAgICB9KSAvLyBvcHRpb25hbGx5IGVuY29kZSBhIEpXVCB3aXRoIHRoZSByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAvLyBhbmQgcmVwbGFjZSBwYXJhbXMgd2l0aCBgeyByZXF1ZXN0OiA8and0PiB9XG4gICAgLnRoZW4oKCkgPT4ge1xuICAgICAgaWYgKHByb3ZpZGVyLmNvbmZpZ3VyYXRpb24ucmVxdWVzdF9wYXJhbWV0ZXJfc3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybiBBdXRoZW50aWNhdGlvblJlcXVlc3QuZW5jb2RlUmVxdWVzdFBhcmFtcyhwYXJhbXMpLnRoZW4oZW5jb2RlZFBhcmFtcyA9PiB7XG4gICAgICAgICAgcGFyYW1zID0gZW5jb2RlZFBhcmFtcztcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkgLy8gcmVuZGVyIHRoZSByZXF1ZXN0IFVSSSBhbmQgdGVybWluYXRlIHRoZSBhbGdvcml0aG1cbiAgICAudGhlbigoKSA9PiB7XG4gICAgICBsZXQgdXJsID0gbmV3IFVSTChlbmRwb2ludCk7XG4gICAgICB1cmwuc2VhcmNoID0gRm9ybVVybEVuY29kZWQuZW5jb2RlKHBhcmFtcyk7XG4gICAgICByZXR1cm4gdXJsLmhyZWY7XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgZ2VuZXJhdGVTZXNzaW9uS2V5cygpIHtcbiAgICByZXR1cm4gY3J5cHRvLnN1YnRsZS5nZW5lcmF0ZUtleSh7XG4gICAgICBuYW1lOiBcIlJTQVNTQS1QS0NTMS12MV81XCIsXG4gICAgICBtb2R1bHVzTGVuZ3RoOiAyMDQ4LFxuICAgICAgcHVibGljRXhwb25lbnQ6IG5ldyBVaW50OEFycmF5KFsweDAxLCAweDAwLCAweDAxXSksXG4gICAgICBoYXNoOiB7XG4gICAgICAgIG5hbWU6IFwiU0hBLTI1NlwiXG4gICAgICB9XG4gICAgfSwgdHJ1ZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSkudGhlbihrZXlQYWlyID0+IHtcbiAgICAgIC8vIHJldHVybnMgYSBrZXlwYWlyIG9iamVjdFxuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5UGFpci5wdWJsaWNLZXkpLCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgnandrJywga2V5UGFpci5wcml2YXRlS2V5KV0pO1xuICAgIH0pLnRoZW4oandrUGFpciA9PiB7XG4gICAgICBsZXQgW3B1YmxpY0p3aywgcHJpdmF0ZUp3a10gPSBqd2tQYWlyO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHVibGljOiBwdWJsaWNKd2ssXG4gICAgICAgIHByaXZhdGU6IHByaXZhdGVKd2tcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICBzdGF0aWMgc3RvcmVTZXNzaW9uS2V5cyhzZXNzaW9uS2V5cywgcGFyYW1zLCBzZXNzaW9uKSB7XG4gICAgLy8gc3RvcmUgdGhlIHByaXZhdGUgb25lIGluIHNlc3Npb24sIHB1YmxpYyBvbmUgZ29lcyBpbnRvIHBhcmFtc1xuICAgIHNlc3Npb25bJ29pZGMuc2Vzc2lvbi5wcml2YXRlS2V5J10gPSBKU09OLnN0cmluZ2lmeShzZXNzaW9uS2V5cy5wcml2YXRlKTtcbiAgICBwYXJhbXMua2V5ID0gc2Vzc2lvbktleXMucHVibGljO1xuICB9XG5cbiAgc3RhdGljIGVuY29kZVJlcXVlc3RQYXJhbXMocGFyYW1zKSB7XG4gICAgY29uc3QgZXhjbHVkZVBhcmFtcyA9IFsnc2NvcGUnLCAnY2xpZW50X2lkJywgJ3Jlc3BvbnNlX3R5cGUnLCAnc3RhdGUnXTtcbiAgICBjb25zdCBrZXlzVG9FbmNvZGUgPSBPYmplY3Qua2V5cyhwYXJhbXMpLmZpbHRlcihrZXkgPT4gIWV4Y2x1ZGVQYXJhbXMuaW5jbHVkZXMoa2V5KSk7XG4gICAgbGV0IHBheWxvYWQgPSB7fTtcbiAgICBrZXlzVG9FbmNvZGUuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgcGF5bG9hZFtrZXldID0gcGFyYW1zW2tleV07XG4gICAgfSk7XG4gICAgbGV0IHJlcXVlc3RQYXJhbUp3dCA9IG5ldyBKV1Qoe1xuICAgICAgaGVhZGVyOiB7XG4gICAgICAgIGFsZzogJ25vbmUnXG4gICAgICB9LFxuICAgICAgcGF5bG9hZFxuICAgIH0sIHtcbiAgICAgIGZpbHRlcjogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gcmVxdWVzdFBhcmFtSnd0LmVuY29kZSgpLnRoZW4ocmVxdWVzdFBhcmFtQ29tcGFjdCA9PiB7XG4gICAgICBsZXQgbmV3UGFyYW1zID0ge1xuICAgICAgICBzY29wZTogcGFyYW1zWydzY29wZSddLFxuICAgICAgICBjbGllbnRfaWQ6IHBhcmFtc1snY2xpZW50X2lkJ10sXG4gICAgICAgIHJlc3BvbnNlX3R5cGU6IHBhcmFtc1sncmVzcG9uc2VfdHlwZSddLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0UGFyYW1Db21wYWN0LFxuICAgICAgICBzdGF0ZTogcGFyYW1zWydzdGF0ZSddXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ld1BhcmFtcztcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcbiAqIEV4cG9ydFxuICovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoZW50aWNhdGlvblJlcXVlc3Q7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkuQnVmZmVyKSlcblxuLyoqKi8gfSksXG4vKiA2OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG4vKipcbiAqIERlcGVuZGVuY2llc1xuICovXG5cbi8qKlxuICogRm9ybVVybEVuY29kZWRcbiAqL1xuY2xhc3MgRm9ybVVybEVuY29kZWQge1xuICAvKipcbiAgICogRW5jb2RlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBSZXByZXNlbnQgYW4gb2JqZWN0IGFzIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBzdHJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZW5jb2RlKGRhdGEpIHtcbiAgICBsZXQgcGFpcnMgPSBbXTtcbiAgICBPYmplY3Qua2V5cyhkYXRhKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YVtrZXldKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbiAgfVxuICAvKipcbiAgICogRGVjb2RlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBQYXJzZSBhIHgtd3d3LWZvcm0tdXJsZW5jb2RlZCBpbnRvIGFuIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGRhdGFcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG5cblxuICBzdGF0aWMgZGVjb2RlKGRhdGEpIHtcbiAgICBsZXQgb2JqID0ge307XG4gICAgZGF0YS5zcGxpdCgnJicpLmZvckVhY2goZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBsZXQgcGFpciA9IHByb3BlcnR5LnNwbGl0KCc9Jyk7XG4gICAgICBsZXQga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pO1xuICAgICAgbGV0IHZhbCA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgICAgIG9ialtrZXldID0gdmFsO1xuICAgIH0pO1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRm9ybVVybEVuY29kZWQ7XG5cbi8qKiovIH0pLFxuLyogNzAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCwgQnVmZmVyKSB7LyoqXG4gKiBEZXBlbmRlbmNpZXNcbiAqL1xuY29uc3Qge1xuICBVUkxcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuY29uc3QgYXNzZXJ0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG5cbmNvbnN0IGNyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oNDkpO1xuXG5jb25zdCBiYXNlNjR1cmwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KTtcblxuY29uc3QgZmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5jb25zdCBIZWFkZXJzID0gZmV0Y2guSGVhZGVycyA/IGZldGNoLkhlYWRlcnMgOiBnbG9iYWwuSGVhZGVycztcblxuY29uc3QgRm9ybVVybEVuY29kZWQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDY5KTtcblxuY29uc3QgSURUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzEpO1xuXG5jb25zdCBTZXNzaW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3Myk7XG5cbmNvbnN0IG9uSHR0cEVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3NCk7XG5cbmNvbnN0IEh0dHBFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzYpO1xuLyoqXG4gKiBBdXRoZW50aWNhdGlvblJlc3BvbnNlXG4gKi9cblxuXG5jbGFzcyBBdXRoZW50aWNhdGlvblJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBycCB7UmVseWluZ1BhcnR5fVxuICAgKiBAcGFyYW0gW3JlZGlyZWN0XSB7c3RyaW5nfSByZXEucXVlcnlcbiAgICogQHBhcmFtIFtib2R5XSB7c3RyaW5nfSByZXEuYm9keS50ZXh0XG4gICAqIEBwYXJhbSBzZXNzaW9uIHtTZXNzaW9ufFN0b3JhZ2V9IHJlcS5zZXNzaW9uIG9yIGxvY2FsU3RvcmFnZSBvciBzaW1pbGFyXG4gICAqIEBwYXJhbSBwYXJhbXMge29iamVjdH0gaGFzaG1hcFxuICAgKiBAcGFyYW0gbW9kZSB7c3RyaW5nfSAncXVlcnknLydmcmFnbWVudCcvJ2Zvcm1fcG9zdCcsXG4gICAqICAgZGV0ZXJtaW5lZCBpbiBgcGFyc2VSZXNwb25zZSgpYFxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIHJwLFxuICAgIHJlZGlyZWN0LFxuICAgIGJvZHksXG4gICAgc2Vzc2lvbixcbiAgICBtb2RlLFxuICAgIHBhcmFtcyA9IHt9XG4gIH0pIHtcbiAgICB0aGlzLnJwID0gcnA7XG4gICAgdGhpcy5yZWRpcmVjdCA9IHJlZGlyZWN0O1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlXG4gICAqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiBBdXRoZW50aWNhdGlvbiByZXNwb25zZSB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IHJlc3BvbnNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPFNlc3Npb24+fVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSkudGhlbih0aGlzLnBhcnNlUmVzcG9uc2UpLnRoZW4odGhpcy5lcnJvclJlc3BvbnNlKS50aGVuKHRoaXMubWF0Y2hSZXF1ZXN0KS50aGVuKHRoaXMudmFsaWRhdGVTdGF0ZVBhcmFtKS50aGVuKHRoaXMudmFsaWRhdGVSZXNwb25zZU1vZGUpLnRoZW4odGhpcy52YWxpZGF0ZVJlc3BvbnNlUGFyYW1zKS50aGVuKHRoaXMuZXhjaGFuZ2VBdXRob3JpemF0aW9uQ29kZSkudGhlbih0aGlzLnZhbGlkYXRlSURUb2tlbikudGhlbihTZXNzaW9uLmZyb21BdXRoUmVzcG9uc2UpO1xuICB9XG4gIC8qKlxuICAgKiBwYXJzZVJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZVxuICAgKlxuICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgKi9cblxuXG4gIHN0YXRpYyBwYXJzZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgbGV0IHtcbiAgICAgIHJlZGlyZWN0LFxuICAgICAgYm9keVxuICAgIH0gPSByZXNwb25zZTsgLy8gcmVzcG9uc2UgbXVzdCBiZSBlaXRoZXIgYSByZWRpcmVjdCB1cmkgb3IgcmVxdWVzdCBib2R5LCBidXQgbm90IGJvdGhcblxuICAgIGlmIChyZWRpcmVjdCAmJiBib2R5IHx8ICFyZWRpcmVjdCAmJiAhYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcig0MDAsICdJbnZhbGlkIHJlc3BvbnNlIG1vZGUnKTtcbiAgICB9IC8vIHBhcnNlIHJlZGlyZWN0IHVyaVxuXG5cbiAgICBpZiAocmVkaXJlY3QpIHtcbiAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHJlZGlyZWN0KTtcbiAgICAgIGxldCB7XG4gICAgICAgIHNlYXJjaCxcbiAgICAgICAgaGFzaFxuICAgICAgfSA9IHVybDtcblxuICAgICAgaWYgKHNlYXJjaCAmJiBoYXNoIHx8ICFzZWFyY2ggJiYgIWhhc2gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEh0dHBFcnJvcig0MDAsICdJbnZhbGlkIHJlc3BvbnNlIG1vZGUnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIHJlc3BvbnNlLm1vZGUgPSAncXVlcnknO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGFzaCkge1xuICAgICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoaGFzaC5zdWJzdHJpbmcoMSkpO1xuICAgICAgICByZXNwb25zZS5tb2RlID0gJ2ZyYWdtZW50JztcbiAgICAgIH1cbiAgICB9IC8vIHBhcnNlIHJlcXVlc3QgZm9ybSBib2R5XG5cblxuICAgIGlmIChib2R5KSB7XG4gICAgICByZXNwb25zZS5wYXJhbXMgPSBGb3JtVXJsRW5jb2RlZC5kZWNvZGUoYm9keSk7XG4gICAgICByZXNwb25zZS5tb2RlID0gJ2Zvcm1fcG9zdCc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBlcnJvclJlc3BvbnNlXG4gICAqXG4gICAqIEBwYXJhbSB7QXV0aGVudGljYXRpb25SZXNwb25zZX0gcmVzcG9uc2VcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IElmIHJlc3BvbnNlIHBhcmFtcyBpbmNsdWRlIHRoZSBPQXV0aDIgJ2Vycm9yJyBwYXJhbSxcbiAgICogICB0aHJvd3MgYW4gZXJyb3IgYmFzZWQgb24gaXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfSBDaGFpbmFibGVcbiAgICpcbiAgICogQHRvZG8gRmlndXJlIG91dCBIVFRQIHN0YXR1cyBjb2RlICh0eXBpY2FsbHkgNDAwLCA0MDEgb3IgNDAzKVxuICAgKiAgIGJhc2VkIG9uIHRoZSBPQXV0aDIvT0lEQyBgZXJyb3JgIGNvZGUsIHByb2JhYmx5IHVzaW5nIGFuIGV4dGVybmFsIGxpYnJhcnlcbiAgICovXG5cblxuICBzdGF0aWMgZXJyb3JSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IGVycm9yQ29kZSA9IHJlc3BvbnNlLnBhcmFtcy5lcnJvcjtcblxuICAgIGlmIChlcnJvckNvZGUpIHtcbiAgICAgIGNvbnN0IGVycm9yUGFyYW1zID0ge307XG4gICAgICBlcnJvclBhcmFtc1snZXJyb3InXSA9IGVycm9yQ29kZTtcbiAgICAgIGVycm9yUGFyYW1zWydlcnJvcl9kZXNjcmlwdGlvbiddID0gcmVzcG9uc2UucGFyYW1zWydlcnJvcl9kZXNjcmlwdGlvbiddO1xuICAgICAgZXJyb3JQYXJhbXNbJ2Vycm9yX3VyaSddID0gcmVzcG9uc2UucGFyYW1zWydlcnJvcl91cmknXTtcbiAgICAgIGVycm9yUGFyYW1zWydzdGF0ZSddID0gcmVzcG9uc2UucGFyYW1zWydzdGF0ZSddO1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UgZXJyb3I6ICR7ZXJyb3JDb2RlfWApO1xuICAgICAgZXJyb3IuaW5mbyA9IGVycm9yUGFyYW1zO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiBtYXRjaFJlcXVlc3RcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyBtYXRjaFJlcXVlc3QocmVzcG9uc2UpIHtcbiAgICBsZXQge1xuICAgICAgcnAsXG4gICAgICBwYXJhbXMsXG4gICAgICBzZXNzaW9uXG4gICAgfSA9IHJlc3BvbnNlO1xuICAgIGxldCBzdGF0ZSA9IHBhcmFtcy5zdGF0ZTtcbiAgICBsZXQgaXNzdWVyID0gcnAucHJvdmlkZXIuY29uZmlndXJhdGlvbi5pc3N1ZXI7XG5cbiAgICBpZiAoIXN0YXRlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3Npbmcgc3RhdGUgcGFyYW1ldGVyIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7XG4gICAgfVxuXG4gICAgbGV0IGtleSA9IGAke2lzc3Vlcn0vcmVxdWVzdEhpc3RvcnkvJHtzdGF0ZX1gO1xuICAgIGxldCByZXF1ZXN0ID0gc2Vzc2lvbltrZXldO1xuXG4gICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc21hdGNoaW5nIHN0YXRlIHBhcmFtZXRlciBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpO1xuICAgIH1cblxuICAgIHJlc3BvbnNlLnJlcXVlc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVTdGF0ZVBhcmFtXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVTdGF0ZVBhcmFtKHJlc3BvbnNlKSB7XG4gICAgbGV0IG9jdGV0cyA9IG5ldyBVaW50OEFycmF5KHJlc3BvbnNlLnJlcXVlc3Quc3RhdGUpO1xuICAgIGxldCBlbmNvZGVkID0gcmVzcG9uc2UucGFyYW1zLnN0YXRlO1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRpZ2VzdCh7XG4gICAgICBuYW1lOiAnU0hBLTI1NidcbiAgICB9LCBvY3RldHMpLnRoZW4oZGlnZXN0ID0+IHtcbiAgICAgIGlmIChlbmNvZGVkICE9PSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBzdGF0ZSBwYXJhbWV0ZXIgaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlTW9kZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlUmVzcG9uc2VNb2RlKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLnJlcXVlc3QucmVzcG9uc2VfdHlwZSAhPT0gJ2NvZGUnICYmIHJlc3BvbnNlLm1vZGUgPT09ICdxdWVyeScpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCByZXNwb25zZSBtb2RlJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZVJlc3BvbnNlUGFyYW1zXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVSZXNwb25zZVBhcmFtcyhyZXNwb25zZSkge1xuICAgIGxldCB7XG4gICAgICByZXF1ZXN0LFxuICAgICAgcGFyYW1zXG4gICAgfSA9IHJlc3BvbnNlO1xuICAgIGxldCBleHBlY3RlZFBhcmFtcyA9IHJlcXVlc3QucmVzcG9uc2VfdHlwZS5zcGxpdCgnICcpO1xuXG4gICAgaWYgKGV4cGVjdGVkUGFyYW1zLmluY2x1ZGVzKCdjb2RlJykpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuY29kZSwgJ01pc3NpbmcgYXV0aG9yaXphdGlvbiBjb2RlIGluIGF1dGhlbnRpY2F0aW9uIHJlc3BvbnNlJyk7IC8vIFRPRE8gYXNzZXJ0IG5vdmVsdHkgb2YgY29kZVxuICAgIH1cblxuICAgIGlmIChleHBlY3RlZFBhcmFtcy5pbmNsdWRlcygnaWRfdG9rZW4nKSkge1xuICAgICAgYXNzZXJ0KHBhcmFtcy5pZF90b2tlbiwgJ01pc3NpbmcgaWRfdG9rZW4gaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICB9XG5cbiAgICBpZiAoZXhwZWN0ZWRQYXJhbXMuaW5jbHVkZXMoJ3Rva2VuJykpIHtcbiAgICAgIGFzc2VydChwYXJhbXMuYWNjZXNzX3Rva2VuLCAnTWlzc2luZyBhY2Nlc3NfdG9rZW4gaW4gYXV0aGVudGljYXRpb24gcmVzcG9uc2UnKTtcbiAgICAgIGFzc2VydChwYXJhbXMudG9rZW5fdHlwZSwgJ01pc3NpbmcgdG9rZW5fdHlwZSBpbiBhdXRoZW50aWNhdGlvbiByZXNwb25zZScpO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogZXhjaGFuZ2VBdXRob3JpemF0aW9uQ29kZVxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9IHJlc3BvbnNlIG9iamVjdFxuICAgKi9cblxuXG4gIHN0YXRpYyBleGNoYW5nZUF1dGhvcml6YXRpb25Db2RlKHJlc3BvbnNlKSB7XG4gICAgbGV0IHtcbiAgICAgIHJwLFxuICAgICAgcGFyYW1zLFxuICAgICAgcmVxdWVzdFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgY29kZSA9IHBhcmFtcy5jb2RlOyAvLyBvbmx5IGV4Y2hhbmdlIHRoZSBhdXRob3JpemF0aW9uIGNvZGUgd2hlbiB0aGUgcmVzcG9uc2UgdHlwZSBpcyBcImNvZGVcIlxuXG4gICAgaWYgKCFjb2RlIHx8IHJlcXVlc3RbJ3Jlc3BvbnNlX3R5cGUnXSAhPT0gJ2NvZGUnKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG5cbiAgICBsZXQge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICByZWdpc3RyYXRpb25cbiAgICB9ID0gcnA7XG4gICAgbGV0IGlkID0gcmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXTtcbiAgICBsZXQgc2VjcmV0ID0gcmVnaXN0cmF0aW9uWydjbGllbnRfc2VjcmV0J107IC8vIHZlcmlmeSB0aGUgY2xpZW50IGlzIG5vdCBwdWJsaWNcblxuICAgIGlmICghc2VjcmV0KSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdDbGllbnQgY2Fubm90IGV4Y2hhbmdlIGF1dGhvcml6YXRpb24gY29kZSBiZWNhdXNlICcgKyAnaXQgaXMgbm90IGEgY29uZmlkZW50aWFsIGNsaWVudCcpKTtcbiAgICB9IC8vIGluaXRpYWxpemUgdG9rZW4gcmVxdWVzdCBhcmd1bWVudHNcblxuXG4gICAgbGV0IGVuZHBvaW50ID0gcHJvdmlkZXIuY29uZmlndXJhdGlvbi50b2tlbl9lbmRwb2ludDtcbiAgICBsZXQgbWV0aG9kID0gJ1BPU1QnOyAvLyBpbml0aWFsaXplIGhlYWRlcnNcblxuICAgIGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoe1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG4gICAgfSk7IC8vIGluaXRpYWxpemUgdGhlIHRva2VuIHJlcXVlc3QgcGFyYW1ldGVyc1xuXG4gICAgbGV0IGJvZHlDb250ZW50cyA9IHtcbiAgICAgICdncmFudF90eXBlJzogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAnY29kZSc6IGNvZGUsXG4gICAgICAncmVkaXJlY3RfdXJpJzogcmVxdWVzdFsncmVkaXJlY3RfdXJpJ10gLy8gZGV0ZXJtaW5lIGNsaWVudCBhdXRoZW50aWNhdGlvbiBtZXRob2RcblxuICAgIH07XG4gICAgbGV0IGF1dGhNZXRob2QgPSByZWdpc3RyYXRpb25bJ3Rva2VuX2VuZHBvaW50X2F1dGhfbWV0aG9kJ10gfHwgJ2NsaWVudF9zZWNyZXRfYmFzaWMnOyAvLyBjbGllbnQgc2VjcmV0IGJhc2ljIGF1dGhlbnRpY2F0aW9uXG5cbiAgICBpZiAoYXV0aE1ldGhvZCA9PT0gJ2NsaWVudF9zZWNyZXRfYmFzaWMnKSB7XG4gICAgICBsZXQgY3JlZGVudGlhbHMgPSBuZXcgQnVmZmVyKGAke2lkfToke3NlY3JldH1gKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICBoZWFkZXJzLnNldCgnQXV0aG9yaXphdGlvbicsIGBCYXNpYyAke2NyZWRlbnRpYWxzfWApO1xuICAgIH0gLy8gY2xpZW50IHNlY3JldCBwb3N0IGF1dGhlbnRpY2F0aW9uXG5cblxuICAgIGlmIChhdXRoTWV0aG9kID09PSAnY2xpZW50X3NlY3JldF9wb3N0Jykge1xuICAgICAgYm9keUNvbnRlbnRzWydjbGllbnRfaWQnXSA9IGlkO1xuICAgICAgYm9keUNvbnRlbnRzWydjbGllbnRfc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgfVxuXG4gICAgbGV0IGJvZHkgPSBGb3JtVXJsRW5jb2RlZC5lbmNvZGUoYm9keUNvbnRlbnRzKTsgLy8gVE9ET1xuICAgIC8vIGNsaWVudF9zZWNyZXRfand0IGF1dGhlbnRpY2F0aW9uXG4gICAgLy8gcHJpdmF0ZV9rZXlfand0XG4gICAgLy8gbWFrZSB0aGUgdG9rZW4gcmVxdWVzdFxuXG4gICAgcmV0dXJuIGZldGNoKGVuZHBvaW50LCB7XG4gICAgICBtZXRob2QsXG4gICAgICBoZWFkZXJzLFxuICAgICAgYm9keVxuICAgIH0pLnRoZW4ob25IdHRwRXJyb3IoJ0Vycm9yIGV4Y2hhbmdpbmcgYXV0aG9yaXphdGlvbiBjb2RlJykpLnRoZW4odG9rZW5SZXNwb25zZSA9PiB0b2tlblJlc3BvbnNlLmpzb24oKSkudGhlbih0b2tlblJlc3BvbnNlID0+IHtcbiAgICAgIGFzc2VydCh0b2tlblJlc3BvbnNlWydhY2Nlc3NfdG9rZW4nXSwgJ01pc3NpbmcgYWNjZXNzX3Rva2VuIGluIHRva2VuIHJlc3BvbnNlJyk7XG4gICAgICBhc3NlcnQodG9rZW5SZXNwb25zZVsndG9rZW5fdHlwZSddLCAnTWlzc2luZyB0b2tlbl90eXBlIGluIHRva2VuIHJlc3BvbnNlJyk7XG4gICAgICBhc3NlcnQodG9rZW5SZXNwb25zZVsnaWRfdG9rZW4nXSwgJ01pc3NpbmcgaWRfdG9rZW4gaW4gdG9rZW4gcmVzcG9uc2UnKTsgLy8gYW55dGhpbmcgZWxzZT9cbiAgICAgIC8vIElTIFRISVMgVEhFIFJJR0hUIFRISU5HIFRPIERPIEhFUkU/XG5cbiAgICAgIHJlc3BvbnNlLnBhcmFtcyA9IE9iamVjdC5hc3NpZ24ocmVzcG9uc2UucGFyYW1zLCB0b2tlblJlc3BvbnNlKTtcbiAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVJRFRva2VuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVJRFRva2VuKHJlc3BvbnNlKSB7XG4gICAgLy8gb25seSB2YWxpZGF0ZSB0aGUgSUQgVG9rZW4gaWYgcHJlc2VudCBpbiB0aGUgcmVzcG9uc2VcbiAgICBpZiAoIXJlc3BvbnNlLnBhcmFtcy5pZF90b2tlbikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLmRlY3J5cHRJRFRva2VuKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UuZGVjb2RlSURUb2tlbikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlSXNzdWVyKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVBdWRpZW5jZSkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnJlc29sdmVLZXlzKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmVyaWZ5U2lnbmF0dXJlKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmFsaWRhdGVFeHBpcmVzKS50aGVuKEF1dGhlbnRpY2F0aW9uUmVzcG9uc2UudmVyaWZ5Tm9uY2UpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUFjcikudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlQXV0aFRpbWUpLnRoZW4oQXV0aGVudGljYXRpb25SZXNwb25zZS52YWxpZGF0ZUFjY2Vzc1Rva2VuSGFzaCkudGhlbihBdXRoZW50aWNhdGlvblJlc3BvbnNlLnZhbGlkYXRlQXV0aG9yaXphdGlvbkNvZGVIYXNoKTtcbiAgfVxuICAvKipcbiAgICogZGVjcnlwdElEVG9rZW5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyBkZWNyeXB0SURUb2tlbihyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgfVxuICAvKipcbiAgICogZGVjb2RlSURUb2tlblxuICAgKlxuICAgKiBOb3RlOiBJZiB0aGUgYGlkX3Rva2VuYCBpcyBub3QgcHJlc2VudCBpbiBwYXJhbXMsIHRoaXMgbWV0aG9kIGRvZXMgbm90XG4gICAqIGdldCBjYWxsZWQgKHNob3J0LWNpcmN1aXRlZCBpbiBgdmFsaWRhdGVJRFRva2VuKClgKS5cbiAgICpcbiAgICogQHBhcmFtIHJlc3BvbnNlIHtBdXRoZW50aWNhdGlvblJlc3BvbnNlfVxuICAgKiBAcGFyYW0gcmVzcG9uc2UucGFyYW1zIHtvYmplY3R9XG4gICAqIEBwYXJhbSBbcmVzcG9uc2UucGFyYW1zLmlkX3Rva2VuXSB7c3RyaW5nfSBJRFRva2VuIGVuY29kZWQgYXMgYSBKV1RcbiAgICpcbiAgICogQHJldHVybnMge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2V9IENoYWluYWJsZVxuICAgKi9cblxuXG4gIHN0YXRpYyBkZWNvZGVJRFRva2VuKHJlc3BvbnNlKSB7XG4gICAgbGV0IGp3dCA9IHJlc3BvbnNlLnBhcmFtcy5pZF90b2tlbjtcblxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZS5kZWNvZGVkID0gSURUb2tlbi5kZWNvZGUoand0KTtcbiAgICB9IGNhdGNoIChkZWNvZGVFcnJvcikge1xuICAgICAgY29uc3QgZXJyb3IgPSBuZXcgSHR0cEVycm9yKDQwMCwgJ0Vycm9yIGRlY29kaW5nIElEIFRva2VuJyk7XG4gICAgICBlcnJvci5jYXVzZSA9IGRlY29kZUVycm9yO1xuICAgICAgZXJyb3IuaW5mbyA9IHtcbiAgICAgICAgaWRfdG9rZW46IGp3dFxuICAgICAgfTtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVJc3N1ZXJcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUlzc3VlcihyZXNwb25zZSkge1xuICAgIGxldCBjb25maWd1cmF0aW9uID0gcmVzcG9uc2UucnAucHJvdmlkZXIuY29uZmlndXJhdGlvbjtcbiAgICBsZXQgcGF5bG9hZCA9IHJlc3BvbnNlLmRlY29kZWQucGF5bG9hZDsgLy8gdmFsaWRhdGUgaXNzdWVyIG9mIHRva2VuIG1hdGNoZXMgdGhpcyByZWx5aW5nIHBhcnR5J3MgcHJvdmlkZXJcblxuICAgIGlmIChwYXlsb2FkLmlzcyAhPT0gY29uZmlndXJhdGlvbi5pc3N1ZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgaXNzdWVyIGluIElEIFRva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiB2YWxpZGF0ZUF1ZGllbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBdWRpZW5jZShyZXNwb25zZSkge1xuICAgIGxldCByZWdpc3RyYXRpb24gPSByZXNwb25zZS5ycC5yZWdpc3RyYXRpb247XG4gICAgbGV0IHtcbiAgICAgIGF1ZCxcbiAgICAgIGF6cFxuICAgIH0gPSByZXNwb25zZS5kZWNvZGVkLnBheWxvYWQ7IC8vIHZhbGlkYXRlIGF1ZGllbmNlIGluY2x1ZGVzIHRoaXMgcmVseWluZyBwYXJ0eVxuXG4gICAgaWYgKHR5cGVvZiBhdWQgPT09ICdzdHJpbmcnICYmIGF1ZCAhPT0gcmVnaXN0cmF0aW9uWydjbGllbnRfaWQnXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBhdWRpZW5jZSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXVkaWVuY2UgaW5jbHVkZXMgdGhpcyByZWx5aW5nIHBhcnR5XG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF1ZCkgJiYgIWF1ZC5pbmNsdWRlcyhyZWdpc3RyYXRpb25bJ2NsaWVudF9pZCddKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBhdWRpZW5jZSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXV0aG9yaXplZCBwYXJ0eSBpcyBwcmVzZW50IGlmIHJlcXVpcmVkXG5cblxuICAgIGlmIChBcnJheS5pc0FycmF5KGF1ZCkgJiYgIWF6cCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGF6cCBjbGFpbSBpbiBpZF90b2tlbicpO1xuICAgIH0gLy8gdmFsaWRhdGUgYXV0aG9yaXplZCBwYXJ0eSBpcyB0aGlzIHJlbHlpbmcgcGFydHlcblxuXG4gICAgaWYgKGF6cCAmJiBhenAgIT09IHJlZ2lzdHJhdGlvblsnY2xpZW50X2lkJ10pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzbWF0Y2hpbmcgYXpwIGNsYWltIGluIGlkX3Rva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG4gIC8qKlxuICAgKiByZXNvbHZlS2V5c1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHJlc29sdmVLZXlzKHJlc3BvbnNlKSB7XG4gICAgbGV0IHJwID0gcmVzcG9uc2UucnA7XG4gICAgbGV0IHByb3ZpZGVyID0gcnAucHJvdmlkZXI7XG4gICAgbGV0IGRlY29kZWQgPSByZXNwb25zZS5kZWNvZGVkO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvdmlkZXIuandrcykudGhlbihqd2tzID0+IGp3a3MgPyBqd2tzIDogcnAuandrcygpKS50aGVuKGp3a3MgPT4ge1xuICAgICAgaWYgKGRlY29kZWQucmVzb2x2ZUtleXMoandrcykpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXNvbHZlIHNpZ25pbmcga2V5IGZvciBJRCBUb2tlbicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiB2ZXJpZnlTaWduYXR1cmVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2ZXJpZnlTaWduYXR1cmUocmVzcG9uc2UpIHtcbiAgICBsZXQgYWxnID0gcmVzcG9uc2UuZGVjb2RlZC5oZWFkZXIuYWxnO1xuICAgIGxldCByZWdpc3RyYXRpb24gPSByZXNwb25zZS5ycC5yZWdpc3RyYXRpb247XG4gICAgbGV0IGV4cGVjdGVkQWxnb3JpdGhtID0gcmVnaXN0cmF0aW9uWydpZF90b2tlbl9zaWduZWRfcmVzcG9uc2VfYWxnJ10gfHwgJ1JTMjU2JzsgLy8gdmFsaWRhdGUgc2lnbmluZyBhbGdvcml0aG0gbWF0Y2hlcyBleHBlY3RhdGlvblxuXG4gICAgaWYgKGFsZyAhPT0gZXhwZWN0ZWRBbGdvcml0aG0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgSUQgVG9rZW4gdG8gYmUgc2lnbmVkIHdpdGggJHtleHBlY3RlZEFsZ29yaXRobX1gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2UuZGVjb2RlZC52ZXJpZnkoKS50aGVuKHZlcmlmaWVkID0+IHtcbiAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIElEIFRva2VuIHNpZ25hdHVyZScpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlRXhwaXJlc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuXG5cbiAgc3RhdGljIHZhbGlkYXRlRXhwaXJlcyhyZXNwb25zZSkge1xuICAgIGxldCBleHAgPSByZXNwb25zZS5kZWNvZGVkLnBheWxvYWQuZXhwOyAvLyB2YWxpZGF0ZSBleHBpcmF0aW9uIG9mIHRva2VuXG5cbiAgICBpZiAoZXhwIDw9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGlyZWQgSUQgVG9rZW4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZlcmlmeU5vbmNlXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmVyaWZ5Tm9uY2UocmVzcG9uc2UpIHtcbiAgICBsZXQgb2N0ZXRzID0gbmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UucmVxdWVzdC5ub25jZSk7XG4gICAgbGV0IG5vbmNlID0gcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkLm5vbmNlO1xuXG4gICAgaWYgKCFub25jZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIG5vbmNlIGluIElEIFRva2VuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGlnZXN0KHtcbiAgICAgIG5hbWU6ICdTSEEtMjU2J1xuICAgIH0sIG9jdGV0cykudGhlbihkaWdlc3QgPT4ge1xuICAgICAgaWYgKG5vbmNlICE9PSBiYXNlNjR1cmwoQnVmZmVyLmZyb20oZGlnZXN0KSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNtYXRjaGluZyBub25jZSBpbiBJRCBUb2tlbicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQWNyXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUFjcihyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQXV0aFRpbWVcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUF1dGhUaW1lKHJlc3BvbnNlKSB7XG4gICAgLy8gVE9ET1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfVxuICAvKipcbiAgICogdmFsaWRhdGVBY2Nlc3NUb2tlbkhhc2hcbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cblxuXG4gIHN0YXRpYyB2YWxpZGF0ZUFjY2Vzc1Rva2VuSGFzaChyZXNwb25zZSkge1xuICAgIC8vIFRPRE9cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cbiAgLyoqXG4gICAqIHZhbGlkYXRlQXV0aG9yaXphdGlvbkNvZGVIYXNoXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG5cblxuICBzdGF0aWMgdmFsaWRhdGVBdXRob3JpemF0aW9uQ29kZUhhc2gocmVzcG9uc2UpIHtcbiAgICAvLyBUT0RPXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9XG5cbn1cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhlbnRpY2F0aW9uUmVzcG9uc2U7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygyMCksIF9fd2VicGFja19yZXF1aXJlX18oNDEpLkJ1ZmZlcikpXG5cbi8qKiovIH0pLFxuLyogNzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuLyoqXG4gKiBMb2NhbCBkZXBlbmRlbmNpZXNcbiAqL1xuY29uc3Qge1xuICBKV1Rcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgSURUb2tlblNjaGVtYSA9IF9fd2VicGFja19yZXF1aXJlX18oNzIpO1xuLyoqXG4gKiBJRFRva2VuXG4gKi9cblxuXG5jbGFzcyBJRFRva2VuIGV4dGVuZHMgSldUIHtcbiAgLyoqXG4gICAqIFNjaGVtYVxuICAgKi9cbiAgc3RhdGljIGdldCBzY2hlbWEoKSB7XG4gICAgcmV0dXJuIElEVG9rZW5TY2hlbWE7XG4gIH1cblxufVxuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gSURUb2tlbjtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKipcbiAqIExvY2FsIGRlcGVuZGVuY2llc1xuICovXG5jb25zdCB7XG4gIEpXVFNjaGVtYVxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpO1xuLyoqXG4gKiBJRFRva2VuIFNjaGVtYVxuICovXG5cblxuY29uc3QgSURUb2tlblNjaGVtYSA9IEpXVFNjaGVtYS5leHRlbmQoe1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogaGVhZGVyXG4gICAgICogaHR0cDovL29wZW5pZC5uZXQvc3BlY3Mvb3BlbmlkLWNvbm5lY3QtY29yZS0xXzAuaHRtbCNJRFRva2VuXG4gICAgICogSUQgVG9rZW5zIFNIT1VMRCBOT1QgdXNlIHRoZSBKV1Mgb3IgSldFIHg1dSwgeDVjLCBqa3UsIG9yIGp3ayBIZWFkZXJcbiAgICAgKiBQYXJhbWV0ZXIgZmllbGRzLiBJbnN0ZWFkLCByZWZlcmVuY2VzIHRvIGtleXMgdXNlZCBhcmUgY29tbXVuaWNhdGVkIGluXG4gICAgICogYWR2YW5jZSB1c2luZyBEaXNjb3ZlcnkgYW5kIFJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzLCBwZXIgU2VjdGlvbiAxMC5cbiAgICAgKi9cbiAgICBoZWFkZXI6IHsvL25vdDogeyByZXF1aXJlZDogWyd4NXUnLCAneDVjJywgJ2prdScsICdqd2snXSB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHBheWxvYWRcbiAgICAgKi9cbiAgICBwYXlsb2FkOiB7XG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpc3NcbiAgICAgICAgICpcbiAgICAgICAgICogUkVRVUlSRUQuIElzc3VlciBJZGVudGlmaWVyIGZvciB0aGUgSXNzdWVyIG9mIHRoZSByZXNwb25zZS5cbiAgICAgICAgICogVGhlIGlzcyB2YWx1ZSBpcyBhIGNhc2Ugc2Vuc2l0aXZlIFVSTCB1c2luZyB0aGUgaHR0cHMgc2NoZW1lXG4gICAgICAgICAqIHRoYXQgY29udGFpbnMgc2NoZW1lLCBob3N0LCBhbmQgb3B0aW9uYWxseSwgcG9ydCBudW1iZXIgYW5kXG4gICAgICAgICAqIHBhdGggY29tcG9uZW50cyBhbmQgbm8gcXVlcnkgb3IgZnJhZ21lbnQgY29tcG9uZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIGlzczoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ3VybCdcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogc3ViXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBTdWJqZWN0IElkZW50aWZpZXIuIEEgbG9jYWxseSB1bmlxdWUgYW5kIG5ldmVyXG4gICAgICAgICAqIHJlYXNzaWduZWQgaWRlbnRpZmllciB3aXRoaW4gdGhlIElzc3VlciBmb3IgdGhlIEVuZC1Vc2VyLCB3aGljaFxuICAgICAgICAgKiBpcyBpbnRlbmRlZCB0byBiZSBjb25zdW1lZCBieSB0aGUgQ2xpZW50LCBlLmcuLCAyNDQwMDMyMCBvclxuICAgICAgICAgKiBBSXRPYXdtd3RXd2NUMGs1MUJheWV3TnZ1dHJKVXFzdmw2cXM3QTQuIEl0IE1VU1QgTk9UIGV4Y2VlZCAyNTVcbiAgICAgICAgICogQVNDSUkgY2hhcmFjdGVycyBpbiBsZW5ndGguIFRoZSBzdWIgdmFsdWUgaXMgYSBjYXNlIHNlbnNpdGl2ZVxuICAgICAgICAgKiBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBzdWI6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBtYXhMZW5ndGg6IDI1NVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhdWRcbiAgICAgICAgICpcbiAgICAgICAgICogUkVRVUlSRUQuIEF1ZGllbmNlKHMpIHRoYXQgdGhpcyBJRCBUb2tlbiBpcyBpbnRlbmRlZCBmb3IuIEl0XG4gICAgICAgICAqIE1VU1QgY29udGFpbiB0aGUgT0F1dGggMi4wIGNsaWVudF9pZCBvZiB0aGUgUmVseWluZyBQYXJ0eSBhcyBhblxuICAgICAgICAgKiBhdWRpZW5jZSB2YWx1ZS4gSXQgTUFZIGFsc28gY29udGFpbiBpZGVudGlmaWVycyBmb3Igb3RoZXIgYXVkaWVuY2VzLlxuICAgICAgICAgKiBJbiB0aGUgZ2VuZXJhbCBjYXNlLCB0aGUgYXVkIHZhbHVlIGlzIGFuIGFycmF5IG9mIGNhc2Ugc2Vuc2l0aXZlXG4gICAgICAgICAqIHN0cmluZ3MuIEluIHRoZSBjb21tb24gc3BlY2lhbCBjYXNlIHdoZW4gdGhlcmUgaXMgb25lIGF1ZGllbmNlLFxuICAgICAgICAgKiB0aGUgYXVkIHZhbHVlIE1BWSBiZSBhIHNpbmdsZSBjYXNlIHNlbnNpdGl2ZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICAvLyBpbmhlcml0ZWQgZnJvbSBKV1RDbGFpbXNTZXRTY2hlbWFcblxuICAgICAgICAvKipcbiAgICAgICAgICogZXhwXG4gICAgICAgICAqXG4gICAgICAgICAqIFJFUVVJUkVELiBFeHBpcmF0aW9uIHRpbWUgb24gb3IgYWZ0ZXIgd2hpY2ggdGhlIElEIFRva2VuIE1VU1QgTk9UXG4gICAgICAgICAqIGJlIGFjY2VwdGVkIGZvciBwcm9jZXNzaW5nLiBUaGUgcHJvY2Vzc2luZyBvZiB0aGlzIHBhcmFtZXRlclxuICAgICAgICAgKiByZXF1aXJlcyB0aGF0IHRoZSBjdXJyZW50IGRhdGUvdGltZSBNVVNUIGJlIGJlZm9yZSB0aGUgZXhwaXJhdGlvblxuICAgICAgICAgKiBkYXRlL3RpbWUgbGlzdGVkIGluIHRoZSB2YWx1ZS4gSW1wbGVtZW50ZXJzIE1BWSBwcm92aWRlIGZvciBzb21lXG4gICAgICAgICAqIHNtYWxsIGxlZXdheSwgdXN1YWxseSBubyBtb3JlIHRoYW4gYSBmZXcgbWludXRlcywgdG8gYWNjb3VudCBmb3JcbiAgICAgICAgICogY2xvY2sgc2tldy4gSXRzIHZhbHVlIGlzIGEgSlNPTiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2ZcbiAgICAgICAgICogc2Vjb25kcyBmcm9tIDE5NzAtMDEtMDFUMDowOjBaIGFzIG1lYXN1cmVkIGluIFVUQyB1bnRpbCB0aGVcbiAgICAgICAgICogZGF0ZS90aW1lLiBTZWUgUkZDIDMzMzkgW1JGQzMzMzldIGZvciBkZXRhaWxzIHJlZ2FyZGluZyBkYXRlL3RpbWVzXG4gICAgICAgICAqIGluIGdlbmVyYWwgYW5kIFVUQyBpbiBwYXJ0aWN1bGFyLlxuICAgICAgICAgKi9cbiAgICAgICAgLy8gaW5oZXJpdGVkIGZyb20gSldUQ2xhaW1zU2V0U2NoZW1hXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGlhdFxuICAgICAgICAgKlxuICAgICAgICAgKiBSRVFVSVJFRC4gVGltZSBhdCB3aGljaCB0aGUgSldUIHdhcyBpc3N1ZWQuIEl0cyB2YWx1ZSBpcyBhXG4gICAgICAgICAqIEpTT04gbnVtYmVyIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZnJvbVxuICAgICAgICAgKiAxOTcwLTAxLTAxVDA6MDowWiBhcyBtZWFzdXJlZCBpbiBVVEMgdW50aWwgdGhlIGRhdGUvdGltZS5cbiAgICAgICAgICovXG4gICAgICAgIC8vIGluaGVyaXRlZCBmcm9tIEpXVENsYWltc1NldFNjaGVtYVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBhdXRoX3RpbWVcbiAgICAgICAgICpcbiAgICAgICAgICogVGltZSB3aGVuIHRoZSBFbmQtVXNlciBhdXRoZW50aWNhdGlvbiBvY2N1cnJlZC4gSXRzIHZhbHVlIGlzIGFcbiAgICAgICAgICogSlNPTiBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSBudW1iZXIgb2Ygc2Vjb25kcyBmcm9tXG4gICAgICAgICAqIDE5NzAtMDEtMDFUMDowOjBaIGFzIG1lYXN1cmVkIGluIFVUQyB1bnRpbCB0aGUgZGF0ZS90aW1lLiBXaGVuIGFcbiAgICAgICAgICogbWF4X2FnZSByZXF1ZXN0IGlzIG1hZGUgb3Igd2hlbiBhdXRoX3RpbWUgaXMgcmVxdWVzdGVkIGFzIGFuXG4gICAgICAgICAqIEVzc2VudGlhbCBDbGFpbSwgdGhlbiB0aGlzIENsYWltIGlzIFJFUVVJUkVEOyBvdGhlcndpc2UsIGl0c1xuICAgICAgICAgKiBpbmNsdXNpb24gaXMgT1BUSU9OQUwuIChUaGUgYXV0aF90aW1lIENsYWltIHNlbWFudGljYWxseVxuICAgICAgICAgKiBjb3JyZXNwb25kcyB0byB0aGUgT3BlbklEIDIuMCBQQVBFIFtPcGVuSUQuUEFQRV0gYXV0aF90aW1lXG4gICAgICAgICAqIHJlc3BvbnNlIHBhcmFtZXRlci4pXG4gICAgICAgICAqL1xuICAgICAgICBhdXRoX3RpbWU6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZm9ybWF0OiAnTnVtZXJpY0RhdGUnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIG5vbmNlXG4gICAgICAgICAqXG4gICAgICAgICAqIFN0cmluZyB2YWx1ZSB1c2VkIHRvIGFzc29jaWF0ZSBhIENsaWVudCBzZXNzaW9uIHdpdGggYW4gSUQgVG9rZW4sXG4gICAgICAgICAqIGFuZCB0byBtaXRpZ2F0ZSByZXBsYXkgYXR0YWNrcy4gVGhlIHZhbHVlIGlzIHBhc3NlZCB0aHJvdWdoXG4gICAgICAgICAqIHVubW9kaWZpZWQgZnJvbSB0aGUgQXV0aGVudGljYXRpb24gUmVxdWVzdCB0byB0aGUgSUQgVG9rZW4uIElmXG4gICAgICAgICAqIHByZXNlbnQgaW4gdGhlIElEIFRva2VuLCBDbGllbnRzIE1VU1QgdmVyaWZ5IHRoYXQgdGhlIG5vbmNlIENsYWltXG4gICAgICAgICAqIFZhbHVlIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiB0aGUgbm9uY2UgcGFyYW1ldGVyIHNlbnQgaW4gdGhlXG4gICAgICAgICAqIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QuIElmIHByZXNlbnQgaW4gdGhlIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QsXG4gICAgICAgICAqIEF1dGhvcml6YXRpb24gU2VydmVycyBNVVNUIGluY2x1ZGUgYSBub25jZSBDbGFpbSBpbiB0aGUgSUQgVG9rZW5cbiAgICAgICAgICogd2l0aCB0aGUgQ2xhaW0gVmFsdWUgYmVpbmcgdGhlIG5vbmNlIHZhbHVlIHNlbnQgaW4gdGhlXG4gICAgICAgICAqIEF1dGhlbnRpY2F0aW9uIFJlcXVlc3QuIEF1dGhvcml6YXRpb24gU2VydmVycyBTSE9VTEQgcGVyZm9ybSBub1xuICAgICAgICAgKiBvdGhlciBwcm9jZXNzaW5nIG9uIG5vbmNlIHZhbHVlcyB1c2VkLiBUaGUgbm9uY2UgdmFsdWUgaXMgYSBjYXNlXG4gICAgICAgICAqIHNlbnNpdGl2ZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBub25jZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjclxuICAgICAgICAgKlxuICAgICAgICAgKiBPUFRJT05BTC4gQXV0aGVudGljYXRpb24gQ29udGV4dCBDbGFzcyBSZWZlcmVuY2UuIFN0cmluZ1xuICAgICAgICAgKiBzcGVjaWZ5aW5nIGFuIEF1dGhlbnRpY2F0aW9uIENvbnRleHQgQ2xhc3MgUmVmZXJlbmNlIHZhbHVlIHRoYXRcbiAgICAgICAgICogaWRlbnRpZmllcyB0aGUgQXV0aGVudGljYXRpb24gQ29udGV4dCBDbGFzcyB0aGF0IHRoZSBhdXRoZW50aWNhdGlvblxuICAgICAgICAgKiBwZXJmb3JtZWQgc2F0aXNmaWVkLiBUaGUgdmFsdWUgXCIwXCIgaW5kaWNhdGVzIHRoZSBFbmQtVXNlclxuICAgICAgICAgKiBhdXRoZW50aWNhdGlvbiBkaWQgbm90IG1lZXQgdGhlIHJlcXVpcmVtZW50cyBvZiBJU08vSUVDIDI5MTE1XG4gICAgICAgICAqIFtJU08yOTExNV0gbGV2ZWwgMS4gQXV0aGVudGljYXRpb24gdXNpbmcgYSBsb25nLWxpdmVkIGJyb3dzZXJcbiAgICAgICAgICogY29va2llLCBmb3IgaW5zdGFuY2UsIGlzIG9uZSBleGFtcGxlIHdoZXJlIHRoZSB1c2Ugb2YgXCJsZXZlbCAwXCIgaXNcbiAgICAgICAgICogYXBwcm9wcmlhdGUuIEF1dGhlbnRpY2F0aW9ucyB3aXRoIGxldmVsIDAgU0hPVUxEIE5PVCBiZSB1c2VkIHRvXG4gICAgICAgICAqIGF1dGhvcml6ZSBhY2Nlc3MgdG8gYW55IHJlc291cmNlIG9mIGFueSBtb25ldGFyeSB2YWx1ZS4gKFRoaXNcbiAgICAgICAgICogY29ycmVzcG9uZHMgdG8gdGhlIE9wZW5JRCAyLjAgUEFQRSBbT3BlbklELlBBUEVdIG5pc3RfYXV0aF9sZXZlbFxuICAgICAgICAgKiAwLikgQW4gYWJzb2x1dGUgVVJJIG9yIGFuIFJGQyA2NzExIFtSRkM2NzExXSByZWdpc3RlcmVkIG5hbWVcbiAgICAgICAgICogU0hPVUxEIGJlIHVzZWQgYXMgdGhlIGFjciB2YWx1ZTsgcmVnaXN0ZXJlZCBuYW1lcyBNVVNUIE5PVCBiZSB1c2VkXG4gICAgICAgICAqIHdpdGggYSBkaWZmZXJlbnQgbWVhbmluZyB0aGFuIHRoYXQgd2hpY2ggaXMgcmVnaXN0ZXJlZC4gUGFydGllc1xuICAgICAgICAgKiB1c2luZyB0aGlzIGNsYWltIHdpbGwgbmVlZCB0byBhZ3JlZSB1cG9uIHRoZSBtZWFuaW5ncyBvZiB0aGVcbiAgICAgICAgICogdmFsdWVzIHVzZWQsIHdoaWNoIG1heSBiZSBjb250ZXh0LXNwZWNpZmljLiBUaGUgYWNyIHZhbHVlIGlzIGFcbiAgICAgICAgICogY2FzZSBzZW5zaXRpdmUgc3RyaW5nLlxuICAgICAgICAgKi9cbiAgICAgICAgYWNyOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogYW1yXG4gICAgICAgICAqIE9QVElPTkFMLiBBdXRoZW50aWNhdGlvbiBNZXRob2RzIFJlZmVyZW5jZXMuIEpTT04gYXJyYXkgb2Ygc3RyaW5nc1xuICAgICAgICAgKiB0aGF0IGFyZSBpZGVudGlmaWVycyBmb3IgYXV0aGVudGljYXRpb24gbWV0aG9kcyB1c2VkIGluIHRoZVxuICAgICAgICAgKiBhdXRoZW50aWNhdGlvbi4gRm9yIGluc3RhbmNlLCB2YWx1ZXMgbWlnaHQgaW5kaWNhdGUgdGhhdCBib3RoXG4gICAgICAgICAqIHBhc3N3b3JkIGFuZCBPVFAgYXV0aGVudGljYXRpb24gbWV0aG9kcyB3ZXJlIHVzZWQuIFRoZSBkZWZpbml0aW9uXG4gICAgICAgICAqIG9mIHBhcnRpY3VsYXIgdmFsdWVzIHRvIGJlIHVzZWQgaW4gdGhlIGFtciBDbGFpbSBpcyBiZXlvbmQgdGhlXG4gICAgICAgICAqIHNjb3BlIG9mIHRoaXMgc3BlY2lmaWNhdGlvbi4gUGFydGllcyB1c2luZyB0aGlzIGNsYWltIHdpbGwgbmVlZCB0b1xuICAgICAgICAgKiBhZ3JlZSB1cG9uIHRoZSBtZWFuaW5ncyBvZiB0aGUgdmFsdWVzIHVzZWQsIHdoaWNoIG1heSBiZSBjb250ZXh0LVxuICAgICAgICAgKiBzcGVjaWZpYy4gVGhlIGFtciB2YWx1ZSBpcyBhbiBhcnJheSBvZiBjYXNlIHNlbnNpdGl2ZSBzdHJpbmdzLlxuICAgICAgICAgKi9cbiAgICAgICAgYW1yOiB7XG4gICAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgICBpdGVtczoge1xuICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGF6cFxuICAgICAgICAgKiBPUFRJT05BTC4gQXV0aG9yaXplZCBwYXJ0eSAtIHRoZSBwYXJ0eSB0byB3aGljaCB0aGUgSUQgVG9rZW4gd2FzXG4gICAgICAgICAqIGlzc3VlZC4gSWYgcHJlc2VudCwgaXQgTVVTVCBjb250YWluIHRoZSBPQXV0aCAyLjAgQ2xpZW50IElEIG9mIHRoaXNcbiAgICAgICAgICogcGFydHkuIFRoaXMgQ2xhaW0gaXMgb25seSBuZWVkZWQgd2hlbiB0aGUgSUQgVG9rZW4gaGFzIGEgc2luZ2xlXG4gICAgICAgICAqIGF1ZGllbmNlIHZhbHVlIGFuZCB0aGF0IGF1ZGllbmNlIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBhdXRob3JpemVkXG4gICAgICAgICAqIHBhcnR5LiBJdCBNQVkgYmUgaW5jbHVkZWQgZXZlbiB3aGVuIHRoZSBhdXRob3JpemVkIHBhcnR5IGlzIHRoZVxuICAgICAgICAgKiBzYW1lIGFzIHRoZSBzb2xlIGF1ZGllbmNlLiBUaGUgYXpwIHZhbHVlIGlzIGEgY2FzZSBzZW5zaXRpdmUgc3RyaW5nXG4gICAgICAgICAqIGNvbnRhaW5pbmcgYSBTdHJpbmdPclVSSSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGF6cDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ1N0cmluZ09yVVJJJ1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFJlcXVpcmVkIENsYWltc1xuICAgICAgICovXG4gICAgICByZXF1aXJlZDogWydpc3MnLCAnc3ViJywgJ2F1ZCcsICdleHAnLCAnaWF0J11cbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IElEVG9rZW5TY2hlbWE7XG5cbi8qKiovIH0pLFxuLyogNzMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cblxuY29uc3QgZmV0Y2ggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG5jb25zdCBvbkh0dHBFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzQpO1xuXG5jb25zdCBQb1BUb2tlbiA9IF9fd2VicGFja19yZXF1aXJlX18oNzUpO1xuXG5jbGFzcyBTZXNzaW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9XG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmNyZWRlbnRpYWxUeXBlIHtzdHJpbmd9ICdhY2Nlc3NfdG9rZW4nIG9yICdwb3BfdG9rZW4nXG4gICAqXG4gICAqIEBwYXJhbSBvcHRpb25zLmlzc3VlciB7c3RyaW5nfSBJZGVudGl0eSBwcm92aWRlciAoaXNzdWVyIG9mIElEL0FjY2VzcyBUb2tlbilcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuYXV0aG9yaXphdGlvbiB7b2JqZWN0fVxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdXRob3JpemF0aW9uLmNsaWVudF9pZCB7c3RyaW5nfSBPSURDL09BdXRoMiBjbGllbnQgaWRcbiAgICogQHBhcmFtIFtvcHRpb25zLmF1dGhvcml6YXRpb24uaWRfdG9rZW5dIHtzdHJpbmd9IENvbXBhY3Qtc2VyaWFsaXplZCBpZF90b2tlbiBwYXJhbVxuICAgKiBAcGFyYW0gW29wdGlvbnMuYXV0aG9yaXphdGlvbi5hY2Nlc3NfdG9rZW5dIHtzdHJpbmd9IENvbXBhY3Qtc2VyaWFsaXplZCBhY2Nlc3NfdG9rZW4gcGFyYW1cbiAgICogQHBhcmFtIFtvcHRpb25zLmF1dGhvcml6YXRpb24ucmVmcmVzaF90b2tlbl0ge3N0cmluZ30gQ29tcGFjdC1zZXJpYWxpemVkIHJlZnJlc2hfdG9rZW5cbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLnNlc3Npb25LZXldIHtzdHJpbmd9IFNlcmlhbGl6ZWQgY2xpZW50IHNlc3Npb24ga2V5IGdlbmVyYXRlZFxuICAgKiAgIGR1cmluZyB0aGUgQXV0aGVudGljYXRpb24gUmVxdWVzdCwgdXNlZCB0byBpc3N1ZSBQb1BUb2tlbnNcbiAgICpcbiAgICogQHBhcmFtIFtvcHRpb25zLmlkQ2xhaW1zXSB7b2JqZWN0fSBEZWNvZGVkL3ZlcmlmaWVkIElEIFRva2VuIEpXVCBwYXlsb2FkXG4gICAqXG4gICAqIEBwYXJhbSBbb3B0aW9ucy5hY2Nlc3NDbGFpbXNdIHtvYmplY3R9IERlY29kZWQvdmVyaWZpZWQgQWNjZXNzIFRva2VuIEpXVCBwYXlsb2FkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5jcmVkZW50aWFsVHlwZSA9IG9wdGlvbnMuY3JlZGVudGlhbFR5cGUgfHwgJ2FjY2Vzc190b2tlbic7XG4gICAgdGhpcy5pc3N1ZXIgPSBvcHRpb25zLmlzc3VlcjtcbiAgICB0aGlzLmF1dGhvcml6YXRpb24gPSBvcHRpb25zLmF1dGhvcml6YXRpb24gfHwge307XG4gICAgdGhpcy5zZXNzaW9uS2V5ID0gb3B0aW9ucy5zZXNzaW9uS2V5O1xuICAgIHRoaXMuaWRDbGFpbXMgPSBvcHRpb25zLmlkQ2xhaW1zO1xuICAgIHRoaXMuYWNjZXNzQ2xhaW1zID0gb3B0aW9ucy5hY2Nlc3NDbGFpbXM7XG4gIH1cblxuICBzdGF0aWMgZnJvbShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTZXNzaW9uKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0gcmVzcG9uc2Uge0F1dGhlbnRpY2F0aW9uUmVzcG9uc2V9XG4gICAqXG4gICAqIEByZXR1cm5zIHtTZXNzaW9ufSBSZWx5aW5nUGFydHkgU2Vzc2lvbiBvYmplY3RcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbUF1dGhSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnN0IFJlbHlpbmdQYXJ0eSA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpOyAvLyBpbXBvcnQgaGVyZSBkdWUgdG8gY2lyY3VsYXIgZGVwXG5cblxuICAgIGxldCBpZENsYWltcyA9IHJlc3BvbnNlLmRlY29kZWQgJiYgcmVzcG9uc2UuZGVjb2RlZC5wYXlsb2FkIHx8IHt9O1xuICAgIGxldCB7XG4gICAgICBycFxuICAgIH0gPSByZXNwb25zZTtcbiAgICBsZXQgcmVnaXN0cmF0aW9uID0gcnAucmVnaXN0cmF0aW9uO1xuICAgIGxldCBycEF1dGhPcHRpb25zID0gcnAuZGVmYXVsdHMuYXV0aGVudGljYXRlIHx8IHt9O1xuICAgIGxldCBjcmVkZW50aWFsVHlwZSA9IHJwQXV0aE9wdGlvbnNbJ2NyZWRlbnRpYWxfdHlwZSddIHx8IHJwLmRlZmF1bHRzLnBvcFRva2VuID8gJ3BvcF90b2tlbicgOiAnYWNjZXNzX3Rva2VuJztcbiAgICBsZXQgc2Vzc2lvbktleSA9IHJlc3BvbnNlLnNlc3Npb25bUmVseWluZ1BhcnR5LlNFU1NJT05fUFJJVkFURV9LRVldO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgY3JlZGVudGlhbFR5cGUsXG4gICAgICBzZXNzaW9uS2V5LFxuICAgICAgaXNzdWVyOiBpZENsYWltcy5pc3MsXG4gICAgICBpZENsYWltcyxcbiAgICAgIGF1dGhvcml6YXRpb246IHtcbiAgICAgICAgY2xpZW50X2lkOiByZWdpc3RyYXRpb25bJ2NsaWVudF9pZCddLFxuICAgICAgICBhY2Nlc3NfdG9rZW46IHJlc3BvbnNlLnBhcmFtc1snYWNjZXNzX3Rva2VuJ10sXG4gICAgICAgIGlkX3Rva2VuOiByZXNwb25zZS5wYXJhbXNbJ2lkX3Rva2VuJ10sXG4gICAgICAgIHJlZnJlc2hfdG9rZW46IHJlc3BvbnNlLnBhcmFtc1sncmVmcmVzaF90b2tlbiddXG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2Vzc2lvbi5mcm9tKG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGVkIGZldGNoKCkgZ2V0dGVyXG4gICAqXG4gICAqIEByZXR1cm5zIHtmdW5jdGlvbn1cbiAgICovXG5cblxuICBnZXQgZmV0Y2goKSB7XG4gICAgLyoqXG4gICAgICogZmV0Y2goKSBmdW5jdGlvbiBzaWduYXR1cmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwge1JlcXVlc3RJbmZvfHN0cmluZ31cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB7b2JqZWN0fVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9uPFByb21pc2U8UmVzcG9uc2U+Pn1cbiAgICAgKi9cbiAgICByZXR1cm4gKHVybCwgb3B0aW9ucykgPT4ge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5oYXNDcmVkZW50aWFscygpKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hXaXRoQ3JlZGVudGlhbHModXJsLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgfSkudGhlbihvbkh0dHBFcnJvcignRXJyb3Igd2hpbGUgZmV0Y2hpbmcgcmVzb3VyY2UnKSk7XG4gICAgfTtcbiAgfVxuICAvKipcbiAgICogYmVhcmVyVG9rZW5Gb3JcbiAgICpcbiAgICogQHBhcmFtIHVybCB7c3RyaW5nfVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fVxuICAgKi9cblxuXG4gIGJlYXJlclRva2VuRm9yKHVybCkge1xuICAgIHN3aXRjaCAodGhpcy5jcmVkZW50aWFsVHlwZSkge1xuICAgICAgY2FzZSAncG9wX3Rva2VuJzpcbiAgICAgICAgcmV0dXJuIFBvUFRva2VuLmlzc3VlRm9yKHVybCwgdGhpcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIC8vICdhY2Nlc3NfdG9rZW4nIGV0Y1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYXV0aG9yaXphdGlvblt0aGlzLmNyZWRlbnRpYWxUeXBlXSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBoYXNDcmVkZW50aWFsc1xuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG5cblxuICBoYXNDcmVkZW50aWFscygpIHtcbiAgICBzd2l0Y2ggKHRoaXMuY3JlZGVudGlhbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3BvcF90b2tlbic6XG4gICAgICAgIHJldHVybiAhIXRoaXMuYXV0aG9yaXphdGlvblsnaWRfdG9rZW4nXTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gJ2FjY2Vzc190b2tlbicgZXRjXG4gICAgICAgIHJldHVybiAhIXRoaXMuYXV0aG9yaXphdGlvblt0aGlzLmNyZWRlbnRpYWxUeXBlXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIGZldGNoV2l0aENyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBwYXJhbSB1cmwge1JlcXVlc3RJbmZvfHN0cmluZ31cbiAgICogQHBhcmFtIG9wdGlvbnMge29iamVjdH1cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2U8UmVzcG9uc2U+fVxuICAgKi9cblxuXG4gIGZldGNoV2l0aENyZWRlbnRpYWxzKHVybCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHJldHVybiB0aGlzLmJlYXJlclRva2VuRm9yKHVybCkudGhlbih0b2tlbiA9PiB7XG4gICAgICBvcHRpb25zLmhlYWRlcnMuYXV0aG9yaXphdGlvbiA9IGBCZWFyZXIgJHt0b2tlbn1gO1xuICAgICAgcmV0dXJuIGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlc3Npb247XG5cbi8qKiovIH0pLFxuLyogNzQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogVGhyb3dzIGFuIGVycm9yIHdoZW4gYSBmZXRjaCByZXNwb25zZSBzdGF0dXMgY29kZSBpbmRpY2F0ZXMgYSA0MDAgb3IgNTAwXG4gKiBIVFRQIGVycm9yLiAoVGhlIHdoYXR3ZyBmZXRjaCBhcGkgZG9lcyBub3Qgbm9ybWFsbHkgcmVqZWN0IG9uIGh0dHAgZXJyb3JcbiAqIHJlc3BvbnNlcykuXG4gKlxuICogVXNhZ2U6XG4gKlxuICogYGBgXG4gKiByZXR1cm4gZmV0Y2godXJsKVxuICogICAudGhlbihvbkh0dHBFcnJvcignRXJyb3Igd2hpbGUgZmV0Y2hpbmcgcmVzb3VyY2UnKVxuICogICAuY2F0Y2goZXJyID0+IGNvbnNvbGUubG9nKGVycikpXG4gKlxuICogLy8gLT4gJ0Vycm9yIHdoaWxlIGZldGNoaW5nIHJlc291cmNlOiA0MDQgTm90IEZvdW5kJyBlcnJvclxuICogLy8gaWYgYSA0MDQgcmVzcG9uc2UgaXMgZW5jb3VudGVyZWRcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBbbWVzc2FnZV0ge3N0cmluZ30gT3B0aW9uYWwgZXJyb3IgbWVzc2FnZSB0byBjbGFyaWZ5IGNvbnRleHRcbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gRm9yIGh0dHAgc3RhdHVzIGNvZGVzID4gMzAwXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBmZXRjaCByZXNwb25zZSBvYmplY3QgKHBhc3NlZCB0aHJvdWdoIGlmIG5vIGVycm9yKVxuICovXG5cbmZ1bmN0aW9uIG9uSHR0cEVycm9yKG1lc3NhZ2UgPSAnZmV0Y2ggZXJyb3InKSB7XG4gIHJldHVybiByZXNwb25zZSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA+PSAyMDAgJiYgcmVzcG9uc2Uuc3RhdHVzIDwgMzAwKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IGAke21lc3NhZ2V9OiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWA7XG4gICAgbGV0IGVycm9yID0gbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgICBlcnJvci5zdGF0dXNDb2RlID0gcmVzcG9uc2Uuc3RhdHVzO1xuICAgIHRocm93IGVycm9yO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9uSHR0cEVycm9yO1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5cbmNvbnN0IHtcbiAgVVJMXG59ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNyk7XG5cbmNvbnN0IHtcbiAgSldULFxuICBKV0tcbn0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KTtcblxuY29uc3QgREVGQVVMVF9NQVhfQUdFID0gMzYwMDsgLy8gRGVmYXVsdCB0b2tlbiBleHBpcmF0aW9uLCBpbiBzZWNvbmRzXG5cbmNsYXNzIFBvUFRva2VuIGV4dGVuZHMgSldUIHtcbiAgLyoqXG4gICAqIEBwYXJhbSByZXNvdXJjZVNlcnZlclVyaSB7c3RyaW5nfSBSUyBVUkkgZm9yIHdoaWNoIHRoaXMgdG9rZW4gaXMgaW50ZW5kZWRcbiAgICpcbiAgICogQHBhcmFtIHNlc3Npb24ge1Nlc3Npb259XG4gICAqIEBwYXJhbSBzZXNzaW9uLnNlc3Npb25LZXkge3N0cmluZ31cbiAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQge3N0cmluZ31cbiAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5pZF90b2tlbiB7c3RyaW5nfVxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQb1BUb2tlbiwgZW5jb2RlZCBhcyBjb21wYWN0IEpXVFxuICAgKi9cbiAgc3RhdGljIGlzc3VlRm9yKHJlc291cmNlU2VydmVyVXJpLCBzZXNzaW9uKSB7XG4gICAgaWYgKCFyZXNvdXJjZVNlcnZlclVyaSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHJlc291cmNlIHNlcnZlciBVUkknKTtcbiAgICB9XG5cbiAgICBpZiAoIXNlc3Npb24uc2Vzc2lvbktleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIHNlc3Npb24ga2V5Jyk7XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGlzc3VlIFBvUFRva2VuIC0gbWlzc2luZyBpZCB0b2tlbicpO1xuICAgIH1cblxuICAgIGxldCBqd2sgPSBKU09OLnBhcnNlKHNlc3Npb24uc2Vzc2lvbktleSk7XG4gICAgcmV0dXJuIEpXSy5pbXBvcnRLZXkoandrKS50aGVuKGltcG9ydGVkU2Vzc2lvbkp3ayA9PiB7XG4gICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgYXVkOiBuZXcgVVJMKHJlc291cmNlU2VydmVyVXJpKS5vcmlnaW4sXG4gICAgICAgIGtleTogaW1wb3J0ZWRTZXNzaW9uSndrLFxuICAgICAgICBpc3M6IHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQsXG4gICAgICAgIGlkX3Rva2VuOiBzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW5cbiAgICAgIH07XG4gICAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWUob3B0aW9ucyk7XG4gICAgfSkudGhlbihqd3QgPT4ge1xuICAgICAgcmV0dXJuIGp3dC5lbmNvZGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogaXNzdWVcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICogQHBhcmFtIG9wdGlvbnMuaXNzIHtzdHJpbmd9IFRva2VuIGlzc3VlciAoUlAgY2xpZW50X2lkKVxuICAgKiBAcGFyYW0gb3B0aW9ucy5hdWQge3N0cmluZ3xBcnJheTxzdHJpbmc+fSBBdWRpZW5jZSBmb3IgdGhlIHRva2VuXG4gICAqICAgKHN1Y2ggYXMgdGhlIFJlc291cmNlIFNlcnZlciB1cmwpXG4gICAqIEBwYXJhbSBvcHRpb25zLmtleSB7SldLfSBQcm9vZiBvZiBQb3NzZXNzaW9uIChwcml2YXRlKSBzaWduaW5nIGtleSwgc2VlXG4gICAqICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzc4MDAjc2VjdGlvbi0zLjFcbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMuaWRfdG9rZW4ge3N0cmluZ30gSldUIGNvbXBhY3QgZW5jb2RlZCBJRCBUb2tlblxuICAgKlxuICAgKiBPcHRpb25hbDpcbiAgICogQHBhcmFtIFtvcHRpb25zLmlhdF0ge251bWJlcn0gSXNzdWVkIGF0IHRpbWVzdGFtcCAoaW4gc2Vjb25kcylcbiAgICogQHBhcmFtIFtvcHRpb25zLm1heF0ge251bWJlcn0gTWF4IHRva2VuIGxpZmV0aW1lIGluIHNlY29uZHNcbiAgICpcbiAgICogQHJldHVybnMge1BvUFRva2VufSBQcm9vZiBvZiBQb3NzZXNzaW9uIFRva2VuIChKV1QgaW5zdGFuY2UpXG4gICAqL1xuXG5cbiAgc3RhdGljIGlzc3VlKG9wdGlvbnMpIHtcbiAgICBsZXQge1xuICAgICAgYXVkLFxuICAgICAgaXNzLFxuICAgICAga2V5XG4gICAgfSA9IG9wdGlvbnM7XG4gICAgbGV0IGFsZyA9IGtleS5hbGc7XG4gICAgbGV0IGlhdCA9IG9wdGlvbnMuaWF0IHx8IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xuICAgIGxldCBtYXggPSBvcHRpb25zLm1heCB8fCBERUZBVUxUX01BWF9BR0U7XG4gICAgbGV0IGV4cCA9IGlhdCArIG1heDsgLy8gdG9rZW4gZXhwaXJhdGlvblxuXG4gICAgbGV0IGhlYWRlciA9IHtcbiAgICAgIGFsZ1xuICAgIH07XG4gICAgbGV0IHBheWxvYWQgPSB7XG4gICAgICBpc3MsXG4gICAgICBhdWQsXG4gICAgICBleHAsXG4gICAgICBpYXQsXG4gICAgICBpZF90b2tlbjogb3B0aW9ucy5pZF90b2tlbixcbiAgICAgIHRva2VuX3R5cGU6ICdwb3AnXG4gICAgfTtcbiAgICBsZXQgand0ID0gbmV3IFBvUFRva2VuKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHBheWxvYWQsXG4gICAgICBrZXk6IGtleS5jcnlwdG9LZXlcbiAgICB9LCB7XG4gICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgfSk7XG4gICAgcmV0dXJuIGp3dDtcbiAgfVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gUG9QVG9rZW47XG5cbi8qKiovIH0pLFxuLyogNzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSHR0cEVycm9yXG52YXIgU3RhbmRhcmRFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oNzcpXG52YXIgU1RBVFVTX0NPREVfVE9fTkFNRSA9IF9fd2VicGFja19yZXF1aXJlX18oNzgpXG52YXIgU1RBVFVTX05BTUVfVE9fQ09ERSA9IGV4cG9ydHNcblxuZnVuY3Rpb24gSHR0cEVycm9yKGNvZGUsIG1zZywgcHJvcHMpIHtcbiAgaWYgKHR5cGVvZiBjb2RlID09IFwic3RyaW5nXCIpIGNvZGUgPSBTVEFUVVNfTkFNRV9UT19DT0RFW2NvZGVdXG4gIGlmICh0eXBlb2YgY29kZSAhPSBcIm51bWJlclwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTm9uLW51bWVyaWMgSFRUUCBjb2RlXCIpXG4gIGlmICh0eXBlb2YgbXNnID09IFwib2JqZWN0XCIgJiYgbXNnICE9IG51bGwpIHsgcHJvcHMgPSBtc2c7IG1zZyA9IG51bGwgfVxuICBTdGFuZGFyZEVycm9yLmNhbGwodGhpcywgbXNnIHx8IFNUQVRVU19DT0RFX1RPX05BTUVbY29kZV0sIHByb3BzKVxuICB0aGlzLmNvZGUgPSBjb2RlXG59XG5cbkh0dHBFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFN0YW5kYXJkRXJyb3IucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7dmFsdWU6IEh0dHBFcnJvciwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX1cbn0pXG5cbi8vIFNldCBuYW1lIGV4cGxpY2l0bHkgZm9yIHdoZW4gdGhlIGNvZGUgZ2V0cyBtaW5pZmllZC5cbkh0dHBFcnJvci5wcm90b3R5cGUubmFtZSA9IFwiSHR0cEVycm9yXCJcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoSHR0cEVycm9yLnByb3RvdHlwZSwge1xuICBzdGF0dXNDb2RlOiBhbGlhcyhcImNvZGVcIiksXG4gIHN0YXR1c01lc3NhZ2U6IGFsaWFzKFwibWVzc2FnZVwiKSxcblxuICBzdGF0dXM6IHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29kZSB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInN0YXR1c1wiLCB7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn0pXG5cbkh0dHBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMuY29kZSArIFwiIFwiICsgdGhpcy5tZXNzYWdlXG59XG5cbmZvciAodmFyIGNvZGUgaW4gU1RBVFVTX0NPREVfVE9fTkFNRSkge1xuICB2YXIgbmFtZSA9IFNUQVRVU19DT0RFX1RPX05BTUVbY29kZV1cbiAgZXhwb3J0c1tuYW1lLnJlcGxhY2UoXCInXCIsIFwiXCIpLnJlcGxhY2UoL1stIF0vZywgXCJfXCIpLnRvVXBwZXJDYXNlKCldID0gK2NvZGVcbn1cblxuZnVuY3Rpb24gYWxpYXMobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpc1tuYW1lXSB9LFxuICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHsgcmV0dXJuIHRoaXNbbmFtZV0gPSB2YWx1ZSB9XG4gIH1cbn1cblxuXG4vKioqLyB9KSxcbi8qIDc3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBoYXMgPSBPYmplY3QuaGFzT3duUHJvcGVydHlcbnZhciBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZlxudmFyIHRyYWNlID0gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2Vcbm1vZHVsZS5leHBvcnRzID0gU3RhbmRhcmRFcnJvclxuXG5mdW5jdGlvbiBTdGFuZGFyZEVycm9yKG1zZywgcHJvcHMpIHtcbiAgLy8gTGV0IGFsbCBwcm9wZXJ0aWVzIGJlIGVudW1lcmFibGUgZm9yIGVhc2llciBzZXJpYWxpemF0aW9uLlxuICBpZiAobXNnICYmIHR5cGVvZiBtc2cgPT0gXCJvYmplY3RcIikgcHJvcHMgPSBtc2csIG1zZyA9IHVuZGVmaW5lZFxuICBlbHNlIHRoaXMubWVzc2FnZSA9IG1zZ1xuXG4gIC8vIE5hbWUgaGFzIHRvIGJlIGFuIG93biBwcm9wZXJ0eSAob3Igb24gdGhlIHByb3RvdHlwZSBhIHNpbmdsZSBzdGVwIHVwKSBmb3JcbiAgLy8gdGhlIHN0YWNrIHRvIGJlIHByaW50ZWQgd2l0aCB0aGUgY29ycmVjdCBuYW1lLlxuICBpZiAocHJvcHMpIGZvciAodmFyIGtleSBpbiBwcm9wcykgdGhpc1trZXldID0gcHJvcHNba2V5XVxuICBpZiAoIWhhcy5jYWxsKHRoaXMsIFwibmFtZVwiKSlcbiAgICB0aGlzLm5hbWUgPSBoYXMuY2FsbChwcm90byh0aGlzKSwgXCJuYW1lXCIpPyB0aGlzLm5hbWUgOiB0aGlzLmNvbnN0cnVjdG9yLm5hbWVcblxuICBpZiAodHJhY2UgJiYgIShcInN0YWNrXCIgaW4gdGhpcykpIHRyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpXG59XG5cblN0YW5kYXJkRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUsIHtcbiAgY29uc3RydWN0b3I6IHt2YWx1ZTogU3RhbmRhcmRFcnJvciwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX1cbn0pXG5cbi8vIFNldCBuYW1lIGV4cGxpY2l0bHkgZm9yIHdoZW4gdGhlIGNvZGUgZ2V0cyBtaW5pZmllZC5cblN0YW5kYXJkRXJyb3IucHJvdG90eXBlLm5hbWUgPSBcIlN0YW5kYXJkRXJyb3JcIlxuXG5cbi8qKiovIH0pLFxuLyogNzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OLnBhcnNlKFwie1xcXCIxMDBcXFwiOlxcXCJDb250aW51ZVxcXCIsXFxcIjEwMVxcXCI6XFxcIlN3aXRjaGluZyBQcm90b2NvbHNcXFwiLFxcXCIxMDJcXFwiOlxcXCJQcm9jZXNzaW5nXFxcIixcXFwiMjAwXFxcIjpcXFwiT0tcXFwiLFxcXCIyMDFcXFwiOlxcXCJDcmVhdGVkXFxcIixcXFwiMjAyXFxcIjpcXFwiQWNjZXB0ZWRcXFwiLFxcXCIyMDNcXFwiOlxcXCJOb24tQXV0aG9yaXRhdGl2ZSBJbmZvcm1hdGlvblxcXCIsXFxcIjIwNFxcXCI6XFxcIk5vIENvbnRlbnRcXFwiLFxcXCIyMDVcXFwiOlxcXCJSZXNldCBDb250ZW50XFxcIixcXFwiMjA2XFxcIjpcXFwiUGFydGlhbCBDb250ZW50XFxcIixcXFwiMjA3XFxcIjpcXFwiTXVsdGktU3RhdHVzXFxcIixcXFwiMjA4XFxcIjpcXFwiQWxyZWFkeSBSZXBvcnRlZFxcXCIsXFxcIjIyNlxcXCI6XFxcIklNIFVzZWRcXFwiLFxcXCIzMDBcXFwiOlxcXCJNdWx0aXBsZSBDaG9pY2VzXFxcIixcXFwiMzAxXFxcIjpcXFwiTW92ZWQgUGVybWFuZW50bHlcXFwiLFxcXCIzMDJcXFwiOlxcXCJGb3VuZFxcXCIsXFxcIjMwM1xcXCI6XFxcIlNlZSBPdGhlclxcXCIsXFxcIjMwNFxcXCI6XFxcIk5vdCBNb2RpZmllZFxcXCIsXFxcIjMwNVxcXCI6XFxcIlVzZSBQcm94eVxcXCIsXFxcIjMwN1xcXCI6XFxcIlRlbXBvcmFyeSBSZWRpcmVjdFxcXCIsXFxcIjMwOFxcXCI6XFxcIlBlcm1hbmVudCBSZWRpcmVjdFxcXCIsXFxcIjQwMFxcXCI6XFxcIkJhZCBSZXF1ZXN0XFxcIixcXFwiNDAxXFxcIjpcXFwiVW5hdXRob3JpemVkXFxcIixcXFwiNDAyXFxcIjpcXFwiUGF5bWVudCBSZXF1aXJlZFxcXCIsXFxcIjQwM1xcXCI6XFxcIkZvcmJpZGRlblxcXCIsXFxcIjQwNFxcXCI6XFxcIk5vdCBGb3VuZFxcXCIsXFxcIjQwNVxcXCI6XFxcIk1ldGhvZCBOb3QgQWxsb3dlZFxcXCIsXFxcIjQwNlxcXCI6XFxcIk5vdCBBY2NlcHRhYmxlXFxcIixcXFwiNDA3XFxcIjpcXFwiUHJveHkgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcXFwiLFxcXCI0MDhcXFwiOlxcXCJSZXF1ZXN0IFRpbWVvdXRcXFwiLFxcXCI0MDlcXFwiOlxcXCJDb25mbGljdFxcXCIsXFxcIjQxMFxcXCI6XFxcIkdvbmVcXFwiLFxcXCI0MTFcXFwiOlxcXCJMZW5ndGggUmVxdWlyZWRcXFwiLFxcXCI0MTJcXFwiOlxcXCJQcmVjb25kaXRpb24gRmFpbGVkXFxcIixcXFwiNDEzXFxcIjpcXFwiUGF5bG9hZCBUb28gTGFyZ2VcXFwiLFxcXCI0MTRcXFwiOlxcXCJVUkkgVG9vIExvbmdcXFwiLFxcXCI0MTVcXFwiOlxcXCJVbnN1cHBvcnRlZCBNZWRpYSBUeXBlXFxcIixcXFwiNDE2XFxcIjpcXFwiUmFuZ2UgTm90IFNhdGlzZmlhYmxlXFxcIixcXFwiNDE3XFxcIjpcXFwiRXhwZWN0YXRpb24gRmFpbGVkXFxcIixcXFwiNDE4XFxcIjpcXFwiSSdtIGEgdGVhcG90XFxcIixcXFwiNDIxXFxcIjpcXFwiTWlzZGlyZWN0ZWQgUmVxdWVzdFxcXCIsXFxcIjQyMlxcXCI6XFxcIlVucHJvY2Vzc2FibGUgRW50aXR5XFxcIixcXFwiNDIzXFxcIjpcXFwiTG9ja2VkXFxcIixcXFwiNDI0XFxcIjpcXFwiRmFpbGVkIERlcGVuZGVuY3lcXFwiLFxcXCI0MjVcXFwiOlxcXCJVbm9yZGVyZWQgQ29sbGVjdGlvblxcXCIsXFxcIjQyNlxcXCI6XFxcIlVwZ3JhZGUgUmVxdWlyZWRcXFwiLFxcXCI0MjhcXFwiOlxcXCJQcmVjb25kaXRpb24gUmVxdWlyZWRcXFwiLFxcXCI0MjlcXFwiOlxcXCJUb28gTWFueSBSZXF1ZXN0c1xcXCIsXFxcIjQzMVxcXCI6XFxcIlJlcXVlc3QgSGVhZGVyIEZpZWxkcyBUb28gTGFyZ2VcXFwiLFxcXCI1MDBcXFwiOlxcXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcXFwiLFxcXCI1MDFcXFwiOlxcXCJOb3QgSW1wbGVtZW50ZWRcXFwiLFxcXCI1MDJcXFwiOlxcXCJCYWQgR2F0ZXdheVxcXCIsXFxcIjUwM1xcXCI6XFxcIlNlcnZpY2UgVW5hdmFpbGFibGVcXFwiLFxcXCI1MDRcXFwiOlxcXCJHYXRld2F5IFRpbWVvdXRcXFwiLFxcXCI1MDVcXFwiOlxcXCJIVFRQIFZlcnNpb24gTm90IFN1cHBvcnRlZFxcXCIsXFxcIjUwNlxcXCI6XFxcIlZhcmlhbnQgQWxzbyBOZWdvdGlhdGVzXFxcIixcXFwiNTA3XFxcIjpcXFwiSW5zdWZmaWNpZW50IFN0b3JhZ2VcXFwiLFxcXCI1MDhcXFwiOlxcXCJMb29wIERldGVjdGVkXFxcIixcXFwiNTA5XFxcIjpcXFwiQmFuZHdpZHRoIExpbWl0IEV4Y2VlZGVkXFxcIixcXFwiNTEwXFxcIjpcXFwiTm90IEV4dGVuZGVkXFxcIixcXFwiNTExXFxcIjpcXFwiTmV0d29yayBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFxcXCJ9XCIpO1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qKlxuICogRGVwZW5kZW5jaWVzXG4gKi9cbmNvbnN0IHtcbiAgSlNPTlNjaGVtYVxufSA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xuLyoqXG4gKiBSZWx5aW5nUGFydHkgU2NoZW1hXG4gKlxuICogVGhpcyBzY2hlbWEgaW5pdGlhbGl6ZXMgYW5kIHZlcmlmaWVzIFJlbHlpbmcgUGFydHkgY2xpZW50IGNvbmZpZ3VyYXRpb24uXG4gKiBSZWx5aW5nUGFydHkgb2JqZWN0cyBjYW4gYmUgcGVyc2lzdGVkIGFuZCByZWh5ZHJhdGVkLiBCeSBlbmNhcHN1bGF0aW5nIHRoaXMgZGF0YSBpblxuICogaXQncyBvd24gY2xhc3MsIGl0J3MgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBSUCBjb25maWd1cmF0aW9ucyBydW5uaW5nXG4gKiBzaW11bHRhbmVvdXNseS5cbiAqL1xuXG5cbmNvbnN0IFJlbHlpbmdQYXJ0eVNjaGVtYSA9IG5ldyBKU09OU2NoZW1hKHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBwcm92aWRlclxuICAgICAqXG4gICAgICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIHByb3ZpZGVyLCBpbmNsdWRpbmcgaXNzdWVyIFVSTCwgaHVtYW4gcmVhZGFibGUgbmFtZSxcbiAgICAgKiBhbmQgYW55IGNvbmZpZ3VyYXRpb24gb3IgcHJvdmlkZXIgbWV0YWRhdGEgcmV0cmlldmVkIGZyb20gdGhlIE9QLlxuICAgICAqL1xuICAgIHByb3ZpZGVyOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIHVybDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGZvcm1hdDogJ3VyaSdcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTk9URTpcbiAgICAgICAgLy8gT3BlbklEIENvbmZpZ3VyYXRpb24gKGRpc2NvdmVyeSByZXNwb25zZSkgYW5kIEpTT04gV2ViIEtleXMgU2V0IGZvciBhblxuICAgICAgICAvLyBpc3N1ZXIgY2FuIGJlIGNhY2hlZCBoZXJlLiBIb3dldmVyIHRoZSBjYWNoZSBzaG91bGQgbm90IGJlIHBlcnNpc3RlZCBvclxuICAgICAgICAvLyByZWxpZWQgdXBvbi5cbiAgICAgICAgLy9cbiAgICAgICAgY29uZmlndXJhdGlvbjoge30sXG4gICAgICAgIC8vIC53ZWxsLWtub3duL29wZW5pZC1jb25maWd1cmF0aW9uXG4gICAgICAgIGp3a3M6IHt9IC8vIC9qd2tzXG5cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogWyd1cmwnXVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBkZWZhdWx0c1xuICAgICAqXG4gICAgICogRGVmYXVsdCByZXF1ZXN0IHBhcmFtZXRlcnMgZm9yIGF1dGhlbnRpY2F0aW9uIGFuZCBkeW5hbWljIHJlZ2lzdHJhdGlvbiByZXF1ZXN0cy5cbiAgICAgKiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGV4dGVuZGVkIG9yIG92ZXJyaWRkZW4gdmlhIGFyZ3VtZW50cyB0byB0aGUgcmVzcGVjdGl2ZVxuICAgICAqIHJlcXVlc3QgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZXNlIGFyZSBwYXJ0IG9mIHRoZSByZWx5aW5nIHBhcnR5IGNsaWVudCBjb25maWd1cmF0aW9uIGFuZCBjYW4gYmUgc2VyaWFsaXplZFxuICAgICAqIGFuZCBwZXJzaXN0ZWQuXG4gICAgICovXG4gICAgZGVmYXVsdHM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAvKipcbiAgICAgICAgICogVXNlIFByb29mIG9mIFBvc3Nlc3Npb24gdG9rZW4gc2VtYW50aWNzIGZvciB0aGUgSUQgVG9rZW5cbiAgICAgICAgICovXG4gICAgICAgIHBvcFRva2VuOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgYXV0aGVudGljYXRpb24gcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBhdXRoZW50aWNhdGU6IHtcbiAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICByZWRpcmVjdF91cmk6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGZvcm1hdDogJ3VyaSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXNwb25zZV90eXBlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBkZWZhdWx0OiAnaWRfdG9rZW4gdG9rZW4nLFxuICAgICAgICAgICAgICAvLyBicm93c2VyIGRldGVjdGlvblxuICAgICAgICAgICAgICBlbnVtOiBbJ2NvZGUnLCAndG9rZW4nLCAnaWRfdG9rZW4gdG9rZW4nLCAnaWRfdG9rZW4gdG9rZW4gY29kZSddXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzcGxheToge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZGVmYXVsdDogJ3BhZ2UnLFxuICAgICAgICAgICAgICBlbnVtOiBbJ3BhZ2UnLCAncG9wdXAnXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J10sXG4gICAgICAgICAgICAgIGRlZmF1bHQ6IFsnb3BlbmlkJ11cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmF1bHQgY2xpZW50IHJlZ2lzdHJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICByZWdpc3Rlcjoge31cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmVnaXN0cmF0aW9uXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIHRoZSBjbGllbnQgcmVnaXN0cmF0aW9uIHJlc3BvbnNlIGZyb20gZHluYW1pYyByZWdpc3RyYXRpb24uIEl0IHNob3VsZFxuICAgICAqIGFsd2F5cyByZWZsZWN0IHRoZSBjbGllbnQgY29uZmlndXJhdGlvbiBvbiB0aGUgb3BlbmlkIHByb3ZpZGVyLiBBIGNsaWVudCBhY2Nlc3NcbiAgICAgKiB0b2tlbiBpcyBzdG9yZWQgaGVyZVxuICAgICAqL1xuICAgIHJlZ2lzdHJhdGlvbjoge30sXG4gICAgLy8gQ2xpZW50TWV0YWRhdGFTY2hlbWFcblxuICAgIC8qKlxuICAgICAqIHN0b3JlXG4gICAgICovXG4gICAgc3RvcmU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgZGVmYXVsdDoge31cbiAgICB9XG4gIH1cbn0pO1xuLyoqXG4gKiBFeHBvcnRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlbHlpbmdQYXJ0eVNjaGVtYTtcblxuLyoqKi8gfSksXG4vKiA4MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmICghc2VsZikge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSA/IGNhbGwgOiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICB9XG5cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7XG59XG5cbnZhciBfcmVxdWlyZSA9IF9fd2VicGFja19yZXF1aXJlX18oMjcpLFxuICAgIFVSTCA9IF9yZXF1aXJlLlVSTDtcblxudmFyIF9yZXF1aXJlMiA9IF9fd2VicGFja19yZXF1aXJlX18oMzcpLFxuICAgIEpXVCA9IF9yZXF1aXJlMi5KV1QsXG4gICAgSldLID0gX3JlcXVpcmUyLkpXSztcblxudmFyIERFRkFVTFRfTUFYX0FHRSA9IDM2MDA7IC8vIERlZmF1bHQgdG9rZW4gZXhwaXJhdGlvbiwgaW4gc2Vjb25kc1xuXG52YXIgUG9QVG9rZW4gPSBmdW5jdGlvbiAoX0pXVCkge1xuICBfaW5oZXJpdHMoUG9QVG9rZW4sIF9KV1QpO1xuXG4gIGZ1bmN0aW9uIFBvUFRva2VuKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQb1BUb2tlbik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKFBvUFRva2VuLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoUG9QVG9rZW4pKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhQb1BUb2tlbiwgbnVsbCwgW3tcbiAgICBrZXk6ICdpc3N1ZUZvcicsXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gcmVzb3VyY2VTZXJ2ZXJVcmkge3N0cmluZ30gUlMgVVJJIGZvciB3aGljaCB0aGlzIHRva2VuIGlzIGludGVuZGVkXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Vzc2lvbiB7U2Vzc2lvbn1cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbi5zZXNzaW9uS2V5IHtzdHJpbmd9XG4gICAgICogQHBhcmFtIHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQge3N0cmluZ31cbiAgICAgKiBAcGFyYW0gc2Vzc2lvbi5hdXRob3JpemF0aW9uLmlkX3Rva2VuIHtzdHJpbmd9XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxzdHJpbmc+fSBQb1BUb2tlbiwgZW5jb2RlZCBhcyBjb21wYWN0IEpXVFxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiBpc3N1ZUZvcihyZXNvdXJjZVNlcnZlclVyaSwgc2Vzc2lvbikge1xuICAgICAgaWYgKCFyZXNvdXJjZVNlcnZlclVyaSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpc3N1ZSBQb1BUb2tlbiAtIG1pc3NpbmcgcmVzb3VyY2Ugc2VydmVyIFVSSScpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXNlc3Npb24uc2Vzc2lvbktleSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBpc3N1ZSBQb1BUb2tlbiAtIG1pc3Npbmcgc2Vzc2lvbiBrZXknKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFzZXNzaW9uLmF1dGhvcml6YXRpb24uaWRfdG9rZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXNzdWUgUG9QVG9rZW4gLSBtaXNzaW5nIGlkIHRva2VuJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBqd2sgPSBKU09OLnBhcnNlKHNlc3Npb24uc2Vzc2lvbktleSk7XG4gICAgICByZXR1cm4gSldLLmltcG9ydEtleShqd2spLnRoZW4oZnVuY3Rpb24gKGltcG9ydGVkU2Vzc2lvbkp3aykge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICBhdWQ6IG5ldyBVUkwocmVzb3VyY2VTZXJ2ZXJVcmkpLm9yaWdpbixcbiAgICAgICAgICBrZXk6IGltcG9ydGVkU2Vzc2lvbkp3ayxcbiAgICAgICAgICBpc3M6IHNlc3Npb24uYXV0aG9yaXphdGlvbi5jbGllbnRfaWQsXG4gICAgICAgICAgaWRfdG9rZW46IHNlc3Npb24uYXV0aG9yaXphdGlvbi5pZF90b2tlblxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gUG9QVG9rZW4uaXNzdWUob3B0aW9ucyk7XG4gICAgICB9KS50aGVuKGZ1bmN0aW9uIChqd3QpIHtcbiAgICAgICAgcmV0dXJuIGp3dC5lbmNvZGUoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBpc3N1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pc3Mge3N0cmluZ30gVG9rZW4gaXNzdWVyIChSUCBjbGllbnRfaWQpXG4gICAgICogQHBhcmFtIG9wdGlvbnMuYXVkIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gQXVkaWVuY2UgZm9yIHRoZSB0b2tlblxuICAgICAqICAgKHN1Y2ggYXMgdGhlIFJlc291cmNlIFNlcnZlciB1cmwpXG4gICAgICogQHBhcmFtIG9wdGlvbnMua2V5IHtKV0t9IFByb29mIG9mIFBvc3Nlc3Npb24gKHByaXZhdGUpIHNpZ25pbmcga2V5LCBzZWVcbiAgICAgKiAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3ODAwI3NlY3Rpb24tMy4xXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucy5pZF90b2tlbiB7c3RyaW5nfSBKV1QgY29tcGFjdCBlbmNvZGVkIElEIFRva2VuXG4gICAgICpcbiAgICAgKiBPcHRpb25hbDpcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuaWF0XSB7bnVtYmVyfSBJc3N1ZWQgYXQgdGltZXN0YW1wIChpbiBzZWNvbmRzKVxuICAgICAqIEBwYXJhbSBbb3B0aW9ucy5tYXhdIHtudW1iZXJ9IE1heCB0b2tlbiBsaWZldGltZSBpbiBzZWNvbmRzXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UG9QVG9rZW59IFByb29mIG9mIFBvc3Nlc3Npb24gVG9rZW4gKEpXVCBpbnN0YW5jZSlcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaXNzdWUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc3N1ZShvcHRpb25zKSB7XG4gICAgICB2YXIgYXVkID0gb3B0aW9ucy5hdWQsXG4gICAgICAgICAgaXNzID0gb3B0aW9ucy5pc3MsXG4gICAgICAgICAga2V5ID0gb3B0aW9ucy5rZXk7XG4gICAgICB2YXIgYWxnID0ga2V5LmFsZztcbiAgICAgIHZhciBpYXQgPSBvcHRpb25zLmlhdCB8fCBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbiAgICAgIHZhciBtYXggPSBvcHRpb25zLm1heCB8fCBERUZBVUxUX01BWF9BR0U7XG4gICAgICB2YXIgZXhwID0gaWF0ICsgbWF4OyAvLyB0b2tlbiBleHBpcmF0aW9uXG5cbiAgICAgIHZhciBoZWFkZXIgPSB7XG4gICAgICAgIGFsZzogYWxnXG4gICAgICB9O1xuICAgICAgdmFyIHBheWxvYWQgPSB7XG4gICAgICAgIGlzczogaXNzLFxuICAgICAgICBhdWQ6IGF1ZCxcbiAgICAgICAgZXhwOiBleHAsXG4gICAgICAgIGlhdDogaWF0LFxuICAgICAgICBpZF90b2tlbjogb3B0aW9ucy5pZF90b2tlbixcbiAgICAgICAgdG9rZW5fdHlwZTogJ3BvcCdcbiAgICAgIH07XG4gICAgICB2YXIgand0ID0gbmV3IFBvUFRva2VuKHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICAgIGtleToga2V5LmNyeXB0b0tleVxuICAgICAgfSwge1xuICAgICAgICBmaWx0ZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBqd3Q7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIFBvUFRva2VuO1xufShKV1QpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvUFRva2VuO1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIm9wZW5JZHBQb3B1cFwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9wZW5JZHBQb3B1cDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwib2J0YWluU2Vzc2lvblwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG9idGFpblNlc3Npb247IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcInBvcHVwSGFuZGxlclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIHBvcHVwSGFuZGxlcjsgfSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2lwY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3VybF91dGlsX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG5cbmZ1bmN0aW9uIG9wZW5JZHBQb3B1cChwb3B1cFVyaSkge1xuICBjb25zdCB3aWR0aCA9IDY1MDtcbiAgY29uc3QgaGVpZ2h0ID0gNDAwO1xuICBjb25zdCBsZWZ0ID0gd2luZG93LnNjcmVlblggKyAod2luZG93LmlubmVyV2lkdGggLSB3aWR0aCkgLyAyO1xuICBjb25zdCB0b3AgPSB3aW5kb3cuc2NyZWVuWSArICh3aW5kb3cuaW5uZXJIZWlnaHQgLSBoZWlnaHQpIC8gMjtcbiAgY29uc3Qgc2V0dGluZ3MgPSBcIndpZHRoPVwiLmNvbmNhdCh3aWR0aCwgXCIsaGVpZ2h0PVwiKS5jb25jYXQoaGVpZ2h0LCBcIixsZWZ0PVwiKS5jb25jYXQobGVmdCwgXCIsdG9wPVwiKS5jb25jYXQodG9wKTtcbiAgcmV0dXJuIHdpbmRvdy5vcGVuKHBvcHVwVXJpLCAnc29saWQtYXV0aC1jbGllbnQnLCBzZXR0aW5ncyk7XG59XG5mdW5jdGlvbiBvYnRhaW5TZXNzaW9uKHN0b3JlLCBwb3B1cCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IHBvcHVwU2VydmVyID0gbmV3IF9pcGNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcIlNlcnZlclwiXShwb3B1cCwgT2JqZWN0KF91cmxfdXRpbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wib3JpZ2luT2ZcIl0pKG9wdGlvbnMucG9wdXBVcmkgfHwgJycpLCBwb3B1cEhhbmRsZXIoc3RvcmUsIG9wdGlvbnMsIHNlc3Npb24gPT4ge1xuICAgICAgcG9wdXBTZXJ2ZXIuc3RvcCgpO1xuICAgICAgcmVzb2x2ZShzZXNzaW9uKTtcbiAgICB9KSk7XG4gICAgcG9wdXBTZXJ2ZXIuc3RhcnQoKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBwb3B1cEhhbmRsZXIoc3RvcmUsIF9yZWYsIGZvdW5kU2Vzc2lvbkNiKSB7XG4gIGxldCB7XG4gICAgcG9wdXBVcmksXG4gICAgY2FsbGJhY2tVcmlcbiAgfSA9IF9yZWY7XG4gIHJldHVybiBhc3luYyBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIC8vIE9yaWdpblxuICAgICAgY2FzZSAnZ2V0QXBwT3JpZ2luJzpcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5sb2NhdGlvbi5vcmlnaW47XG4gICAgICAvLyBTdG9yYWdlXG5cbiAgICAgIGNhc2UgJ3N0b3JhZ2UvZ2V0SXRlbSc6XG4gICAgICAgIHJldHVybiBzdG9yZS5nZXRJdGVtKC4uLmFyZ3MpO1xuXG4gICAgICBjYXNlICdzdG9yYWdlL3NldEl0ZW0nOlxuICAgICAgICByZXR1cm4gc3RvcmUuc2V0SXRlbSguLi5hcmdzKTtcblxuICAgICAgY2FzZSAnc3RvcmFnZS9yZW1vdmVJdGVtJzpcbiAgICAgICAgcmV0dXJuIHN0b3JlLnJlbW92ZUl0ZW0oLi4uYXJncyk7XG4gICAgICAvLyBMb2dpblxuXG4gICAgICBjYXNlICdnZXRMb2dpbk9wdGlvbnMnOlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcHVwVXJpLFxuICAgICAgICAgIGNhbGxiYWNrVXJpXG4gICAgICAgIH07XG5cbiAgICAgIGNhc2UgJ2ZvdW5kU2Vzc2lvbic6XG4gICAgICAgIGZvdW5kU2Vzc2lvbkNiKC4uLmFyZ3MpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqKi8gfSlcbi8qKioqKiovIF0pW1wiZGVmYXVsdFwiXTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///8\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(92)\nvar ieee754 = __webpack_require__(93)\nvar isArray = __webpack_require__(94)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzP2I2MzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosYUFBYSxtQkFBTyxDQUFDLEVBQVc7QUFDaEMsY0FBYyxtQkFBTyxDQUFDLEVBQVM7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLEVBQVM7O0FBRS9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbURBQW1EO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEVBQUU7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSxxQkFBcUIsZUFBZTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1CQUFtQixjQUFjO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1REFBdUQsT0FBTztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELE9BQU87QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixZQUFZO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbnZhciBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFVzZSBPYmplY3QgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIER1ZSB0byB2YXJpb3VzIGJyb3dzZXIgYnVncywgc29tZXRpbWVzIHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24gd2lsbCBiZSB1c2VkIGV2ZW5cbiAqIHdoZW4gdGhlIGJyb3dzZXIgc3VwcG9ydHMgdHlwZWQgYXJyYXlzLlxuICpcbiAqIE5vdGU6XG4gKlxuICogICAtIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcyxcbiAqICAgICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgIC0gSUUxMCBoYXMgYSBicm9rZW4gYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFycmF5cyBvZlxuICogICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgIHRvIGBmYWxzZWAgc28gdGhleVxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgYmVoYXZlcyBjb3JyZWN0bHkuXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlQgIT09IHVuZGVmaW5lZFxuICA/IGdsb2JhbC5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gIDogdHlwZWRBcnJheVN1cHBvcnQoKVxuXG4vKlxuICogRXhwb3J0IGtNYXhMZW5ndGggYWZ0ZXIgdHlwZWQgYXJyYXkgc3VwcG9ydCBpcyBkZXRlcm1pbmVkLlxuICovXG5leHBvcnRzLmtNYXhMZW5ndGggPSBrTWF4TGVuZ3RoKClcblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIGFyci5zdWJhcnJheSgxLCAxKS5ieXRlTGVuZ3RoID09PSAwIC8vIGllMTAgaGFzIGJyb2tlbiBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBrTWF4TGVuZ3RoICgpIHtcbiAgcmV0dXJuIEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUXG4gICAgPyAweDdmZmZmZmZmXG4gICAgOiAweDNmZmZmZmZmXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAodGhhdCwgbGVuZ3RoKSB7XG4gIGlmIChrTWF4TGVuZ3RoKCkgPCBsZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIGlmICh0aGF0ID09PSBudWxsKSB7XG4gICAgICB0aGF0ID0gbmV3IEJ1ZmZlcihsZW5ndGgpXG4gICAgfVxuICAgIHRoYXQubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICByZXR1cm4gdGhhdFxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZSh0aGlzLCBhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20odGhpcywgYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG4vLyBUT0RPOiBMZWdhY3ksIG5vdCBuZWVkZWQgYW55bW9yZS4gUmVtb3ZlIGluIG5leHQgbWFqb3IgdmVyc2lvbi5cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiBmcm9tICh0aGF0LCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuXG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodGhhdCwgdmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20obnVsbCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbiAgQnVmZmVyLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXlcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcbiAgICAvLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgICB2YWx1ZTogbnVsbCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jICh0aGF0LCBzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhudWxsLCBzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHRoYXQsIHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgIHRoYXRbaV0gPSAwXG4gICAgfVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUobnVsbCwgc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAodGhhdCwgc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IHRoYXQud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIHRoYXQgPSB0aGF0LnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKHRoYXQsIGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICB0aGF0W2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKHRoYXQsIGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgYXJyYXkuYnl0ZUxlbmd0aCAvLyB0aGlzIHRocm93cyBpZiBgYXJyYXlgIGlzIG5vdCBhIHZhbGlkIEFycmF5QnVmZmVyXG5cbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlLCBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoYXQgPSBhcnJheVxuICAgIHRoYXQuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gYW4gb2JqZWN0IGluc3RhbmNlIG9mIHRoZSBCdWZmZXIgY2xhc3NcbiAgICB0aGF0ID0gZnJvbUFycmF5TGlrZSh0aGF0LCBhcnJheSlcbiAgfVxuICByZXR1cm4gdGhhdFxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0ICh0aGF0LCBvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdGhhdCA9IGNyZWF0ZUJ1ZmZlcih0aGF0LCBsZW4pXG5cbiAgICBpZiAodGhhdC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGF0XG4gICAgfVxuXG4gICAgb2JqLmNvcHkodGhhdCwgMCwgMCwgbGVuKVxuICAgIHJldHVybiB0aGF0XG4gIH1cblxuICBpZiAob2JqKSB7XG4gICAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHwgJ2xlbmd0aCcgaW4gb2JqKSB7XG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IGlzbmFuKG9iai5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgMClcbiAgICAgIH1cbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iailcbiAgICB9XG5cbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh0aGF0LCBvYmouZGF0YSlcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgYXJyYXktbGlrZSBvYmplY3QuJylcbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IGtNYXhMZW5ndGgoKWAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBrTWF4TGVuZ3RoKCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsga01heExlbmd0aCgpLnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgc3RyaW5nIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhlIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgYW5kIGBpcy1idWZmZXJgIChpbiBTYWZhcmkgNS03KSB0byBkZXRlY3Rcbi8vIEJ1ZmZlciBpbnN0YW5jZXMuXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoIHwgMFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkubWF0Y2goLy57Mn0vZykuam9pbignICcpXG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICB9XG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgIC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChpc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmXG4gICAgICAgIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBpZiAoc3RyTGVuICUgMiAhPT0gMCkgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAoaXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHwgMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIC8vIGxlZ2FjeSB3cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aCkgLSByZW1vdmUgaW4gdjAuMTNcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWZcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAgIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgKytpKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoIHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgMik7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuZnVuY3Rpb24gb2JqZWN0V3JpdGVVSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuKSB7XG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGJ1Zi5sZW5ndGggLSBvZmZzZXQsIDQpOyBpIDwgajsgKytpKSB7XG4gICAgYnVmW29mZnNldCArIGldID0gKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGggLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHZhbHVlID0gTWF0aC5mbG9vcih2YWx1ZSlcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlKVxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwIHx8ICFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKGNvZGUgPCAyNTYpIHtcbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IHV0ZjhUb0J5dGVzKG5ldyBCdWZmZXIodmFsLCBlbmNvZGluZykudG9TdHJpbmcoKSlcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyaW5ndHJpbShzdHIpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gaXNuYW4gKHZhbCkge1xuICByZXR1cm4gdmFsICE9PSB2YWwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///9\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzPzNhN2MiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///10\n")},function(module,exports,__webpack_require__){eval("var $iterators = __webpack_require__(63);\nvar getKeys = __webpack_require__(41);\nvar redefine = __webpack_require__(16);\nvar global = __webpack_require__(2);\nvar hide = __webpack_require__(3);\nvar Iterators = __webpack_require__(25);\nvar wks = __webpack_require__(1);\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5kb20uaXRlcmFibGUuanM/YWM2YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUMvQyxjQUFjLG1CQUFPLENBQUMsRUFBZ0I7QUFDdEMsZUFBZSxtQkFBTyxDQUFDLEVBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLENBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLENBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjExLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyICRpdGVyYXRvcnMgPSByZXF1aXJlKCcuL2VzNi5hcnJheS5pdGVyYXRvcicpO1xudmFyIGdldEtleXMgPSByZXF1aXJlKCcuL19vYmplY3Qta2V5cycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi9fcmVkZWZpbmUnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi9faGlkZScpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHdrcyA9IHJlcXVpcmUoJy4vX3drcycpO1xudmFyIElURVJBVE9SID0gd2tzKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3a3MoJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBJdGVyYXRvcnMuQXJyYXk7XG5cbnZhciBET01JdGVyYWJsZXMgPSB7XG4gIENTU1J1bGVMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogZmFsc2UsXG4gIENTU1ZhbHVlTGlzdDogZmFsc2UsXG4gIENsaWVudFJlY3RMaXN0OiBmYWxzZSxcbiAgRE9NUmVjdExpc3Q6IGZhbHNlLFxuICBET01TdHJpbmdMaXN0OiBmYWxzZSxcbiAgRE9NVG9rZW5MaXN0OiB0cnVlLFxuICBEYXRhVHJhbnNmZXJJdGVtTGlzdDogZmFsc2UsXG4gIEZpbGVMaXN0OiBmYWxzZSxcbiAgSFRNTEFsbENvbGxlY3Rpb246IGZhbHNlLFxuICBIVE1MQ29sbGVjdGlvbjogZmFsc2UsXG4gIEhUTUxGb3JtRWxlbWVudDogZmFsc2UsXG4gIEhUTUxTZWxlY3RFbGVtZW50OiBmYWxzZSxcbiAgTWVkaWFMaXN0OiB0cnVlLCAvLyBUT0RPOiBOb3Qgc3BlYyBjb21wbGlhbnQsIHNob3VsZCBiZSBmYWxzZS5cbiAgTWltZVR5cGVBcnJheTogZmFsc2UsXG4gIE5hbWVkTm9kZU1hcDogZmFsc2UsXG4gIE5vZGVMaXN0OiB0cnVlLFxuICBQYWludFJlcXVlc3RMaXN0OiBmYWxzZSxcbiAgUGx1Z2luOiBmYWxzZSxcbiAgUGx1Z2luQXJyYXk6IGZhbHNlLFxuICBTVkdMZW5ndGhMaXN0OiBmYWxzZSxcbiAgU1ZHTnVtYmVyTGlzdDogZmFsc2UsXG4gIFNWR1BhdGhTZWdMaXN0OiBmYWxzZSxcbiAgU1ZHUG9pbnRMaXN0OiBmYWxzZSxcbiAgU1ZHU3RyaW5nTGlzdDogZmFsc2UsXG4gIFNWR1RyYW5zZm9ybUxpc3Q6IGZhbHNlLFxuICBTb3VyY2VCdWZmZXJMaXN0OiBmYWxzZSxcbiAgU3R5bGVTaGVldExpc3Q6IHRydWUsIC8vIFRPRE86IE5vdCBzcGVjIGNvbXBsaWFudCwgc2hvdWxkIGJlIGZhbHNlLlxuICBUZXh0VHJhY2tDdWVMaXN0OiBmYWxzZSxcbiAgVGV4dFRyYWNrTGlzdDogZmFsc2UsXG4gIFRvdWNoTGlzdDogZmFsc2Vcbn07XG5cbmZvciAodmFyIGNvbGxlY3Rpb25zID0gZ2V0S2V5cyhET01JdGVyYWJsZXMpLCBpID0gMDsgaSA8IGNvbGxlY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBOQU1FID0gY29sbGVjdGlvbnNbaV07XG4gIHZhciBleHBsaWNpdCA9IERPTUl0ZXJhYmxlc1tOQU1FXTtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbTkFNRV07XG4gIHZhciBwcm90byA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIHZhciBrZXk7XG4gIGlmIChwcm90bykge1xuICAgIGlmICghcHJvdG9bSVRFUkFUT1JdKSBoaWRlKHByb3RvLCBJVEVSQVRPUiwgQXJyYXlWYWx1ZXMpO1xuICAgIGlmICghcHJvdG9bVE9fU1RSSU5HX1RBR10pIGhpZGUocHJvdG8sIFRPX1NUUklOR19UQUcsIE5BTUUpO1xuICAgIEl0ZXJhdG9yc1tOQU1FXSA9IEFycmF5VmFsdWVzO1xuICAgIGlmIChleHBsaWNpdCkgZm9yIChrZXkgaW4gJGl0ZXJhdG9ycykgaWYgKCFwcm90b1trZXldKSByZWRlZmluZShwcm90bywga2V5LCAkaXRlcmF0b3JzW2tleV0sIHRydWUpO1xuICB9XG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///11\n")},function(module,exports){eval("module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1vYmplY3QuanM/ZDNmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///12\n")},function(module,exports,__webpack_require__){eval("// Thank's IE8 for his funny defineProperty\nmodule.exports = !__webpack_require__(14)(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZXNjcmlwdG9ycy5qcz85ZTFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMsRUFBVTtBQUNwQyxpQ0FBaUMsUUFBUSxtQkFBbUIsVUFBVSxFQUFFLEVBQUU7QUFDMUUsQ0FBQyIsImZpbGUiOiIxMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIXJlcXVpcmUoJy4vX2ZhaWxzJykoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///13\n")},function(module,exports){eval("module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mYWlscy5qcz83OWU1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EiLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///14\n")},function(module,exports){eval('// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError("Can\'t call method on  " + it);\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kZWZpbmVkLmpzP2JlMTMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMi4xIFJlcXVpcmVPYmplY3RDb2VyY2libGUoYXJndW1lbnQpXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiAgXCIgKyBpdCk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///15\n')},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(2);\nvar hide = __webpack_require__(3);\nvar has = __webpack_require__(17);\nvar SRC = __webpack_require__(23)('src');\nvar $toString = __webpack_require__(70);\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\n__webpack_require__(22).inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWRlZmluZS5qcz8yYWJhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxDQUFXO0FBQ2hDLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLEVBQXVCO0FBQy9DO0FBQ0E7O0FBRUEsbUJBQU8sQ0FBQyxFQUFTO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4vX2dsb2JhbCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi9faGFzJyk7XG52YXIgU1JDID0gcmVxdWlyZSgnLi9fdWlkJykoJ3NyYycpO1xudmFyICR0b1N0cmluZyA9IHJlcXVpcmUoJy4vX2Z1bmN0aW9uLXRvLXN0cmluZycpO1xudmFyIFRPX1NUUklORyA9ICd0b1N0cmluZyc7XG52YXIgVFBMID0gKCcnICsgJHRvU3RyaW5nKS5zcGxpdChUT19TVFJJTkcpO1xuXG5yZXF1aXJlKCcuL19jb3JlJykuaW5zcGVjdFNvdXJjZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gJHRvU3RyaW5nLmNhbGwoaXQpO1xufTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsLCBzYWZlKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIHZhbCA9PSAnZnVuY3Rpb24nO1xuICBpZiAoaXNGdW5jdGlvbikgaGFzKHZhbCwgJ25hbWUnKSB8fCBoaWRlKHZhbCwgJ25hbWUnLCBrZXkpO1xuICBpZiAoT1trZXldID09PSB2YWwpIHJldHVybjtcbiAgaWYgKGlzRnVuY3Rpb24pIGhhcyh2YWwsIFNSQykgfHwgaGlkZSh2YWwsIFNSQywgT1trZXldID8gJycgKyBPW2tleV0gOiBUUEwuam9pbihTdHJpbmcoa2V5KSkpO1xuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgT1trZXldID0gdmFsO1xuICB9IGVsc2UgaWYgKCFzYWZlKSB7XG4gICAgZGVsZXRlIE9ba2V5XTtcbiAgICBoaWRlKE8sIGtleSwgdmFsKTtcbiAgfSBlbHNlIGlmIChPW2tleV0pIHtcbiAgICBPW2tleV0gPSB2YWw7XG4gIH0gZWxzZSB7XG4gICAgaGlkZShPLCBrZXksIHZhbCk7XG4gIH1cbi8vIGFkZCBmYWtlIEZ1bmN0aW9uI3RvU3RyaW5nIGZvciBjb3JyZWN0IHdvcmsgd3JhcHBlZCBtZXRob2RzIC8gY29uc3RydWN0b3JzIHdpdGggbWV0aG9kcyBsaWtlIExvRGFzaCBpc05hdGl2ZVxufSkoRnVuY3Rpb24ucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gdHlwZW9mIHRoaXMgPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzW1NSQ10gfHwgJHRvU3RyaW5nLmNhbGwodGhpcyk7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///16\n")},function(module,exports){eval("var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19oYXMuanM/NjlhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGhhc093blByb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGl0LCBrZXkpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///17\n")},function(module,exports){eval("// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pbnRlZ2VyLmpzPzQ1ODgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjQgVG9JbnRlZ2VyXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXNOYU4oaXQgPSAraXQpID8gMCA6IChpdCA+IDAgPyBmbG9vciA6IGNlaWwpKGl0KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///18\n")},function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzP2YyOGMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///19\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process) {\n\nif (typeof process === 'undefined' ||\n    !process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy1uZXh0aWNrLWFyZ3MvaW5kZXguanM/OTY2ZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSwrQ0FBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///20\n")},function(module,exports,__webpack_require__){eval("var core = __webpack_require__(22);\nvar global = __webpack_require__(2);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: __webpack_require__(36) ? 'pure' : 'global',\n  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQuanM/NTUzNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQztBQUNBLGtEQUFrRDs7QUFFbEQ7QUFDQSxxRUFBcUU7QUFDckUsQ0FBQztBQUNEO0FBQ0EsUUFBUSxtQkFBTyxDQUFDLEVBQVk7QUFDNUI7QUFDQSxDQUFDIiwiZmlsZSI6IjIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvcmUgPSByZXF1aXJlKCcuL19jb3JlJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi9fZ2xvYmFsJyk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCAoZ2xvYmFsW1NIQVJFRF0gPSB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiBjb3JlLnZlcnNpb24sXG4gIG1vZGU6IHJlcXVpcmUoJy4vX2xpYnJhcnknKSA/ICdwdXJlJyA6ICdnbG9iYWwnLFxuICBjb3B5cmlnaHQ6ICfCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJ1xufSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///21\n")},function(module,exports){eval("var core = module.exports = { version: '2.6.11' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb3JlLmpzPzgzNzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsNkJBQTZCO0FBQzdCLHVDQUF1QyIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBjb3JlID0gbW9kdWxlLmV4cG9ydHMgPSB7IHZlcnNpb246ICcyLjYuMTEnIH07XG5pZiAodHlwZW9mIF9fZSA9PSAnbnVtYmVyJykgX19lID0gY29yZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///22\n")},function(module,exports){eval("var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL191aWQuanM/Y2E1YSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjIzLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGlkID0gMDtcbnZhciBweCA9IE1hdGgucmFuZG9tKCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuICdTeW1ib2woJy5jb25jYXQoa2V5ID09PSB1bmRlZmluZWQgPyAnJyA6IGtleSwgJylfJywgKCsraWQgKyBweCkudG9TdHJpbmcoMzYpKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///23\n")},function(module,exports,__webpack_require__){eval("var anObject = __webpack_require__(4);\nvar IE8_DOM_DEFINE = __webpack_require__(65);\nvar toPrimitive = __webpack_require__(66);\nvar dP = Object.defineProperty;\n\nexports.f = __webpack_require__(13) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHAuanM/ODZjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFtQjtBQUNoRCxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFpQjtBQUMzQzs7QUFFQSxZQUFZLG1CQUFPLENBQUMsRUFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsWUFBWTtBQUNmO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuL19pZTgtZG9tLWRlZmluZScpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi9fdG8tcHJpbWl0aXZlJyk7XG52YXIgZFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cbmV4cG9ydHMuZiA9IHJlcXVpcmUoJy4vX2Rlc2NyaXB0b3JzJykgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eShPLCBQLCBBdHRyaWJ1dGVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICBQID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIGRQKE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCEnKTtcbiAgaWYgKCd2YWx1ZScgaW4gQXR0cmlidXRlcykgT1tQXSA9IEF0dHJpYnV0ZXMudmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///24\n")},function(module,exports){eval("module.exports = {};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyYXRvcnMuanM/ODRmMiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiIyNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0ge307XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///25\n")},function(module,exports,__webpack_require__){eval("// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = __webpack_require__(68);\nvar defined = __webpack_require__(15);\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1pb2JqZWN0LmpzPzY4MjEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsRUFBWTtBQUNsQztBQUNBO0FBQ0EiLCJmaWxlIjoiMjYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyB0byBpbmRleGVkIG9iamVjdCwgdG9PYmplY3Qgd2l0aCBmYWxsYmFjayBmb3Igbm9uLWFycmF5LWxpa2UgRVMzIHN0cmluZ3NcbnZhciBJT2JqZWN0ID0gcmVxdWlyZSgnLi9faW9iamVjdCcpO1xudmFyIGRlZmluZWQgPSByZXF1aXJlKCcuL19kZWZpbmVkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSU9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///26\n")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jb2YuanM/MmQ5NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///27\n")},function(module,exports,__webpack_require__){eval("// 7.1.15 ToLength\nvar toInteger = __webpack_require__(18);\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1sZW5ndGguanM/OWRlZiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRCIsImZpbGUiOiIyOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xNSBUb0xlbmd0aFxudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA+IDAgPyBtaW4odG9JbnRlZ2VyKGl0KSwgMHgxZmZmZmZmZmZmZmZmZikgOiAwOyAvLyBwb3coMiwgNTMpIC0gMSA9PSA5MDA3MTk5MjU0NzQwOTkxXG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///28\n")},function(module,exports,__webpack_require__){eval("var shared = __webpack_require__(21)('keys');\nvar uid = __webpack_require__(23);\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zaGFyZWQta2V5LmpzPzYxM2IiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLEVBQVc7QUFDaEMsVUFBVSxtQkFBTyxDQUFDLEVBQVE7QUFDMUI7QUFDQTtBQUNBIiwiZmlsZSI6IjI5LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4vX3NoYXJlZCcpKCdrZXlzJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi9fdWlkJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHNoYXJlZFtrZXldIHx8IChzaGFyZWRba2V5XSA9IHVpZChrZXkpKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///29\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar regexpFlags = __webpack_require__(84);\n\nvar nativeExec = RegExp.prototype.exec;\n// This always refers to the native implementation, because the\n// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,\n// which loads this file before patching the method.\nvar nativeReplace = String.prototype.replace;\n\nvar patchedExec = nativeExec;\n\nvar LAST_INDEX = 'lastIndex';\n\nvar UPDATES_LAST_INDEX_WRONG = (function () {\n  var re1 = /a/,\n      re2 = /b*/g;\n  nativeExec.call(re1, 'a');\n  nativeExec.call(re2, 'a');\n  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;\n})();\n\n// nonparticipating capturing group, copied from es5-shim's String#split patch.\nvar NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;\n\nvar PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;\n\nif (PATCH) {\n  patchedExec = function exec(str) {\n    var re = this;\n    var lastIndex, reCopy, match, i;\n\n    if (NPCG_INCLUDED) {\n      reCopy = new RegExp('^' + re.source + '$(?!\\\\s)', regexpFlags.call(re));\n    }\n    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];\n\n    match = nativeExec.call(re, str);\n\n    if (UPDATES_LAST_INDEX_WRONG && match) {\n      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;\n    }\n    if (NPCG_INCLUDED && match && match.length > 1) {\n      // Fix browsers whose `exec` methods don't consistently return `undefined`\n      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/\n      // eslint-disable-next-line no-loop-func\n      nativeReplace.call(match[0], reCopy, function () {\n        for (i = 1; i < arguments.length - 2; i++) {\n          if (arguments[i] === undefined) match[i] = undefined;\n        }\n      });\n    }\n\n    return match;\n  };\n}\n\nmodule.exports = patchedExec;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy5qcz81MjBhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLEVBQVU7O0FBRXBDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwiZmlsZSI6IjMwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL19mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS8sXG4gICAgICByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMVtMQVNUX0lOREVYXSAhPT0gMCB8fCByZTJbTEFTVF9JTkRFWF0gIT09IDA7XG59KSgpO1xuXG4vLyBub25wYXJ0aWNpcGF0aW5nIGNhcHR1cmluZyBncm91cCwgY29waWVkIGZyb20gZXM1LXNoaW0ncyBTdHJpbmcjc3BsaXQgcGF0Y2guXG52YXIgTlBDR19JTkNMVURFRCA9IC8oKT8/Ly5leGVjKCcnKVsxXSAhPT0gdW5kZWZpbmVkO1xuXG52YXIgUEFUQ0ggPSBVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgfHwgTlBDR19JTkNMVURFRDtcblxuaWYgKFBBVENIKSB7XG4gIHBhdGNoZWRFeGVjID0gZnVuY3Rpb24gZXhlYyhzdHIpIHtcbiAgICB2YXIgcmUgPSB0aGlzO1xuICAgIHZhciBsYXN0SW5kZXgsIHJlQ29weSwgbWF0Y2gsIGk7XG5cbiAgICBpZiAoTlBDR19JTkNMVURFRCkge1xuICAgICAgcmVDb3B5ID0gbmV3IFJlZ0V4cCgnXicgKyByZS5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIHJlZ2V4cEZsYWdzLmNhbGwocmUpKTtcbiAgICB9XG4gICAgaWYgKFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORykgbGFzdEluZGV4ID0gcmVbTEFTVF9JTkRFWF07XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlW0xBU1RfSU5ERVhdID0gcmUuZ2xvYmFsID8gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGggOiBsYXN0SW5kZXg7XG4gICAgfVxuICAgIGlmIChOUENHX0lOQ0xVREVEICYmIG1hdGNoICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIEZpeCBicm93c2VycyB3aG9zZSBgZXhlY2AgbWV0aG9kcyBkb24ndCBjb25zaXN0ZW50bHkgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgICAvLyBmb3IgTlBDRywgbGlrZSBJRTguIE5PVEU6IFRoaXMgZG9lc24nIHdvcmsgZm9yIC8oLj8pPy9cbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb29wLWZ1bmNcbiAgICAgIG5hdGl2ZVJlcGxhY2UuY2FsbChtYXRjaFswXSwgcmVDb3B5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAoaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSA9PT0gdW5kZWZpbmVkKSBtYXRjaFtpXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGNoZWRFeGVjO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///30\n")},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcz9mYWExIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHNCQUFzQjtBQUN2Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBLGlDQUFpQyxRQUFRO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEseUJBQXlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///31\n")},function(module,exports,__webpack_require__){eval("exports = module.exports = __webpack_require__(52);\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = __webpack_require__(34);\nexports.Duplex = __webpack_require__(5);\nexports.Transform = __webpack_require__(56);\nexports.PassThrough = __webpack_require__(102);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzPzBhYzMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsMkJBQTJCLG1CQUFPLENBQUMsRUFBMkI7QUFDOUQ7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLEVBQTJCO0FBQ3RELGlCQUFpQixtQkFBTyxDQUFDLENBQXlCO0FBQ2xELG9CQUFvQixtQkFBTyxDQUFDLEVBQTRCO0FBQ3hELHNCQUFzQixtQkFBTyxDQUFDLEdBQThCIiwiZmlsZSI6IjMyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///32\n")},function(module,exports,__webpack_require__){eval("/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(9)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzP2Y2MGIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxhQUFhLG1CQUFPLENBQUMsQ0FBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzMy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///33\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(20);\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(10));\nutil.inherits = __webpack_require__(7);\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: __webpack_require__(100)\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(53);\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(33).Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = __webpack_require__(54);\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(5);\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || __webpack_require__(5);\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(19), __webpack_require__(51).setImmediate, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcz82ZmZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLFVBQVUsbUJBQU8sQ0FBQyxFQUFzQjtBQUN4Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsRUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFVO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG1CQUFPLENBQUMsR0FBZ0I7QUFDckM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyxFQUEyQjtBQUNoRDs7QUFFQTs7QUFFQSxhQUFhLG1CQUFPLENBQUMsRUFBYTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUE0Qjs7QUFFdEQ7O0FBRUE7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFrQjs7QUFFL0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDBGQUEwRjs7QUFFM0k7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxHQUFHO0FBQ0gsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsbUJBQU8sQ0FBQyxDQUFrQjs7QUFFL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQzs7QUFFakM7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsb0RBQW9EO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEUiLCJmaWxlIjoiMzQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///34\n")},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value )\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'rel' || attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']+)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(9).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaHR0cC1saW5rLWhlYWRlci9saWIvbGluay5qcz9jN2UyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhDQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBOztBQUVBLGVBQWUsTUFBTTtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBOztBQUVBOztBQUVBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4QkFBOEI7QUFDdkM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsaUJBQWlCLHNCQUFzQjtBQUN2QztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsT0FBTztBQUNQO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsMEJBQTBCLEVBQUU7QUFDNUIsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsY0FBYztBQUN6QixZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLFVBQVU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6IjM1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBDT01QQVRJQkxFX0VOQ09ESU5HX1BBVFRFUk4gPSAvXnV0Zi0/OHxhc2NpaXx1dGYtPzE2LT9sZXx1Y3MtPzJ8YmFzZS0/NjR8bGF0aW4tPzEkL2lcbnZhciBXU19UUklNX1BBVFRFUk4gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2dcbnZhciBXU19DSEFSX1BBVFRFUk4gPSAvXFxzfFxcdUZFRkZ8XFx4QTAvXG52YXIgV1NfRk9MRF9QQVRURVJOID0gL1xccj9cXG5bXFx4MjBcXHgwOV0rL2dcbnZhciBERUxJTUlURVJfUEFUVEVSTiA9IC9bOyxcIl0vXG52YXIgV1NfREVMSU1JVEVSX1BBVFRFUk4gPSAvWzssXCJdfFxccy9cblxudmFyIFNUQVRFID0ge1xuICBJRExFOiAxIDw8IDAsXG4gIFVSSTogMSA8PCAxLFxuICBBVFRSOiAxIDw8IDIsXG59XG5cbmZ1bmN0aW9uIHRyaW0oIHZhbHVlICkge1xuICByZXR1cm4gdmFsdWUucmVwbGFjZSggV1NfVFJJTV9QQVRURVJOLCAnJyApXG59XG5cbmZ1bmN0aW9uIGhhc1doaXRlc3BhY2UoIHZhbHVlICkge1xuICByZXR1cm4gV1NfQ0hBUl9QQVRURVJOLnRlc3QoIHZhbHVlIClcbn1cblxuZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoIHZhbHVlLCBvZmZzZXQgKSB7XG4gIHdoaWxlKCBoYXNXaGl0ZXNwYWNlKCB2YWx1ZVtvZmZzZXRdICkgKSB7XG4gICAgb2Zmc2V0KytcbiAgfVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIG5lZWRzUXVvdGVzKCB2YWx1ZSApIHtcbiAgcmV0dXJuIFdTX0RFTElNSVRFUl9QQVRURVJOLnRlc3QoIHZhbHVlIClcbn1cblxuY2xhc3MgTGluayB7XG5cbiAgLyoqXG4gICAqIExpbmtcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbdmFsdWVdXG4gICAqIEByZXR1cm5zIHtMaW5rfVxuICAgKi9cbiAgY29uc3RydWN0b3IoIHZhbHVlICkge1xuXG4gICAgLyoqIEB0eXBlIHtBcnJheX0gVVJJIHJlZmVyZW5jZXMgKi9cbiAgICB0aGlzLnJlZnMgPSBbXVxuXG4gICAgaWYoIHZhbHVlICkge1xuICAgICAgdGhpcy5wYXJzZSggdmFsdWUgKVxuICAgIH1cblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByZWZzIHdpdGggZ2l2ZW4gcmVsYXRpb24gdHlwZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybnMge0FycmF5PE9iamVjdD59XG4gICAqL1xuICByZWwoIHZhbHVlICkge1xuXG4gICAgdmFyIGxpbmtzID0gW11cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5yZWZzLmxlbmd0aDsgaSsrICkge1xuICAgICAgaWYoIHRoaXMucmVmc1sgaSBdLnJlbCA9PT0gdmFsdWUgKSB7XG4gICAgICAgIGxpbmtzLnB1c2goIHRoaXMucmVmc1sgaSBdIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGlua3NcblxuICB9XG5cbiAgLyoqXG4gICAqIEdldCByZWZzIHdoZXJlIGdpdmVuIGF0dHJpYnV0ZSBoYXMgYSBnaXZlbiB2YWx1ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICAgKiBAcGFyYW0ge1N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybnMge0FycmF5PE9iamVjdD59XG4gICAqL1xuICBnZXQoIGF0dHIsIHZhbHVlICkge1xuXG4gICAgYXR0ciA9IGF0dHIudG9Mb3dlckNhc2UoKVxuXG4gICAgdmFyIGxpbmtzID0gW11cblxuICAgIGZvciggdmFyIGkgPSAwOyBpIDwgdGhpcy5yZWZzLmxlbmd0aDsgaSsrICkge1xuICAgICAgaWYoIHRoaXMucmVmc1sgaSBdWyBhdHRyIF0gPT09IHZhbHVlICkge1xuICAgICAgICBsaW5rcy5wdXNoKCB0aGlzLnJlZnNbIGkgXSApXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmtzXG5cbiAgfVxuXG4gIHNldCggbGluayApIHtcbiAgICB0aGlzLnJlZnMucHVzaCggbGluayApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGhhcyggYXR0ciwgdmFsdWUgKSB7XG5cbiAgICBhdHRyID0gYXR0ci50b0xvd2VyQ2FzZSgpXG5cbiAgICBmb3IoIHZhciBpID0gMDsgaSA8IHRoaXMucmVmcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGlmKCB0aGlzLnJlZnNbIGkgXVsgYXR0ciBdID09PSB2YWx1ZSApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2VcblxuICB9XG5cbiAgcGFyc2UoIHZhbHVlLCBvZmZzZXQgKSB7XG5cbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMFxuICAgIHZhbHVlID0gb2Zmc2V0ID8gdmFsdWUuc2xpY2UoIG9mZnNldCApIDogdmFsdWVcblxuICAgIC8vIFRyaW0gJiB1bmZvbGQgZm9sZGVkIGxpbmVzXG4gICAgdmFsdWUgPSB0cmltKCB2YWx1ZSApLnJlcGxhY2UoIFdTX0ZPTERfUEFUVEVSTiwgJycgKVxuXG4gICAgdmFyIHN0YXRlID0gU1RBVEUuSURMRVxuICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGhcbiAgICB2YXIgb2Zmc2V0ID0gMFxuICAgIHZhciByZWYgPSBudWxsXG5cbiAgICB3aGlsZSggb2Zmc2V0IDwgbGVuZ3RoICkge1xuICAgICAgaWYoIHN0YXRlID09PSBTVEFURS5JRExFICkge1xuICAgICAgICBpZiggaGFzV2hpdGVzcGFjZSggdmFsdWVbb2Zmc2V0XSApICkge1xuICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmKCB2YWx1ZVtvZmZzZXRdID09PSAnPCcgKSB7XG4gICAgICAgICAgdmFyIGVuZCA9IHZhbHVlLmluZGV4T2YoICc+Jywgb2Zmc2V0IClcbiAgICAgICAgICBpZiggZW5kID09PSAtMSApIHRocm93IG5ldyBFcnJvciggJ0V4cGVjdGVkIGVuZCBvZiBVUkkgZGVsaW1pdGVyIGF0IG9mZnNldCAnICsgb2Zmc2V0IClcbiAgICAgICAgICByZWYgPSB7IHVyaTogdmFsdWUuc2xpY2UoIG9mZnNldCArIDEsIGVuZCApIH1cbiAgICAgICAgICB0aGlzLnJlZnMucHVzaCggcmVmIClcbiAgICAgICAgICBvZmZzZXQgPSBlbmRcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLlVSSVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJyArIHZhbHVlW29mZnNldF0gKyAnXCIgYXQgb2Zmc2V0ICcgKyBvZmZzZXQgKVxuICAgICAgICB9XG4gICAgICAgIG9mZnNldCsrXG4gICAgICB9IGVsc2UgaWYoIHN0YXRlID09PSBTVEFURS5VUkkgKSB7XG4gICAgICAgIGlmKCBoYXNXaGl0ZXNwYWNlKCB2YWx1ZVtvZmZzZXRdICkgKSB7XG4gICAgICAgICAgb2Zmc2V0KytcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYoIHZhbHVlW29mZnNldF0gPT09ICc7JyApIHtcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLkFUVFJcbiAgICAgICAgICBvZmZzZXQrK1xuICAgICAgICB9IGVsc2UgaWYoIHZhbHVlW29mZnNldF0gPT09ICcsJyApIHtcbiAgICAgICAgICBzdGF0ZSA9IFNUQVRFLklETEVcbiAgICAgICAgICBvZmZzZXQrK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvciggJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyIFwiJyArIHZhbHVlW29mZnNldF0gKyAnXCIgYXQgb2Zmc2V0ICcgKyBvZmZzZXQgKVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYoIHN0YXRlID09PSBTVEFURS5BVFRSICkge1xuICAgICAgICBpZiggdmFsdWVbb2Zmc2V0XSA9PT0nOycgfHwgaGFzV2hpdGVzcGFjZSggdmFsdWVbb2Zmc2V0XSApICkge1xuICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgZW5kID0gdmFsdWUuaW5kZXhPZiggJz0nLCBvZmZzZXQgKVxuICAgICAgICBpZiggZW5kID09PSAtMSApIHRocm93IG5ldyBFcnJvciggJ0V4cGVjdGVkIGF0dHJpYnV0ZSBkZWxpbWl0ZXIgYXQgb2Zmc2V0ICcgKyBvZmZzZXQgKVxuICAgICAgICB2YXIgYXR0ciA9IHRyaW0oIHZhbHVlLnNsaWNlKCBvZmZzZXQsIGVuZCApICkudG9Mb3dlckNhc2UoKVxuICAgICAgICB2YXIgYXR0clZhbHVlID0gJydcbiAgICAgICAgb2Zmc2V0ID0gZW5kICsgMVxuICAgICAgICBvZmZzZXQgPSBza2lwV2hpdGVzcGFjZSggdmFsdWUsIG9mZnNldCApXG4gICAgICAgIGlmKCB2YWx1ZVtvZmZzZXRdID09PSAnXCInICkge1xuICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgICAgd2hpbGUoIG9mZnNldCA8IGxlbmd0aCApIHtcbiAgICAgICAgICAgIGlmKCB2YWx1ZVtvZmZzZXRdID09PSAnXCInICkge1xuICAgICAgICAgICAgICBvZmZzZXQrKzsgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCB2YWx1ZVtvZmZzZXRdID09PSAnXFxcXCcgKSB7XG4gICAgICAgICAgICAgIG9mZnNldCsrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdHRyVmFsdWUgKz0gdmFsdWVbb2Zmc2V0XVxuICAgICAgICAgICAgb2Zmc2V0KytcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IG9mZnNldCArIDFcbiAgICAgICAgICB3aGlsZSggIURFTElNSVRFUl9QQVRURVJOLnRlc3QoIHZhbHVlW2VuZF0gKSAmJiBlbmQgPCBsZW5ndGggKSB7XG4gICAgICAgICAgICBlbmQrK1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdHRyVmFsdWUgPSB2YWx1ZS5zbGljZSggb2Zmc2V0LCBlbmQgKVxuICAgICAgICAgIG9mZnNldCA9IGVuZFxuICAgICAgICB9XG4gICAgICAgIGlmKCByZWZbIGF0dHIgXSAmJiBMaW5rLmlzU2luZ2xlT2NjdXJlbmNlQXR0ciggYXR0ciApICkge1xuICAgICAgICAgIC8vIElnbm9yZSBtdWx0aXBsZXMgb2YgYXR0cmlidXRlcyB3aGljaCBtYXkgb25seSBhcHBlYXIgb25jZVxuICAgICAgICB9IGVsc2UgaWYoIGF0dHJbIGF0dHIubGVuZ3RoIC0gMSBdID09PSAnKicgKSB7XG4gICAgICAgICAgcmVmWyBhdHRyIF0gPSBMaW5rLnBhcnNlRXh0ZW5kZWRWYWx1ZSggYXR0clZhbHVlIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdHRyVmFsdWUgPSBhdHRyID09PSAncmVsJyB8fCBhdHRyID09PSAndHlwZScgP1xuICAgICAgICAgICAgYXR0clZhbHVlLnRvTG93ZXJDYXNlKCkgOiBhdHRyVmFsdWVcbiAgICAgICAgICBpZiggcmVmWyBhdHRyIF0gIT0gbnVsbCApIHtcbiAgICAgICAgICAgIGlmKCBBcnJheS5pc0FycmF5KCByZWZbIGF0dHIgXSApICkge1xuICAgICAgICAgICAgICByZWZbIGF0dHIgXS5wdXNoKCBhdHRyVmFsdWUgKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVmWyBhdHRyIF0gPSBbIHJlZlsgYXR0ciBdLCBhdHRyVmFsdWUgXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWZbIGF0dHIgXSA9IGF0dHJWYWx1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2goIHZhbHVlW29mZnNldF0gKSB7XG4gICAgICAgICAgY2FzZSAnLCc6IHN0YXRlID0gU1RBVEUuSURMRTsgYnJlYWtcbiAgICAgICAgICBjYXNlICc7Jzogc3RhdGUgPSBTVEFURS5BVFRSOyBicmVha1xuICAgICAgICB9XG4gICAgICAgIG9mZnNldCsrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoICdVbmtub3duIHBhcnNlciBzdGF0ZSBcIicgKyBzdGF0ZSArICdcIicgKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJlZiA9IG51bGxcblxuICAgIHJldHVybiB0aGlzXG5cbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuXG4gICAgdmFyIHJlZnMgPSBbXVxuICAgIHZhciBsaW5rID0gJydcbiAgICB2YXIgcmVmID0gbnVsbFxuXG4gICAgZm9yKCB2YXIgaSA9IDA7IGkgPCB0aGlzLnJlZnMubGVuZ3RoOyBpKysgKSB7XG4gICAgICByZWYgPSB0aGlzLnJlZnNbaV1cbiAgICAgIGxpbmsgPSBPYmplY3Qua2V5cyggdGhpcy5yZWZzW2ldICkucmVkdWNlKCBmdW5jdGlvbiggbGluaywgYXR0ciApIHtcbiAgICAgICAgaWYoIGF0dHIgPT09ICd1cmknICkgcmV0dXJuIGxpbmtcbiAgICAgICAgcmV0dXJuIGxpbmsgKyAnOyAnICsgTGluay5mb3JtYXRBdHRyaWJ1dGUoIGF0dHIsIHJlZlsgYXR0ciBdIClcbiAgICAgIH0sICc8JyArIHJlZi51cmkgKyAnPicgKVxuICAgICAgcmVmcy5wdXNoKCBsaW5rIClcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcy5qb2luKCAnLCAnIClcblxuICB9XG5cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYW4gZW5jb2RpbmcgY2FuIGJlXG4gKiBuYXRpdmVseSBoYW5kbGVkIHdpdGggYSBgQnVmZmVyYFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuTGluay5pc0NvbXBhdGlibGVFbmNvZGluZyA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgcmV0dXJuIENPTVBBVElCTEVfRU5DT0RJTkdfUEFUVEVSTi50ZXN0KCB2YWx1ZSApXG59XG5cbkxpbmsucGFyc2UgPSBmdW5jdGlvbiggdmFsdWUsIG9mZnNldCApIHtcbiAgcmV0dXJuIG5ldyBMaW5rKCkucGFyc2UoIHZhbHVlLCBvZmZzZXQgKVxufVxuXG5MaW5rLmlzU2luZ2xlT2NjdXJlbmNlQXR0ciA9IGZ1bmN0aW9uKCBhdHRyICkge1xuICByZXR1cm4gYXR0ciA9PT0gJ3JlbCcgfHwgYXR0ciA9PT0gJ3R5cGUnIHx8IGF0dHIgPT09ICdtZWRpYScgfHxcbiAgICBhdHRyID09PSAndGl0bGUnIHx8IGF0dHIgPT09ICd0aXRsZSonXG59XG5cbkxpbmsuaXNUb2tlbkF0dHIgPSBmdW5jdGlvbiggYXR0ciApIHtcbiAgcmV0dXJuIGF0dHIgPT09ICdyZWwnIHx8IGF0dHIgPT09ICd0eXBlJyB8fCBhdHRyID09PSAnYW5jaG9yJ1xufVxuXG5MaW5rLmVzY2FwZVF1b3RlcyA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcbiAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoIC9cIi9nLCAnXFxcXFwiJyApXG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGV4dGVuZGVkIHZhbHVlIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgaXRcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbkxpbmsucGFyc2VFeHRlbmRlZFZhbHVlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuICB2YXIgcGFydHMgPSAvKFteJ10rKT8oPzonKFteJ10rKScpPyguKykvLmV4ZWMoIHZhbHVlIClcbiAgcmV0dXJuIHtcbiAgICBsYW5ndWFnZTogcGFydHNbMl0udG9Mb3dlckNhc2UoKSxcbiAgICBlbmNvZGluZzogTGluay5pc0NvbXBhdGlibGVFbmNvZGluZyggcGFydHNbMV0gKSA/XG4gICAgICBudWxsIDogcGFydHNbMV0udG9Mb3dlckNhc2UoKSxcbiAgICB2YWx1ZTogTGluay5pc0NvbXBhdGlibGVFbmNvZGluZyggcGFydHNbMV0gKSA/XG4gICAgICBkZWNvZGVVUklDb21wb25lbnQoIHBhcnRzWzNdICkgOiBwYXJ0c1szXVxuICB9XG59XG5cbi8qKlxuICogRm9ybWF0IGEgZ2l2ZW4gZXh0ZW5kZWQgYXR0cmlidXRlIGFuZCBpdCdzIHZhbHVlXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0clxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqL1xuTGluay5mb3JtYXRFeHRlbmRlZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBhdHRyLCBkYXRhICkge1xuXG4gIHZhciBlbmNvZGluZyA9ICggZGF0YS5lbmNvZGluZyB8fMKgJ3V0Zi04JyApLnRvVXBwZXJDYXNlKClcbiAgdmFyIGxhbmd1YWdlID0gZGF0YS5sYW5ndWFnZSB8fCAnZW4nXG5cbiAgdmFyIGVuY29kZWRWYWx1ZSA9ICcnXG5cbiAgaWYoIEJ1ZmZlci5pc0J1ZmZlciggZGF0YS52YWx1ZSApICYmIExpbmsuaXNDb21wYXRpYmxlRW5jb2RpbmcoIGVuY29kaW5nICkgKSB7XG4gICAgZW5jb2RlZFZhbHVlID0gZGF0YS52YWx1ZS50b1N0cmluZyggZW5jb2RpbmcgKVxuICB9IGVsc2UgaWYoIEJ1ZmZlci5pc0J1ZmZlciggZGF0YS52YWx1ZSApICkge1xuICAgIGVuY29kZWRWYWx1ZSA9IGRhdGEudmFsdWUudG9TdHJpbmcoICdoZXgnIClcbiAgICAgIC5yZXBsYWNlKCAvWzAtOWEtZl17Mn0vZ2ksICclJDEnIClcbiAgfSBlbHNlIHtcbiAgICBlbmNvZGVkVmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQoIGRhdGEudmFsdWUgKVxuICB9XG5cbiAgcmV0dXJuIGF0dHIgKyAnPScgKyBlbmNvZGluZyArICdcXCcnICtcbiAgICBsYW5ndWFnZSArICdcXCcnICsgZW5jb2RlZFZhbHVlXG5cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSBnaXZlbiBhdHRyaWJ1dGUgYW5kIGl0J3MgdmFsdWVcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbkxpbmsuZm9ybWF0QXR0cmlidXRlID0gZnVuY3Rpb24oIGF0dHIsIHZhbHVlICkge1xuXG4gIGlmKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuICAgIHJldHVybiB2YWx1ZS5tYXAoKCBpdGVtICkgPT4ge1xuICAgICAgcmV0dXJuIExpbmsuZm9ybWF0QXR0cmlidXRlKCBhdHRyLCBpdGVtIClcbiAgICB9KS5qb2luKCAnOyAnIClcbiAgfVxuXG4gIGlmKCBhdHRyWyBhdHRyLmxlbmd0aCAtIDEgXSA9PT0gJyonIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgKSB7XG4gICAgcmV0dXJuIExpbmsuZm9ybWF0RXh0ZW5kZWRBdHRyaWJ1dGUoIGF0dHIsIHZhbHVlIClcbiAgfVxuXG4gIGlmKCBMaW5rLmlzVG9rZW5BdHRyKCBhdHRyICkgKSB7XG4gICAgdmFsdWUgPSBuZWVkc1F1b3RlcyggdmFsdWUgKSA/XG4gICAgICAnXCInICsgTGluay5lc2NhcGVRdW90ZXMoIHZhbHVlICkgKyAnXCInIDpcbiAgICAgIExpbmsuZXNjYXBlUXVvdGVzKCB2YWx1ZSApXG4gIH0gZWxzZSBpZiggbmVlZHNRdW90ZXMoIHZhbHVlICkgKSB7XG4gICAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlIClcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGVzY2FwZSA8U1A+IDwsPiA8Oz4gd2l0aGluIHF1b3Rlc1xuICAgIHZhbHVlID0gdmFsdWVcbiAgICAgIC5yZXBsYWNlKCAvJTIwL2csICcgJyApXG4gICAgICAucmVwbGFjZSggLyUyQy9nLCAnLCcgKVxuICAgICAgLnJlcGxhY2UoIC8lM0IvZywgJzsnIClcblxuICAgIHZhbHVlID0gJ1wiJyArIHZhbHVlICsgJ1wiJ1xuICB9XG5cbiAgcmV0dXJuIGF0dHIgKyAnPScgKyB2YWx1ZVxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlua1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///35\n")},function(module,exports){eval("module.exports = false;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19saWJyYXJ5LmpzPzJkMDAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiMzYuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///36\n")},function(module,exports,__webpack_require__){eval("var isObject = __webpack_require__(12);\nvar document = __webpack_require__(2).document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19kb20tY3JlYXRlLmpzPzIzMGUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLEVBQWM7QUFDckMsZUFBZSxtQkFBTyxDQUFDLENBQVc7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzNy5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vX2lzLW9iamVjdCcpO1xudmFyIGRvY3VtZW50ID0gcmVxdWlyZSgnLi9fZ2xvYmFsJykuZG9jdW1lbnQ7XG4vLyB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCBpcyAnb2JqZWN0JyBpbiBvbGQgSUVcbnZhciBpcyA9IGlzT2JqZWN0KGRvY3VtZW50KSAmJiBpc09iamVjdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpcyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXQpIDoge307XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///37\n")},function(module,exports){eval("module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19wcm9wZXJ0eS1kZXNjLmpzPzQ2MzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIzOC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJpdG1hcCwgdmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBlbnVtZXJhYmxlOiAhKGJpdG1hcCAmIDEpLFxuICAgIGNvbmZpZ3VyYWJsZTogIShiaXRtYXAgJiAyKSxcbiAgICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///38\n")},function(module,exports,__webpack_require__){eval("var global = __webpack_require__(2);\nvar core = __webpack_require__(22);\nvar hide = __webpack_require__(3);\nvar redefine = __webpack_require__(16);\nvar ctx = __webpack_require__(71);\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19leHBvcnQuanM/NWNhMSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsQ0FBVztBQUNoQyxXQUFXLG1CQUFPLENBQUMsRUFBUztBQUM1QixXQUFXLG1CQUFPLENBQUMsQ0FBUztBQUM1QixlQUFlLG1CQUFPLENBQUMsRUFBYTtBQUNwQyxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsdUJBQXVCO0FBQ3pHLGlFQUFpRTtBQUNqRSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLGNBQWM7QUFDZCxjQUFjO0FBQ2QsY0FBYztBQUNkLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGdCQUFnQjtBQUNoQiIsImZpbGUiOiIzOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBnbG9iYWwgPSByZXF1aXJlKCcuL19nbG9iYWwnKTtcbnZhciBjb3JlID0gcmVxdWlyZSgnLi9fY29yZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuL19oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuL19yZWRlZmluZScpO1xudmFyIGN0eCA9IHJlcXVpcmUoJy4vX2N0eCcpO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xuXG52YXIgJGV4cG9ydCA9IGZ1bmN0aW9uICh0eXBlLCBuYW1lLCBzb3VyY2UpIHtcbiAgdmFyIElTX0ZPUkNFRCA9IHR5cGUgJiAkZXhwb3J0LkY7XG4gIHZhciBJU19HTE9CQUwgPSB0eXBlICYgJGV4cG9ydC5HO1xuICB2YXIgSVNfU1RBVElDID0gdHlwZSAmICRleHBvcnQuUztcbiAgdmFyIElTX1BST1RPID0gdHlwZSAmICRleHBvcnQuUDtcbiAgdmFyIElTX0JJTkQgPSB0eXBlICYgJGV4cG9ydC5CO1xuICB2YXIgdGFyZ2V0ID0gSVNfR0xPQkFMID8gZ2xvYmFsIDogSVNfU1RBVElDID8gZ2xvYmFsW25hbWVdIHx8IChnbG9iYWxbbmFtZV0gPSB7fSkgOiAoZ2xvYmFsW25hbWVdIHx8IHt9KVtQUk9UT1RZUEVdO1xuICB2YXIgZXhwb3J0cyA9IElTX0dMT0JBTCA/IGNvcmUgOiBjb3JlW25hbWVdIHx8IChjb3JlW25hbWVdID0ge30pO1xuICB2YXIgZXhwUHJvdG8gPSBleHBvcnRzW1BST1RPVFlQRV0gfHwgKGV4cG9ydHNbUFJPVE9UWVBFXSA9IHt9KTtcbiAgdmFyIGtleSwgb3duLCBvdXQsIGV4cDtcbiAgaWYgKElTX0dMT0JBTCkgc291cmNlID0gbmFtZTtcbiAgZm9yIChrZXkgaW4gc291cmNlKSB7XG4gICAgLy8gY29udGFpbnMgaW4gbmF0aXZlXG4gICAgb3duID0gIUlTX0ZPUkNFRCAmJiB0YXJnZXQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZDtcbiAgICAvLyBleHBvcnQgbmF0aXZlIG9yIHBhc3NlZFxuICAgIG91dCA9IChvd24gPyB0YXJnZXQgOiBzb3VyY2UpW2tleV07XG4gICAgLy8gYmluZCB0aW1lcnMgdG8gZ2xvYmFsIGZvciBjYWxsIGZyb20gZXhwb3J0IGNvbnRleHRcbiAgICBleHAgPSBJU19CSU5EICYmIG93biA/IGN0eChvdXQsIGdsb2JhbCkgOiBJU19QUk9UTyAmJiB0eXBlb2Ygb3V0ID09ICdmdW5jdGlvbicgPyBjdHgoRnVuY3Rpb24uY2FsbCwgb3V0KSA6IG91dDtcbiAgICAvLyBleHRlbmQgZ2xvYmFsXG4gICAgaWYgKHRhcmdldCkgcmVkZWZpbmUodGFyZ2V0LCBrZXksIG91dCwgdHlwZSAmICRleHBvcnQuVSk7XG4gICAgLy8gZXhwb3J0XG4gICAgaWYgKGV4cG9ydHNba2V5XSAhPSBvdXQpIGhpZGUoZXhwb3J0cywga2V5LCBleHApO1xuICAgIGlmIChJU19QUk9UTyAmJiBleHBQcm90b1trZXldICE9IG91dCkgZXhwUHJvdG9ba2V5XSA9IG91dDtcbiAgfVxufTtcbmdsb2JhbC5jb3JlID0gY29yZTtcbi8vIHR5cGUgYml0bWFwXG4kZXhwb3J0LkYgPSAxOyAgIC8vIGZvcmNlZFxuJGV4cG9ydC5HID0gMjsgICAvLyBnbG9iYWxcbiRleHBvcnQuUyA9IDQ7ICAgLy8gc3RhdGljXG4kZXhwb3J0LlAgPSA4OyAgIC8vIHByb3RvXG4kZXhwb3J0LkIgPSAxNjsgIC8vIGJpbmRcbiRleHBvcnQuVyA9IDMyOyAgLy8gd3JhcFxuJGV4cG9ydC5VID0gNjQ7ICAvLyBzYWZlXG4kZXhwb3J0LlIgPSAxMjg7IC8vIHJlYWwgcHJvdG8gbWV0aG9kIGZvciBgbGlicmFyeWBcbm1vZHVsZS5leHBvcnRzID0gJGV4cG9ydDtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///39\n")},function(module,exports){eval("module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hLWZ1bmN0aW9uLmpzP2Q4ZTgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHRocm93IFR5cGVFcnJvcihpdCArICcgaXMgbm90IGEgZnVuY3Rpb24hJyk7XG4gIHJldHVybiBpdDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///40\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = __webpack_require__(75);\nvar enumBugKeys = __webpack_require__(42);\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy5qcz8wZDU4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLEVBQXlCO0FBQzdDLGtCQUFrQixtQkFBTyxDQUFDLEVBQWtCOztBQUU1QztBQUNBO0FBQ0EiLCJmaWxlIjoiNDEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMTQgLyAxNS4yLjMuMTQgT2JqZWN0LmtleXMoTylcbnZhciAka2V5cyA9IHJlcXVpcmUoJy4vX29iamVjdC1rZXlzLWludGVybmFsJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuL19lbnVtLWJ1Zy1rZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gIHJldHVybiAka2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///41\n")},function(module,exports){eval("// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19lbnVtLWJ1Zy1rZXlzLmpzP2UxMWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJRSA4LSBkb24ndCBlbnVtIGJ1ZyBrZXlzXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgJ2NvbnN0cnVjdG9yLGhhc093blByb3BlcnR5LGlzUHJvdG90eXBlT2YscHJvcGVydHlJc0VudW1lcmFibGUsdG9Mb2NhbGVTdHJpbmcsdG9TdHJpbmcsdmFsdWVPZidcbikuc3BsaXQoJywnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///42\n")},function(module,exports,__webpack_require__){eval("var def = __webpack_require__(24).f;\nvar has = __webpack_require__(17);\nvar TAG = __webpack_require__(1)('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zZXQtdG8tc3RyaW5nLXRhZy5qcz83ZjIwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxFQUFjO0FBQ2hDLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLFVBQVUsbUJBQU8sQ0FBQyxDQUFROztBQUUxQjtBQUNBLG9FQUFvRSxpQ0FBaUM7QUFDckciLCJmaWxlIjoiNDMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZGVmID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJykuZjtcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciBUQUcgPSByZXF1aXJlKCcuL193a3MnKSgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIHRhZywgc3RhdCkge1xuICBpZiAoaXQgJiYgIWhhcyhpdCA9IHN0YXQgPyBpdCA6IGl0LnByb3RvdHlwZSwgVEFHKSkgZGVmKGl0LCBUQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogdGFnIH0pO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///43\n")},function(module,exports,__webpack_require__){eval("// 7.1.13 ToObject(argument)\nvar defined = __webpack_require__(15);\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1vYmplY3QuanM/NGJmOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDO0FBQ0E7QUFDQSIsImZpbGUiOiI0NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIDcuMS4xMyBUb09iamVjdChhcmd1bWVudClcbnZhciBkZWZpbmVkID0gcmVxdWlyZSgnLi9fZGVmaW5lZCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIE9iamVjdChkZWZpbmVkKGl0KSk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///44\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar isRegExp = __webpack_require__(80);\nvar anObject = __webpack_require__(4);\nvar speciesConstructor = __webpack_require__(81);\nvar advanceStringIndex = __webpack_require__(46);\nvar toLength = __webpack_require__(28);\nvar callRegExpExec = __webpack_require__(47);\nvar regexpExec = __webpack_require__(30);\nvar fails = __webpack_require__(14);\nvar $min = Math.min;\nvar $push = [].push;\nvar $SPLIT = 'split';\nvar LENGTH = 'length';\nvar LAST_INDEX = 'lastIndex';\nvar MAX_UINT32 = 0xffffffff;\n\n// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError\nvar SUPPORTS_Y = !fails(function () { RegExp(MAX_UINT32, 'y'); });\n\n// @@split logic\n__webpack_require__(48)('split', 2, function (defined, SPLIT, $split, maybeCallNative) {\n  var internalSplit;\n  if (\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ) {\n    // based on es5-shim implementation, need to rework it\n    internalSplit = function (separator, limit) {\n      var string = String(this);\n      if (separator === undefined && limit === 0) return [];\n      // If `separator` is not a regex, use native split\n      if (!isRegExp(separator)) return $split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var match, lastIndex, lastLength;\n      while (match = regexpExec.call(separatorCopy, string)) {\n        lastIndex = separatorCopy[LAST_INDEX];\n        if (lastIndex > lastLastIndex) {\n          output.push(string.slice(lastLastIndex, match.index));\n          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if (output[LENGTH] >= splitLimit) break;\n        }\n        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if (lastLastIndex === string[LENGTH]) {\n        if (lastLength || !separatorCopy.test('')) output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {\n    internalSplit = function (separator, limit) {\n      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);\n    };\n  } else {\n    internalSplit = $split;\n  }\n\n  return [\n    // `String.prototype.split` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.split\n    function split(separator, limit) {\n      var O = defined(this);\n      var splitter = separator == undefined ? undefined : separator[SPLIT];\n      return splitter !== undefined\n        ? splitter.call(separator, O, limit)\n        : internalSplit.call(String(O), separator, limit);\n    },\n    // `RegExp.prototype[@@split]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split\n    //\n    // NOTE: This cannot be properly polyfilled in engines that don't support\n    // the 'y' flag.\n    function (regexp, limit) {\n      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var C = speciesConstructor(rx, RegExp);\n\n      var unicodeMatching = rx.unicode;\n      var flags = (rx.ignoreCase ? 'i' : '') +\n                  (rx.multiline ? 'm' : '') +\n                  (rx.unicode ? 'u' : '') +\n                  (SUPPORTS_Y ? 'y' : 'g');\n\n      // ^(? + rx + ) is needed, in combination with some S slicing, to\n      // simulate the 'y' flag.\n      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);\n      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;\n      if (lim === 0) return [];\n      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];\n      var p = 0;\n      var q = 0;\n      var A = [];\n      while (q < S.length) {\n        splitter.lastIndex = SUPPORTS_Y ? q : 0;\n        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));\n        var e;\n        if (\n          z === null ||\n          (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p\n        ) {\n          q = advanceStringIndex(S, q, unicodeMatching);\n        } else {\n          A.push(S.slice(p, q));\n          if (A.length === lim) return A;\n          for (var i = 1; i <= z.length - 1; i++) {\n            A.push(z[i]);\n            if (A.length === lim) return A;\n          }\n          q = p = e;\n        }\n      }\n      A.push(S.slice(p));\n      return A;\n    }\n  ];\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuc3BsaXQuanM/MjhhNSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyx5QkFBeUIsbUJBQU8sQ0FBQyxFQUF3QjtBQUN6RCx5QkFBeUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUMxRCxlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUF5QjtBQUN0RCxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUN6QyxZQUFZLG1CQUFPLENBQUMsRUFBVTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMseUJBQXlCLEVBQUU7O0FBRWhFO0FBQ0EsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GO0FBQ25GO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI0NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi9faXMtcmVnZXhwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL19zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgYWR2YW5jZVN0cmluZ0luZGV4ID0gcmVxdWlyZSgnLi9fYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIGNhbGxSZWdFeHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMtYWJzdHJhY3QnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgJG1pbiA9IE1hdGgubWluO1xudmFyICRwdXNoID0gW10ucHVzaDtcbnZhciAkU1BMSVQgPSAnc3BsaXQnO1xudmFyIExFTkdUSCA9ICdsZW5ndGgnO1xudmFyIExBU1RfSU5ERVggPSAnbGFzdEluZGV4JztcbnZhciBNQVhfVUlOVDMyID0gMHhmZmZmZmZmZjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgUmVnRXhwKE1BWF9VSU5UMzIsICd5Jyk7IH0pO1xuXG4vLyBAQHNwbGl0IGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3NwbGl0JywgMiwgZnVuY3Rpb24gKGRlZmluZWQsIFNQTElULCAkc3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJ1skU1BMSVRdKC8oYikqLylbMV0gPT0gJ2MnIHx8XG4gICAgJ3Rlc3QnWyRTUExJVF0oLyg/OikvLCAtMSlbTEVOR1RIXSAhPSA0IHx8XG4gICAgJ2FiJ1skU1BMSVRdKC8oPzphYikqLylbTEVOR1RIXSAhPSAyIHx8XG4gICAgJy4nWyRTUExJVF0oLyguPykoLj8pLylbTEVOR1RIXSAhPSA0IHx8XG4gICAgJy4nWyRTUExJVF0oLygpKCkvKVtMRU5HVEhdID4gMSB8fFxuICAgICcnWyRTUExJVF0oLy4/LylbTEVOR1RIXVxuICApIHtcbiAgICAvLyBiYXNlZCBvbiBlczUtc2hpbSBpbXBsZW1lbnRhdGlvbiwgbmVlZCB0byByZXdvcmsgaXRcbiAgICBpbnRlcm5hbFNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBzdHJpbmcgPSBTdHJpbmcodGhpcyk7XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQgJiYgbGltaXQgPT09IDApIHJldHVybiBbXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHJldHVybiAkc3BsaXQuY2FsbChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgdmFyIG91dHB1dCA9IFtdO1xuICAgICAgdmFyIGZsYWdzID0gKHNlcGFyYXRvci5pZ25vcmVDYXNlID8gJ2knIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IubXVsdGlsaW5lID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLnN0aWNreSA/ICd5JyA6ICcnKTtcbiAgICAgIHZhciBsYXN0TGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciBzcGxpdExpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9VSU5UMzIgOiBsaW1pdCA+Pj4gMDtcbiAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICB2YXIgc2VwYXJhdG9yQ29weSA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgdmFyIG1hdGNoLCBsYXN0SW5kZXgsIGxhc3RMZW5ndGg7XG4gICAgICB3aGlsZSAobWF0Y2ggPSByZWdleHBFeGVjLmNhbGwoc2VwYXJhdG9yQ29weSwgc3RyaW5nKSkge1xuICAgICAgICBsYXN0SW5kZXggPSBzZXBhcmF0b3JDb3B5W0xBU1RfSU5ERVhdO1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaFtMRU5HVEhdID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZ1tMRU5HVEhdKSAkcHVzaC5hcHBseShvdXRwdXQsIG1hdGNoLnNsaWNlKDEpKTtcbiAgICAgICAgICBsYXN0TGVuZ3RoID0gbWF0Y2hbMF1bTEVOR1RIXTtcbiAgICAgICAgICBsYXN0TGFzdEluZGV4ID0gbGFzdEluZGV4O1xuICAgICAgICAgIGlmIChvdXRwdXRbTEVOR1RIXSA+PSBzcGxpdExpbWl0KSBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VwYXJhdG9yQ29weVtMQVNUX0lOREVYXSA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHlbTEFTVF9JTkRFWF0rKzsgLy8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcFxuICAgICAgfVxuICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZ1tMRU5HVEhdKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXRbTEVOR1RIXSA+IHNwbGl0TGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgc3BsaXRMaW1pdCkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJ1skU1BMSVRdKHVuZGVmaW5lZCwgMClbTEVOR1RIXSkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiAkc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludGVybmFsU3BsaXQgPSAkc3BsaXQ7XG4gIH1cblxuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnNwbGl0YCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNwbGl0XG4gICAgZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIHNwbGl0dGVyID0gc2VwYXJhdG9yID09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHNlcGFyYXRvcltTUExJVF07XG4gICAgICByZXR1cm4gc3BsaXR0ZXIgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHNwbGl0dGVyLmNhbGwoc2VwYXJhdG9yLCBPLCBsaW1pdClcbiAgICAgICAgOiBpbnRlcm5hbFNwbGl0LmNhbGwoU3RyaW5nKE8pLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAc3BsaXRcbiAgICAvL1xuICAgIC8vIE5PVEU6IFRoaXMgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gZW5naW5lcyB0aGF0IGRvbid0IHN1cHBvcnRcbiAgICAvLyB0aGUgJ3knIGZsYWcuXG4gICAgZnVuY3Rpb24gKHJlZ2V4cCwgbGltaXQpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUoaW50ZXJuYWxTcGxpdCwgcmVnZXhwLCB0aGlzLCBsaW1pdCwgaW50ZXJuYWxTcGxpdCAhPT0gJHNwbGl0KTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gJG1pbih0b0xlbmd0aChzcGxpdHRlci5sYXN0SW5kZXggKyAoU1VQUE9SVFNfWSA/IDAgOiBxKSksIFMubGVuZ3RoKSkgPT09IHBcbiAgICAgICAgKSB7XG4gICAgICAgICAgcSA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCBxLCB1bmljb2RlTWF0Y2hpbmcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIEEucHVzaChTLnNsaWNlKHAsIHEpKTtcbiAgICAgICAgICBpZiAoQS5sZW5ndGggPT09IGxpbSkgcmV0dXJuIEE7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gei5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIEEucHVzaCh6W2ldKTtcbiAgICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcSA9IHAgPSBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBBLnB1c2goUy5zbGljZShwKSk7XG4gICAgICByZXR1cm4gQTtcbiAgICB9XG4gIF07XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///45\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar at = __webpack_require__(82)(true);\n\n // `AdvanceStringIndex` abstract operation\n// https://tc39.github.io/ecma262/#sec-advancestringindex\nmodule.exports = function (S, index, unicode) {\n  return index + (unicode ? at(S, index).length : 1);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZHZhbmNlLXN0cmluZy1pbmRleC5qcz8wMzkwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsU0FBUyxtQkFBTyxDQUFDLEVBQWM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiNDYuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgYXQgPSByZXF1aXJlKCcuL19zdHJpbmctYXQnKSh0cnVlKTtcblxuIC8vIGBBZHZhbmNlU3RyaW5nSW5kZXhgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYWR2YW5jZXN0cmluZ2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChTLCBpbmRleCwgdW5pY29kZSkge1xuICByZXR1cm4gaW5kZXggKyAodW5pY29kZSA/IGF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///46\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar classof = __webpack_require__(83);\nvar builtinExec = RegExp.prototype.exec;\n\n // `RegExpExec` abstract operation\n// https://tc39.github.io/ecma262/#sec-regexpexec\nmodule.exports = function (R, S) {\n  var exec = R.exec;\n  if (typeof exec === 'function') {\n    var result = exec.call(R, S);\n    if (typeof result !== 'object') {\n      throw new TypeError('RegExp exec method returned something other than an Object or null');\n    }\n    return result;\n  }\n  if (classof(R) !== 'RegExp') {\n    throw new TypeError('RegExp#exec called on incompatible receiver');\n  }\n  return builtinExec.call(R, S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19yZWdleHAtZXhlYy1hYnN0cmFjdC5qcz81ZjFiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjQ3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4vX2NsYXNzb2YnKTtcbnZhciBidWlsdGluRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcblxuIC8vIGBSZWdFeHBFeGVjYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cGV4ZWNcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIGlmICh0eXBlb2YgZXhlYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZXN1bHQgPSBleGVjLmNhbGwoUiwgUyk7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAgZXhlYyBtZXRob2QgcmV0dXJuZWQgc29tZXRoaW5nIG90aGVyIHRoYW4gYW4gT2JqZWN0IG9yIG51bGwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyJyk7XG4gIH1cbiAgcmV0dXJuIGJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///47\n")},function(module,exports,__webpack_require__){"use strict";eval("\n__webpack_require__(85);\nvar redefine = __webpack_require__(16);\nvar hide = __webpack_require__(3);\nvar fails = __webpack_require__(14);\nvar defined = __webpack_require__(15);\nvar wks = __webpack_require__(1);\nvar regexpExec = __webpack_require__(30);\n\nvar SPECIES = wks('species');\n\nvar REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {\n  // #replace needs built-in support for named groups.\n  // #match works fine because it just return the exec results, even if it has\n  // a \"grops\" property.\n  var re = /./;\n  re.exec = function () {\n    var result = [];\n    result.groups = { a: '7' };\n    return result;\n  };\n  return ''.replace(re, '$<a>') !== '7';\n});\n\nvar SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = (function () {\n  // Chrome 51 has a buggy \"split\" implementation when RegExp#exec !== nativeExec\n  var re = /(?:)/;\n  var originalExec = re.exec;\n  re.exec = function () { return originalExec.apply(this, arguments); };\n  var result = 'ab'.split(re);\n  return result.length === 2 && result[0] === 'a' && result[1] === 'b';\n})();\n\nmodule.exports = function (KEY, length, exec) {\n  var SYMBOL = wks(KEY);\n\n  var DELEGATES_TO_SYMBOL = !fails(function () {\n    // String methods call symbol-named RegEp methods\n    var O = {};\n    O[SYMBOL] = function () { return 7; };\n    return ''[KEY](O) != 7;\n  });\n\n  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {\n    // Symbol-named RegExp methods call .exec\n    var execCalled = false;\n    var re = /a/;\n    re.exec = function () { execCalled = true; return null; };\n    if (KEY === 'split') {\n      // RegExp[@@split] doesn't call the regex's exec method, but first creates\n      // a new one. We need to return the patched regex when creating the new one.\n      re.constructor = {};\n      re.constructor[SPECIES] = function () { return re; };\n    }\n    re[SYMBOL]('');\n    return !execCalled;\n  }) : undefined;\n\n  if (\n    !DELEGATES_TO_SYMBOL ||\n    !DELEGATES_TO_EXEC ||\n    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||\n    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)\n  ) {\n    var nativeRegExpMethod = /./[SYMBOL];\n    var fns = exec(\n      defined,\n      SYMBOL,\n      ''[KEY],\n      function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {\n        if (regexp.exec === regexpExec) {\n          if (DELEGATES_TO_SYMBOL && !forceStringMethod) {\n            // The native String method already delegates to @@method (this\n            // polyfilled function), leasing to infinite recursion.\n            // We avoid it by directly calling the native @@method method.\n            return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };\n          }\n          return { done: true, value: nativeMethod.call(str, regexp, arg2) };\n        }\n        return { done: false };\n      }\n    );\n    var strfn = fns[0];\n    var rxfn = fns[1];\n\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function (string, arg) { return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function (string) { return rxfn.call(string, this); }\n    );\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19maXgtcmUtd2tzLmpzPzIxNGYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixtQkFBTyxDQUFDLEVBQW1CO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxFQUFhO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxDQUFTO0FBQzVCLFlBQVksbUJBQU8sQ0FBQyxFQUFVO0FBQzlCLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDLFVBQVUsbUJBQU8sQ0FBQyxDQUFRO0FBQzFCLGlCQUFpQixtQkFBTyxDQUFDLEVBQWdCOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDRDQUE0QztBQUNyRTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixVQUFVO0FBQ3ZDO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixtQkFBbUIsYUFBYTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQ0FBcUM7QUFDckU7QUFDQTtBQUNBLDJCQUEyQixnQ0FBZ0M7QUFDM0Q7QUFDQTtBQUNBIiwiZmlsZSI6IjQ4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xucmVxdWlyZSgnLi9lczYucmVnZXhwLmV4ZWMnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4vX2ZhaWxzJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbnZhciB3a3MgPSByZXF1aXJlKCcuL193a3MnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi9fcmVnZXhwLWV4ZWMnKTtcblxudmFyIFNQRUNJRVMgPSB3a3MoJ3NwZWNpZXMnKTtcblxudmFyIFJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gI3JlcGxhY2UgbmVlZHMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgbmFtZWQgZ3JvdXBzLlxuICAvLyAjbWF0Y2ggd29ya3MgZmluZSBiZWNhdXNlIGl0IGp1c3QgcmV0dXJuIHRoZSBleGVjIHJlc3VsdHMsIGV2ZW4gaWYgaXQgaGFzXG4gIC8vIGEgXCJncm9wc1wiIHByb3BlcnR5LlxuICB2YXIgcmUgPSAvLi87XG4gIHJlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHJlc3VsdC5ncm91cHMgPSB7IGE6ICc3JyB9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHJldHVybiAnJy5yZXBsYWNlKHJlLCAnJDxhPicpICE9PSAnNyc7XG59KTtcblxudmFyIFNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQyA9IChmdW5jdGlvbiAoKSB7XG4gIC8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuICB2YXIgcmUgPSAvKD86KS87XG4gIHZhciBvcmlnaW5hbEV4ZWMgPSByZS5leGVjO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb3JpZ2luYWxFeGVjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gIHZhciByZXN1bHQgPSAnYWInLnNwbGl0KHJlKTtcbiAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IDIgJiYgcmVzdWx0WzBdID09PSAnYScgJiYgcmVzdWx0WzFdID09PSAnYic7XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChLRVksIGxlbmd0aCwgZXhlYykge1xuICB2YXIgU1lNQk9MID0gd2tzKEtFWSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19TWU1CT0wgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIC8vIFN0cmluZyBtZXRob2RzIGNhbGwgc3ltYm9sLW5hbWVkIFJlZ0VwIG1ldGhvZHNcbiAgICB2YXIgTyA9IHt9O1xuICAgIE9bU1lNQk9MXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDc7IH07XG4gICAgcmV0dXJuICcnW0tFWV0oTykgIT0gNztcbiAgfSk7XG5cbiAgdmFyIERFTEVHQVRFU19UT19FWEVDID0gREVMRUdBVEVTX1RPX1NZTUJPTCA/ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG4gICAgaWYgKEtFWSA9PT0gJ3NwbGl0Jykge1xuICAgICAgLy8gUmVnRXhwW0BAc3BsaXRdIGRvZXNuJ3QgY2FsbCB0aGUgcmVnZXgncyBleGVjIG1ldGhvZCwgYnV0IGZpcnN0IGNyZWF0ZXNcbiAgICAgIC8vIGEgbmV3IG9uZS4gV2UgbmVlZCB0byByZXR1cm4gdGhlIHBhdGNoZWQgcmVnZXggd2hlbiBjcmVhdGluZyB0aGUgbmV3IG9uZS5cbiAgICAgIHJlLmNvbnN0cnVjdG9yID0ge307XG4gICAgICByZS5jb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlOyB9O1xuICAgIH1cbiAgICByZVtTWU1CT0xdKCcnKTtcbiAgICByZXR1cm4gIWV4ZWNDYWxsZWQ7XG4gIH0pIDogdW5kZWZpbmVkO1xuXG4gIGlmIChcbiAgICAhREVMRUdBVEVTX1RPX1NZTUJPTCB8fFxuICAgICFERUxFR0FURVNfVE9fRVhFQyB8fFxuICAgIChLRVkgPT09ICdyZXBsYWNlJyAmJiAhUkVQTEFDRV9TVVBQT1JUU19OQU1FRF9HUk9VUFMpIHx8XG4gICAgKEtFWSA9PT0gJ3NwbGl0JyAmJiAhU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDKVxuICApIHtcbiAgICB2YXIgbmF0aXZlUmVnRXhwTWV0aG9kID0gLy4vW1NZTUJPTF07XG4gICAgdmFyIGZucyA9IGV4ZWMoXG4gICAgICBkZWZpbmVkLFxuICAgICAgU1lNQk9MLFxuICAgICAgJydbS0VZXSxcbiAgICAgIGZ1bmN0aW9uIG1heWJlQ2FsbE5hdGl2ZShuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICBpZiAocmVnZXhwLmV4ZWMgPT09IHJlZ2V4cEV4ZWMpIHtcbiAgICAgICAgICBpZiAoREVMRUdBVEVTX1RPX1NZTUJPTCAmJiAhZm9yY2VTdHJpbmdNZXRob2QpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgICAgLy8gcG9seWZpbGxlZCBmdW5jdGlvbiksIGxlYXNpbmcgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAgICAgICAgICAgLy8gV2UgYXZvaWQgaXQgYnkgZGlyZWN0bHkgY2FsbGluZyB0aGUgbmF0aXZlIEBAbWV0aG9kIG1ldGhvZC5cbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IG5hdGl2ZU1ldGhvZC5jYWxsKHN0ciwgcmVnZXhwLCBhcmcyKSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlIH07XG4gICAgICB9XG4gICAgKTtcbiAgICB2YXIgc3RyZm4gPSBmbnNbMF07XG4gICAgdmFyIHJ4Zm4gPSBmbnNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmZuKTtcbiAgICBoaWRlKFJlZ0V4cC5wcm90b3R5cGUsIFNZTUJPTCwgbGVuZ3RoID09IDJcbiAgICAgIC8vIDIxLjIuNS44IFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXShzdHJpbmcsIHJlcGxhY2VWYWx1ZSlcbiAgICAgIC8vIDIxLjIuNS4xMSBSZWdFeHAucHJvdG90eXBlW0BAc3BsaXRdKHN0cmluZywgbGltaXQpXG4gICAgICA/IGZ1bmN0aW9uIChzdHJpbmcsIGFyZykgeyByZXR1cm4gcnhmbi5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJ4Zm4uY2FsbChzdHJpbmcsIHRoaXMpOyB9XG4gICAgKTtcbiAgfVxufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///48\n")},function(module,exports){eval("function DefaultGraph () {\n  this.value = ''\n}\n\nDefaultGraph.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType\n}\n\nDefaultGraph.prototype.termType = 'DefaultGraph'\n\nmodule.exports = DefaultGraph\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2RlZmF1bHQtZ3JhcGguanM/ZDc2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjQ5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gRGVmYXVsdEdyYXBoICgpIHtcbiAgdGhpcy52YWx1ZSA9ICcnXG59XG5cbkRlZmF1bHRHcmFwaC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiAhIW90aGVyICYmIG90aGVyLnRlcm1UeXBlID09PSB0aGlzLnRlcm1UeXBlXG59XG5cbkRlZmF1bHRHcmFwaC5wcm90b3R5cGUudGVybVR5cGUgPSAnRGVmYXVsdEdyYXBoJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRHcmFwaFxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///49\n")},function(module,exports){eval("function NamedNode (iri) {\n  this.value = iri\n}\n\nNamedNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nNamedNode.prototype.termType = 'NamedNode'\n\nmodule.exports = NamedNode\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL25hbWVkLW5vZGUuanM/MTFhOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBIiwiZmlsZSI6IjUwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gTmFtZWROb2RlIChpcmkpIHtcbiAgdGhpcy52YWx1ZSA9IGlyaVxufVxuXG5OYW1lZE5vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZVxufVxuXG5OYW1lZE5vZGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ05hbWVkTm9kZSdcblxubW9kdWxlLmV4cG9ydHMgPSBOYW1lZE5vZGVcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///50\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||\n            (typeof self !== "undefined" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(95);\n// On some exotic environments, it\'s not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||\n                       (typeof global !== "undefined" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||\n                         (typeof global !== "undefined" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcz81MTE4Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjUxLmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///51\n')},function(module,exports,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(20);\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = __webpack_require__(96);\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = __webpack_require__(31).EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = __webpack_require__(53);\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(33).Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(10));\nutil.inherits = __webpack_require__(7);\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = __webpack_require__(97);\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = __webpack_require__(98);\nvar destroyImpl = __webpack_require__(54);\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || __webpack_require__(5);\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = __webpack_require__(55).StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || __webpack_require__(5);\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = __webpack_require__(55).StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6), __webpack_require__(19)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcz82ZjJlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLEVBQXNCO0FBQ3hDOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLEVBQVM7QUFDL0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUyxtQkFBTyxDQUFDLEVBQVE7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLEVBQTJCO0FBQ2hEOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxFQUFhO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCLG1CQUFPLENBQUMsRUFBYztBQUMvQyxnQkFBZ0IsbUJBQU8sQ0FBQyxDQUFVO0FBQ2xDOztBQUVBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsRUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixtQkFBTyxDQUFDLEVBQStCO0FBQ3hELGtCQUFrQixtQkFBTyxDQUFDLEVBQTRCO0FBQ3REOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDZFQUE2RTtBQUN0Sjs7QUFFQTtBQUNBLHFCQUFxQixtQkFBTyxDQUFDLENBQWtCOztBQUUvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELDBGQUEwRjs7QUFFM0k7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtQkFBTyxDQUFDLEVBQWlCO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsQ0FBa0I7O0FBRS9DOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrR0FBa0c7QUFDbEcsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLDRGQUE0RjtBQUM1RixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLG1CQUFPLENBQUMsRUFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDRDQUE0Qzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0RUFBNEU7O0FBRTVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0EsbURBQW1ELGlFQUFpRTtBQUNwSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QyxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDLE9BQU87QUFDdkM7QUFDQTtBQUNBO0FBQ0EsQyIsImZpbGUiOiI1Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///52\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(31).EventEmitter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcz8yYWFhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLEVBQVEiLCJmaWxlIjoiNTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///53\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\n/*<replacement>*/\n\nvar pna = __webpack_require__(20);\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzP2M0YzAiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7O0FBRUEsVUFBVSxtQkFBTyxDQUFDLEVBQXNCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHBuYSA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmICghY2IgJiYgZXJyKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIF90aGlzLCBlcnIpO1xuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3lcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///54\n")},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n/*<replacement>*/\n\nvar Buffer = __webpack_require__(101).Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzPzdkNzIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjs7QUFFQSxhQUFhLG1CQUFPLENBQUMsR0FBYTtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLHNDQUFzQyxzQ0FBc0M7QUFDekc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjU1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///55\n")},function(module,exports,__webpack_require__){"use strict";eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n\n\nmodule.exports = Transform;\n\nvar Duplex = __webpack_require__(5);\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(10));\nutil.inherits = __webpack_require__(7);\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanM/ZGNkMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFlBQVk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyxDQUFrQjs7QUFFdkM7QUFDQSx5QkFBeUIsbUJBQU8sQ0FBQyxFQUFjO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLENBQVU7QUFDbEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSIsImZpbGUiOiI1Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///56\n")},function(module,exports,__webpack_require__){eval('!function(t,e){ true?module.exports=e():undefined}(window,(function(){return function(t){var e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={i:n,l:!1,exports:{}};return t[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=t,r.c=e,r.d=function(t,e,n){r.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:n})},r.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},r.t=function(t,e){if(1&e&&(t=r(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var i in t)r.d(n,i,function(e){return t[e]}.bind(null,i));return n},r.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return r.d(e,"a",e),e},r.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},r.p="",r(r.s=205)}([function(t,e,r){t.exports=r(28)},function(t,e){function r(t,e,r,n,i,o,a){try{var s=t[o](a),u=s.value}catch(t){return void r(t)}s.done?e(u):Promise.resolve(u).then(n,i)}t.exports=function(t){return function(){var e=this,n=arguments;return new Promise((function(i,o){var a=t.apply(e,n);function s(t){r(a,i,o,s,u,"next",t)}function u(t){r(a,i,o,s,u,"throw",t)}s(void 0)}))}}},function(t,e,r){var n=r(4),i=r(22).f,o=r(14),a=r(17),s=r(62),u=r(101),c=r(68);t.exports=function(t,e){var r,f,l,h,p,d=t.target,v=t.global,g=t.stat;if(r=v?n:g?n[d]||s(d,{}):(n[d]||{}).prototype)for(f in e){if(h=e[f],l=t.noTargetGet?(p=i(r,f))&&p.value:r[f],!c(v?f:d+(g?".":"#")+f,t.forced)&&void 0!==l){if(typeof h==typeof l)continue;u(h,l)}(t.sham||l&&l.sham)&&o(h,"sham",!0),a(r,f,h,t)}}},function(t,e,r){var n=r(4),i=r(64),o=r(13),a=r(65),s=r(69),u=r(107),c=i("wks"),f=n.Symbol,l=u?f:f&&f.withoutSetter||a;t.exports=function(t){return o(c,t)||(s&&o(f,t)?c[t]=f[t]:c[t]=l("Symbol."+t)),c[t]}},function(t,e,r){(function(e){var r=function(t){return t&&t.Math==Math&&t};t.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof e&&e)||Function("return this")()}).call(this,r(21))},function(t,e){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,e,r){"use strict";var n="http://www.w3.org/1999/02/22-rdf-syntax-ns#",i="http://www.w3.org/2001/XMLSchema#",o="http://www.w3.org/2000/10/swap/";e.a={xsd:{decimal:i+"decimal",boolean:i+"boolean",double:i+"double",integer:i+"integer",string:i+"string"},rdf:{type:n+"type",nil:n+"nil",first:n+"first",rest:n+"rest",langString:n+"langString"},owl:{sameAs:"http://www.w3.org/2002/07/owl#sameAs"},r:{forSome:o+"reify#forSome",forAll:o+"reify#forAll"},log:{implies:o+"log#implies"}}},function(t,e,r){var n=r(5);t.exports=!n((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a}))},function(t,e,r){var n=r(10);t.exports=function(t){if(!n(t))throw TypeError(String(t)+" is not an object");return t}},function(t,e,r){var n=r(169),i=r(170),o=r(171);t.exports=function(t){return n(t)||i(t)||o()}},function(t,e){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,e,r){var n=r(7),i=r(99),o=r(8),a=r(43),s=Object.defineProperty;e.f=n?s:function(t,e,r){if(o(t),e=a(e,!0),o(r),i)try{return s(t,e,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported");return"value"in r&&(t[e]=r.value),t}},function(t,e,r){var n=r(60),i=r(20);t.exports=function(t){return n(i(t))}},function(t,e){var r={}.hasOwnProperty;t.exports=function(t,e){return r.call(t,e)}},function(t,e,r){var n=r(7),i=r(11),o=r(31);t.exports=n?function(t,e,r){return i.f(t,e,o(1,r))}:function(t,e,r){return t[e]=r,t}},function(t,e,r){var n=r(32),i=Math.min;t.exports=function(t){return t>0?i(n(t),9007199254740991):0}},function(t,e){function r(e){return t.exports=r=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)},r(e)}t.exports=r},function(t,e,r){var n=r(4),i=r(14),o=r(13),a=r(62),s=r(63),u=r(24),c=u.get,f=u.enforce,l=String(String).split("String");(t.exports=function(t,e,r,s){var u=!!s&&!!s.unsafe,c=!!s&&!!s.enumerable,h=!!s&&!!s.noTargetGet;"function"==typeof r&&("string"!=typeof e||o(r,"name")||i(r,"name",e),f(r).source=l.join("string"==typeof e?e:"")),t!==n?(u?!h&&t[e]&&(c=!0):delete t[e],c?t[e]=r:i(t,e,r)):c?t[e]=r:a(e,r)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||s(this)}))},function(t,e){t.exports=function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}},function(t,e){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,e){t.exports=function(t){if(null==t)throw TypeError("Can\'t call method on "+t);return t}},function(t,e){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(t){"object"==typeof window&&(r=window)}t.exports=r},function(t,e,r){var n=r(7),i=r(59),o=r(31),a=r(12),s=r(43),u=r(13),c=r(99),f=Object.getOwnPropertyDescriptor;e.f=n?f:function(t,e){if(t=a(t),e=s(e,!0),c)try{return f(t,e)}catch(t){}if(u(t,e))return o(!i.f.call(t,e),t[e])}},function(t,e,r){"use strict";var n=r(55),i=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};t.exports=l;var o=r(39);o.inherits=r(29);var a=r(138),s=r(95);o.inherits(l,a);for(var u=i(s.prototype),c=0;c<u.length;c++){var f=u[c];l.prototype[f]||(l.prototype[f]=s.prototype[f])}function l(t){if(!(this instanceof l))return new l(t);a.call(this,t),s.call(this,t),t&&!1===t.readable&&(this.readable=!1),t&&!1===t.writable&&(this.writable=!1),this.allowHalfOpen=!0,t&&!1===t.allowHalfOpen&&(this.allowHalfOpen=!1),this.once("end",h)}function h(){this.allowHalfOpen||this._writableState.ended||n.nextTick(p,this)}function p(t){t.end()}Object.defineProperty(l.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(l.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed&&this._writableState.destroyed)},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}}),l.prototype._destroy=function(t,e){this.push(null),this.end(),n.nextTick(e,t)}},function(t,e,r){var n,i,o,a=r(147),s=r(4),u=r(10),c=r(14),f=r(13),l=r(44),h=r(45),p=s.WeakMap;if(a){var d=new p,v=d.get,g=d.has,y=d.set;n=function(t,e){return y.call(d,t,e),e},i=function(t){return v.call(d,t)||{}},o=function(t){return g.call(d,t)}}else{var b=l("state");h[b]=!0,n=function(t,e){return c(t,b,e),e},i=function(t){return f(t,b)?t[b]:{}},o=function(t){return f(t,b)}}t.exports={set:n,get:i,has:o,enforce:function(t){return o(t)?i(t):n(t,{})},getterFor:function(t){return function(e){var r;if(!u(e)||(r=i(e)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return r}}}},function(t,e){t.exports=!1},function(t,e,r){var n=r(103),i=r(4),o=function(t){return"function"==typeof t?t:void 0};t.exports=function(t,e){return arguments.length<2?o(n[t])||o(i[t]):n[t]&&n[t][e]||i[t]&&i[t][e]}},function(t,e,r){var n=r(20);t.exports=function(t){return Object(n(t))}},function(t,e,r){var n=function(t){"use strict";var e=Object.prototype,r=e.hasOwnProperty,n="function"==typeof Symbol?Symbol:{},i=n.iterator||"@@iterator",o=n.asyncIterator||"@@asyncIterator",a=n.toStringTag||"@@toStringTag";function s(t,e,r,n){var i=e&&e.prototype instanceof f?e:f,o=Object.create(i.prototype),a=new x(n||[]);return o._invoke=function(t,e,r){var n="suspendedStart";return function(i,o){if("executing"===n)throw new Error("Generator is already running");if("completed"===n){if("throw"===i)throw o;return E()}for(r.method=i,r.arg=o;;){var a=r.delegate;if(a){var s=_(a,r);if(s){if(s===c)continue;return s}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if("suspendedStart"===n)throw n="completed",r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);n="executing";var f=u(t,e,r);if("normal"===f.type){if(n=r.done?"completed":"suspendedYield",f.arg===c)continue;return{value:f.arg,done:r.done}}"throw"===f.type&&(n="completed",r.method="throw",r.arg=f.arg)}}}(t,r,a),o}function u(t,e,r){try{return{type:"normal",arg:t.call(e,r)}}catch(t){return{type:"throw",arg:t}}}t.wrap=s;var c={};function f(){}function l(){}function h(){}var p={};p[i]=function(){return this};var d=Object.getPrototypeOf,v=d&&d(d(k([])));v&&v!==e&&r.call(v,i)&&(p=v);var g=h.prototype=f.prototype=Object.create(p);function y(t){["next","throw","return"].forEach((function(e){t[e]=function(t){return this._invoke(e,t)}}))}function b(t){var e;this._invoke=function(n,i){function o(){return new Promise((function(e,o){!function e(n,i,o,a){var s=u(t[n],t,i);if("throw"!==s.type){var c=s.arg,f=c.value;return f&&"object"==typeof f&&r.call(f,"__await")?Promise.resolve(f.__await).then((function(t){e("next",t,o,a)}),(function(t){e("throw",t,o,a)})):Promise.resolve(f).then((function(t){c.value=t,o(c)}),(function(t){return e("throw",t,o,a)}))}a(s.arg)}(n,i,e,o)}))}return e=e?e.then(o,o):o()}}function _(t,e){var r=t.iterator[e.method];if(void 0===r){if(e.delegate=null,"throw"===e.method){if(t.iterator.return&&(e.method="return",e.arg=void 0,_(t,e),"throw"===e.method))return c;e.method="throw",e.arg=new TypeError("The iterator does not provide a \'throw\' method")}return c}var n=u(r,t.iterator,e.arg);if("throw"===n.type)return e.method="throw",e.arg=n.arg,e.delegate=null,c;var i=n.arg;return i?i.done?(e[t.resultName]=i.value,e.next=t.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,c):i:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,c)}function m(t){var e={tryLoc:t[0]};1 in t&&(e.catchLoc=t[1]),2 in t&&(e.finallyLoc=t[2],e.afterLoc=t[3]),this.tryEntries.push(e)}function w(t){var e=t.completion||{};e.type="normal",delete e.arg,t.completion=e}function x(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(m,this),this.reset(!0)}function k(t){if(t){var e=t[i];if(e)return e.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var n=-1,o=function e(){for(;++n<t.length;)if(r.call(t,n))return e.value=t[n],e.done=!1,e;return e.value=void 0,e.done=!0,e};return o.next=o}}return{next:E}}function E(){return{value:void 0,done:!0}}return l.prototype=g.constructor=h,h.constructor=l,h[a]=l.displayName="GeneratorFunction",t.isGeneratorFunction=function(t){var e="function"==typeof t&&t.constructor;return!!e&&(e===l||"GeneratorFunction"===(e.displayName||e.name))},t.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,h):(t.__proto__=h,a in t||(t[a]="GeneratorFunction")),t.prototype=Object.create(g),t},t.awrap=function(t){return{__await:t}},y(b.prototype),b.prototype[o]=function(){return this},t.AsyncIterator=b,t.async=function(e,r,n,i){var o=new b(s(e,r,n,i));return t.isGeneratorFunction(r)?o:o.next().then((function(t){return t.done?t.value:o.next()}))},y(g),g[a]="Generator",g[i]=function(){return this},g.toString=function(){return"[object Generator]"},t.keys=function(t){var e=[];for(var r in t)e.push(r);return e.reverse(),function r(){for(;e.length;){var n=e.pop();if(n in t)return r.value=n,r.done=!1,r}return r.done=!0,r}},t.values=k,x.prototype={constructor:x,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!t)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var t=this.tryEntries[0].completion;if("throw"===t.type)throw t.arg;return this.rval},dispatchException:function(t){if(this.done)throw t;var e=this;function n(r,n){return a.type="throw",a.arg=t,e.next=r,n&&(e.method="next",e.arg=void 0),!!n}for(var i=this.tryEntries.length-1;i>=0;--i){var o=this.tryEntries[i],a=o.completion;if("root"===o.tryLoc)return n("end");if(o.tryLoc<=this.prev){var s=r.call(o,"catchLoc"),u=r.call(o,"finallyLoc");if(s&&u){if(this.prev<o.catchLoc)return n(o.catchLoc,!0);if(this.prev<o.finallyLoc)return n(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return n(o.catchLoc,!0)}else{if(!u)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return n(o.finallyLoc)}}}},abrupt:function(t,e){for(var n=this.tryEntries.length-1;n>=0;--n){var i=this.tryEntries[n];if(i.tryLoc<=this.prev&&r.call(i,"finallyLoc")&&this.prev<i.finallyLoc){var o=i;break}}o&&("break"===t||"continue"===t)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=t,a.arg=e,o?(this.method="next",this.next=o.finallyLoc,c):this.complete(a)},complete:function(t,e){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&e&&(this.next=e),c},finish:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),w(r),c}},catch:function(t){for(var e=this.tryEntries.length-1;e>=0;--e){var r=this.tryEntries[e];if(r.tryLoc===t){var n=r.completion;if("throw"===n.type){var i=n.arg;w(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,e,r){return this.delegate={iterator:k(t),resultName:e,nextLoc:r},"next"===this.method&&(this.arg=void 0),c}},t}(t.exports);try{regeneratorRuntime=n}catch(t){Function("r","regeneratorRuntime = r")(n)}},function(t,e){"function"==typeof Object.create?t.exports=function(t,e){t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}})}:t.exports=function(t,e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}},function(t,e){function r(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}t.exports=function(t,e,n){return e&&r(t.prototype,e),n&&r(t,n),t}},function(t,e){t.exports=function(t,e){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:e}}},function(t,e){var r=Math.ceil,n=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?n:r)(t)}},function(t,e,r){var n=r(71),i=r(60),o=r(27),a=r(15),s=r(112),u=[].push,c=function(t){var e=1==t,r=2==t,c=3==t,f=4==t,l=6==t,h=5==t||l;return function(p,d,v,g){for(var y,b,_=o(p),m=i(_),w=n(d,v,3),x=a(m.length),k=0,E=g||s,S=e?E(p,x):r?E(p,0):void 0;x>k;k++)if((h||k in m)&&(b=w(y=m[k],k,_),t))if(e)S[k]=b;else if(b)switch(t){case 3:return!0;case 5:return y;case 6:return k;case 2:u.call(S,y)}else if(f)return!1;return l?-1:c||f?f:S}};t.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6)}},function(t,e){t.exports={}},function(t,e,r){"use strict";var n=r(2),i=r(53);n({target:"RegExp",proto:!0,forced:/./.exec!==i},{exec:i})},function(t,e,r){"use strict";var n=r(5);t.exports=function(t,e){var r=[][t];return!r||!n((function(){r.call(null,e||function(){throw 1},1)}))}},function(t,e,r){"use strict";var n=r(2),i=r(33).map,o=r(5),a=r(54)("map"),s=a&&!o((function(){[].map.call({length:-1,0:1},(function(t){throw t}))}));n({target:"Array",proto:!0,forced:!a||!s},{map:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e){var r,n,i=t.exports={};function o(){throw new Error("setTimeout has not been defined")}function a(){throw new Error("clearTimeout has not been defined")}function s(t){if(r===setTimeout)return setTimeout(t,0);if((r===o||!r)&&setTimeout)return r=setTimeout,setTimeout(t,0);try{return r(t,0)}catch(e){try{return r.call(null,t,0)}catch(e){return r.call(this,t,0)}}}!function(){try{r="function"==typeof setTimeout?setTimeout:o}catch(t){r=o}try{n="function"==typeof clearTimeout?clearTimeout:a}catch(t){n=a}}();var u,c=[],f=!1,l=-1;function h(){f&&u&&(f=!1,u.length?c=u.concat(c):l=-1,c.length&&p())}function p(){if(!f){var t=s(h);f=!0;for(var e=c.length;e;){for(u=c,c=[];++l<e;)u&&u[l].run();l=-1,e=c.length}u=null,f=!1,function(t){if(n===clearTimeout)return clearTimeout(t);if((n===a||!n)&&clearTimeout)return n=clearTimeout,clearTimeout(t);try{n(t)}catch(e){try{return n.call(null,t)}catch(e){return n.call(this,t)}}}(t)}}function d(t,e){this.fun=t,this.array=e}function v(){}i.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];c.push(new d(t,e)),1!==c.length||f||s(p)},d.prototype.run=function(){this.fun.apply(null,this.array)},i.title="browser",i.browser=!0,i.env={},i.argv=[],i.version="",i.versions={},i.on=v,i.addListener=v,i.once=v,i.off=v,i.removeListener=v,i.removeAllListeners=v,i.emit=v,i.prependListener=v,i.prependOnceListener=v,i.listeners=function(t){return[]},i.binding=function(t){throw new Error("process.binding is not supported")},i.cwd=function(){return"/"},i.chdir=function(t){throw new Error("process.chdir is not supported")},i.umask=function(){return 0}},function(t,e,r){(function(t){function r(t){return Object.prototype.toString.call(t)}e.isArray=function(t){return Array.isArray?Array.isArray(t):"[object Array]"===r(t)},e.isBoolean=function(t){return"boolean"==typeof t},e.isNull=function(t){return null===t},e.isNullOrUndefined=function(t){return null==t},e.isNumber=function(t){return"number"==typeof t},e.isString=function(t){return"string"==typeof t},e.isSymbol=function(t){return"symbol"==typeof t},e.isUndefined=function(t){return void 0===t},e.isRegExp=function(t){return"[object RegExp]"===r(t)},e.isObject=function(t){return"object"==typeof t&&null!==t},e.isDate=function(t){return"[object Date]"===r(t)},e.isError=function(t){return"[object Error]"===r(t)||t instanceof Error},e.isFunction=function(t){return"function"==typeof t},e.isPrimitive=function(t){return null===t||"boolean"==typeof t||"number"==typeof t||"string"==typeof t||"symbol"==typeof t||void 0===t},e.isBuffer=t.isBuffer}).call(this,r(92).Buffer)},function(t,e,r){var n=r(96),i=r(155);t.exports=function(t,e){return!e||"object"!==n(e)&&"function"!=typeof e?i(t):e}},function(t,e,r){var n=r(80);t.exports=function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&n(t,e)}},function(t,e,r){var n=r(166),i=r(167),o=r(168);t.exports=function(t,e){return n(t)||i(t,e)||o()}},function(t,e,r){var n=r(10);t.exports=function(t,e){if(!n(t))return t;var r,i;if(e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!n(i=r.call(t)))return i;if(!e&&"function"==typeof(r=t.toString)&&!n(i=r.call(t)))return i;throw TypeError("Can\'t convert object to primitive value")}},function(t,e,r){var n=r(64),i=r(65),o=n("keys");t.exports=function(t){return o[t]||(o[t]=i(t))}},function(t,e){t.exports={}},function(t,e,r){var n=r(104),i=r(67).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(t){return n(t,i)}},function(t,e,r){var n=r(19);t.exports=Array.isArray||function(t){return"Array"==n(t)}},function(t,e,r){var n=r(104),i=r(67);t.exports=Object.keys||function(t){return n(t,i)}},function(t,e,r){var n=r(11).f,i=r(13),o=r(3)("toStringTag");t.exports=function(t,e,r){t&&!i(t=r?t:t.prototype,o)&&n(t,o,{configurable:!0,value:e})}},function(t,e){t.exports=function(t){if("function"!=typeof t)throw TypeError(String(t)+" is not a function");return t}},function(t,e,r){"use strict";var n=r(12),i=r(113),o=r(34),a=r(24),s=r(114),u=a.set,c=a.getterFor("Array Iterator");t.exports=s(Array,"Array",(function(t,e){u(this,{type:"Array Iterator",target:n(t),index:0,kind:e})}),(function(){var t=c(this),e=t.target,r=t.kind,n=t.index++;return!e||n>=e.length?(t.target=void 0,{value:void 0,done:!0}):"keys"==r?{value:n,done:!1}:"values"==r?{value:e[n],done:!1}:{value:[n,e[n]],done:!1}}),"values"),o.Arguments=o.Array,i("keys"),i("values"),i("entries")},function(t,e,r){var n=r(72),i=r(17),o=r(154);n||i(Object.prototype,"toString",o,{unsafe:!0})},function(t,e,r){"use strict";var n,i,o=r(73),a=r(119),s=RegExp.prototype.exec,u=String.prototype.replace,c=s,f=(n=/a/,i=/b*/g,s.call(n,"a"),s.call(i,"a"),0!==n.lastIndex||0!==i.lastIndex),l=a.UNSUPPORTED_Y||a.BROKEN_CARET,h=void 0!==/()??/.exec("")[1];(f||h||l)&&(c=function(t){var e,r,n,i,a=this,c=l&&a.sticky,p=o.call(a),d=a.source,v=0,g=t;return c&&(-1===(p=p.replace("y","")).indexOf("g")&&(p+="g"),g=String(t).slice(a.lastIndex),a.lastIndex>0&&(!a.multiline||a.multiline&&"\\n"!==t[a.lastIndex-1])&&(d="(?: "+d+")",g=" "+g,v++),r=new RegExp("^(?:"+d+")",p)),h&&(r=new RegExp("^"+d+"$(?!\\\\s)",p)),f&&(e=a.lastIndex),n=s.call(c?r:a,g),c?n?(n.input=n.input.slice(v),n[0]=n[0].slice(v),n.index=a.lastIndex,a.lastIndex+=n[0].length):a.lastIndex=0:f&&n&&(a.lastIndex=a.global?n.index+n[0].length:e),h&&n&&n.length>1&&u.call(n[0],r,(function(){for(i=1;i<arguments.length-2;i++)void 0===arguments[i]&&(n[i]=void 0)})),n}),t.exports=c},function(t,e,r){var n=r(5),i=r(3),o=r(83),a=i("species");t.exports=function(t){return o>=51||!n((function(){var e=[];return(e.constructor={})[a]=function(){return{foo:1}},1!==e[t](Boolean).foo}))}},function(t,e,r){"use strict";(function(e){!e.version||0===e.version.indexOf("v0.")||0===e.version.indexOf("v1.")&&0!==e.version.indexOf("v1.8.")?t.exports={nextTick:function(t,r,n,i){if("function"!=typeof t)throw new TypeError(\'"callback" argument must be a function\');var o,a,s=arguments.length;switch(s){case 0:case 1:return e.nextTick(t);case 2:return e.nextTick((function(){t.call(null,r)}));case 3:return e.nextTick((function(){t.call(null,r,n)}));case 4:return e.nextTick((function(){t.call(null,r,n,i)}));default:for(o=new Array(s-1),a=0;a<o.length;)o[a++]=arguments[a];return e.nextTick((function(){t.apply(null,o)}))}}}:t.exports=e}).call(this,r(38))},function(t,e,r){var n=r(92),i=n.Buffer;function o(t,e){for(var r in t)e[r]=t[r]}function a(t,e,r){return i(t,e,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=n:(o(n,e),e.Buffer=a),o(i,a),a.from=function(t,e,r){if("number"==typeof t)throw new TypeError("Argument must not be a number");return i(t,e,r)},a.alloc=function(t,e,r){if("number"!=typeof t)throw new TypeError("Argument must be a number");var n=i(t);return void 0!==e?"string"==typeof r?n.fill(e,r):n.fill(e):n.fill(0),n},a.allocUnsafe=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return i(t)},a.allocUnsafeSlow=function(t){if("number"!=typeof t)throw new TypeError("Argument must be a number");return n.SlowBuffer(t)}},function(t,e,r){var n=r(156);function i(e,r,o){return"undefined"!=typeof Reflect&&Reflect.get?t.exports=i=Reflect.get:t.exports=i=function(t,e,r){var i=n(t,e);if(i){var o=Object.getOwnPropertyDescriptor(i,e);return o.get?o.get.call(r):o.value}},i(e,r,o||e)}t.exports=i},function(t,e,r){(function(n){e.log=function(...t){return"object"==typeof console&&console.log&&console.log(...t)},e.formatArgs=function(e){if(e[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+e[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const r="color: "+this.color;e.splice(1,0,r,"color: inherit");let n=0,i=0;e[0].replace(/%[a-zA-Z%]/g,t=>{"%%"!==t&&(n++,"%c"===t&&(i=n))}),e.splice(i,0,r)},e.save=function(t){try{t?e.storage.setItem("debug",t):e.storage.removeItem("debug")}catch(t){}},e.load=function(){let t;try{t=e.storage.getItem("debug")}catch(t){}!t&&void 0!==n&&"env"in n&&(t=n.env.DEBUG);return t},e.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/)},e.storage=function(){try{return localStorage}catch(t){}}(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.exports=r(172)(e);const{formatters:i}=t.exports;i.j=function(t){try{return JSON.stringify(t)}catch(t){return"[UnexpectedJSONParseError]: "+t.message}}}).call(this,r(38))},function(t,e,r){"use strict";var n={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!n.call({1:2},1);e.f=o?function(t){var e=i(this,t);return!!e&&e.enumerable}:n},function(t,e,r){var n=r(5),i=r(19),o="".split;t.exports=n((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==i(t)?o.call(t,""):Object(t)}:Object},function(t,e,r){var n=r(4),i=r(10),o=n.document,a=i(o)&&i(o.createElement);t.exports=function(t){return a?o.createElement(t):{}}},function(t,e,r){var n=r(4),i=r(14);t.exports=function(t,e){try{i(n,t,e)}catch(r){n[t]=e}return e}},function(t,e,r){var n=r(100),i=Function.toString;"function"!=typeof n.inspectSource&&(n.inspectSource=function(t){return i.call(t)}),t.exports=n.inspectSource},function(t,e,r){var n=r(25),i=r(100);(t.exports=function(t,e){return i[t]||(i[t]=void 0!==e?e:{})})("versions",[]).push({version:"3.6.1",mode:n?"pure":"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})},function(t,e){var r=0,n=Math.random();t.exports=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++r+n).toString(36)}},function(t,e,r){var n=r(12),i=r(15),o=r(105),a=function(t){return function(e,r,a){var s,u=n(e),c=i(u.length),f=o(a,c);if(t&&r!=r){for(;c>f;)if((s=u[f++])!=s)return!0}else for(;c>f;f++)if((t||f in u)&&u[f]===r)return t||f||0;return!t&&-1}};t.exports={includes:a(!0),indexOf:a(!1)}},function(t,e){t.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(t,e,r){var n=r(5),i=/#|\\.prototype\\./,o=function(t,e){var r=s[a(t)];return r==c||r!=u&&("function"==typeof e?n(e):!!e)},a=o.normalize=function(t){return String(t).replace(i,".").toLowerCase()},s=o.data={},u=o.NATIVE="N",c=o.POLYFILL="P";t.exports=o},function(t,e,r){var n=r(5);t.exports=!!Object.getOwnPropertySymbols&&!n((function(){return!String(Symbol())}))},function(t,e,r){var n,i=r(8),o=r(108),a=r(67),s=r(45),u=r(109),c=r(61),f=r(44),l=f("IE_PROTO"),h=function(){},p=function(t){return"<script>"+t+"<\\/script>"},d=function(){try{n=document.domain&&new ActiveXObject("htmlfile")}catch(t){}var t,e;d=n?function(t){t.write(p("")),t.close();var e=t.parentWindow.Object;return t=null,e}(n):((e=c("iframe")).style.display="none",u.appendChild(e),e.src=String("javascript:"),(t=e.contentWindow.document).open(),t.write(p("document.F=Object")),t.close(),t.F);for(var r=a.length;r--;)delete d.prototype[a[r]];return d()};s[l]=!0,t.exports=Object.create||function(t,e){var r;return null!==t?(h.prototype=i(t),r=new h,h.prototype=null,r[l]=t):r=d(),void 0===e?r:o(r,e)}},function(t,e,r){var n=r(50);t.exports=function(t,e,r){if(n(t),void 0===e)return t;switch(r){case 0:return function(){return t.call(e)};case 1:return function(r){return t.call(e,r)};case 2:return function(r,n){return t.call(e,r,n)};case 3:return function(r,n,i){return t.call(e,r,n,i)}}return function(){return t.apply(e,arguments)}}},function(t,e,r){var n={};n[r(3)("toStringTag")]="z",t.exports="[object z]"===String(n)},function(t,e,r){"use strict";var n=r(8);t.exports=function(){var t=n(this),e="";return t.global&&(e+="g"),t.ignoreCase&&(e+="i"),t.multiline&&(e+="m"),t.dotAll&&(e+="s"),t.unicode&&(e+="u"),t.sticky&&(e+="y"),e}},function(t,e,r){"use strict";var n=r(120).charAt,i=r(24),o=r(114),a=i.set,s=i.getterFor("String Iterator");o(String,"String",(function(t){a(this,{type:"String Iterator",string:String(t),index:0})}),(function(){var t,e=s(this),r=e.string,i=e.index;return i>=r.length?{value:void 0,done:!0}:(t=n(r,i),e.index+=t.length,{value:t,done:!1})}))},function(t,e,r){"use strict";var n=r(76),i=r(8),o=r(15),a=r(20),s=r(77),u=r(78);n("match",1,(function(t,e,r){return[function(e){var r=a(this),n=null==e?void 0:e[t];return void 0!==n?n.call(e,r):new RegExp(e)[t](String(r))},function(t){var n=r(e,t,this);if(n.done)return n.value;var a=i(t),c=String(this);if(!a.global)return u(a,c);var f=a.unicode;a.lastIndex=0;for(var l,h=[],p=0;null!==(l=u(a,c));){var d=String(l[0]);h[p]=d,""===d&&(a.lastIndex=s(c,o(a.lastIndex),f)),p++}return 0===p?null:h}]}))},function(t,e,r){"use strict";var n=r(17),i=r(5),o=r(3),a=r(53),s=r(14),u=o("species"),c=!i((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")})),f="$0"==="a".replace(/./,"$0"),l=!i((function(){var t=/(?:)/,e=t.exec;t.exec=function(){return e.apply(this,arguments)};var r="ab".split(t);return 2!==r.length||"a"!==r[0]||"b"!==r[1]}));t.exports=function(t,e,r,h){var p=o(t),d=!i((function(){var e={};return e[p]=function(){return 7},7!=""[t](e)})),v=d&&!i((function(){var e=!1,r=/a/;return"split"===t&&((r={}).constructor={},r.constructor[u]=function(){return r},r.flags="",r[p]=/./[p]),r.exec=function(){return e=!0,null},r[p](""),!e}));if(!d||!v||"replace"===t&&(!c||!f)||"split"===t&&!l){var g=/./[p],y=r(p,""[t],(function(t,e,r,n,i){return e.exec===a?d&&!i?{done:!0,value:g.call(e,r,n)}:{done:!0,value:t.call(r,e,n)}:{done:!1}}),{REPLACE_KEEPS_$0:f}),b=y[0],_=y[1];n(String.prototype,t,b),n(RegExp.prototype,p,2==e?function(t,e){return _.call(t,this,e)}:function(t){return _.call(t,this)})}h&&s(RegExp.prototype[p],"sham",!0)}},function(t,e,r){"use strict";var n=r(120).charAt;t.exports=function(t,e,r){return e+(r?n(t,e).length:1)}},function(t,e,r){var n=r(19),i=r(53);t.exports=function(t,e){var r=t.exec;if("function"==typeof r){var o=r.call(t,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==n(t))throw TypeError("RegExp#exec called on incompatible receiver");return i.call(t,e)}},function(t,e,r){var n=r(4),i=r(121),o=r(51),a=r(14),s=r(3),u=s("iterator"),c=s("toStringTag"),f=o.values;for(var l in i){var h=n[l],p=h&&h.prototype;if(p){if(p[u]!==f)try{a(p,u,f)}catch(t){p[u]=f}if(p[c]||a(p,c,l),i[l])for(var d in o)if(p[d]!==o[d])try{a(p,d,o[d])}catch(t){p[d]=o[d]}}}},function(t,e){function r(e,n){return t.exports=r=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t},r(e,n)}t.exports=r},function(t,e,r){"use strict";var n=r(2),i=r(5),o=r(47),a=r(10),s=r(27),u=r(15),c=r(82),f=r(112),l=r(54),h=r(3),p=r(83),d=h("isConcatSpreadable"),v=p>=51||!i((function(){var t=[];return t[d]=!1,t.concat()[0]!==t})),g=l("concat"),y=function(t){if(!a(t))return!1;var e=t[d];return void 0!==e?!!e:o(t)};n({target:"Array",proto:!0,forced:!v||!g},{concat:function(t){var e,r,n,i,o,a=s(this),l=f(a,0),h=0;for(e=-1,n=arguments.length;e<n;e++)if(o=-1===e?a:arguments[e],y(o)){if(h+(i=u(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(r=0;r<i;r++,h++)r in o&&c(l,h,o[r])}else{if(h>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(l,h++,o)}return l.length=h,l}})},function(t,e,r){"use strict";var n=r(43),i=r(11),o=r(31);t.exports=function(t,e,r){var a=n(e);a in t?i.f(t,a,o(0,r)):t[a]=r}},function(t,e,r){var n,i,o=r(4),a=r(122),s=o.process,u=s&&s.versions,c=u&&u.v8;c?i=(n=c.split("."))[0]+n[1]:a&&(!(n=a.match(/Edge\\/(\\d+)/))||n[1]>=74)&&(n=a.match(/Chrome\\/(\\d+)/))&&(i=n[1]),t.exports=i&&+i},function(t,e,r){"use strict";var n=r(2),i=r(33).filter,o=r(5),a=r(54)("filter"),s=a&&!o((function(){[].filter.call({length:-1,0:1},(function(t){throw t}))}));n({target:"Array",proto:!0,forced:!a||!s},{filter:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";var n=r(2),i=r(123);n({target:"Array",proto:!0,forced:[].forEach!=i},{forEach:i})},function(t,e,r){"use strict";var n=r(2),i=r(66).includes,o=r(113);n({target:"Array",proto:!0},{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(t,e,r){var n=r(7),i=r(11).f,o=Function.prototype,a=o.toString,s=/^\\s*function ([^ (]*)/;n&&!("name"in o)&&i(o,"name",{configurable:!0,get:function(){try{return a.call(this).match(s)[1]}catch(t){return""}}})},function(t,e,r){var n=r(10),i=r(19),o=r(3)("match");t.exports=function(t){var e;return n(t)&&(void 0!==(e=t[o])?!!e:"RegExp"==i(t))}},function(t,e,r){"use strict";var n=r(76),i=r(8),o=r(27),a=r(15),s=r(32),u=r(20),c=r(77),f=r(78),l=Math.max,h=Math.min,p=Math.floor,d=/\\$([$&\'`]|\\d\\d?|<[^>]*>)/g,v=/\\$([$&\'`]|\\d\\d?)/g;n("replace",2,(function(t,e,r,n){return[function(r,n){var i=u(this),o=null==r?void 0:r[t];return void 0!==o?o.call(r,i,n):e.call(String(i),r,n)},function(t,o){if(n.REPLACE_KEEPS_$0||"string"==typeof o&&-1===o.indexOf("$0")){var u=r(e,t,this,o);if(u.done)return u.value}var p=i(t),d=String(this),v="function"==typeof o;v||(o=String(o));var y=p.global;if(y){var b=p.unicode;p.lastIndex=0}for(var _=[];;){var m=f(p,d);if(null===m)break;if(_.push(m),!y)break;""===String(m[0])&&(p.lastIndex=c(d,a(p.lastIndex),b))}for(var w,x="",k=0,E=0;E<_.length;E++){m=_[E];for(var S=String(m[0]),j=l(h(s(m.index),d.length),0),R=[],C=1;C<m.length;C++)R.push(void 0===(w=m[C])?w:String(w));var I=m.groups;if(v){var O=[S].concat(R,j,d);void 0!==I&&O.push(I);var T=String(o.apply(void 0,O))}else T=g(S,d,j,R,I,o);j>=k&&(x+=d.slice(k,j)+T,k=j+S.length)}return x+d.slice(k)}];function g(t,r,n,i,a,s){var u=n+t.length,c=i.length,f=v;return void 0!==a&&(a=o(a),f=d),e.call(s,f,(function(e,o){var s;switch(o.charAt(0)){case"$":return"$";case"&":return t;case"`":return r.slice(0,n);case"\'":return r.slice(u);case"<":s=a[o.slice(1,-1)];break;default:var f=+o;if(0===f)return e;if(f>c){var l=p(f/10);return 0===l?e:l<=c?void 0===i[l-1]?o.charAt(1):i[l-1]+o.charAt(1):e}s=i[f-1]}return void 0===s?"":s}))}}))},function(t,e,r){var n=r(4),i=r(121),o=r(123),a=r(14);for(var s in i){var u=n[s],c=u&&u.prototype;if(c&&c.forEach!==o)try{a(c,"forEach",o)}catch(t){c.forEach=o}}},function(t,e,r){"use strict";var n,i,o,a,s=r(2),u=r(25),c=r(4),f=r(26),l=r(177),h=r(17),p=r(178),d=r(49),v=r(125),g=r(10),y=r(50),b=r(179),_=r(19),m=r(63),w=r(180),x=r(184),k=r(132),E=r(133).set,S=r(185),j=r(186),R=r(187),C=r(135),I=r(188),O=r(24),T=r(68),P=r(3),A=r(83),L=P("species"),F="Promise",M=O.get,N=O.set,B=O.getterFor(F),D=l,U=c.TypeError,q=c.document,G=c.process,W=f("fetch"),z=C.f,Y=z,Q="process"==_(G),$=!!(q&&q.createEvent&&c.dispatchEvent),H=T(F,(function(){if(!(m(D)!==String(D))){if(66===A)return!0;if(!Q&&"function"!=typeof PromiseRejectionEvent)return!0}if(u&&!D.prototype.finally)return!0;if(A>=51&&/native code/.test(D))return!1;var t=D.resolve(1),e=function(t){t((function(){}),(function(){}))};return(t.constructor={})[L]=e,!(t.then((function(){}))instanceof e)})),K=H||!x((function(t){D.all(t).catch((function(){}))})),V=function(t){var e;return!(!g(t)||"function"!=typeof(e=t.then))&&e},Z=function(t,e,r){if(!e.notified){e.notified=!0;var n=e.reactions;S((function(){for(var i=e.value,o=1==e.state,a=0;n.length>a;){var s,u,c,f=n[a++],l=o?f.ok:f.fail,h=f.resolve,p=f.reject,d=f.domain;try{l?(o||(2===e.rejection&&et(t,e),e.rejection=1),!0===l?s=i:(d&&d.enter(),s=l(i),d&&(d.exit(),c=!0)),s===f.promise?p(U("Promise-chain cycle")):(u=V(s))?u.call(s,h,p):h(s)):p(i)}catch(t){d&&!c&&d.exit(),p(t)}}e.reactions=[],e.notified=!1,r&&!e.rejection&&X(t,e)}))}},J=function(t,e,r){var n,i;$?((n=q.createEvent("Event")).promise=e,n.reason=r,n.initEvent(t,!1,!0),c.dispatchEvent(n)):n={promise:e,reason:r},(i=c["on"+t])?i(n):"unhandledrejection"===t&&R("Unhandled promise rejection",r)},X=function(t,e){E.call(c,(function(){var r,n=e.value;if(tt(e)&&(r=I((function(){Q?G.emit("unhandledRejection",n,t):J("unhandledrejection",t,n)})),e.rejection=Q||tt(e)?2:1,r.error))throw r.value}))},tt=function(t){return 1!==t.rejection&&!t.parent},et=function(t,e){E.call(c,(function(){Q?G.emit("rejectionHandled",t):J("rejectionhandled",t,e.value)}))},rt=function(t,e,r,n){return function(i){t(e,r,i,n)}},nt=function(t,e,r,n){e.done||(e.done=!0,n&&(e=n),e.value=r,e.state=2,Z(t,e,!0))},it=function(t,e,r,n){if(!e.done){e.done=!0,n&&(e=n);try{if(t===r)throw U("Promise can\'t be resolved itself");var i=V(r);i?S((function(){var n={done:!1};try{i.call(r,rt(it,t,n,e),rt(nt,t,n,e))}catch(r){nt(t,n,r,e)}})):(e.value=r,e.state=1,Z(t,e,!1))}catch(r){nt(t,{done:!1},r,e)}}};H&&(D=function(t){b(this,D,F),y(t),n.call(this);var e=M(this);try{t(rt(it,this,e),rt(nt,this,e))}catch(t){nt(this,e,t)}},(n=function(t){N(this,{type:F,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=p(D.prototype,{then:function(t,e){var r=B(this),n=z(k(this,D));return n.ok="function"!=typeof t||t,n.fail="function"==typeof e&&e,n.domain=Q?G.domain:void 0,r.parent=!0,r.reactions.push(n),0!=r.state&&Z(this,r,!1),n.promise},catch:function(t){return this.then(void 0,t)}}),i=function(){var t=new n,e=M(t);this.promise=t,this.resolve=rt(it,t,e),this.reject=rt(nt,t,e)},C.f=z=function(t){return t===D||t===o?new i(t):Y(t)},u||"function"!=typeof l||(a=l.prototype.then,h(l.prototype,"then",(function(t,e){var r=this;return new D((function(t,e){a.call(r,t,e)})).then(t,e)}),{unsafe:!0}),"function"==typeof W&&s({global:!0,enumerable:!0,forced:!0},{fetch:function(t){return j(D,W.apply(c,arguments))}}))),s({global:!0,wrap:!0,forced:H},{Promise:D}),d(D,F,!1,!0),v(F),o=f(F),s({target:F,stat:!0,forced:H},{reject:function(t){var e=z(this);return e.reject.call(void 0,t),e.promise}}),s({target:F,stat:!0,forced:u||H},{resolve:function(t){return j(u&&this===o?D:this,t)}}),s({target:F,stat:!0,forced:K},{all:function(t){var e=this,r=z(e),n=r.resolve,i=r.reject,o=I((function(){var r=y(e.resolve),o=[],a=0,s=1;w(t,(function(t){var u=a++,c=!1;o.push(void 0),s++,r.call(e,t).then((function(t){c||(c=!0,o[u]=t,--s||n(o))}),i)})),--s||n(o)}));return o.error&&i(o.value),r.promise},race:function(t){var e=this,r=z(e),n=r.reject,i=I((function(){var i=y(e.resolve);w(t,(function(t){i.call(e,t).then(r.resolve,n)}))}));return i.error&&n(i.value),r.promise}})},function(t,e,r){"use strict";(function(t){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\nvar n=r(190),i=r(191),o=r(137);function a(){return u.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function s(t,e){if(a()<e)throw new RangeError("Invalid typed array length");return u.TYPED_ARRAY_SUPPORT?(t=new Uint8Array(e)).__proto__=u.prototype:(null===t&&(t=new u(e)),t.length=e),t}function u(t,e,r){if(!(u.TYPED_ARRAY_SUPPORT||this instanceof u))return new u(t,e,r);if("number"==typeof t){if("string"==typeof e)throw new Error("If encoding is specified then the first argument must be a string");return l(this,t)}return c(this,t,e,r)}function c(t,e,r,n){if("number"==typeof e)throw new TypeError(\'"value" argument must not be a number\');return"undefined"!=typeof ArrayBuffer&&e instanceof ArrayBuffer?function(t,e,r,n){if(e.byteLength,r<0||e.byteLength<r)throw new RangeError("\'offset\' is out of bounds");if(e.byteLength<r+(n||0))throw new RangeError("\'length\' is out of bounds");e=void 0===r&&void 0===n?new Uint8Array(e):void 0===n?new Uint8Array(e,r):new Uint8Array(e,r,n);u.TYPED_ARRAY_SUPPORT?(t=e).__proto__=u.prototype:t=h(t,e);return t}(t,e,r,n):"string"==typeof e?function(t,e,r){"string"==typeof r&&""!==r||(r="utf8");if(!u.isEncoding(r))throw new TypeError(\'"encoding" must be a valid string encoding\');var n=0|d(e,r),i=(t=s(t,n)).write(e,r);i!==n&&(t=t.slice(0,i));return t}(t,e,r):function(t,e){if(u.isBuffer(e)){var r=0|p(e.length);return 0===(t=s(t,r)).length||e.copy(t,0,0,r),t}if(e){if("undefined"!=typeof ArrayBuffer&&e.buffer instanceof ArrayBuffer||"length"in e)return"number"!=typeof e.length||(n=e.length)!=n?s(t,0):h(t,e);if("Buffer"===e.type&&o(e.data))return h(t,e.data)}var n;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(t,e)}function f(t){if("number"!=typeof t)throw new TypeError(\'"size" argument must be a number\');if(t<0)throw new RangeError(\'"size" argument must not be negative\')}function l(t,e){if(f(e),t=s(t,e<0?0:0|p(e)),!u.TYPED_ARRAY_SUPPORT)for(var r=0;r<e;++r)t[r]=0;return t}function h(t,e){var r=e.length<0?0:0|p(e.length);t=s(t,r);for(var n=0;n<r;n+=1)t[n]=255&e[n];return t}function p(t){if(t>=a())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+a().toString(16)+" bytes");return 0|t}function d(t,e){if(u.isBuffer(t))return t.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(t)||t instanceof ArrayBuffer))return t.byteLength;"string"!=typeof t&&(t=""+t);var r=t.length;if(0===r)return 0;for(var n=!1;;)switch(e){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return U(t).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return q(t).length;default:if(n)return U(t).length;e=(""+e).toLowerCase(),n=!0}}function v(t,e,r){var n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(e>>>=0))return"";for(t||(t="utf8");;)switch(t){case"hex":return I(this,e,r);case"utf8":case"utf-8":return j(this,e,r);case"ascii":return R(this,e,r);case"latin1":case"binary":return C(this,e,r);case"base64":return S(this,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return O(this,e,r);default:if(n)throw new TypeError("Unknown encoding: "+t);t=(t+"").toLowerCase(),n=!0}}function g(t,e,r){var n=t[e];t[e]=t[r],t[r]=n}function y(t,e,r,n,i){if(0===t.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof e&&(e=u.from(e,n)),u.isBuffer(e))return 0===e.length?-1:b(t,e,r,n,i);if("number"==typeof e)return e&=255,u.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):b(t,[e],r,n,i);throw new TypeError("val must be string, number or Buffer")}function b(t,e,r,n,i){var o,a=1,s=t.length,u=e.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(t.length<2||e.length<2)return-1;a=2,s/=2,u/=2,r/=2}function c(t,e){return 1===a?t[e]:t.readUInt16BE(e*a)}if(i){var f=-1;for(o=r;o<s;o++)if(c(t,o)===c(e,-1===f?0:o-f)){if(-1===f&&(f=o),o-f+1===u)return f*a}else-1!==f&&(o-=o-f),f=-1}else for(r+u>s&&(r=s-u),o=r;o>=0;o--){for(var l=!0,h=0;h<u;h++)if(c(t,o+h)!==c(e,h)){l=!1;break}if(l)return o}return-1}function _(t,e,r,n){r=Number(r)||0;var i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=e.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var a=0;a<n;++a){var s=parseInt(e.substr(2*a,2),16);if(isNaN(s))return a;t[r+a]=s}return a}function m(t,e,r,n){return G(U(e,t.length-r),t,r,n)}function w(t,e,r,n){return G(function(t){for(var e=[],r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function x(t,e,r,n){return w(t,e,r,n)}function k(t,e,r,n){return G(q(e),t,r,n)}function E(t,e,r,n){return G(function(t,e){for(var r,n,i,o=[],a=0;a<t.length&&!((e-=2)<0);++a)r=t.charCodeAt(a),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(e,t.length-r),t,r,n)}function S(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function j(t,e,r){r=Math.min(t.length,r);for(var n=[],i=e;i<r;){var o,a,s,u,c=t[i],f=null,l=c>239?4:c>223?3:c>191?2:1;if(i+l<=r)switch(l){case 1:c<128&&(f=c);break;case 2:128==(192&(o=t[i+1]))&&(u=(31&c)<<6|63&o)>127&&(f=u);break;case 3:o=t[i+1],a=t[i+2],128==(192&o)&&128==(192&a)&&(u=(15&c)<<12|(63&o)<<6|63&a)>2047&&(u<55296||u>57343)&&(f=u);break;case 4:o=t[i+1],a=t[i+2],s=t[i+3],128==(192&o)&&128==(192&a)&&128==(192&s)&&(u=(15&c)<<18|(63&o)<<12|(63&a)<<6|63&s)>65535&&u<1114112&&(f=u)}null===f?(f=65533,l=1):f>65535&&(f-=65536,n.push(f>>>10&1023|55296),f=56320|1023&f),n.push(f),i+=l}return function(t){var e=t.length;if(e<=4096)return String.fromCharCode.apply(String,t);var r="",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=4096));return r}(n)}e.Buffer=u,e.SlowBuffer=function(t){+t!=t&&(t=0);return u.alloc(+t)},e.INSPECT_MAX_BYTES=50,u.TYPED_ARRAY_SUPPORT=void 0!==t.TYPED_ARRAY_SUPPORT?t.TYPED_ARRAY_SUPPORT:function(){try{var t=new Uint8Array(1);return t.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===t.foo()&&"function"==typeof t.subarray&&0===t.subarray(1,1).byteLength}catch(t){return!1}}(),e.kMaxLength=a(),u.poolSize=8192,u._augment=function(t){return t.__proto__=u.prototype,t},u.from=function(t,e,r){return c(null,t,e,r)},u.TYPED_ARRAY_SUPPORT&&(u.prototype.__proto__=Uint8Array.prototype,u.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&u[Symbol.species]===u&&Object.defineProperty(u,Symbol.species,{value:null,configurable:!0})),u.alloc=function(t,e,r){return function(t,e,r,n){return f(e),e<=0?s(t,e):void 0!==r?"string"==typeof n?s(t,e).fill(r,n):s(t,e).fill(r):s(t,e)}(null,t,e,r)},u.allocUnsafe=function(t){return l(null,t)},u.allocUnsafeSlow=function(t){return l(null,t)},u.isBuffer=function(t){return!(null==t||!t._isBuffer)},u.compare=function(t,e){if(!u.isBuffer(t)||!u.isBuffer(e))throw new TypeError("Arguments must be Buffers");if(t===e)return 0;for(var r=t.length,n=e.length,i=0,o=Math.min(r,n);i<o;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(t){switch(String(t).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},u.concat=function(t,e){if(!o(t))throw new TypeError(\'"list" argument must be an Array of Buffers\');if(0===t.length)return u.alloc(0);var r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;var n=u.allocUnsafe(e),i=0;for(r=0;r<t.length;++r){var a=t[r];if(!u.isBuffer(a))throw new TypeError(\'"list" argument must be an Array of Buffers\');a.copy(n,i),i+=a.length}return n},u.byteLength=d,u.prototype._isBuffer=!0,u.prototype.swap16=function(){var t=this.length;if(t%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var e=0;e<t;e+=2)g(this,e,e+1);return this},u.prototype.swap32=function(){var t=this.length;if(t%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var e=0;e<t;e+=4)g(this,e,e+3),g(this,e+1,e+2);return this},u.prototype.swap64=function(){var t=this.length;if(t%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var e=0;e<t;e+=8)g(this,e,e+7),g(this,e+1,e+6),g(this,e+2,e+5),g(this,e+3,e+4);return this},u.prototype.toString=function(){var t=0|this.length;return 0===t?"":0===arguments.length?j(this,0,t):v.apply(this,arguments)},u.prototype.equals=function(t){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");return this===t||0===u.compare(this,t)},u.prototype.inspect=function(){var t="",r=e.INSPECT_MAX_BYTES;return this.length>0&&(t=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(t+=" ... ")),"<Buffer "+t+">"},u.prototype.compare=function(t,e,r,n,i){if(!u.isBuffer(t))throw new TypeError("Argument must be a Buffer");if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),e<0||r>t.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(this===t)return 0;for(var o=(i>>>=0)-(n>>>=0),a=(r>>>=0)-(e>>>=0),s=Math.min(o,a),c=this.slice(n,i),f=t.slice(e,r),l=0;l<s;++l)if(c[l]!==f[l]){o=c[l],a=f[l];break}return o<a?-1:a<o?1:0},u.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},u.prototype.indexOf=function(t,e,r){return y(this,t,e,r,!0)},u.prototype.lastIndexOf=function(t,e,r){return y(this,t,e,r,!1)},u.prototype.write=function(t,e,r,n){if(void 0===e)n="utf8",r=this.length,e=0;else if(void 0===r&&"string"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");e|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return _(this,t,e,r);case"utf8":case"utf-8":return m(this,t,e,r);case"ascii":return w(this,t,e,r);case"latin1":case"binary":return x(this,t,e,r);case"base64":return k(this,t,e,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return E(this,t,e,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};function R(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function C(t,e,r){var n="";r=Math.min(t.length,r);for(var i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function I(t,e,r){var n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=e;o<r;++o)i+=D(t[o]);return i}function O(t,e,r){for(var n=t.slice(e,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function T(t,e,r){if(t%1!=0||t<0)throw new RangeError("offset is not uint");if(t+e>r)throw new RangeError("Trying to access beyond buffer length")}function P(t,e,r,n,i,o){if(!u.isBuffer(t))throw new TypeError(\'"buffer" argument must be a Buffer instance\');if(e>i||e<o)throw new RangeError(\'"value" argument is out of bounds\');if(r+n>t.length)throw new RangeError("Index out of range")}function A(t,e,r,n){e<0&&(e=65535+e+1);for(var i=0,o=Math.min(t.length-r,2);i<o;++i)t[r+i]=(e&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function L(t,e,r,n){e<0&&(e=4294967295+e+1);for(var i=0,o=Math.min(t.length-r,4);i<o;++i)t[r+i]=e>>>8*(n?i:3-i)&255}function F(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function M(t,e,r,n,o){return o||F(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function N(t,e,r,n,o){return o||F(t,0,r,8),i.write(t,e,r,n,52,8),r+8}u.prototype.slice=function(t,e){var r,n=this.length;if((t=~~t)<0?(t+=n)<0&&(t=0):t>n&&(t=n),(e=void 0===e?n:~~e)<0?(e+=n)<0&&(e=0):e>n&&(e=n),e<t&&(e=t),u.TYPED_ARRAY_SUPPORT)(r=this.subarray(t,e)).__proto__=u.prototype;else{var i=e-t;r=new u(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+t]}return r},u.prototype.readUIntLE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n},u.prototype.readUIntBE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t+--e],i=1;e>0&&(i*=256);)n+=this[t+--e]*i;return n},u.prototype.readUInt8=function(t,e){return e||T(t,1,this.length),this[t]},u.prototype.readUInt16LE=function(t,e){return e||T(t,2,this.length),this[t]|this[t+1]<<8},u.prototype.readUInt16BE=function(t,e){return e||T(t,2,this.length),this[t]<<8|this[t+1]},u.prototype.readUInt32LE=function(t,e){return e||T(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},u.prototype.readUInt32BE=function(t,e){return e||T(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},u.prototype.readIntLE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=this[t],i=1,o=0;++o<e&&(i*=256);)n+=this[t+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*e)),n},u.prototype.readIntBE=function(t,e,r){t|=0,e|=0,r||T(t,e,this.length);for(var n=e,i=1,o=this[t+--n];n>0&&(i*=256);)o+=this[t+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*e)),o},u.prototype.readInt8=function(t,e){return e||T(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},u.prototype.readInt16LE=function(t,e){e||T(t,2,this.length);var r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(t,e){e||T(t,2,this.length);var r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(t,e){return e||T(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},u.prototype.readInt32BE=function(t,e){return e||T(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},u.prototype.readFloatLE=function(t,e){return e||T(t,4,this.length),i.read(this,t,!0,23,4)},u.prototype.readFloatBE=function(t,e){return e||T(t,4,this.length),i.read(this,t,!1,23,4)},u.prototype.readDoubleLE=function(t,e){return e||T(t,8,this.length),i.read(this,t,!0,52,8)},u.prototype.readDoubleBE=function(t,e){return e||T(t,8,this.length),i.read(this,t,!1,52,8)},u.prototype.writeUIntLE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||P(this,t,e,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},u.prototype.writeUIntBE=function(t,e,r,n){(t=+t,e|=0,r|=0,n)||P(this,t,e,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},u.prototype.writeUInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,255,0),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),this[e]=255&t,e+1},u.prototype.writeUInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):A(this,t,e,!0),e+2},u.prototype.writeUInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,65535,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):A(this,t,e,!1),e+2},u.prototype.writeUInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t):L(this,t,e,!0),e+4},u.prototype.writeUInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,4294967295,0),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},u.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=0,a=1,s=0;for(this[e]=255&t;++o<r&&(a*=256);)t<0&&0===s&&0!==this[e+o-1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},u.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e|=0,!n){var i=Math.pow(2,8*r-1);P(this,t,e,r,i-1,-i)}var o=r-1,a=1,s=0;for(this[e+o]=255&t;--o>=0&&(a*=256);)t<0&&0===s&&0!==this[e+o+1]&&(s=1),this[e+o]=(t/a>>0)-s&255;return e+r},u.prototype.writeInt8=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,1,127,-128),u.TYPED_ARRAY_SUPPORT||(t=Math.floor(t)),t<0&&(t=255+t+1),this[e]=255&t,e+1},u.prototype.writeInt16LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8):A(this,t,e,!0),e+2},u.prototype.writeInt16BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,2,32767,-32768),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>8,this[e+1]=255&t):A(this,t,e,!1),e+2},u.prototype.writeInt32LE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),u.TYPED_ARRAY_SUPPORT?(this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24):L(this,t,e,!0),e+4},u.prototype.writeInt32BE=function(t,e,r){return t=+t,e|=0,r||P(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),u.TYPED_ARRAY_SUPPORT?(this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t):L(this,t,e,!1),e+4},u.prototype.writeFloatLE=function(t,e,r){return M(this,t,e,!0,r)},u.prototype.writeFloatBE=function(t,e,r){return M(this,t,e,!1,r)},u.prototype.writeDoubleLE=function(t,e,r){return N(this,t,e,!0,r)},u.prototype.writeDoubleBE=function(t,e,r){return N(this,t,e,!1,r)},u.prototype.copy=function(t,e,r,n){if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);var i,o=n-r;if(this===t&&r<e&&e<n)for(i=o-1;i>=0;--i)t[i+e]=this[i+r];else if(o<1e3||!u.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)t[i+e]=this[i+r];else Uint8Array.prototype.set.call(t,this.subarray(r,r+o),e);return o},u.prototype.fill=function(t,e,r,n){if("string"==typeof t){if("string"==typeof e?(n=e,e=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===t.length){var i=t.charCodeAt(0);i<256&&(t=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!u.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof t&&(t&=255);if(e<0||this.length<e||this.length<r)throw new RangeError("Out of range index");if(r<=e)return this;var o;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),"number"==typeof t)for(o=e;o<r;++o)this[o]=t;else{var a=u.isBuffer(t)?t:U(new u(t,n).toString()),s=a.length;for(o=0;o<r-e;++o)this[o+e]=a[o%s]}return this};var B=/[^+\\/0-9A-Za-z-_]/g;function D(t){return t<16?"0"+t.toString(16):t.toString(16)}function U(t,e){var r;e=e||1/0;for(var n=t.length,i=null,o=[],a=0;a<n;++a){if((r=t.charCodeAt(a))>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(a+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function q(t){return n.toByteArray(function(t){if((t=function(t){return t.trim?t.trim():t.replace(/^\\s+|\\s+$/g,"")}(t).replace(B,"")).length<2)return"";for(;t.length%4!=0;)t+="=";return t}(t))}function G(t,e,r,n){for(var i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}}).call(this,r(21))},function(t,e,r){"use strict";var n,i="object"==typeof Reflect?Reflect:null,o=i&&"function"==typeof i.apply?i.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};n=i&&"function"==typeof i.ownKeys?i.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var a=Number.isNaN||function(t){return t!=t};function s(){s.init.call(this)}t.exports=s,s.EventEmitter=s,s.prototype._events=void 0,s.prototype._eventsCount=0,s.prototype._maxListeners=void 0;var u=10;function c(t){if("function"!=typeof t)throw new TypeError(\'The "listener" argument must be of type Function. Received type \'+typeof t)}function f(t){return void 0===t._maxListeners?s.defaultMaxListeners:t._maxListeners}function l(t,e,r,n){var i,o,a,s;if(c(r),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit("newListener",e,r.listener?r.listener:r),o=t._events),a=o[e]),void 0===a)a=o[e]=r,++t._eventsCount;else if("function"==typeof a?a=o[e]=n?[r,a]:[a,r]:n?a.unshift(r):a.push(r),(i=f(t))>0&&a.length>i&&!a.warned){a.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(e)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=t,u.type=e,u.count=a.length,s=u,console&&console.warn&&console.warn(s)}return t}function h(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function p(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},i=h.bind(n);return i.listener=r,n.wrapFn=i,i}function d(t,e,r){var n=t._events;if(void 0===n)return[];var i=n[e];return void 0===i?[]:"function"==typeof i?r?[i.listener||i]:[i]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(i):g(i,i.length)}function v(t){var e=this._events;if(void 0!==e){var r=e[t];if("function"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function g(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}Object.defineProperty(s,"defaultMaxListeners",{enumerable:!0,get:function(){return u},set:function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError(\'The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received \'+t+".");u=t}}),s.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},s.prototype.setMaxListeners=function(t){if("number"!=typeof t||t<0||a(t))throw new RangeError(\'The value of "n" is out of range. It must be a non-negative number. Received \'+t+".");return this._maxListeners=t,this},s.prototype.getMaxListeners=function(){return f(this)},s.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var n="error"===t,i=this._events;if(void 0!==i)n=n&&void 0===i.error;else if(!n)return!1;if(n){var a;if(e.length>0&&(a=e[0]),a instanceof Error)throw a;var s=new Error("Unhandled error."+(a?" ("+a.message+")":""));throw s.context=a,s}var u=i[t];if(void 0===u)return!1;if("function"==typeof u)o(u,this,e);else{var c=u.length,f=g(u,c);for(r=0;r<c;++r)o(f[r],this,e)}return!0},s.prototype.addListener=function(t,e){return l(this,t,e,!1)},s.prototype.on=s.prototype.addListener,s.prototype.prependListener=function(t,e){return l(this,t,e,!0)},s.prototype.once=function(t,e){return c(e),this.on(t,p(this,t,e)),this},s.prototype.prependOnceListener=function(t,e){return c(e),this.prependListener(t,p(this,t,e)),this},s.prototype.removeListener=function(t,e){var r,n,i,o,a;if(c(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit("removeListener",t,r.listener||e));else if("function"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){a=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,i),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit("removeListener",t,a||e)}return this},s.prototype.off=s.prototype.removeListener,s.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)"removeListener"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},s.prototype.listeners=function(t){return d(this,t,!0)},s.prototype.rawListeners=function(t){return d(this,t,!1)},s.listenerCount=function(t,e){return"function"==typeof t.listenerCount?t.listenerCount(e):v.call(t,e)},s.prototype.listenerCount=v,s.prototype.eventNames=function(){return this._eventsCount>0?n(this._events):[]}},function(t,e,r){(e=t.exports=r(138)).Stream=e,e.Readable=e,e.Writable=r(95),e.Duplex=r(23),e.Transform=r(142),e.PassThrough=r(196)},function(t,e,r){"use strict";(function(e,n,i){var o=r(55);function a(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,r){var n=t.entry;t.entry=null;for(;n;){var i=n.callback;e.pendingcb--,i(r),n=n.next}e.corkedRequestsFree?e.corkedRequestsFree.next=t:e.corkedRequestsFree=t}(e,t)}}t.exports=b;var s,u=!e.browser&&["v0.10","v0.9."].indexOf(e.version.slice(0,5))>-1?n:o.nextTick;b.WritableState=y;var c=r(39);c.inherits=r(29);var f={deprecate:r(195)},l=r(139),h=r(56).Buffer,p=i.Uint8Array||function(){};var d,v=r(140);function g(){}function y(t,e){s=s||r(23),t=t||{};var n=e instanceof s;this.objectMode=!!t.objectMode,n&&(this.objectMode=this.objectMode||!!t.writableObjectMode);var i=t.highWaterMark,c=t.writableHighWaterMark,f=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(c||0===c)?c:f,this.highWaterMark=Math.floor(this.highWaterMark),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var l=!1===t.decodeStrings;this.decodeStrings=!l,this.defaultEncoding=t.defaultEncoding||"utf8",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var r=t._writableState,n=r.sync,i=r.writecb;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(r),e)!function(t,e,r,n,i){--e.pendingcb,r?(o.nextTick(i,n),o.nextTick(E,t,e),t._writableState.errorEmitted=!0,t.emit("error",n)):(i(n),t._writableState.errorEmitted=!0,t.emit("error",n),E(t,e))}(t,r,n,e,i);else{var a=x(r);a||r.corked||r.bufferProcessing||!r.bufferedRequest||w(t,r),n?u(m,t,r,a,i):m(t,r,a,i)}}(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.bufferedRequestCount=0,this.corkedRequestsFree=new a(this)}function b(t){if(s=s||r(23),!(d.call(b,this)||this instanceof s))return new b(t);this._writableState=new y(t,this),this.writable=!0,t&&("function"==typeof t.write&&(this._write=t.write),"function"==typeof t.writev&&(this._writev=t.writev),"function"==typeof t.destroy&&(this._destroy=t.destroy),"function"==typeof t.final&&(this._final=t.final)),l.call(this)}function _(t,e,r,n,i,o,a){e.writelen=n,e.writecb=a,e.writing=!0,e.sync=!0,r?t._writev(i,e.onwrite):t._write(i,o,e.onwrite),e.sync=!1}function m(t,e,r,n){r||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit("drain"))}(t,e),e.pendingcb--,n(),E(t,e)}function w(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var n=e.bufferedRequestCount,i=new Array(n),o=e.corkedRequestsFree;o.entry=r;for(var s=0,u=!0;r;)i[s]=r,r.isBuf||(u=!1),r=r.next,s+=1;i.allBuffers=u,_(t,e,!0,e.length,i,"",o.finish),e.pendingcb++,e.lastBufferedRequest=null,o.next?(e.corkedRequestsFree=o.next,o.next=null):e.corkedRequestsFree=new a(e),e.bufferedRequestCount=0}else{for(;r;){var c=r.chunk,f=r.encoding,l=r.callback;if(_(t,e,!1,e.objectMode?1:c.length,c,f,l),r=r.next,e.bufferedRequestCount--,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequest=r,e.bufferProcessing=!1}function x(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function k(t,e){t._final((function(r){e.pendingcb--,r&&t.emit("error",r),e.prefinished=!0,t.emit("prefinish"),E(t,e)}))}function E(t,e){var r=x(e);return r&&(!function(t,e){e.prefinished||e.finalCalled||("function"==typeof t._final?(e.pendingcb++,e.finalCalled=!0,o.nextTick(k,t,e)):(e.prefinished=!0,t.emit("prefinish")))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit("finish"))),r}c.inherits(b,l),y.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(y.prototype,"buffer",{get:f.deprecate((function(){return this.getBuffer()}),"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.","DEP0003")})}catch(t){}}(),"function"==typeof Symbol&&Symbol.hasInstance&&"function"==typeof Function.prototype[Symbol.hasInstance]?(d=Function.prototype[Symbol.hasInstance],Object.defineProperty(b,Symbol.hasInstance,{value:function(t){return!!d.call(this,t)||this===b&&(t&&t._writableState instanceof y)}})):d=function(t){return t instanceof this},b.prototype.pipe=function(){this.emit("error",new Error("Cannot pipe, not readable"))},b.prototype.write=function(t,e,r){var n,i=this._writableState,a=!1,s=!i.objectMode&&(n=t,h.isBuffer(n)||n instanceof p);return s&&!h.isBuffer(t)&&(t=function(t){return h.from(t)}(t)),"function"==typeof e&&(r=e,e=null),s?e="buffer":e||(e=i.defaultEncoding),"function"!=typeof r&&(r=g),i.ended?function(t,e){var r=new Error("write after end");t.emit("error",r),o.nextTick(e,r)}(this,r):(s||function(t,e,r,n){var i=!0,a=!1;return null===r?a=new TypeError("May not write null values to stream"):"string"==typeof r||void 0===r||e.objectMode||(a=new TypeError("Invalid non-string/buffer chunk")),a&&(t.emit("error",a),o.nextTick(n,a),i=!1),i}(this,i,t,r))&&(i.pendingcb++,a=function(t,e,r,n,i,o){if(!r){var a=function(t,e,r){t.objectMode||!1===t.decodeStrings||"string"!=typeof e||(e=h.from(e,r));return e}(e,n,i);n!==a&&(r=!0,i="buffer",n=a)}var s=e.objectMode?1:n.length;e.length+=s;var u=e.length<e.highWaterMark;u||(e.needDrain=!0);if(e.writing||e.corked){var c=e.lastBufferedRequest;e.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},c?c.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else _(t,e,!1,s,n,i,o);return u}(this,i,s,t,e,r)),a},b.prototype.cork=function(){this._writableState.corked++},b.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.finished||t.bufferProcessing||!t.bufferedRequest||w(this,t))},b.prototype.setDefaultEncoding=function(t){if("string"==typeof t&&(t=t.toLowerCase()),!(["hex","utf8","utf-8","ascii","binary","base64","ucs2","ucs-2","utf16le","utf-16le","raw"].indexOf((t+"").toLowerCase())>-1))throw new TypeError("Unknown encoding: "+t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(b.prototype,"writableHighWaterMark",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),b.prototype._write=function(t,e,r){r(new Error("_write() is not implemented"))},b.prototype._writev=null,b.prototype.end=function(t,e,r){var n=this._writableState;"function"==typeof t?(r=t,t=null,e=null):"function"==typeof e&&(r=e,e=null),null!=t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||n.finished||function(t,e,r){e.ending=!0,E(t,e),r&&(e.finished?o.nextTick(r):t.once("finish",r));e.ended=!0,t.writable=!1}(this,n,r)},Object.defineProperty(b.prototype,"destroyed",{get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),b.prototype.destroy=v.destroy,b.prototype._undestroy=v.undestroy,b.prototype._destroy=function(t,e){this.end(),e(t)}}).call(this,r(38),r(136).setImmediate,r(21))},function(t,e){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?t.exports=r=function(t){return typeof t}:t.exports=r=function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t},r(e)}t.exports=r},function(t,e,r){var n=r(16),i=r(80),o=r(202),a=r(203);function s(e){var r="function"==typeof Map?new Map:void 0;return t.exports=s=function(t){if(null===t||!o(t))return t;if("function"!=typeof t)throw new TypeError("Super expression must either be null or a function");if(void 0!==r){if(r.has(t))return r.get(t);r.set(t,e)}function e(){return a(t,arguments,n(this).constructor)}return e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),i(e,t)},s(e)}t.exports=s},function(t,e,r){"use strict";var n=r(2),i=r(4),o=r(26),a=r(25),s=r(7),u=r(69),c=r(107),f=r(5),l=r(13),h=r(47),p=r(10),d=r(8),v=r(27),g=r(12),y=r(43),b=r(31),_=r(70),m=r(48),w=r(46),x=r(148),k=r(106),E=r(22),S=r(11),j=r(59),R=r(14),C=r(17),I=r(64),O=r(44),T=r(45),P=r(65),A=r(3),L=r(110),F=r(111),M=r(49),N=r(24),B=r(33).forEach,D=O("hidden"),U=A("toPrimitive"),q=N.set,G=N.getterFor("Symbol"),W=Object.prototype,z=i.Symbol,Y=o("JSON","stringify"),Q=E.f,$=S.f,H=x.f,K=j.f,V=I("symbols"),Z=I("op-symbols"),J=I("string-to-symbol-registry"),X=I("symbol-to-string-registry"),tt=I("wks"),et=i.QObject,rt=!et||!et.prototype||!et.prototype.findChild,nt=s&&f((function(){return 7!=_($({},"a",{get:function(){return $(this,"a",{value:7}).a}})).a}))?function(t,e,r){var n=Q(W,e);n&&delete W[e],$(t,e,r),n&&t!==W&&$(W,e,n)}:$,it=function(t,e){var r=V[t]=_(z.prototype);return q(r,{type:"Symbol",tag:t,description:e}),s||(r.description=e),r},ot=c?function(t){return"symbol"==typeof t}:function(t){return Object(t)instanceof z},at=function(t,e,r){t===W&&at(Z,e,r),d(t);var n=y(e,!0);return d(r),l(V,n)?(r.enumerable?(l(t,D)&&t[D][n]&&(t[D][n]=!1),r=_(r,{enumerable:b(0,!1)})):(l(t,D)||$(t,D,b(1,{})),t[D][n]=!0),nt(t,n,r)):$(t,n,r)},st=function(t,e){d(t);var r=g(e),n=m(r).concat(lt(r));return B(n,(function(e){s&&!ut.call(r,e)||at(t,e,r[e])})),t},ut=function(t){var e=y(t,!0),r=K.call(this,e);return!(this===W&&l(V,e)&&!l(Z,e))&&(!(r||!l(this,e)||!l(V,e)||l(this,D)&&this[D][e])||r)},ct=function(t,e){var r=g(t),n=y(e,!0);if(r!==W||!l(V,n)||l(Z,n)){var i=Q(r,n);return!i||!l(V,n)||l(r,D)&&r[D][n]||(i.enumerable=!0),i}},ft=function(t){var e=H(g(t)),r=[];return B(e,(function(t){l(V,t)||l(T,t)||r.push(t)})),r},lt=function(t){var e=t===W,r=H(e?Z:g(t)),n=[];return B(r,(function(t){!l(V,t)||e&&!l(W,t)||n.push(V[t])})),n};(u||(C((z=function(){if(this instanceof z)throw TypeError("Symbol is not a constructor");var t=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=P(t),r=function(t){this===W&&r.call(Z,t),l(this,D)&&l(this[D],e)&&(this[D][e]=!1),nt(this,e,b(1,t))};return s&&rt&&nt(W,e,{configurable:!0,set:r}),it(e,t)}).prototype,"toString",(function(){return G(this).tag})),C(z,"withoutSetter",(function(t){return it(P(t),t)})),j.f=ut,S.f=at,E.f=ct,w.f=x.f=ft,k.f=lt,L.f=function(t){return it(A(t),t)},s&&($(z.prototype,"description",{configurable:!0,get:function(){return G(this).description}}),a||C(W,"propertyIsEnumerable",ut,{unsafe:!0}))),n({global:!0,wrap:!0,forced:!u,sham:!u},{Symbol:z}),B(m(tt),(function(t){F(t)})),n({target:"Symbol",stat:!0,forced:!u},{for:function(t){var e=String(t);if(l(J,e))return J[e];var r=z(e);return J[e]=r,X[r]=e,r},keyFor:function(t){if(!ot(t))throw TypeError(t+" is not a symbol");if(l(X,t))return X[t]},useSetter:function(){rt=!0},useSimple:function(){rt=!1}}),n({target:"Object",stat:!0,forced:!u,sham:!s},{create:function(t,e){return void 0===e?_(t):st(_(t),e)},defineProperty:at,defineProperties:st,getOwnPropertyDescriptor:ct}),n({target:"Object",stat:!0,forced:!u},{getOwnPropertyNames:ft,getOwnPropertySymbols:lt}),n({target:"Object",stat:!0,forced:f((function(){k.f(1)}))},{getOwnPropertySymbols:function(t){return k.f(v(t))}}),Y)&&n({target:"JSON",stat:!0,forced:!u||f((function(){var t=z();return"[null]"!=Y([t])||"{}"!=Y({a:t})||"{}"!=Y(Object(t))}))},{stringify:function(t,e,r){for(var n,i=[t],o=1;arguments.length>o;)i.push(arguments[o++]);if(n=e,(p(e)||void 0!==t)&&!ot(t))return h(e)||(e=function(t,e){if("function"==typeof n&&(e=n.call(this,t,e)),!ot(e))return e}),i[1]=e,Y.apply(null,i)}});z.prototype[U]||R(z.prototype,U,z.prototype.valueOf),M(z,"Symbol"),T[D]=!0},function(t,e,r){var n=r(7),i=r(5),o=r(61);t.exports=!n&&!i((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(t,e,r){var n=r(4),i=r(62),o=n["__core-js_shared__"]||i("__core-js_shared__",{});t.exports=o},function(t,e,r){var n=r(13),i=r(102),o=r(22),a=r(11);t.exports=function(t,e){for(var r=i(e),s=a.f,u=o.f,c=0;c<r.length;c++){var f=r[c];n(t,f)||s(t,f,u(e,f))}}},function(t,e,r){var n=r(26),i=r(46),o=r(106),a=r(8);t.exports=n("Reflect","ownKeys")||function(t){var e=i.f(a(t)),r=o.f;return r?e.concat(r(t)):e}},function(t,e,r){var n=r(4);t.exports=n},function(t,e,r){var n=r(13),i=r(12),o=r(66).indexOf,a=r(45);t.exports=function(t,e){var r,s=i(t),u=0,c=[];for(r in s)!n(a,r)&&n(s,r)&&c.push(r);for(;e.length>u;)n(s,r=e[u++])&&(~o(c,r)||c.push(r));return c}},function(t,e,r){var n=r(32),i=Math.max,o=Math.min;t.exports=function(t,e){var r=n(t);return r<0?i(r+e,0):o(r,e)}},function(t,e){e.f=Object.getOwnPropertySymbols},function(t,e,r){var n=r(69);t.exports=n&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(t,e,r){var n=r(7),i=r(11),o=r(8),a=r(48);t.exports=n?Object.defineProperties:function(t,e){o(t);for(var r,n=a(e),s=n.length,u=0;s>u;)i.f(t,r=n[u++],e[r]);return t}},function(t,e,r){var n=r(26);t.exports=n("document","documentElement")},function(t,e,r){var n=r(3);e.f=n},function(t,e,r){var n=r(103),i=r(13),o=r(110),a=r(11).f;t.exports=function(t){var e=n.Symbol||(n.Symbol={});i(e,t)||a(e,t,{value:o.f(t)})}},function(t,e,r){var n=r(10),i=r(47),o=r(3)("species");t.exports=function(t,e){var r;return i(t)&&("function"!=typeof(r=t.constructor)||r!==Array&&!i(r.prototype)?n(r)&&null===(r=r[o])&&(r=void 0):r=void 0),new(void 0===r?Array:r)(0===e?0:e)}},function(t,e,r){var n=r(3),i=r(70),o=r(11),a=n("unscopables"),s=Array.prototype;null==s[a]&&o.f(s,a,{configurable:!0,value:i(null)}),t.exports=function(t){s[a][t]=!0}},function(t,e,r){"use strict";var n=r(2),i=r(151),o=r(116),a=r(117),s=r(49),u=r(14),c=r(17),f=r(3),l=r(25),h=r(34),p=r(115),d=p.IteratorPrototype,v=p.BUGGY_SAFARI_ITERATORS,g=f("iterator"),y=function(){return this};t.exports=function(t,e,r,f,p,b,_){i(r,e,f);var m,w,x,k=function(t){if(t===p&&C)return C;if(!v&&t in j)return j[t];switch(t){case"keys":case"values":case"entries":return function(){return new r(this,t)}}return function(){return new r(this)}},E=e+" Iterator",S=!1,j=t.prototype,R=j[g]||j["@@iterator"]||p&&j[p],C=!v&&R||k(p),I="Array"==e&&j.entries||R;if(I&&(m=o(I.call(new t)),d!==Object.prototype&&m.next&&(l||o(m)===d||(a?a(m,d):"function"!=typeof m[g]&&u(m,g,y)),s(m,E,!0,!0),l&&(h[E]=y))),"values"==p&&R&&"values"!==R.name&&(S=!0,C=function(){return R.call(this)}),l&&!_||j[g]===C||u(j,g,C),h[e]=C,p)if(w={values:k("values"),keys:b?C:k("keys"),entries:k("entries")},_)for(x in w)(v||S||!(x in j))&&c(j,x,w[x]);else n({target:e,proto:!0,forced:v||S},w);return w}},function(t,e,r){"use strict";var n,i,o,a=r(116),s=r(14),u=r(13),c=r(3),f=r(25),l=c("iterator"),h=!1;[].keys&&("next"in(o=[].keys())?(i=a(a(o)))!==Object.prototype&&(n=i):h=!0),null==n&&(n={}),f||u(n,l)||s(n,l,(function(){return this})),t.exports={IteratorPrototype:n,BUGGY_SAFARI_ITERATORS:h}},function(t,e,r){var n=r(13),i=r(27),o=r(44),a=r(152),s=o("IE_PROTO"),u=Object.prototype;t.exports=a?Object.getPrototypeOf:function(t){return t=i(t),n(t,s)?t[s]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,e,r){var n=r(8),i=r(153);t.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var t,e=!1,r={};try{(t=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(r,[]),e=r instanceof Array}catch(t){}return function(r,o){return n(r),i(o),e?t.call(r,o):r.__proto__=o,r}}():void 0)},function(t,e,r){var n=r(72),i=r(19),o=r(3)("toStringTag"),a="Arguments"==i(function(){return arguments}());t.exports=n?i:function(t){var e,r,n;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=function(t,e){try{return t[e]}catch(t){}}(e=Object(t),o))?r:a?i(e):"Object"==(n=i(e))&&"function"==typeof e.callee?"Arguments":n}},function(t,e,r){"use strict";var n=r(5);function i(t,e){return RegExp(t,e)}e.UNSUPPORTED_Y=n((function(){var t=i("a","y");return t.lastIndex=2,null!=t.exec("abcd")})),e.BROKEN_CARET=n((function(){var t=i("^r","gy");return t.lastIndex=2,null!=t.exec("str")}))},function(t,e,r){var n=r(32),i=r(20),o=function(t){return function(e,r){var o,a,s=String(i(e)),u=n(r),c=s.length;return u<0||u>=c?t?"":void 0:(o=s.charCodeAt(u))<55296||o>56319||u+1===c||(a=s.charCodeAt(u+1))<56320||a>57343?t?s.charAt(u):o:t?s.slice(u,u+2):a-56320+(o-55296<<10)+65536}};t.exports={codeAt:o(!1),charAt:o(!0)}},function(t,e){t.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(t,e,r){var n=r(26);t.exports=n("navigator","userAgent")||""},function(t,e,r){"use strict";var n=r(33).forEach,i=r(36);t.exports=i("forEach")?function(t){return n(this,t,arguments.length>1?arguments[1]:void 0)}:[].forEach},function(t,e,r){var n=r(2),i=r(27),o=r(48);n({target:"Object",stat:!0,forced:r(5)((function(){o(1)}))},{keys:function(t){return o(i(t))}})},function(t,e,r){"use strict";var n=r(26),i=r(11),o=r(3),a=r(7),s=o("species");t.exports=function(t){var e=n(t),r=i.f;a&&e&&!e[s]&&r(e,s,{configurable:!0,get:function(){return this}})}},function(t,e,r){"use strict";var n,i=r(2),o=r(22).f,a=r(15),s=r(127),u=r(20),c=r(128),f=r(25),l="".endsWith,h=Math.min,p=c("endsWith");i({target:"String",proto:!0,forced:!!(f||p||(n=o(String.prototype,"endsWith"),!n||n.writable))&&!p},{endsWith:function(t){var e=String(u(this));s(t);var r=arguments.length>1?arguments[1]:void 0,n=a(e.length),i=void 0===r?n:h(a(r),n),o=String(t);return l?l.call(e,o,i):e.slice(i-o.length,i)===o}})},function(t,e,r){var n=r(88);t.exports=function(t){if(n(t))throw TypeError("The method doesn\'t accept regular expressions");return t}},function(t,e,r){var n=r(3)("match");t.exports=function(t){var e=/./;try{"/./"[t](e)}catch(r){try{return e[n]=!1,"/./"[t](e)}catch(t){}}return!1}},function(t,e,r){"use strict";var n=r(2),i=r(127),o=r(20);n({target:"String",proto:!0,forced:!r(128)("includes")},{includes:function(t){return!!~String(o(this)).indexOf(i(t),arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){var n=r(2),i=r(175);n({target:"Array",proto:!0,forced:i!==[].lastIndexOf},{lastIndexOf:i})},function(t,e,r){"use strict";var n=r(2),i=r(10),o=r(47),a=r(105),s=r(15),u=r(12),c=r(82),f=r(54),l=r(3)("species"),h=[].slice,p=Math.max;n({target:"Array",proto:!0,forced:!f("slice")},{slice:function(t,e){var r,n,f,d=u(this),v=s(d.length),g=a(t,v),y=a(void 0===e?v:e,v);if(o(d)&&("function"!=typeof(r=d.constructor)||r!==Array&&!o(r.prototype)?i(r)&&null===(r=r[l])&&(r=void 0):r=void 0,r===Array||void 0===r))return h.call(d,g,y);for(n=new(void 0===r?Array:r)(p(y-g,0)),f=0;g<y;g++,f++)g in d&&c(n,f,d[g]);return n.length=f,n}})},function(t,e,r){var n=r(8),i=r(50),o=r(3)("species");t.exports=function(t,e){var r,a=n(t).constructor;return void 0===a||null==(r=n(a)[o])?e:i(r)}},function(t,e,r){var n,i,o,a=r(4),s=r(5),u=r(19),c=r(71),f=r(109),l=r(61),h=r(134),p=a.location,d=a.setImmediate,v=a.clearImmediate,g=a.process,y=a.MessageChannel,b=a.Dispatch,_=0,m={},w=function(t){if(m.hasOwnProperty(t)){var e=m[t];delete m[t],e()}},x=function(t){return function(){w(t)}},k=function(t){w(t.data)},E=function(t){a.postMessage(t+"",p.protocol+"//"+p.host)};d&&v||(d=function(t){for(var e=[],r=1;arguments.length>r;)e.push(arguments[r++]);return m[++_]=function(){("function"==typeof t?t:Function(t)).apply(void 0,e)},n(_),_},v=function(t){delete m[t]},"process"==u(g)?n=function(t){g.nextTick(x(t))}:b&&b.now?n=function(t){b.now(x(t))}:y&&!h?(o=(i=new y).port2,i.port1.onmessage=k,n=c(o.postMessage,o,1)):!a.addEventListener||"function"!=typeof postMessage||a.importScripts||s(E)?n="onreadystatechange"in l("script")?function(t){f.appendChild(l("script")).onreadystatechange=function(){f.removeChild(this),w(t)}}:function(t){setTimeout(x(t),0)}:(n=E,a.addEventListener("message",k,!1))),t.exports={set:d,clear:v}},function(t,e,r){var n=r(122);t.exports=/(iphone|ipod|ipad).*applewebkit/i.test(n)},function(t,e,r){"use strict";var n=r(50),i=function(t){var e,r;this.promise=new t((function(t,n){if(void 0!==e||void 0!==r)throw TypeError("Bad Promise constructor");e=t,r=n})),this.resolve=n(e),this.reject=n(r)};t.exports.f=function(t){return new i(t)}},function(t,e,r){(function(t){var n=void 0!==t&&t||"undefined"!=typeof self&&self||window,i=Function.prototype.apply;function o(t,e){this._id=t,this._clearFn=e}e.setTimeout=function(){return new o(i.call(setTimeout,n,arguments),clearTimeout)},e.setInterval=function(){return new o(i.call(setInterval,n,arguments),clearInterval)},e.clearTimeout=e.clearInterval=function(t){t&&t.close()},o.prototype.unref=o.prototype.ref=function(){},o.prototype.close=function(){this._clearFn.call(n,this._id)},e.enroll=function(t,e){clearTimeout(t._idleTimeoutId),t._idleTimeout=e},e.unenroll=function(t){clearTimeout(t._idleTimeoutId),t._idleTimeout=-1},e._unrefActive=e.active=function(t){clearTimeout(t._idleTimeoutId);var e=t._idleTimeout;e>=0&&(t._idleTimeoutId=setTimeout((function(){t._onTimeout&&t._onTimeout()}),e))},r(189),e.setImmediate="undefined"!=typeof self&&self.setImmediate||void 0!==t&&t.setImmediate||this&&this.setImmediate,e.clearImmediate="undefined"!=typeof self&&self.clearImmediate||void 0!==t&&t.clearImmediate||this&&this.clearImmediate}).call(this,r(21))},function(t,e){var r={}.toString;t.exports=Array.isArray||function(t){return"[object Array]"==r.call(t)}},function(t,e,r){"use strict";(function(e,n){var i=r(55);t.exports=_;var o,a=r(137);_.ReadableState=b;r(93).EventEmitter;var s=function(t,e){return t.listeners(e).length},u=r(139),c=r(56).Buffer,f=e.Uint8Array||function(){};var l=r(39);l.inherits=r(29);var h=r(192),p=void 0;p=h&&h.debuglog?h.debuglog("stream"):function(){};var d,v=r(193),g=r(140);l.inherits(_,u);var y=["error","close","destroy","pause","resume"];function b(t,e){t=t||{};var n=e instanceof(o=o||r(23));this.objectMode=!!t.objectMode,n&&(this.objectMode=this.objectMode||!!t.readableObjectMode);var i=t.highWaterMark,a=t.readableHighWaterMark,s=this.objectMode?16:16384;this.highWaterMark=i||0===i?i:n&&(a||0===a)?a:s,this.highWaterMark=Math.floor(this.highWaterMark),this.buffer=new v,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||"utf8",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(d||(d=r(141).StringDecoder),this.decoder=new d(t.encoding),this.encoding=t.encoding)}function _(t){if(o=o||r(23),!(this instanceof _))return new _(t);this._readableState=new b(t,this),this.readable=!0,t&&("function"==typeof t.read&&(this._read=t.read),"function"==typeof t.destroy&&(this._destroy=t.destroy)),u.call(this)}function m(t,e,r,n,i){var o,a=t._readableState;null===e?(a.reading=!1,function(t,e){if(e.ended)return;if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,k(t)}(t,a)):(i||(o=function(t,e){var r;n=e,c.isBuffer(n)||n instanceof f||"string"==typeof e||void 0===e||t.objectMode||(r=new TypeError("Invalid non-string/buffer chunk"));var n;return r}(a,e)),o?t.emit("error",o):a.objectMode||e&&e.length>0?("string"==typeof e||a.objectMode||Object.getPrototypeOf(e)===c.prototype||(e=function(t){return c.from(t)}(e)),n?a.endEmitted?t.emit("error",new Error("stream.unshift() after end event")):w(t,a,e,!0):a.ended?t.emit("error",new Error("stream.push() after EOF")):(a.reading=!1,a.decoder&&!r?(e=a.decoder.write(e),a.objectMode||0!==e.length?w(t,a,e,!1):S(t,a)):w(t,a,e,!1))):n||(a.reading=!1));return function(t){return!t.ended&&(t.needReadable||t.length<t.highWaterMark||0===t.length)}(a)}function w(t,e,r,n){e.flowing&&0===e.length&&!e.sync?(t.emit("data",r),t.read(0)):(e.length+=e.objectMode?1:r.length,n?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&k(t)),S(t,e)}Object.defineProperty(_.prototype,"destroyed",{get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),_.prototype.destroy=g.destroy,_.prototype._undestroy=g.undestroy,_.prototype._destroy=function(t,e){this.push(null),e(t)},_.prototype.push=function(t,e){var r,n=this._readableState;return n.objectMode?r=!0:"string"==typeof t&&((e=e||n.defaultEncoding)!==n.encoding&&(t=c.from(t,e),e=""),r=!0),m(this,t,e,!1,r)},_.prototype.unshift=function(t){return m(this,t,null,!0,!1)},_.prototype.isPaused=function(){return!1===this._readableState.flowing},_.prototype.setEncoding=function(t){return d||(d=r(141).StringDecoder),this._readableState.decoder=new d(t),this._readableState.encoding=t,this};function x(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=8388608?t=8388608:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function k(t){var e=t._readableState;e.needReadable=!1,e.emittedReadable||(p("emitReadable",e.flowing),e.emittedReadable=!0,e.sync?i.nextTick(E,t):E(t))}function E(t){p("emit readable"),t.emit("readable"),I(t)}function S(t,e){e.readingMore||(e.readingMore=!0,i.nextTick(j,t,e))}function j(t,e){for(var r=e.length;!e.reading&&!e.flowing&&!e.ended&&e.length<e.highWaterMark&&(p("maybeReadMore read 0"),t.read(0),r!==e.length);)r=e.length;e.readingMore=!1}function R(t){p("readable nexttick read 0"),t.read(0)}function C(t,e){e.reading||(p("resume read 0"),t.read(0)),e.resumeScheduled=!1,e.awaitDrain=0,t.emit("resume"),I(t),e.flowing&&!e.reading&&t.read(0)}function I(t){var e=t._readableState;for(p("flow",e.flowing);e.flowing&&null!==t.read(););}function O(t,e){return 0===e.length?null:(e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(""):1===e.buffer.length?e.buffer.head.data:e.buffer.concat(e.length),e.buffer.clear()):r=function(t,e,r){var n;t<e.head.data.length?(n=e.head.data.slice(0,t),e.head.data=e.head.data.slice(t)):n=t===e.head.data.length?e.shift():r?function(t,e){var r=e.head,n=1,i=r.data;t-=i.length;for(;r=r.next;){var o=r.data,a=t>o.length?o.length:t;if(a===o.length?i+=o:i+=o.slice(0,t),0===(t-=a)){a===o.length?(++n,r.next?e.head=r.next:e.head=e.tail=null):(e.head=r,r.data=o.slice(a));break}++n}return e.length-=n,i}(t,e):function(t,e){var r=c.allocUnsafe(t),n=e.head,i=1;n.data.copy(r),t-=n.data.length;for(;n=n.next;){var o=n.data,a=t>o.length?o.length:t;if(o.copy(r,r.length-t,0,a),0===(t-=a)){a===o.length?(++i,n.next?e.head=n.next:e.head=e.tail=null):(e.head=n,n.data=o.slice(a));break}++i}return e.length-=i,r}(t,e);return n}(t,e.buffer,e.decoder),r);var r}function T(t){var e=t._readableState;if(e.length>0)throw new Error(\'"endReadable()" called on non-empty stream\');e.endEmitted||(e.ended=!0,i.nextTick(P,e,t))}function P(t,e){t.endEmitted||0!==t.length||(t.endEmitted=!0,e.readable=!1,e.emit("end"))}function A(t,e){for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return-1}_.prototype.read=function(t){p("read",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&(e.length>=e.highWaterMark||e.ended))return p("read: emitReadable",e.length,e.ended),0===e.length&&e.ended?T(this):k(this),null;if(0===(t=x(t,e))&&e.ended)return 0===e.length&&T(this),null;var n,i=e.needReadable;return p("need readable",i),(0===e.length||e.length-t<e.highWaterMark)&&p("length less than watermark",i=!0),e.ended||e.reading?p("reading or ended",i=!1):i&&(p("do read"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=x(r,e))),null===(n=t>0?O(t,e):null)?(e.needReadable=!0,t=0):e.length-=t,0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&T(this)),null!==n&&this.emit("data",n),n},_.prototype._read=function(t){this.emit("error",new Error("_read() is not implemented"))},_.prototype.pipe=function(t,e){var r=this,o=this._readableState;switch(o.pipesCount){case 0:o.pipes=t;break;case 1:o.pipes=[o.pipes,t];break;default:o.pipes.push(t)}o.pipesCount+=1,p("pipe count=%d opts=%j",o.pipesCount,e);var u=(!e||!1!==e.end)&&t!==n.stdout&&t!==n.stderr?f:_;function c(e,n){p("onunpipe"),e===r&&n&&!1===n.hasUnpiped&&(n.hasUnpiped=!0,p("cleanup"),t.removeListener("close",y),t.removeListener("finish",b),t.removeListener("drain",l),t.removeListener("error",g),t.removeListener("unpipe",c),r.removeListener("end",f),r.removeListener("end",_),r.removeListener("data",v),h=!0,!o.awaitDrain||t._writableState&&!t._writableState.needDrain||l())}function f(){p("onend"),t.end()}o.endEmitted?i.nextTick(u):r.once("end",u),t.on("unpipe",c);var l=function(t){return function(){var e=t._readableState;p("pipeOnDrain",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&s(t,"data")&&(e.flowing=!0,I(t))}}(r);t.on("drain",l);var h=!1;var d=!1;function v(e){p("ondata"),d=!1,!1!==t.write(e)||d||((1===o.pipesCount&&o.pipes===t||o.pipesCount>1&&-1!==A(o.pipes,t))&&!h&&(p("false write response, pause",r._readableState.awaitDrain),r._readableState.awaitDrain++,d=!0),r.pause())}function g(e){p("onerror",e),_(),t.removeListener("error",g),0===s(t,"error")&&t.emit("error",e)}function y(){t.removeListener("finish",b),_()}function b(){p("onfinish"),t.removeListener("close",y),_()}function _(){p("unpipe"),r.unpipe(t)}return r.on("data",v),function(t,e,r){if("function"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events[e]?a(t._events[e])?t._events[e].unshift(r):t._events[e]=[r,t._events[e]]:t.on(e,r)}(t,"error",g),t.once("close",y),t.once("finish",b),t.emit("pipe",r),o.flowing||(p("pipe resume"),r.resume()),t},_.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes||(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit("unpipe",this,r)),this;if(!t){var n=e.pipes,i=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var o=0;o<i;o++)n[o].emit("unpipe",this,r);return this}var a=A(e.pipes,t);return-1===a||(e.pipes.splice(a,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit("unpipe",this,r)),this},_.prototype.on=function(t,e){var r=u.prototype.on.call(this,t,e);if("data"===t)!1!==this._readableState.flowing&&this.resume();else if("readable"===t){var n=this._readableState;n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.emittedReadable=!1,n.reading?n.length&&k(this):i.nextTick(R,this))}return r},_.prototype.addListener=_.prototype.on,_.prototype.resume=function(){var t=this._readableState;return t.flowing||(p("resume"),t.flowing=!0,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,i.nextTick(C,t,e))}(this,t)),this},_.prototype.pause=function(){return p("call pause flowing=%j",this._readableState.flowing),!1!==this._readableState.flowing&&(p("pause"),this._readableState.flowing=!1,this.emit("pause")),this},_.prototype.wrap=function(t){var e=this,r=this._readableState,n=!1;for(var i in t.on("end",(function(){if(p("wrapped end"),r.decoder&&!r.ended){var t=r.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on("data",(function(i){(p("wrapped data"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i)||(r.objectMode||i&&i.length)&&(e.push(i)||(n=!0,t.pause()))})),t)void 0===this[i]&&"function"==typeof t[i]&&(this[i]=function(e){return function(){return t[e].apply(t,arguments)}}(i));for(var o=0;o<y.length;o++)t.on(y[o],this.emit.bind(this,y[o]));return this._read=function(e){p("wrapped _read",e),n&&(n=!1,t.resume())},this},Object.defineProperty(_.prototype,"readableHighWaterMark",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),_._fromList=O}).call(this,r(21),r(38))},function(t,e,r){t.exports=r(93).EventEmitter},function(t,e,r){"use strict";var n=r(55);function i(t,e){t.emit("error",e)}t.exports={destroy:function(t,e){var r=this,o=this._readableState&&this._readableState.destroyed,a=this._writableState&&this._writableState.destroyed;return o||a?(e?e(t):!t||this._writableState&&this._writableState.errorEmitted||n.nextTick(i,this,t),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!e&&t?(n.nextTick(i,r,t),r._writableState&&(r._writableState.errorEmitted=!0)):e&&e(t)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)}}},function(t,e,r){"use strict";var n=r(56).Buffer,i=n.isEncoding||function(t){switch((t=""+t)&&t.toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":case"raw":return!0;default:return!1}};function o(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return"utf8";for(var e;;)switch(t){case"utf8":case"utf-8":return"utf8";case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return"utf16le";case"latin1":case"binary":return"latin1";case"base64":case"ascii":case"hex":return t;default:if(e)return;t=(""+t).toLowerCase(),e=!0}}(t);if("string"!=typeof e&&(n.isEncoding===i||!i(t)))throw new Error("Unknown encoding: "+t);return e||t}(t),this.encoding){case"utf16le":this.text=u,this.end=c,e=4;break;case"utf8":this.fillLast=s,e=4;break;case"base64":this.text=f,this.end=l,e=3;break;default:return this.write=h,void(this.end=p)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(e)}function a(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function s(t){var e=this.lastTotal-this.lastNeed,r=function(t,e,r){if(128!=(192&e[0]))return t.lastNeed=0,"�";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,"�";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,"�"}}(this,t);return void 0!==r?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function u(t,e){if((t.length-e)%2==0){var r=t.toString("utf16le",e);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString("utf16le",e,t.length-1)}function c(t){var e=t&&t.length?this.write(t):"";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString("utf16le",0,r)}return e}function f(t,e){var r=(t.length-e)%3;return 0===r?t.toString("base64",e):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString("base64",e,t.length-r))}function l(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+this.lastChar.toString("base64",0,3-this.lastNeed):e}function h(t){return t.toString(this.encoding)}function p(t){return t&&t.length?this.write(t):""}e.StringDecoder=o,o.prototype.write=function(t){if(0===t.length)return"";var e,r;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return"";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||""},o.prototype.end=function(t){var e=t&&t.length?this.write(t):"";return this.lastNeed?e+"�":e},o.prototype.text=function(t,e){var r=function(t,e,r){var n=e.length-1;if(n<r)return 0;var i=a(e[n]);if(i>=0)return i>0&&(t.lastNeed=i-1),i;if(--n<r||-2===i)return 0;if((i=a(e[n]))>=0)return i>0&&(t.lastNeed=i-2),i;if(--n<r||-2===i)return 0;if((i=a(e[n]))>=0)return i>0&&(2===i?i=0:t.lastNeed=i-3),i;return 0}(this,t,e);if(!this.lastNeed)return t.toString("utf8",e);this.lastTotal=r;var n=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,n),t.toString("utf8",e,n)},o.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},function(t,e,r){"use strict";t.exports=a;var n=r(23),i=r(39);function o(t,e){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(!n)return this.emit("error",new Error("write callback called multiple times"));r.writechunk=null,r.writecb=null,null!=e&&this.push(e),n(t);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function a(t){if(!(this instanceof a))return new a(t);n.call(this,t),this._transformState={afterTransform:o.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&("function"==typeof t.transform&&(this._transform=t.transform),"function"==typeof t.flush&&(this._flush=t.flush)),this.on("prefinish",s)}function s(){var t=this;"function"==typeof this._flush?this._flush((function(e,r){u(t,e,r)})):u(this,null,null)}function u(t,e,r){if(e)return t.emit("error",e);if(null!=r&&t.push(r),t._writableState.length)throw new Error("Calling transform done when ws.length != 0");if(t._transformState.transforming)throw new Error("Calling transform done when still transforming");return t.push(null)}i.inherits=r(29),i.inherits(a,n),a.prototype.push=function(t,e){return this._transformState.needTransform=!1,n.prototype.push.call(this,t,e)},a.prototype._transform=function(t,e,r){throw new Error("_transform() is not implemented")},a.prototype._write=function(t,e,r){var n=this._transformState;if(n.writecb=r,n.writechunk=t,n.writeencoding=e,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},a.prototype._read=function(t){var e=this._transformState;null!==e.writechunk&&e.writecb&&!e.transforming?(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform)):e.needTransform=!0},a.prototype._destroy=function(t,e){var r=this;n.prototype._destroy.call(this,t,(function(t){e(t),r.emit("close")}))}},function(t,e){t.exports=function(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}},function(t,e){const r={acl:"http://www.w3.org/ns/auth/acl#",arg:"http://www.w3.org/ns/pim/arg#",cal:"http://www.w3.org/2002/12/cal/ical#",contact:"http://www.w3.org/2000/10/swap/pim/contact#",dc:"http://purl.org/dc/elements/1.1/",dct:"http://purl.org/dc/terms/",doap:"http://usefulinc.com/ns/doap#",foaf:"http://xmlns.com/foaf/0.1/",http:"http://www.w3.org/2007/ont/http#",httph:"http://www.w3.org/2007/ont/httph#",icalTZ:"http://www.w3.org/2002/12/cal/icaltzd#",ldp:"http://www.w3.org/ns/ldp#",link:"http://www.w3.org/2007/ont/link#",log:"http://www.w3.org/2000/10/swap/log#",meeting:"http://www.w3.org/ns/pim/meeting#",mo:"http://purl.org/ontology/mo/",owl:"http://www.w3.org/2002/07/owl#",pad:"http://www.w3.org/ns/pim/pad#",patch:"http://www.w3.org/ns/pim/patch#",qu:"http://www.w3.org/2000/10/swap/pim/qif#",trip:"http://www.w3.org/ns/pim/trip#",rdf:"http://www.w3.org/1999/02/22-rdf-syntax-ns#",rdfs:"http://www.w3.org/2000/01/rdf-schema#",rss:"http://purl.org/rss/1.0/",sched:"http://www.w3.org/ns/pim/schedule#",schema:"http:/schema.org/",sioc:"http://rdfs.org/sioc/ns#",solid:"http://www.w3.org/ns/solid/terms#",space:"http://www.w3.org/ns/pim/space#",stat:"http://www.w3.org/ns/posix/stat#",tab:"http://www.w3.org/2007/ont/link#",tabont:"http://www.w3.org/2007/ont/link#",ui:"http://www.w3.org/ns/ui#",vcard:"http://www.w3.org/2006/vcard/ns#",wf:"http://www.w3.org/2005/01/wf/flow#",xsd:"http://www.w3.org/2001/XMLSchema#"};t.exports=function(t={namedNode:t=>t}){const e={};for(const n in r){const i=r[n];e[n]=function(e=""){return t.namedNode(i+e)}}return e}},function(t,e,r){"use strict";(function(t,n){r.d(e,"a",(function(){return h}));var i=r(6);const{xsd:o}=i.a,{fromCharCode:a}=String;var s=/\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g,u={"\\\\":"\\\\","\'":"\'",\'"\':\'"\',n:"\\n",r:"\\r",t:"\\t",f:"\\f",b:"\\b",_:"_","~":"~",".":".","-":"-","!":"!",$:"$","&":"&","(":"(",")":")","*":"*","+":"+",",":",",";":";","=":"=","/":"/","?":"?","#":"#","@":"@","%":"%"},c=/[\\x00-\\x20<>\\\\"\\{\\}\\|\\^\\`]/,f={_iri:!0,_unescapedIri:!0,_simpleQuotedString:!0,_langcode:!0,_blank:!0,_newline:!0,_comment:!0,_whitespace:!0,_endOfFile:!0},l=/$0^/;class h{constructor(t){if(this._iri=/^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/,this._unescapedIri=/^<([^\\x00-\\x20<>\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/,this._simpleQuotedString=/^"([^"\\\\\\r\\n]*)"(?=[^"])/,this._simpleApostropheString=/^\'([^\'\\\\\\r\\n]*)\'(?=[^\'])/,this._langcode=/^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i,this._prefix=/^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/,this._prefixed=/^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}"\'<]))/,this._variable=/^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}"\'<])/,this._blank=/^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}"\'<]))/,this._number=/^[\\-+]?(?:\\d+\\.?\\d*([eE](?:[\\-\\+])?\\d+)|\\d*\\.?\\d+)(?=\\.?[,;:\\s#()\\[\\]\\{\\}"\'<])/,this._boolean=/^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}"\'<])/,this._keyword=/^@[a-z]+(?=[\\s#<:])/i,this._sparqlKeyword=/^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i,this._shortPredicates=/^a(?=[\\s()\\[\\]\\{\\}"\'<])/,this._newline=/^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/,this._comment=/#([^\\n\\r]*)/,this._whitespace=/^[ \\t]+/,this._endOfFile=/^(?:#[^\\n\\r]*)?$/,t=t||{},this._lineMode=!!t.lineMode)for(var e in this._n3Mode=!1,this)!(e in f)&&this[e]instanceof RegExp&&(this[e]=l);else this._n3Mode=!1!==t.n3;this._comments=!!t.comments,this._literalClosingPos=0}_tokenizeToEnd(t,e){for(var r=this._input,n=this._comments;;){for(var i,a;i=this._newline.exec(r);)n&&(a=this._comment.exec(i[0]))&&t(null,{line:this._line,type:"comment",value:a[1],prefix:""}),r=r.substr(i[0].length,r.length),this._line++;if(!i&&(i=this._whitespace.exec(r))&&(r=r.substr(i[0].length,r.length)),this._endOfFile.test(r))return e&&(n&&(a=this._comment.exec(r))&&t(null,{line:this._line,type:"comment",value:a[1],prefix:""}),t(r=null,{line:this._line,type:"eof",value:"",prefix:""})),this._input=r;var s=this._line,u="",f="",l="",h=r[0],p=null,d=0,v=!1;switch(h){case"^":if(r.length<3)break;if("^"!==r[1]){this._n3Mode&&(d=1,u="^");break}if(this._previousMarker="^^","<"!==(r=r.substr(2))[0]){v=!0;break}case"<":if(p=this._unescapedIri.exec(r))u="IRI",f=p[1];else if(p=this._iri.exec(r)){if(null===(f=this._unescape(p[1]))||c.test(f))return y(this);u="IRI"}else this._n3Mode&&r.length>1&&"="===r[1]&&(u="inverse",d=2,f=">");break;case"_":((p=this._blank.exec(r))||e&&(p=this._blank.exec(r+" ")))&&(u="blank",l="_",f=p[1]);break;case\'"\':if(p=this._simpleQuotedString.exec(r))f=p[1];else if(({value:f,matchLength:d}=this._parseLiteral(r)),null===f)return y(this);null===p&&0===d||(u="literal",this._literalClosingPos=0);break;case"\'":if(!this._lineMode){if(p=this._simpleApostropheString.exec(r))f=p[1];else if(({value:f,matchLength:d}=this._parseLiteral(r)),null===f)return y(this);null===p&&0===d||(u="literal",this._literalClosingPos=0)}break;case"?":this._n3Mode&&(p=this._variable.exec(r))&&(u="var",f=p[0]);break;case"@":"literal"===this._previousMarker&&(p=this._langcode.exec(r))?(u="langcode",f=p[1]):(p=this._keyword.exec(r))&&(u=p[0]);break;case".":if(1===r.length?e:r[1]<"0"||r[1]>"9"){u=".",d=1;break}case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":case"+":case"-":(p=this._number.exec(r)||e&&(p=this._number.exec(r+" ")))&&(u="literal",f=p[0],l=p[1]?o.double:/^[+\\-]?\\d+$/.test(p[0])?o.integer:o.decimal);break;case"B":case"b":case"p":case"P":case"G":case"g":(p=this._sparqlKeyword.exec(r))?u=p[0].toUpperCase():v=!0;break;case"f":case"t":(p=this._boolean.exec(r))?(u="literal",f=p[0],l=o.boolean):v=!0;break;case"a":(p=this._shortPredicates.exec(r))?(u="abbreviation",f="a"):v=!0;break;case"=":this._n3Mode&&r.length>1&&(u="abbreviation",">"!==r[1]?(d=1,f="="):(d=2,f=">"));break;case"!":if(!this._n3Mode)break;case",":case";":case"[":case"]":case"(":case")":case"{":case"}":this._lineMode||(d=1,u=h);break;default:v=!0}if(v&&("@prefix"!==this._previousMarker&&"PREFIX"!==this._previousMarker||!(p=this._prefix.exec(r))?((p=this._prefixed.exec(r))||e&&(p=this._prefixed.exec(r+" ")))&&(u="prefixed",l=p[1]||"",f=this._unescape(p[2])):(u="prefix",f=p[1]||"")),"^^"===this._previousMarker)switch(u){case"prefixed":u="type";break;case"IRI":u="typeIRI";break;default:u=""}if(!u)return e||!/^\'\'\'|^"""/.test(r)&&/\\n|\\r/.test(r)?y(this):this._input=r;var g={line:s,type:u,value:f,prefix:l};t(null,g),this.previousToken=g,this._previousMarker=u,r=r.substr(d||p[0].length,r.length)}function y(e){t(e._syntaxError(/^\\S*/.exec(r)[0]))}}_unescape(t){try{return t.replace(s,(function(t,e,r,n){var i;if(e){if(i=parseInt(e,16),isNaN(i))throw new Error;return a(i)}if(r){if(i=parseInt(r,16),isNaN(i))throw new Error;return i<=65535?a(i):a(55296+(i-=65536)/1024,56320+(1023&i))}var o=u[n];if(!o)throw new Error;return o}))}catch(t){return null}}_parseLiteral(t){if(t.length>=3){const e=t.match(/^(?:"""|"|\'\'\'|\'|)/)[0],r=e.length;let n=Math.max(this._literalClosingPos,r);for(;(n=t.indexOf(e,n))>0;){let e=0;for(;"\\\\"===t[n-e-1];)e++;if(e%2==0){const e=t.substring(r,n),i=e.split(/\\r\\n|\\r|\\n/).length-1,o=n+r;if(1===r&&0!==i||3===r&&this._lineMode)break;return this._line+=i,{value:this._unescape(e),matchLength:o}}n++}this._literalClosingPos=t.length-r+1}return{value:"",matchLength:0}}_syntaxError(t){this._input=null;var e=new Error(\'Unexpected "\'+t+\'" on line \'+this._line+".");return e.context={token:void 0,line:this._line,previousToken:this.previousToken},e}tokenize(e,r){var i=this;if(this._line=1,"string"==typeof e){if(this._input=e,"function"!=typeof r){var o,a=[];if(this._tokenizeToEnd((function(t,e){t?o=t:a.push(e)}),!0),o)throw o;return a}t((function(){i._tokenizeToEnd(r,!0)}))}else this._input="",this._pendingBuffer=null,"function"==typeof e.setEncoding&&e.setEncoding("utf8"),e.on("data",(function(t){null!==i._input&&0!==t.length&&(i._pendingBuffer&&(t=n.concat([i._pendingBuffer,t]),i._pendingBuffer=null),128&t[t.length-1]?i._pendingBuffer=t:(i._input+=t,i._tokenizeToEnd(r,!1)))})),e.on("end",(function(){null!==i._input&&i._tokenizeToEnd(r,!0)})),e.on("error",r)}}}).call(this,r(136).setImmediate,r(92).Buffer)},function(t,e,r){t.exports=i;var n=r(93).EventEmitter;function i(){n.call(this)}r(29)(i,n),i.Readable=r(94),i.Writable=r(197),i.Duplex=r(198),i.Transform=r(199),i.PassThrough=r(200),i.Stream=i,i.prototype.pipe=function(t,e){var r=this;function i(e){t.writable&&!1===t.write(e)&&r.pause&&r.pause()}function o(){r.readable&&r.resume&&r.resume()}r.on("data",i),t.on("drain",o),t._isStdio||e&&!1===e.end||(r.on("end",s),r.on("close",u));var a=!1;function s(){a||(a=!0,t.end())}function u(){a||(a=!0,"function"==typeof t.destroy&&t.destroy())}function c(t){if(f(),0===n.listenerCount(this,"error"))throw t}function f(){r.removeListener("data",i),t.removeListener("drain",o),r.removeListener("end",s),r.removeListener("close",u),r.removeListener("error",c),t.removeListener("error",c),r.removeListener("end",f),r.removeListener("close",f),t.removeListener("close",f)}return r.on("error",c),t.on("error",c),r.on("end",f),r.on("close",f),t.on("close",f),t.emit("pipe",r),t}},function(t,e,r){var n=r(4),i=r(63),o=n.WeakMap;t.exports="function"==typeof o&&/native code/.test(i(o))},function(t,e,r){var n=r(12),i=r(46).f,o={}.toString,a="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];t.exports.f=function(t){return a&&"[object Window]"==o.call(t)?function(t){try{return i(t)}catch(t){return a.slice()}}(t):i(n(t))}},function(t,e,r){"use strict";var n=r(2),i=r(7),o=r(4),a=r(13),s=r(10),u=r(11).f,c=r(101),f=o.Symbol;if(i&&"function"==typeof f&&(!("description"in f.prototype)||void 0!==f().description)){var l={},h=function(){var t=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof h?new f(t):void 0===t?f():f(t);return""===t&&(l[e]=!0),e};c(h,f);var p=h.prototype=f.prototype;p.constructor=h;var d=p.toString,v="Symbol(test)"==String(f("test")),g=/^Symbol\\((.*)\\)[^)]+$/;u(p,"description",{configurable:!0,get:function(){var t=s(this)?this.valueOf():this,e=d.call(t);if(a(l,t))return"";var r=v?e.slice(7,-1):e.replace(g,"$1");return""===r?void 0:r}}),n({global:!0,forced:!0},{Symbol:h})}},function(t,e,r){r(111)("iterator")},function(t,e,r){"use strict";var n=r(115).IteratorPrototype,i=r(70),o=r(31),a=r(49),s=r(34),u=function(){return this};t.exports=function(t,e,r){var c=e+" Iterator";return t.prototype=i(n,{next:o(1,r)}),a(t,c,!1,!0),s[c]=u,t}},function(t,e,r){var n=r(5);t.exports=!n((function(){function t(){}return t.prototype.constructor=null,Object.getPrototypeOf(new t)!==t.prototype}))},function(t,e,r){var n=r(10);t.exports=function(t){if(!n(t)&&null!==t)throw TypeError("Can\'t set "+String(t)+" as a prototype");return t}},function(t,e,r){"use strict";var n=r(72),i=r(118);t.exports=n?{}.toString:function(){return"[object "+i(this)+"]"}},function(t,e){t.exports=function(t){if(void 0===t)throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called");return t}},function(t,e,r){var n=r(16);t.exports=function(t,e){for(;!Object.prototype.hasOwnProperty.call(t,e)&&null!==(t=n(t)););return t}},function(t,e,r){var n=r(2),i=r(7);n({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperties:r(108)})},function(t,e,r){var n=r(2),i=r(7);n({target:"Object",stat:!0,forced:!i,sham:!i},{defineProperty:r(11).f})},function(t,e,r){var n=r(2),i=r(160).entries;n({target:"Object",stat:!0},{entries:function(t){return i(t)}})},function(t,e,r){var n=r(7),i=r(48),o=r(12),a=r(59).f,s=function(t){return function(e){for(var r,s=o(e),u=i(s),c=u.length,f=0,l=[];c>f;)r=u[f++],n&&!a.call(s,r)||l.push(t?[r,s[r]]:s[r]);return l}};t.exports={entries:s(!0),values:s(!1)}},function(t,e,r){var n=r(2),i=r(5),o=r(12),a=r(22).f,s=r(7),u=i((function(){a(1)}));n({target:"Object",stat:!0,forced:!s||u,sham:!s},{getOwnPropertyDescriptor:function(t,e){return a(o(t),e)}})},function(t,e,r){var n=r(2),i=r(7),o=r(102),a=r(12),s=r(22),u=r(82);n({target:"Object",stat:!0,sham:!i},{getOwnPropertyDescriptors:function(t){for(var e,r,n=a(t),i=s.f,c=o(n),f={},l=0;c.length>l;)void 0!==(r=i(n,e=c[l++]))&&u(f,e,r);return f}})},function(t,e,r){var n=r(7),i=r(4),o=r(68),a=r(164),s=r(11).f,u=r(46).f,c=r(88),f=r(73),l=r(119),h=r(17),p=r(5),d=r(24).set,v=r(125),g=r(3)("match"),y=i.RegExp,b=y.prototype,_=/a/g,m=/a/g,w=new y(_)!==_,x=l.UNSUPPORTED_Y;if(n&&o("RegExp",!w||x||p((function(){return m[g]=!1,y(_)!=_||y(m)==m||"/a/i"!=y(_,"i")})))){for(var k=function(t,e){var r,n=this instanceof k,i=c(t),o=void 0===e;if(!n&&i&&t.constructor===k&&o)return t;w?i&&!o&&(t=t.source):t instanceof k&&(o&&(e=f.call(t)),t=t.source),x&&(r=!!e&&e.indexOf("y")>-1)&&(e=e.replace(/y/g,""));var s=a(w?new y(t,e):y(t,e),n?this:b,k);return x&&r&&d(s,{sticky:r}),s},E=function(t){t in k||s(k,t,{configurable:!0,get:function(){return y[t]},set:function(e){y[t]=e}})},S=u(y),j=0;S.length>j;)E(S[j++]);b.constructor=k,k.prototype=b,h(i,"RegExp",k)}v("RegExp")},function(t,e,r){var n=r(10),i=r(117);t.exports=function(t,e,r){var o,a;return i&&"function"==typeof(o=e.constructor)&&o!==r&&n(a=o.prototype)&&a!==r.prototype&&i(t,a),t}},function(t,e,r){"use strict";var n=r(17),i=r(8),o=r(5),a=r(73),s=RegExp.prototype,u=s.toString,c=o((function(){return"/a/b"!=u.call({source:"a",flags:"b"})})),f="toString"!=u.name;(c||f)&&n(RegExp.prototype,"toString",(function(){var t=i(this),e=String(t.source),r=t.flags;return"/"+e+"/"+String(void 0===r&&t instanceof RegExp&&!("flags"in s)?a.call(t):r)}),{unsafe:!0})},function(t,e){t.exports=function(t){if(Array.isArray(t))return t}},function(t,e){t.exports=function(t,e){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t)){var r=[],n=!0,i=!1,o=void 0;try{for(var a,s=t[Symbol.iterator]();!(n=(a=s.next()).done)&&(r.push(a.value),!e||r.length!==e);n=!0);}catch(t){i=!0,o=t}finally{try{n||null==s.return||s.return()}finally{if(i)throw o}}return r}}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}},function(t,e){t.exports=function(t){if(Array.isArray(t)){for(var e=0,r=new Array(t.length);e<t.length;e++)r[e]=t[e];return r}}},function(t,e){t.exports=function(t){if(Symbol.iterator in Object(t)||"[object Arguments]"===Object.prototype.toString.call(t))return Array.from(t)}},function(t,e){t.exports=function(){throw new TypeError("Invalid attempt to spread non-iterable instance")}},function(t,e,r){t.exports=function(t){function e(t){let e=0;for(let r=0;r<t.length;r++)e=(e<<5)-e+t.charCodeAt(r),e|=0;return n.colors[Math.abs(e)%n.colors.length]}function n(t){let r;function a(...t){if(!a.enabled)return;const e=a,i=Number(new Date),o=i-(r||i);e.diff=o,e.prev=r,e.curr=i,r=i,t[0]=n.coerce(t[0]),"string"!=typeof t[0]&&t.unshift("%O");let s=0;t[0]=t[0].replace(/%([a-zA-Z%])/g,(r,i)=>{if("%%"===r)return r;s++;const o=n.formatters[i];if("function"==typeof o){const n=t[s];r=o.call(e,n),t.splice(s,1),s--}return r}),n.formatArgs.call(e,t),(e.log||n.log).apply(e,t)}return a.namespace=t,a.enabled=n.enabled(t),a.useColors=n.useColors(),a.color=e(t),a.destroy=i,a.extend=o,"function"==typeof n.init&&n.init(a),n.instances.push(a),a}function i(){const t=n.instances.indexOf(this);return-1!==t&&(n.instances.splice(t,1),!0)}function o(t,e){const r=n(this.namespace+(void 0===e?":":e)+t);return r.log=this.log,r}function a(t){return t.toString().substring(2,t.toString().length-2).replace(/\\.\\*\\?$/,"*")}return n.debug=n,n.default=n,n.coerce=function(t){if(t instanceof Error)return t.stack||t.message;return t},n.disable=function(){const t=[...n.names.map(a),...n.skips.map(a).map(t=>"-"+t)].join(",");return n.enable(""),t},n.enable=function(t){let e;n.save(t),n.names=[],n.skips=[];const r=("string"==typeof t?t:"").split(/[\\s,]+/),i=r.length;for(e=0;e<i;e++)r[e]&&("-"===(t=r[e].replace(/\\*/g,".*?"))[0]?n.skips.push(new RegExp("^"+t.substr(1)+"$")):n.names.push(new RegExp("^"+t+"$")));for(e=0;e<n.instances.length;e++){const t=n.instances[e];t.enabled=n.enabled(t.namespace)}},n.enabled=function(t){if("*"===t[t.length-1])return!0;let e,r;for(e=0,r=n.skips.length;e<r;e++)if(n.skips[e].test(t))return!1;for(e=0,r=n.names.length;e<r;e++)if(n.names[e].test(t))return!0;return!1},n.humanize=r(173),Object.keys(t).forEach(e=>{n[e]=t[e]}),n.instances=[],n.names=[],n.skips=[],n.formatters={},n.selectColor=e,n.enable(n.load()),n}},function(t,e){var r=1e3,n=6e4,i=60*n,o=24*i;function a(t,e,r,n){var i=e>=1.5*r;return Math.round(t/r)+" "+n+(i?"s":"")}t.exports=function(t,e){e=e||{};var s=typeof t;if("string"===s&&t.length>0)return function(t){if((t=String(t)).length>100)return;var e=/^(-?(?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(t);if(!e)return;var a=parseFloat(e[1]);switch((e[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return 315576e5*a;case"weeks":case"week":case"w":return 6048e5*a;case"days":case"day":case"d":return a*o;case"hours":case"hour":case"hrs":case"hr":case"h":return a*i;case"minutes":case"minute":case"mins":case"min":case"m":return a*n;case"seconds":case"second":case"secs":case"sec":case"s":return a*r;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return a;default:return}}(t);if("number"===s&&isFinite(t))return e.long?function(t){var e=Math.abs(t);if(e>=o)return a(t,e,o,"day");if(e>=i)return a(t,e,i,"hour");if(e>=n)return a(t,e,n,"minute");if(e>=r)return a(t,e,r,"second");return t+" ms"}(t):function(t){var e=Math.abs(t);if(e>=o)return Math.round(t/o)+"d";if(e>=i)return Math.round(t/i)+"h";if(e>=n)return Math.round(t/n)+"m";if(e>=r)return Math.round(t/r)+"s";return t+"ms"}(t);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(t))}},function(t,e,r){"use strict";var n=r(2),i=r(33).every;n({target:"Array",proto:!0,forced:r(36)("every")},{every:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";var n=r(12),i=r(32),o=r(15),a=r(36),s=Math.min,u=[].lastIndexOf,c=!!u&&1/[1].lastIndexOf(1,-0)<0,f=a("lastIndexOf");t.exports=c||f?function(t){if(c)return u.apply(this,arguments)||0;var e=n(this),r=o(e.length),a=r-1;for(arguments.length>1&&(a=s(a,i(arguments[1]))),a<0&&(a=r+a);a>=0;a--)if(a in e&&e[a]===t)return a||0;return-1}:u},function(t,e,r){"use strict";var n=r(76),i=r(88),o=r(8),a=r(20),s=r(132),u=r(77),c=r(15),f=r(78),l=r(53),h=r(5),p=[].push,d=Math.min,v=!h((function(){return!RegExp(4294967295,"y")}));n("split",2,(function(t,e,r){var n;return n="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(t,r){var n=String(a(this)),o=void 0===r?4294967295:r>>>0;if(0===o)return[];if(void 0===t)return[n];if(!i(t))return e.call(n,t,o);for(var s,u,c,f=[],h=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),d=0,v=new RegExp(t.source,h+"g");(s=l.call(v,n))&&!((u=v.lastIndex)>d&&(f.push(n.slice(d,s.index)),s.length>1&&s.index<n.length&&p.apply(f,s.slice(1)),c=s[0].length,d=u,f.length>=o));)v.lastIndex===s.index&&v.lastIndex++;return d===n.length?!c&&v.test("")||f.push(""):f.push(n.slice(d)),f.length>o?f.slice(0,o):f}:"0".split(void 0,0).length?function(t,r){return void 0===t&&0===r?[]:e.call(this,t,r)}:e,[function(e,r){var i=a(this),o=null==e?void 0:e[t];return void 0!==o?o.call(e,i,r):n.call(String(i),e,r)},function(t,i){var a=r(n,t,this,i,n!==e);if(a.done)return a.value;var l=o(t),h=String(this),p=s(l,RegExp),g=l.unicode,y=(l.ignoreCase?"i":"")+(l.multiline?"m":"")+(l.unicode?"u":"")+(v?"y":"g"),b=new p(v?l:"^(?:"+l.source+")",y),_=void 0===i?4294967295:i>>>0;if(0===_)return[];if(0===h.length)return null===f(b,h)?[h]:[];for(var m=0,w=0,x=[];w<h.length;){b.lastIndex=v?w:0;var k,E=f(b,v?h:h.slice(w));if(null===E||(k=d(c(b.lastIndex+(v?0:w)),h.length))===m)w=u(h,w,g);else{if(x.push(h.slice(m,w)),x.length===_)return x;for(var S=1;S<=E.length-1;S++)if(x.push(E[S]),x.length===_)return x;w=m=k}}return x.push(h.slice(m)),x}]}),!v)},function(t,e,r){var n=r(4);t.exports=n.Promise},function(t,e,r){var n=r(17);t.exports=function(t,e,r){for(var i in e)n(t,i,e[i],r);return t}},function(t,e){t.exports=function(t,e,r){if(!(t instanceof e))throw TypeError("Incorrect "+(r?r+" ":"")+"invocation");return t}},function(t,e,r){var n=r(8),i=r(181),o=r(15),a=r(71),s=r(182),u=r(183),c=function(t,e){this.stopped=t,this.result=e};(t.exports=function(t,e,r,f,l){var h,p,d,v,g,y,b,_=a(e,r,f?2:1);if(l)h=t;else{if("function"!=typeof(p=s(t)))throw TypeError("Target is not iterable");if(i(p)){for(d=0,v=o(t.length);v>d;d++)if((g=f?_(n(b=t[d])[0],b[1]):_(t[d]))&&g instanceof c)return g;return new c(!1)}h=p.call(t)}for(y=h.next;!(b=y.call(h)).done;)if("object"==typeof(g=u(h,_,b.value,f))&&g&&g instanceof c)return g;return new c(!1)}).stop=function(t){return new c(!0,t)}},function(t,e,r){var n=r(3),i=r(34),o=n("iterator"),a=Array.prototype;t.exports=function(t){return void 0!==t&&(i.Array===t||a[o]===t)}},function(t,e,r){var n=r(118),i=r(34),o=r(3)("iterator");t.exports=function(t){if(null!=t)return t[o]||t["@@iterator"]||i[n(t)]}},function(t,e,r){var n=r(8);t.exports=function(t,e,r,i){try{return i?e(n(r)[0],r[1]):e(r)}catch(e){var o=t.return;throw void 0!==o&&n(o.call(t)),e}}},function(t,e,r){var n=r(3)("iterator"),i=!1;try{var o=0,a={next:function(){return{done:!!o++}},return:function(){i=!0}};a[n]=function(){return this},Array.from(a,(function(){throw 2}))}catch(t){}t.exports=function(t,e){if(!e&&!i)return!1;var r=!1;try{var o={};o[n]=function(){return{next:function(){return{done:r=!0}}}},t(o)}catch(t){}return r}},function(t,e,r){var n,i,o,a,s,u,c,f,l=r(4),h=r(22).f,p=r(19),d=r(133).set,v=r(134),g=l.MutationObserver||l.WebKitMutationObserver,y=l.process,b=l.Promise,_="process"==p(y),m=h(l,"queueMicrotask"),w=m&&m.value;w||(n=function(){var t,e;for(_&&(t=y.domain)&&t.exit();i;){e=i.fn,i=i.next;try{e()}catch(t){throw i?a():o=void 0,t}}o=void 0,t&&t.enter()},_?a=function(){y.nextTick(n)}:g&&!v?(s=!0,u=document.createTextNode(""),new g(n).observe(u,{characterData:!0}),a=function(){u.data=s=!s}):b&&b.resolve?(c=b.resolve(void 0),f=c.then,a=function(){f.call(c,n)}):a=function(){d.call(l,n)}),t.exports=w||function(t){var e={fn:t,next:void 0};o&&(o.next=e),i||(i=e,a()),o=e}},function(t,e,r){var n=r(8),i=r(10),o=r(135);t.exports=function(t,e){if(n(t),i(e)&&e.constructor===t)return e;var r=o.f(t);return(0,r.resolve)(e),r.promise}},function(t,e,r){var n=r(4);t.exports=function(t,e){var r=n.console;r&&r.error&&(1===arguments.length?r.error(t):r.error(t,e))}},function(t,e){t.exports=function(t){try{return{error:!1,value:t()}}catch(t){return{error:!0,value:t}}}},function(t,e,r){(function(t,e){!function(t,r){"use strict";if(!t.setImmediate){var n,i,o,a,s,u=1,c={},f=!1,l=t.document,h=Object.getPrototypeOf&&Object.getPrototypeOf(t);h=h&&h.setTimeout?h:t,"[object process]"==={}.toString.call(t.process)?n=function(t){e.nextTick((function(){d(t)}))}:!function(){if(t.postMessage&&!t.importScripts){var e=!0,r=t.onmessage;return t.onmessage=function(){e=!1},t.postMessage("","*"),t.onmessage=r,e}}()?t.MessageChannel?((o=new MessageChannel).port1.onmessage=function(t){d(t.data)},n=function(t){o.port2.postMessage(t)}):l&&"onreadystatechange"in l.createElement("script")?(i=l.documentElement,n=function(t){var e=l.createElement("script");e.onreadystatechange=function(){d(t),e.onreadystatechange=null,i.removeChild(e),e=null},i.appendChild(e)}):n=function(t){setTimeout(d,0,t)}:(a="setImmediate$"+Math.random()+"$",s=function(e){e.source===t&&"string"==typeof e.data&&0===e.data.indexOf(a)&&d(+e.data.slice(a.length))},t.addEventListener?t.addEventListener("message",s,!1):t.attachEvent("onmessage",s),n=function(e){t.postMessage(a+e,"*")}),h.setImmediate=function(t){"function"!=typeof t&&(t=new Function(""+t));for(var e=new Array(arguments.length-1),r=0;r<e.length;r++)e[r]=arguments[r+1];var i={callback:t,args:e};return c[u]=i,n(u),u++},h.clearImmediate=p}function p(t){delete c[t]}function d(t){if(f)setTimeout(d,0,t);else{var e=c[t];if(e){f=!0;try{!function(t){var e=t.callback,r=t.args;switch(r.length){case 0:e();break;case 1:e(r[0]);break;case 2:e(r[0],r[1]);break;case 3:e(r[0],r[1],r[2]);break;default:e.apply(void 0,r)}}(e)}finally{p(t),f=!1}}}}}("undefined"==typeof self?void 0===t?this:t:self)}).call(this,r(21),r(38))},function(t,e,r){"use strict";e.byteLength=function(t){var e=c(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,n=c(t),a=n[0],s=n[1],u=new o(function(t,e,r){return 3*(e+r)/4-r}(0,a,s)),f=0,l=s>0?a-4:a;for(r=0;r<l;r+=4)e=i[t.charCodeAt(r)]<<18|i[t.charCodeAt(r+1)]<<12|i[t.charCodeAt(r+2)]<<6|i[t.charCodeAt(r+3)],u[f++]=e>>16&255,u[f++]=e>>8&255,u[f++]=255&e;2===s&&(e=i[t.charCodeAt(r)]<<2|i[t.charCodeAt(r+1)]>>4,u[f++]=255&e);1===s&&(e=i[t.charCodeAt(r)]<<10|i[t.charCodeAt(r+1)]<<4|i[t.charCodeAt(r+2)]>>2,u[f++]=e>>8&255,u[f++]=255&e);return u},e.fromByteArray=function(t){for(var e,r=t.length,i=r%3,o=[],a=0,s=r-i;a<s;a+=16383)o.push(f(t,a,a+16383>s?s:a+16383));1===i?(e=t[r-1],o.push(n[e>>2]+n[e<<4&63]+"==")):2===i&&(e=(t[r-2]<<8)+t[r-1],o.push(n[e>>10]+n[e>>4&63]+n[e<<2&63]+"="));return o.join("")};for(var n=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,a="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",s=0,u=a.length;s<u;++s)n[s]=a[s],i[a.charCodeAt(s)]=s;function c(t){var e=t.length;if(e%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=t.indexOf("=");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function f(t,e,r){for(var i,o,a=[],s=e;s<r;s+=3)i=(t[s]<<16&16711680)+(t[s+1]<<8&65280)+(255&t[s+2]),a.push(n[(o=i)>>18&63]+n[o>>12&63]+n[o>>6&63]+n[63&o]);return a.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(t,e){e.read=function(t,e,r,n,i){var o,a,s=8*i-n-1,u=(1<<s)-1,c=u>>1,f=-7,l=r?i-1:0,h=r?-1:1,p=t[e+l];for(l+=h,o=p&(1<<-f)-1,p>>=-f,f+=s;f>0;o=256*o+t[e+l],l+=h,f-=8);for(a=o&(1<<-f)-1,o>>=-f,f+=n;f>0;a=256*a+t[e+l],l+=h,f-=8);if(0===o)o=1-c;else{if(o===u)return a?NaN:1/0*(p?-1:1);a+=Math.pow(2,n),o-=c}return(p?-1:1)*a*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var a,s,u,c=8*o-i-1,f=(1<<c)-1,l=f>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,v=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(s=isNaN(e)?1:0,a=f):(a=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-a))<1&&(a--,u*=2),(e+=a+l>=1?h/u:h*Math.pow(2,1-l))*u>=2&&(a++,u/=2),a+l>=f?(s=0,a=f):a+l>=1?(s=(e*u-1)*Math.pow(2,i),a+=l):(s=e*Math.pow(2,l-1)*Math.pow(2,i),a=0));i>=8;t[r+p]=255&s,p+=d,s/=256,i-=8);for(a=a<<i|s,c+=i;c>0;t[r+p]=255&a,p+=d,a/=256,c-=8);t[r+p-d]|=128*v}},function(t,e){},function(t,e,r){"use strict";var n=r(56).Buffer,i=r(194);t.exports=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this.head=null,this.tail=null,this.length=0}return t.prototype.push=function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length},t.prototype.unshift=function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length},t.prototype.shift=function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}},t.prototype.clear=function(){this.head=this.tail=null,this.length=0},t.prototype.join=function(t){if(0===this.length)return"";for(var e=this.head,r=""+e.data;e=e.next;)r+=t+e.data;return r},t.prototype.concat=function(t){if(0===this.length)return n.alloc(0);if(1===this.length)return this.head.data;for(var e,r,i,o=n.allocUnsafe(t>>>0),a=this.head,s=0;a;)e=a.data,r=o,i=s,e.copy(r,i),s+=a.data.length,a=a.next;return o},t}(),i&&i.inspect&&i.inspect.custom&&(t.exports.prototype[i.inspect.custom]=function(){var t=i.inspect({length:this.length});return this.constructor.name+" "+t})},function(t,e){},function(t,e,r){(function(e){function r(t){try{if(!e.localStorage)return!1}catch(t){return!1}var r=e.localStorage[t];return null!=r&&"true"===String(r).toLowerCase()}t.exports=function(t,e){if(r("noDeprecation"))return t;var n=!1;return function(){if(!n){if(r("throwDeprecation"))throw new Error(e);r("traceDeprecation")?console.trace(e):console.warn(e),n=!0}return t.apply(this,arguments)}}}).call(this,r(21))},function(t,e,r){"use strict";t.exports=o;var n=r(142),i=r(39);function o(t){if(!(this instanceof o))return new o(t);n.call(this,t)}i.inherits=r(29),i.inherits(o,n),o.prototype._transform=function(t,e,r){r(null,t)}},function(t,e,r){t.exports=r(95)},function(t,e,r){t.exports=r(23)},function(t,e,r){t.exports=r(94).Transform},function(t,e,r){t.exports=r(94).PassThrough},function(t,e,r){"use strict";var n=r(2),i=r(60),o=r(12),a=r(36),s=[].join,u=i!=Object,c=a("join",",");n({target:"Array",proto:!0,forced:u||c},{join:function(t){return s.call(o(this),void 0===t?",":t)}})},function(t,e){t.exports=function(t){return-1!==Function.toString.call(t).indexOf("[native code]")}},function(t,e,r){var n=r(80);function i(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(t){return!1}}function o(e,r,a){return i()?t.exports=o=Reflect.construct:t.exports=o=function(t,e,r){var i=[null];i.push.apply(i,e);var o=new(Function.bind.apply(t,i));return r&&n(o,r.prototype),o},o.apply(null,arguments)}t.exports=o},function(t,e,r){"use strict";var n=r(2),i=r(66).indexOf,o=r(36),a=[].indexOf,s=!!a&&1/[1].indexOf(1,-0)<0,u=o("indexOf");n({target:"Array",proto:!0,forced:s||u},{indexOf:function(t){return s?a.apply(this,arguments)||0:i(this,t,arguments.length>1?arguments[1]:void 0)}})},function(t,e,r){"use strict";r.r(e);r(98),r(149),r(150),r(51),r(52),r(35),r(74),r(75),r(79);var n=r(0),i=r.n(n),o=(r(28),r(1)),a=r.n(o),s=r(18),u=r.n(s),c=r(30),f=r.n(c),l=r(40),h=r.n(l),p=r(16),d=r.n(p),v=r(57),g=r.n(v),y=r(41),b=r.n(y),_=(r(81),r(84),r(85),r(86),r(37),r(87),r(157),r(158),r(159),r(161),r(162),r(124),r(163),r(165),r(126),r(129),r(89),r(90),r(42)),m=r.n(_),w=r(9),x=r.n(w),k=r(143),E=r.n(k),S=r(58),j=r.n(S),R=(r(174),r(130),r(131),r(176),function(t){for(;t.endsWith("/");)t=t.slice(0,-1);return t}),C=function(t){for(var e=t.split("/"),r=e[0],n=0,i=1;i<e.length-1;i++){n=i,""===e[i]&&(r+="/");break}return r=r+"/"+e[n+1]+"/"},I=function(t){return(t=R(t)).substring(0,t.lastIndexOf("/")+1)},O=function(t){return(t=R(t)).substr(t.lastIndexOf("/")+1)},T=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return e.every((function(t){return t.endsWith("/")}))},P=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];return e.every((function(t){return!t.endsWith("/")}))},A={CONTAINER:\'<http://www.w3.org/ns/ldp#BasicContainer>; rel="type"\',RESOURCE:\'<http://www.w3.org/ns/ldp#Resource>; rel="type"\'},L=(r(91),r(96)),F=r.n(L),M=r(6);const{rdf:N,xsd:B}=M.a;var D,U,q=0;class G{constructor(t){this.id=t}get value(){return this.id}equals(t){return t instanceof G?this.id===t.id:!!t&&this.termType===t.termType&&this.value===t.value}toJSON(){return{termType:this.termType,value:this.value}}}class W extends G{get termType(){return"NamedNode"}}class z extends G{get termType(){return"Literal"}get value(){return this.id.substring(1,this.id.lastIndexOf(\'"\'))}get language(){var t=this.id,e=t.lastIndexOf(\'"\')+1;return e<t.length&&"@"===t[e++]?t.substr(e).toLowerCase():""}get datatype(){return new W(this.datatypeString)}get datatypeString(){var t,e=this.id,r=e.lastIndexOf(\'"\')+1;return r<e.length&&"^"===(t=e[r])?e.substr(r+2):"@"!==t?B.string:N.langString}equals(t){return t instanceof z?this.id===t.id:!!t&&!!t.datatype&&this.termType===t.termType&&this.value===t.value&&this.language===t.language&&this.datatype.value===t.datatype.value}toJSON(){return{termType:this.termType,value:this.value,language:this.language,datatype:{termType:"NamedNode",value:this.datatypeString}}}}class Y extends G{constructor(t){super("_:"+t)}get termType(){return"BlankNode"}get value(){return this.id.substr(2)}}class Q extends G{constructor(t){super("?"+t)}get termType(){return"Variable"}get value(){return this.id.substr(1)}}class $ extends G{constructor(){return super(""),U||this}get termType(){return"DefaultGraph"}equals(t){return this===t||!!t&&this.termType===t.termType}}U=new $;class H{constructor(t,e,r,n){this.subject=t,this.predicate=e,this.object=r,this.graph=n||U}toJSON(){return{subject:this.subject.toJSON(),predicate:this.predicate.toJSON(),object:this.object.toJSON(),graph:this.graph.toJSON()}}equals(t){return!!t&&this.subject.equals(t.subject)&&this.predicate.equals(t.predicate)&&this.object.equals(t.object)&&this.graph.equals(t.graph)}}var K=D={namedNode:function(t){return new W(t)},blankNode:function(t){t||(t="n3-"+q++);return new Y(t)},variable:function(t){return new Q(t)},literal:function(t,e){if("string"==typeof e)return new z(\'"\'+t+\'"@\'+e.toLowerCase());let r=e?e.value:"";""===r&&("boolean"==typeof t?r=B.boolean:"number"==typeof t&&(Number.isFinite(t)?r=Number.isInteger(t)?B.integer:B.double:(r=B.double,Number.isNaN(t)||(t=t>0?"INF":"-INF"))));return""===r||r===B.string?new z(\'"\'+t+\'"\'):new z(\'"\'+t+\'"^^\'+r)},defaultGraph:function(){return U},quad:V,triple:V,internal:{Term:G,NamedNode:W,BlankNode:Y,Variable:Q,Literal:z,DefaultGraph:$,Quad:H,Triple:H,fromId:function(t,e){if(e=e||D,!t)return e.defaultGraph();switch(t[0]){case"_":return e.blankNode(t.substr(2));case"?":return e.variable(t.substr(1));case\'"\':if(e===D)return new z(t);if(\'"\'===t[t.length-1])return e.literal(t.substr(1,t.length-2));var r=t.lastIndexOf(\'"\',t.length-1);return e.literal(t.substr(1,r-1),"@"===t[r+1]?t.substr(r+2):e.namedNode(t.substr(r+3)));default:return e.namedNode(t)}},toId:function(t){if("string"==typeof t)return t;if(t instanceof G)return t.id;if(!t)return U.id;switch(t.termType){case"NamedNode":return t.value;case"BlankNode":return"_:"+t.value;case"Variable":return"?"+t.value;case"DefaultGraph":return"";case"Literal":return\'"\'+t.value+\'"\'+(t.language?"@"+t.language:t.datatype&&t.datatype.value!==B.string?"^^"+t.datatype.value:"");default:throw new Error("Unexpected termType: "+t.termType)}}}};function V(t,e,r,n){return new H(t,e,r,n)}var Z=r(145),J=0,X=0;class tt{constructor(t){this._contextStack=[],this._graph=null,t=t||{},this._setBase(t.baseIRI),t.factory&&rt(this,t.factory);var e="string"==typeof t.format?t.format.match(/\\w*$/)[0].toLowerCase():"",r="turtle"===e,n="trig"===e,i=/triple/.test(e),o=/quad/.test(e),a=this._n3Mode=/n3/.test(e),s=i||o;(this._supportsNamedGraphs=!(r||a))||(this._readPredicateOrNamedGraph=this._readPredicate),this._supportsQuads=!(r||n||i||a),s&&(this._resolveRelativeIRI=function(t){return null}),this._blankNodePrefix="string"!=typeof t.blankNodePrefix?"":t.blankNodePrefix.replace(/^(?!_:)/,"_:"),this._lexer=t.lexer||new Z.a({lineMode:s,n3:a}),this._explicitQuantifiers=!!t.explicitQuantifiers}static _resetBlankNodeIds(){J=X=0}_blank(){return this._blankNode("b"+X++)}_setBase(t){if(t){var e=t.indexOf("#");e>=0&&(t=t.substr(0,e)),this._base=t,this._basePath=t.indexOf("/")<0?t:t.replace(/[^\\/?]*(?:\\?.*)?$/,""),t=t.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i),this._baseRoot=t[0],this._baseScheme=t[1]}else this._base="",this._basePath=""}_saveContext(t,e,r,n,i){var o=this._n3Mode;this._contextStack.push({subject:r,predicate:n,object:i,graph:e,type:t,inverse:!!o&&this._inversePredicate,blankPrefix:o?this._prefixes._:"",quantified:o?this._quantified:null}),o&&(this._inversePredicate=!1,this._prefixes._=this._graph?this._graph.id.substr(2)+".":".",this._quantified=Object.create(this._quantified))}_restoreContext(){var t=this._contextStack.pop(),e=this._n3Mode;this._subject=t.subject,this._predicate=t.predicate,this._object=t.object,this._graph=t.graph,e&&(this._inversePredicate=t.inverse,this._prefixes._=t.blankPrefix,this._quantified=t.quantified)}_readInTopContext(t){switch(t.type){case"eof":return null!==this._graph?this._error("Unclosed graph",t):(delete this._prefixes._,this._callback(null,null,this._prefixes));case"PREFIX":this._sparqlStyle=!0;case"@prefix":return this._readPrefix;case"BASE":this._sparqlStyle=!0;case"@base":return this._readBaseIRI;case"{":if(this._supportsNamedGraphs)return this._graph="",this._subject=null,this._readSubject;case"GRAPH":if(this._supportsNamedGraphs)return this._readNamedGraphLabel;default:return this._readSubject(t)}}_readEntity(t,e){var r;switch(t.type){case"IRI":case"typeIRI":var n=this._resolveIRI(t.value);if(null===n)return this._error("Invalid IRI",t);r=this._namedNode(n);break;case"type":case"prefixed":var i=this._prefixes[t.prefix];if(void 0===i)return this._error(\'Undefined prefix "\'+t.prefix+\':"\',t);r=this._namedNode(i+t.value);break;case"blank":r=this._blankNode(this._prefixes[t.prefix]+t.value);break;case"var":r=this._variable(t.value.substr(1));break;default:return this._error("Expected entity but got "+t.type,t)}return!e&&this._n3Mode&&r.id in this._quantified&&(r=this._quantified[r.id]),r}_readSubject(t){switch(this._predicate=null,t.type){case"[":return this._saveContext("blank",this._graph,this._subject=this._blank(),null,null),this._readBlankNodeHead;case"(":return this._saveContext("list",this._graph,this.RDF_NIL,null,null),this._subject=null,this._readListItem;case"{":return this._n3Mode?(this._saveContext("formula",this._graph,this._graph=this._blank(),null,null),this._readSubject):this._error("Unexpected graph",t);case"}":return this._readPunctuation(t);case"@forSome":return this._n3Mode?(this._subject=null,this._predicate=this.N3_FORSOME,this._quantifier=this._blankNode,this._readQuantifierList):this._error(\'Unexpected "@forSome"\',t);case"@forAll":return this._n3Mode?(this._subject=null,this._predicate=this.N3_FORALL,this._quantifier=this._variable,this._readQuantifierList):this._error(\'Unexpected "@forAll"\',t);default:if(void 0===(this._subject=this._readEntity(t)))return;if(this._n3Mode)return this._getPathReader(this._readPredicateOrNamedGraph)}return this._readPredicateOrNamedGraph}_readPredicate(t){var e=t.type;switch(e){case"inverse":this._inversePredicate=!0;case"abbreviation":this._predicate=this.ABBREVIATIONS[t.value];break;case".":case"]":case"}":return null===this._predicate?this._error("Unexpected "+e,t):(this._subject=null,"]"===e?this._readBlankNodeTail(t):this._readPunctuation(t));case";":return null!==this._predicate?this._readPredicate:this._error("Expected predicate but got ;",t);case"blank":if(!this._n3Mode)return this._error("Disallowed blank node as predicate",t);default:if(void 0===(this._predicate=this._readEntity(t)))return}return this._readObject}_readObject(t){switch(t.type){case"literal":if(0===t.prefix.length)return this._literalValue=t.value,this._readDataTypeOrLang;this._object=this._literal(t.value,this._namedNode(t.prefix));break;case"[":return this._saveContext("blank",this._graph,this._subject,this._predicate,this._subject=this._blank()),this._readBlankNodeHead;case"(":return this._saveContext("list",this._graph,this._subject,this._predicate,this.RDF_NIL),this._subject=null,this._readListItem;case"{":return this._n3Mode?(this._saveContext("formula",this._graph,this._subject,this._predicate,this._graph=this._blank()),this._readSubject):this._error("Unexpected graph",t);default:if(void 0===(this._object=this._readEntity(t)))return;if(this._n3Mode)return this._getPathReader(this._getContextEndReader())}return this._getContextEndReader()}_readPredicateOrNamedGraph(t){return"{"===t.type?this._readGraph(t):this._readPredicate(t)}_readGraph(t){return"{"!==t.type?this._error("Expected graph but got "+t.type,t):(this._graph=this._subject,this._subject=null,this._readSubject)}_readBlankNodeHead(t){return"]"===t.type?(this._subject=null,this._readBlankNodeTail(t)):(this._predicate=null,this._readPredicate(t))}_readBlankNodeTail(t){if("]"!==t.type)return this._readBlankNodePunctuation(t);null!==this._subject&&this._emit(this._subject,this._predicate,this._object,this._graph);var e=null===this._predicate;return this._restoreContext(),null===this._object?e?this._readPredicateOrNamedGraph:this._readPredicateAfterBlank:this._getContextEndReader()}_readPredicateAfterBlank(t){switch(t.type){case".":case"}":return this._subject=null,this._readPunctuation(t);default:return this._readPredicate(t)}}_readListItem(t){var e=null,r=null,n=this._subject,i=this._contextStack,o=i[i.length-1],a=this._readListItem;switch(t.type){case"[":this._saveContext("blank",this._graph,r=this._blank(),this.RDF_FIRST,this._subject=e=this._blank()),a=this._readBlankNodeHead;break;case"(":this._saveContext("list",this._graph,r=this._blank(),this.RDF_FIRST,this.RDF_NIL),this._subject=null;break;case")":if(this._restoreContext(),0!==i.length&&"list"===i[i.length-1].type&&this._emit(this._subject,this._predicate,this._object,this._graph),null===this._predicate){if(a=this._readPredicate,this._subject===this.RDF_NIL)return a}else if(a=this._getContextEndReader(),this._object===this.RDF_NIL)return a;r=this.RDF_NIL;break;case"literal":0===t.prefix.length?(this._literalValue=t.value,a=this._readListItemDataTypeOrLang):(e=this._literal(t.value,this._namedNode(t.prefix)),a=this._getContextEndReader());break;default:if(void 0===(e=this._readEntity(t)))return}if(null===r&&(this._subject=r=this._blank()),null===n?null===o.predicate?o.subject=r:o.object=r:this._emit(n,this.RDF_REST,r,this._graph),null!==e){if(this._n3Mode&&("IRI"===t.type||"prefixed"===t.type))return this._saveContext("item",this._graph,r,this.RDF_FIRST,e),this._subject=e,this._predicate=null,this._getPathReader(this._readListItem);this._emit(r,this.RDF_FIRST,e,this._graph)}return a}_readDataTypeOrLang(t){return this._completeLiteral(t,!1)}_readListItemDataTypeOrLang(t){return this._completeLiteral(t,!0)}_completeLiteral(t,e){switch(t.type){case"type":case"typeIRI":var r=this._readEntity(t);if(void 0===r)return;this._object=this._literal(this._literalValue,r),t=null;break;case"langcode":this._object=this._literal(this._literalValue,t.value),t=null;break;default:this._object=this._literal(this._literalValue)}return e&&this._emit(this._subject,this.RDF_FIRST,this._object,this._graph),null===t?this._getContextEndReader():(this._readCallback=this._getContextEndReader(),this._readCallback(t))}_readFormulaTail(t){return"}"!==t.type?this._readPunctuation(t):(null!==this._subject&&this._emit(this._subject,this._predicate,this._object,this._graph),this._restoreContext(),null===this._object?this._readPredicate:this._getContextEndReader())}_readPunctuation(t){var e,r=this._subject,n=this._graph,i=this._inversePredicate;switch(t.type){case"}":if(null===this._graph)return this._error("Unexpected graph closing",t);if(this._n3Mode)return this._readFormulaTail(t);this._graph=null;case".":this._subject=null,e=this._contextStack.length?this._readSubject:this._readInTopContext,i&&(this._inversePredicate=!1);break;case";":e=this._readPredicate;break;case",":e=this._readObject;break;default:if(this._supportsQuads&&null===this._graph&&void 0!==(n=this._readEntity(t))){e=this._readQuadPunctuation;break}return this._error(\'Expected punctuation to follow "\'+this._object.id+\'"\',t)}if(null!==r){var o=this._predicate,a=this._object;i?this._emit(a,o,r,n):this._emit(r,o,a,n)}return e}_readBlankNodePunctuation(t){var e;switch(t.type){case";":e=this._readPredicate;break;case",":e=this._readObject;break;default:return this._error(\'Expected punctuation to follow "\'+this._object.id+\'"\',t)}return this._emit(this._subject,this._predicate,this._object,this._graph),e}_readQuadPunctuation(t){return"."!==t.type?this._error("Expected dot to follow quad",t):this._readInTopContext}_readPrefix(t){return"prefix"!==t.type?this._error("Expected prefix to follow @prefix",t):(this._prefix=t.value,this._readPrefixIRI)}_readPrefixIRI(t){if("IRI"!==t.type)return this._error(\'Expected IRI to follow prefix "\'+this._prefix+\':"\',t);var e=this._readEntity(t);return this._prefixes[this._prefix]=e.value,this._prefixCallback(this._prefix,e),this._readDeclarationPunctuation}_readBaseIRI(t){var e="IRI"===t.type&&this._resolveIRI(t.value);return e?(this._setBase(e),this._readDeclarationPunctuation):this._error("Expected valid IRI to follow base declaration",t)}_readNamedGraphLabel(t){switch(t.type){case"IRI":case"blank":case"prefixed":return this._readSubject(t),this._readGraph;case"[":return this._readNamedGraphBlankLabel;default:return this._error("Invalid graph label",t)}}_readNamedGraphBlankLabel(t){return"]"!==t.type?this._error("Invalid graph label",t):(this._subject=this._blank(),this._readGraph)}_readDeclarationPunctuation(t){return this._sparqlStyle?(this._sparqlStyle=!1,this._readInTopContext(t)):"."!==t.type?this._error("Expected declaration to end with a dot",t):this._readInTopContext}_readQuantifierList(t){var e;switch(t.type){case"IRI":case"prefixed":if(void 0!==(e=this._readEntity(t,!0)))break;default:return this._error("Unexpected "+t.type,t)}return this._explicitQuantifiers?(null===this._subject?this._emit(this._graph||this.DEFAULTGRAPH,this._predicate,this._subject=this._blank(),this.QUANTIFIERS_GRAPH):this._emit(this._subject,this.RDF_REST,this._subject=this._blank(),this.QUANTIFIERS_GRAPH),this._emit(this._subject,this.RDF_FIRST,e,this.QUANTIFIERS_GRAPH)):this._quantified[e.id]=this._quantifier("b"+X++),this._readQuantifierPunctuation}_readQuantifierPunctuation(t){return","===t.type?this._readQuantifierList:(this._explicitQuantifiers&&(this._emit(this._subject,this.RDF_REST,this.RDF_NIL,this.QUANTIFIERS_GRAPH),this._subject=null),this._readCallback=this._getContextEndReader(),this._readCallback(t))}_getPathReader(t){return this._afterPath=t,this._readPath}_readPath(t){switch(t.type){case"!":return this._readForwardPath;case"^":return this._readBackwardPath;default:var e=this._contextStack,r=e.length&&e[e.length-1];if(r&&"item"===r.type){var n=this._subject;this._restoreContext(),this._emit(this._subject,this.RDF_FIRST,n,this._graph)}return this._afterPath(t)}}_readForwardPath(t){var e,r,n=this._blank();if(void 0!==(r=this._readEntity(t)))return null===this._predicate?(e=this._subject,this._subject=n):(e=this._object,this._object=n),this._emit(e,r,n,this._graph),this._readPath}_readBackwardPath(t){var e,r,n=this._blank();if(void 0!==(e=this._readEntity(t)))return null===this._predicate?(r=this._subject,this._subject=n):(r=this._object,this._object=n),this._emit(n,e,r,this._graph),this._readPath}_getContextEndReader(){var t=this._contextStack;if(!t.length)return this._readPunctuation;switch(t[t.length-1].type){case"blank":return this._readBlankNodeTail;case"list":return this._readListItem;case"formula":return this._readFormulaTail}}_emit(t,e,r,n){this._callback(null,this._quad(t,e,r,n||this.DEFAULTGRAPH))}_error(t,e){var r=new Error(t+" on line "+e.line+".");r.context={token:e,line:e.line,previousToken:this._lexer.previousToken},this._callback(r),this._callback=et}_resolveIRI(t){return/^[a-z][a-z0-9+.-]*:/i.test(t)?t:this._resolveRelativeIRI(t)}_resolveRelativeIRI(t){if(!t.length)return this._base;switch(t[0]){case"#":return this._base+t;case"?":return this._base.replace(/(?:\\?.*)?$/,t);case"/":return("/"===t[1]?this._baseScheme:this._baseRoot)+this._removeDotSegments(t);default:return/^[^/:]*:/.test(t)?null:this._removeDotSegments(this._basePath+t)}}_removeDotSegments(t){if(!/(^|\\/)\\.\\.?($|[/#?])/.test(t))return t;for(var e="",r=t.length,n=-1,i=-1,o=0,a="/";n<r;){switch(a){case":":if(i<0&&"/"===t[++n]&&"/"===t[++n])for(;(i=n+1)<r&&"/"!==t[i];)n=i;break;case"?":case"#":n=r;break;case"/":if("."===t[n+1])switch(a=t[1+ ++n]){case"/":e+=t.substring(o,n-1),o=n+1;break;case void 0:case"?":case"#":return e+t.substring(o,n)+t.substr(n+1);case".":if(void 0===(a=t[1+ ++n])||"/"===a||"?"===a||"#"===a){if((o=(e+=t.substring(o,n-2)).lastIndexOf("/"))>=i&&(e=e.substr(0,o)),"/"!==a)return e+"/"+t.substr(n+1);o=n+1}}}a=t[++n]}return e+t.substring(o)}parse(t,e,r){var n=this;if(this._readCallback=this._readInTopContext,this._sparqlStyle=!1,this._prefixes=Object.create(null),this._prefixes._=this._blankNodePrefix?this._blankNodePrefix.substr(2):"b"+J+++"_",this._prefixCallback=r||et,this._inversePredicate=!1,this._quantified=Object.create(null),!e){var i,o=[];if(this._callback=function(t,e){t?i=t:e&&o.push(e)},this._lexer.tokenize(t).every((function(t){return n._readCallback=n._readCallback(t)})),i)throw i;return o}this._callback=e,this._lexer.tokenize(t,(function(t,e){null!==t?(n._callback(t),n._callback=et):n._readCallback&&(n._readCallback=n._readCallback(e))}))}}function et(){}function rt(t,e){var r=e.namedNode;t._namedNode=r,t._blankNode=e.blankNode,t._literal=e.literal,t._variable=e.variable,t._quad=e.quad,t.DEFAULTGRAPH=e.defaultGraph(),t.RDF_FIRST=r(M.a.rdf.first),t.RDF_REST=r(M.a.rdf.rest),t.RDF_NIL=r(M.a.rdf.nil),t.N3_FORALL=r(M.a.r.forAll),t.N3_FORSOME=r(M.a.r.forSome),t.ABBREVIATIONS={a:r(M.a.rdf.type),"=":r(M.a.owl.sameAs),">":r(M.a.log.implies)},t.QUANTIFIERS_GRAPH=r("urn:n3:quantifiers")}rt(tt.prototype,K);var nt=r(146);const{toId:it,fromId:ot}=K.internal;class at{constructor(t,e){this._size=0,this._graphs=Object.create(null),this._id=0,this._ids=Object.create(null),this._ids["><"]=0,this._entities=Object.create(null),this._blankNodeIndex=0,e||!t||t[0]||(e=t,t=null),e=e||{},this._factory=e.factory||K,t&&this.addQuads(t)}get size(){var t=this._size;if(null!==t)return t;t=0;var e,r,n=this._graphs;for(var i in n)for(var o in e=n[i].subjects)for(var a in r=e[o])t+=Object.keys(r[a]).length;return this._size=t}_addToIndex(t,e,r,n){var i=t[e]||(t[e]={}),o=i[r]||(i[r]={}),a=n in o;return a||(o[n]=null),!a}_removeFromIndex(t,e,r,n){var i,o=t[e],a=o[r];for(i in delete a[n],a)return;for(i in delete o[r],o)return;delete t[e]}_findInIndex(t,e,r,n,i,o,a,s,u,c){var f,l,h,p=!e+!r+!n>1?Object.keys(this._ids):this._entities;for(var d in e&&((f=t,t={})[e]=f[e]),t){var v=p[d];if(l=t[d])for(var g in r&&((f=l,l={})[r]=f[r]),l){var y=p[g];if(h=l[g])for(var b=(n?n in h?[n]:[]:Object.keys(h)),_=0;_<b.length;_++){var m={subject:null,predicate:null,object:null};m[i]=ot(v,this._factory),m[o]=ot(y,this._factory),m[a]=ot(p[b[_]],this._factory);var w=this._factory.quad(m.subject,m.predicate,m.object,ot(s,this._factory));if(c)c.push(w);else if(u(w))return!0}}}return c}_loop(t,e){for(var r in t)e(r)}_loopByKey0(t,e,r){var n,i;if(n=t[e])for(i in n)r(i)}_loopByKey1(t,e,r){var n;for(n in t)t[n][e]&&r(n)}_loopBy2Keys(t,e,r,n){var i,o,a;if((i=t[e])&&(o=i[r]))for(a in o)n(a)}_countInIndex(t,e,r,n){var i,o,a,s=0;for(var u in e&&((i=t,t={})[e]=i[e]),t)if(o=t[u])for(var c in r&&((i=o,o={})[r]=i[r]),o)(a=o[c])&&(n?n in a&&s++:s+=Object.keys(a).length);return s}_getGraphs(t){if(!st(t))return this._graphs;var e={};return e[t]=this._graphs[t],e}_uniqueEntities(t){var e=Object.create(null),r=this._entities;return function(n){n in e||(e[n]=!0,t(ot(r[n])))}}addQuad(t,e,r,n){e||(n=t.graph,r=t.object,e=t.predicate,t=t.subject),t=it(t),e=it(e),r=it(r),n=it(n);var i=this._graphs[n];i||(i=this._graphs[n]={subjects:{},predicates:{},objects:{}},Object.freeze(i));var o=this._ids,a=this._entities;t=o[t]||(o[a[++this._id]=t]=this._id),e=o[e]||(o[a[++this._id]=e]=this._id),r=o[r]||(o[a[++this._id]=r]=this._id);var s=this._addToIndex(i.subjects,t,e,r);return this._addToIndex(i.predicates,e,r,t),this._addToIndex(i.objects,r,t,e),this._size=null,s}addQuads(t){for(var e=0;e<t.length;e++)this.addQuad(t[e])}import(t){var e=this;return t.on("data",(function(t){e.addQuad(t)})),t}removeQuad(t,e,r,n){e||(n=t.graph,r=t.object,e=t.predicate,t=t.subject),t=it(t),e=it(e),r=it(r),n=it(n);var i,o,a,s=this._ids,u=this._graphs;if(!((t=s[t])&&(e=s[e])&&(r=s[r])&&(i=u[n])&&(o=i.subjects[t])&&(a=o[e])&&r in a))return!1;for(t in this._removeFromIndex(i.subjects,t,e,r),this._removeFromIndex(i.predicates,e,r,t),this._removeFromIndex(i.objects,r,t,e),null!==this._size&&this._size--,i.subjects)return!0;return delete u[n],!0}removeQuads(t){for(var e=0;e<t.length;e++)this.removeQuad(t[e])}remove(t){var e=this;return t.on("data",(function(t){e.removeQuad(t)})),t}removeMatches(t,e,r,n){return this.remove(this.match(t,e,r,n))}deleteGraph(t){return this.removeMatches(null,null,null,t)}getQuads(t,e,r,n){t=t&&it(t),e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s,u=[],c=this._getGraphs(n),f=this._ids;if(st(t)&&!(o=f[t])||st(e)&&!(a=f[e])||st(r)&&!(s=f[r]))return u;for(var l in c)(i=c[l])&&(o?s?this._findInIndex(i.objects,s,o,a,"object","subject","predicate",l,null,u):this._findInIndex(i.subjects,o,a,null,"subject","predicate","object",l,null,u):a?this._findInIndex(i.predicates,a,s,null,"predicate","object","subject",l,null,u):s?this._findInIndex(i.objects,s,null,null,"object","subject","predicate",l,null,u):this._findInIndex(i.subjects,null,null,null,"subject","predicate","object",l,null,u));return u}match(t,e,r,n){var i=new nt.Readable({objectMode:!0});return i._read=()=>{for(var o of this.getQuads(t,e,r,n))i.push(o);i.push(null)},i}countQuads(t,e,r,n){t=t&&it(t),e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s,u=0,c=this._getGraphs(n),f=this._ids;if(st(t)&&!(o=f[t])||st(e)&&!(a=f[e])||st(r)&&!(s=f[r]))return 0;for(var l in c)(i=c[l])&&(u+=t?r?this._countInIndex(i.objects,s,o,a):this._countInIndex(i.subjects,o,a,s):e?this._countInIndex(i.predicates,a,s,o):this._countInIndex(i.objects,s,o,a));return u}forEach(t,e,r,n,i){this.some((function(e){return t(e),!1}),e,r,n,i)}every(t,e,r,n,i){var o=!1,a=!this.some((function(e){return o=!0,!t(e)}),e,r,n,i);return o&&a}some(t,e,r,n,i){e=e&&it(e),r=r&&it(r),n=n&&it(n),i=i&&it(i);var o,a,s,u,c=this._getGraphs(i),f=this._ids;if(st(e)&&!(a=f[e])||st(r)&&!(s=f[r])||st(n)&&!(u=f[n]))return!1;for(var l in c)if(o=c[l])if(a){if(u){if(this._findInIndex(o.objects,u,a,s,"object","subject","predicate",l,t,null))return!0}else if(this._findInIndex(o.subjects,a,s,null,"subject","predicate","object",l,t,null))return!0}else if(s){if(this._findInIndex(o.predicates,s,u,null,"predicate","object","subject",l,t,null))return!0}else if(u){if(this._findInIndex(o.objects,u,null,null,"object","subject","predicate",l,t,null))return!0}else if(this._findInIndex(o.subjects,null,null,null,"subject","predicate","object",l,t,null))return!0;return!1}getSubjects(t,e,r){var n=[];return this.forSubjects((function(t){n.push(t)}),t,e,r),n}forSubjects(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.predicates,o,a,t):this._loopByKey1(i.subjects,o,t):a?this._loopByKey0(i.objects,a,t):this._loop(i.subjects,t))}getPredicates(t,e,r){var n=[];return this.forPredicates((function(t){n.push(t)}),t,e,r),n}forPredicates(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.objects,a,o,t):this._loopByKey0(i.subjects,o,t):a?this._loopByKey1(i.predicates,a,t):this._loop(i.predicates,t))}getObjects(t,e,r){var n=[];return this.forObjects((function(t){n.push(t)}),t,e,r),n}forObjects(t,e,r,n){e=e&&it(e),r=r&&it(r),n=n&&it(n);var i,o,a,s=this._ids,u=this._getGraphs(n);if(t=this._uniqueEntities(t),!(st(e)&&!(o=s[e])||st(r)&&!(a=s[r])))for(n in u)(i=u[n])&&(o?a?this._loopBy2Keys(i.subjects,o,a,t):this._loopByKey1(i.objects,o,t):a?this._loopByKey0(i.predicates,a,t):this._loop(i.objects,t))}getGraphs(t,e,r){var n=[];return this.forGraphs((function(t){n.push(t)}),t,e,r),n}forGraphs(t,e,r,n){for(var i in this._graphs)this.some((function(e){return t(e.graph),!0}),e,r,n,i)}createBlankNode(t){var e,r;if(t)for(e=t="_:"+t,r=1;this._ids[e];)e=t+r++;else do{e="_:b"+this._blankNodeIndex++}while(this._ids[e]);return this._ids[e]=++this._id,this._entities[this._id]=e,this._factory.blankNode(e.substr(2))}extractLists({remove:t=!1,ignoreErrors:e=!1}={}){var r={},n=e?()=>!0:(t,e)=>{throw new Error(`${t.value} ${e}`)},i=this.getQuads(null,M.a.rdf.rest,M.a.rdf.nil,null),o=t?[...i]:[];return i.forEach(e=>{for(var i,a,s=[],u=!1,c=e.graph,f=e.subject;f&&!u;){var l,h,p=this.getQuads(null,null,f,null),d=this.getQuads(f,null,null,null),v=null,g=null,y=null;for(l=0;l<d.length&&!u;l++)(h=d[l]).graph.equals(c)?i?u=n(f,"has non-list arcs out"):h.predicate.value===M.a.rdf.first?v?u=n(f,"has multiple rdf:first arcs"):o.push(v=h):h.predicate.value===M.a.rdf.rest?g?u=n(f,"has multiple rdf:rest arcs"):o.push(g=h):p.length?u=n(f,"can\'t be subject and object"):(i=h,a="subject"):u=n(f,"not confined to single graph");for(l=0;l<p.length&&!u;++l)h=p[l],i?u=n(f,"can\'t have coreferences"):h.predicate.value===M.a.rdf.rest?y?u=n(f,"has incoming rdf:rest arcs"):y=h:(i=h,a="object");v?s.unshift(v.object):u=n(f,"has no list head"),f=y&&y.subject}u?t=!1:i&&(r[i[a].value]=s)}),t&&this.removeQuads(o),r}}function st(t){return"string"==typeof t||t instanceof String}var ut=r(144),ct=r.n(ut)()(),ft=K.namedNode,lt=K.literal,ht=function(){function t(e){u()(this,t),this._fetch=e,this.parser=new tt,this.store=new at,this.cache={},this.prefix={}}var e,r,n,o;return f()(t,[{key:"setPrefix",value:function(t,e){this.prefix[t]=e}},{key:"getPrefix",value:function(t){return this.prefix[t]}},{key:"query",value:(o=a()(i.a.mark((function t(e,r,n,o,a){var s,u,c=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(!(c.length>5&&void 0!==c[5]?c[5]:{useCache:!0}).useCache||!(e in this.cache)){t.next=3;break}return t.abrupt("return",this._queryCached(e,r,n,o,a));case 3:return t.next=5,this._fetch(e,{headers:{Accept:"text/turtle"}});case 5:return s=t.sent,t.next=8,s.text();case 8:return u=t.sent,t.abrupt("return",this.queryTurtle(e,u,r,n,o,a));case 10:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n,i){return o.apply(this,arguments)})},{key:"queryTurtle",value:(n=a()(i.a.mark((function t(e,r,n,o,a,s){var u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this._parse(r,e);case 2:return u=t.sent,this.cache[e]=u,t.abrupt("return",this._queryCached(e,n,o,a,s));case 5:case"end":return t.stop()}}),t,this)}))),function(t,e,r,i,o,a){return n.apply(this,arguments)})},{key:"_queryCached",value:(r=a()(i.a.mark((function t(e,r,n,o,a){var s,u=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return a||(a=ft(e)[a]=[r,n,o,a].map((function(t){if("object"===F()(t)&&t){if(t.id)return t;var r=Object.keys(t),n=t[r];return 1===r.length&&"thisDoc"===r[0]?ft(n?e+"#"+n:e):ct[r]?ft(ct[r](n)):u.prefix[r]?ft(u.prefix[r]+n):ft(r+n)}return t&&void 0!==t?lt(t):t}))),s=this.cache[e],t.abrupt("return",s.getQuads(a[0],a[1],a[2],a[3]));case 3:case"end":return t.stop()}}),t,this)}))),function(t,e,n,i,o){return r.apply(this,arguments)})},{key:"_parse",value:(e=a()(i.a.mark((function t(e,r){var n,o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=[],o=new tt({baseIRI:r}),t.abrupt("return",new Promise((function(t,r){o.parse(e,(function(e,i,o){if(i&&n.push(i),e)return r(e);if(!i){var a=new at;a.addQuads(n),t(a)}}))})));case 3:case"end":return t.stop()}}),t)}))),function(t,r){return e.apply(this,arguments)})}]),t}(),pt=I,dt=O;function vt(t,e){var r={url:t};for(var n in e.forEach((function(t){var e=t.predicate.value.replace(/.*\\//,"").replace(/.*#/,""),n=t.object.value.match("http://www.w3.org/ns/iana/media-types/")?t.object.value.replace("http://www.w3.org/ns/iana/media-types/",""):t.object.value.replace(/.*\\//,"");e.match("type")||(n=n.replace(/.*#/,"")),"ldp#Resource"!==n&&"ldp#Container"!==n&&(r[e]=[].concat(x()(r[e]||[]),[n.replace("#Resource","")]))})),r)1===r[n].length&&(r[n]=r[n][0]);return void 0===r.type&&(r.type="application/octet-stream"),r.itemType=r.type.includes("ldp#BasicContainer")?"Container":"Resource",r.name=dt(t),r.parent=pt(t),r}function gt(t,e,r){var n={type:"folder"};return n.modified=t.modified,n.mtime=t.mtime,n.size=t.size,n.itemType=t.itemType,n.name=t.name,n.parent=t.parent,n.url=t.url,n.folders=e,n.files=r,n}var yt={parseFolderResponse:function(){var t=a()(i.a.mark((function t(e){var r,n,o,s,u,c,f,l,h=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=h.length>1&&void 0!==h[1]?h[1]:e.url,t.next=3,e.text();case 3:return n=t.sent,o=new ht,t.next=7,o.queryTurtle(r,n,{thisDoc:""});case 7:return s=t.sent,u=vt(r,s),t.next=11,o.queryTurtle(r,n,{thisDoc:""},{ldp:"contains"});case 11:return c=t.sent,f=[],l=[],t.next=16,Promise.all(c.map(function(){var t=a()(i.a.mark((function t(e){var n,a,s;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=e.object,t.next=3,o.query(r,n);case 3:a=t.sent,(s=vt(n.value,a)).itemType.includes("Container")?(s.type="folder",f.push(s)):l.push(s);case 6:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()));case 16:return t.abrupt("return",gt(u,f,l));case 17:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}()},bt=(r(201),r(97)),_t=r.n(bt),mt=function(t){function e(t){var r,n;u()(this,e);for(var i=arguments.length,o=new Array(i>1?i-1:0),a=1;a<i;a++)o[a-1]=arguments[a];return(n=h()(this,(r=d()(e)).call.apply(r,[this].concat(o)))).name="SingleResponseError",o.length||(n.message="".concat(t.status," ").concat(t.url)),n.response=t,n.ok=!1,n.status=t.status,n.statusText=t.statusText,n.url=t.url,n}return b()(e,t),e}(_t()(Error)),wt=function(t){function e(t){var r,n,i=t.successful,o=void 0===i?[]:i,a=t.rejectedErrors,s=void 0===a?[]:a,c=t.errors,f=void 0===c?[]:c;u()(this,e);for(var l=arguments.length,p=new Array(l>1?l-1:0),v=1;v<l;v++)p[v-1]=arguments[v];return(n=h()(this,(r=d()(e)).call.apply(r,[this].concat(p)))).name="SFCFetchError",n.successful=o,n.rejected=s.map((function(t){return t.response})),n.rejectedErrors=s,n.errors=f,n.ok=!1,s.length?1!==s.length||f.length?(n.message="".concat(n.name," ").concat([].concat(x()(s),x()(f)).map((function(t){return t.message})).join("\\n")),n.status=-2,n.statusText=n.message):(n.message="".concat(n.name," ").concat(s[0].message),n.status=s[0].status,n.statusText=s[0].statusText):(n.message="".concat(n.name," ").concat(f.map((function(t){return t.message})).join("\\n")),n.status=-1,n.statusText=n.message),n.successful=o,n.rejected=s.map((function(t){return t.response})),n.rejectedErrors=s,n.errors=f,n}return b()(e,t),e}(_t()(Error)),xt={401:"Make sure that the user is properly logged in",403:"Make sure that the origin of your app is authorized for your pod",404:"The requested resource could not be found",409:"A conflict appeared. If you tried to delete a folder, make sure that it is empty",500:"An internal server error occured"};function kt(t){return Et.apply(this,arguments)}function Et(){return(Et=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=e.map((function(t){return t.then((function(t){return{status:"fulfilled",value:t}})).catch((function(t){return{status:"rejected",reason:t}}))})),t.abrupt("return",Promise.all(r));case 2:case"end":return t.stop()}}),t)})))).apply(this,arguments)}function St(){return(St=a()(i.a.mark((function t(e){var r,n,o,a,s,u,c,f;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,kt(e);case 2:if(n=t.sent,o=(r=[]).concat.apply(r,x()(n.filter((function(t){return"fulfilled"===t.status})).map((function(t){return t.value})))),!(a=n.filter((function(t){return"rejected"===t.status})).map((function(t){return t.reason}))).length){t.next=9;break}throw c=(s=[]).concat.apply(s,x()(a.map((function(t){return t.errors})))),f=(u=[]).concat.apply(u,x()(a.map((function(t){return t.rejectedErrors})))),new wt({successful:o,rejectedErrors:f,errors:c});case 9:return t.abrupt("return",o);case 10:case"end":return t.stop()}}),t)})))).apply(this,arguments)}var jt={FetchError:wt,SingleResponseError:mt,assertResponseOk:function(t){if(!t.ok){var e=t.status in xt?new mt(t,"".concat(t.status," ").concat(t.url," - ").concat(xt[t.status])):new mt(t);throw new wt({successful:[],rejectedErrors:[e]})}return t},composedFetch:function(t){return St.apply(this,arguments)},promisesSettled:kt,toFetchError:function(t){throw t instanceof wt?t:t instanceof mt?new wt({rejectedErrors:[t]}):t instanceof Error?new wt({errors:[t]}):t}};r(204);function Rt(t,e){var r={};return function(t){if(t){return t.match(/<[^>]*>\\s*(\\s*;\\s*[^()<>@,;:"/[\\]?={} \\t]+=(([^\\(\\)<>@,;:"\\/\\[\\]\\?={} \\t]+)|("[^"]*")))*(,|$)/g)}}(t).map((function(t){var e=t.substring(t.indexOf("<")+1,t.indexOf(">")),r=t.substring(t.indexOf(\'rel="\')+\'rel="\'.length,t.lastIndexOf(\'"\'));return["describedby"===r.toLowerCase()?"meta":r,e]})).filter((function(t){var e=m()(t,1)[0];return["meta","acl"].includes(e)})).forEach((function(t){var n=m()(t,2),i=n[0],o=n[1];r[i]=function(t,e){var r,n,i,o,a,s=e.indexOf("#");s>0&&(e=e.slice(0,s));if(0===t.length)return e;if(0===t.indexOf("#"))return e+t;if(t.indexOf(":")>=0)return t;if(r=e.indexOf(":"),0===e.length)return t;if(r<0)return t;if(n=e.slice(0,+r+1||9e9),0===t.indexOf("//"))return n+t;if(e.indexOf("//",r)===r+1){if((i=e.indexOf("/",r+3))<0)return e.length-r-3>0?e+"/"+t:n+t}else if((i=e.indexOf("/",r+1))<0)return e.length-r-1>0?e+"/"+t:n+t;if(0===t.indexOf("/"))return e.slice(0,i)+t;if(a=e.slice(i),(o=a.lastIndexOf("/"))<0)return n+t;o>=0&&o<a.length-1&&(a=a.slice(0,+o+1||9e9));a+=t;for(;a.match(/[^\\/]*\\/\\.\\.\\//);)a=a.replace(/[^\\/]*\\/\\.\\.\\//,"");return a=(a=a.replace(/\\.\\//g,"")).replace(/\\/\\.$/,"/"),e.slice(0,i)+a}(o,e)})),r}var Ct=function(t){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.url,r=t.headers.get("link");return null===r?{}:Rt(r,e)};function It(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function Ot(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?It(Object(r),!0).forEach((function(e){E()(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):It(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}var Tt=j()("solid-file-client:fetch"),Pt=C,At=I,Lt=O,Ft=T,Mt=P,Nt=A,Bt=jt.FetchError,Dt=jt.assertResponseOk,Ut=jt.composedFetch,qt=jt.toFetchError,Gt=Ct,Wt=yt.parseFolderResponse,zt={REPLACE:"replace",KEEP_SOURCE:"keep_source",KEEP_TARGET:"keep_target"},Yt={EXCLUDE:"exclude",INCLUDE:"include",INCLUDE_POSSIBLE:"include_possible"},Qt="no_modify",$t="to_target",Ht="to_source",Kt={withAcl:!0,withMeta:!0,agent:Qt,merge:zt.REPLACE,createPath:!0},Vt={enableLogging:!1};function Zt(t){return Jt((function(e){return e.status===t}))}function Jt(t){return function(e){if(!t(e))throw qt(e);return e}}var Xt=function(t){function e(t,r){var n;return u()(this,e),(n=h()(this,d()(e).call(this,t.fetch.bind(t),r)))._auth=t,n}var r,n,o,s;return b()(e,t),f()(e,[{key:"readFile",value:(s=a()(i.a.mark((function t(e,r){var n,o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.get(e,r);case 2:if(n=t.sent,!(o=n.headers.get("content-type"))||!o.match(/(image|audio|video)/)){t.next=6;break}return t.abrupt("return",n.blob());case 6:if(!n.text){t.next=8;break}return t.abrupt("return",n.text());case 8:return t.abrupt("return",n);case 9:case"end":return t.stop()}}),t,this)}))),function(t,e){return s.apply(this,arguments)})},{key:"readHead",value:(o=a()(i.a.mark((function t(r,n){var o,a,s,u,c,f,l,h;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,g()(d()(e.prototype),"head",this).call(this,r,n);case 2:for(o=t.sent,a="",s=!0,u=!1,c=void 0,t.prev=7,f=o.headers.entries()[Symbol.iterator]();!(s=(l=f.next()).done);s=!0)h=l.value,a+=h[0]+": "+h[1]+"\\n";t.next=15;break;case 11:t.prev=11,t.t0=t.catch(7),u=!0,c=t.t0;case 15:t.prev=15,t.prev=16,s||null==f.return||f.return();case 18:if(t.prev=18,!u){t.next=21;break}throw c;case 21:return t.finish(18);case 22:return t.finish(15);case 23:return t.abrupt("return",a);case 24:case"end":return t.stop()}}),t,this,[[7,11,15,23],[16,,18,22]])}))),function(t,e){return o.apply(this,arguments)})},{key:"deleteFile",value:(n=a()(i.a.mark((function t(r){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",g()(d()(e.prototype),"_deleteItemWithLinks",this).call(this,r));case 1:case"end":return t.stop()}}),t,this)}))),function(t){return n.apply(this,arguments)})},{key:"deleteFolder",value:(r=a()(i.a.mark((function t(r,n){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",g()(d()(e.prototype),"deleteFolderRecursively",this).call(this,r));case 1:case"end":return t.stop()}}),t,this)}))),function(t,e){return r.apply(this,arguments)})}]),e}(function(){function t(e,r){u()(this,t),r=Ot({},Vt,{},r),this._fetch=e,this.rdf=new ht(this.fetch.bind(this)),r.enableLogging&&("string"==typeof r.enableLogging?j.a.enable(r.enableLogging):j.a.enable("solid-file-client:*"))}var e,r,n,o,s,c,l,h,p,d,v,g,y,b,_,w,k;return f()(t,[{key:"fetch",value:function(t,e){return this._fetch(t,e).then((function(r){return Tt("".concat(r.status," - ").concat(e&&e.method," ").concat(t)),r})).then(Dt)}},{key:"get",value:function(t,e){return this.fetch(t,Ot({},e,{method:"GET"}))}},{key:"delete",value:function(t,e){return this.fetch(t,Ot({},e,{method:"DELETE"}))}},{key:"post",value:function(t,e){return this.fetch(t,Ot({},e,{method:"POST"}))}},{key:"put",value:function(t,e){return this.fetch(t,Ot({},e,{method:"PUT"}))}},{key:"patch",value:function(t,e){return this.fetch(t,Ot({},e,{method:"PATCH"}))}},{key:"head",value:function(t,e){return this.fetch(t,Ot({},e,{method:"HEAD"}))}},{key:"options",value:function(t,e){return this.fetch(t,Ot({},e,{method:"OPTIONS"}))}},{key:"itemExists",value:(k=a()(i.a.mark((function t(e){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.abrupt("return",this.head(e).then((function(){return!0})).catch((function(t){return Zt(404)(t),!1})));case 1:case"end":return t.stop()}}),t,this)}))),function(t){return k.apply(this,arguments)})},{key:"postItem",value:(w=a()(i.a.mark((function t(e,r,n,o,a){var s,u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(a=Ot({},{createPath:!0},{},a),s=At(e),!a.createPath){t.next=5;break}return t.next=5,this.createFolder(s);case 5:return u={headers:{link:o,slug:Lt(e),"Content-Type":n},body:r},t.abrupt("return",this.post(s,u));case 7:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n,i){return w.apply(this,arguments)})},{key:"createFolder",value:(_=a()(i.a.mark((function t(e,r){var n;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return r=Ot({},{createPath:!0,merge:zt.KEEP_TARGET},{},r),t.prev=1,t.next=4,this.head(e);case 4:if(n=t.sent,r.merge===zt.REPLACE){t.next=7;break}return t.abrupt("return",n);case 7:return t.next=9,this.deleteFolderRecursively(e);case 9:t.next=14;break;case 11:t.prev=11,t.t0=t.catch(1),Zt(404)(t.t0);case 14:return t.abrupt("return",this.postItem(e,"","text/turtle",Nt.CONTAINER,r));case 15:case"end":return t.stop()}}),t,this,[[1,11]])}))),function(t,e){return _.apply(this,arguments)})},{key:"postFile",value:function(t,e,r,n){return this.postItem(t,e,r,Nt.RESOURCE,n)}},{key:"createFile",value:function(t,e,r,n){return this.putFile(t,e,r,n)}},{key:"putFile",value:(b=a()(i.a.mark((function t(e,r,n,o){var a;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(o=Ot({},Kt,{},o),t.t0=o.merge===zt.KEEP_TARGET,!t.t0){t.next=6;break}return t.next=5,this.itemExists(e);case 5:t.t0=t.sent;case 6:if(!t.t0){t.next=8;break}qt(new Error("File already existed: "+e));case 8:return a={headers:{link:Nt.RESOURCE,"Content-Type":n},body:r},t.abrupt("return",this.put(e,a));case 10:case"end":return t.stop()}}),t,this)}))),function(t,e,r,n){return b.apply(this,arguments)})},{key:"readFolder",value:(y=a()(i.a.mark((function t(e,r){var n,o,s,u=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return e=e.endsWith("/")?e:e+"/",r=Ot({links:Yt.EXCLUDE},r),t.next=4,this.get(e,{headers:{Accept:"text/turtle"}});case 4:return n=t.sent,t.next=7,Wt(n,e);case 7:if(o=t.sent,r.links!==Yt.INCLUDE_POSSIBLE&&r.links!==Yt.INCLUDE){t.next=12;break}return s=function(){var t=a()(i.a.mark((function t(e){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,u.getItemLinks(e.url,r);case 2:e.links=t.sent;case 3:case"end":return t.stop()}}),t)})));return function(e){return t.apply(this,arguments)}}(),t.next=12,Ut([s(o)].concat(x()(o.files.map(s))));case 12:return t.abrupt("return",o);case 13:case"end":return t.stop()}}),t,this)}))),function(t,e){return y.apply(this,arguments)})},{key:"getItemLinks",value:(g=a()(i.a.mark((function t(e){var r,n,o=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return(r=o.length>1&&void 0!==o[1]?o[1]:{links:Yt.INCLUDE_POSSIBLE}).links===Yt.EXCLUDE&&qt(new Error("Invalid option LINKS.EXCLUDE for getItemLinks")),t.next=4,this.head(e).then(Gt);case 4:if(n=t.sent,r.links!==Yt.INCLUDE){t.next=8;break}return t.next=8,this._removeInexistingLinks(n);case 8:return t.abrupt("return",n);case 9:case"end":return t.stop()}}),t,this)}))),function(t){return g.apply(this,arguments)})},{key:"_removeInexistingLinks",value:(v=a()(i.a.mark((function t(e){var r=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,Ut(Object.entries(e).map((function(t){var n=m()(t,2),i=n[0],o=n[1];return r.itemExists(o).catch(Zt(404)).then((function(t){t||delete e[i]}))})));case 2:case"end":return t.stop()}}),t)}))),function(t){return v.apply(this,arguments)})},{key:"copyFile",value:(d=a()(i.a.mark((function t(e,r,n){var o,a,s,u;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(n=Ot({},Kt,{},n),!e.endsWith("/")&&!r.endsWith("/")){t.next=3;break}throw qt(new Error("Folders are not allowed with copyFile. Found: ".concat(e," and ").concat(r)));case 3:if(!e.endsWith(".acl")&&!r.endsWith(".acl")){t.next=5;break}throw qt(new Error("Use copyAclFile for copying ACL files. Found: ".concat(e," and ").concat(r)));case 5:return t.next=7,this.get(e);case 7:return o=t.sent,t.next=10,o.blob();case 10:return a=t.sent,s=o.headers.get("content-type"),t.next=14,this.putFile(r,a,s,n);case 14:return u=t.sent,t.next=17,this.copyLinksForItem(e,r,n,o,u);case 17:return t.abrupt("return",u);case 18:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return d.apply(this,arguments)})},{key:"_linkUrlsDefined",value:(p=a()(i.a.mark((function t(e,r){return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if("string"==typeof e){t.next=4;break}return t.abrupt("return",!1);case 4:if(t.t0="string"!=typeof r,!t.t0){t.next=9;break}return t.next=8,this.itemExists(e);case 8:t.t0=t.sent;case 9:if(!t.t0){t.next=13;break}throw qt(new Error("Cannot copy link file because target location was not provided by the pod"));case 13:if("string"==typeof r){t.next=17;break}return t.abrupt("return",!1);case 17:return t.abrupt("return",!0);case 18:case"end":return t.stop()}}),t,this)}))),function(t,e){return p.apply(this,arguments)})},{key:"copyMetaFileForItem",value:(h=a()(i.a.mark((function t(e,r){var n,o,a,s,u,c=arguments;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=c.length>2&&void 0!==c[2]?c[2]:{},t.next=3,this.getItemLinks(e);case 3:return o=t.sent,a=o.meta,t.next=7,this.getItemLinks(r);case 7:return s=t.sent,u=s.meta,t.next=11,this._linkUrlsDefined(a,u);case 11:if(t.sent){t.next=13;break}return t.abrupt("return",void 0);case 13:return t.abrupt("return",this.copyFile(a,u,{withAcl:n.withAcl,withMeta:!1}));case 14:case"end":return t.stop()}}),t,this)}))),function(t,e){return h.apply(this,arguments)})},{key:"copyAclFileForItem",value:(l=a()(i.a.mark((function t(e,r,n){var o,a,s,u,c,f,l,h,p;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return n=Ot({},Kt,{},{agent:Qt},{},n),t.next=3,this.getItemLinks(e);case 3:return o=t.sent,a=o.acl,t.next=7,this.getItemLinks(r);case 7:return s=t.sent,u=s.acl,t.next=11,this._linkUrlsDefined(a,u);case 11:if(t.sent){t.next=13;break}return t.abrupt("return",void 0);case 13:return t.next=15,this.get(a);case 15:return c=t.sent,f=c.headers.get("Content-Type"),t.next=19,c.text();case 19:return l=t.sent,h=Lt(e),p=Ft(r)?"":Lt(r),l.includes(e)&&(l=l.replace(new RegExp("<"+e+">","g"),"<./"+p+">")),p!==h&&(l=l.replace(new RegExp(h+">","g"),p+">")),n.agent===$t&&(l=(l=l.replace(new RegExp("<"+Pt(e)+"profile/card#","g"),"</profile/card#")).replace(new RegExp("<"+Pt(e)+"profile/card#me>","g"),"</profile/card#me>")),n.agent===Ht&&(l=(l=l.replace(new RegExp("</profile/card#","g"),"<"+Pt(e)+"profile/card#")).replace(new RegExp("</profile/card#me>","g"),"<"+Pt(e)+"profile/card#me>")),t.abrupt("return",this.putFile(u,l,f,n));case 27:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return l.apply(this,arguments)})},{key:"copyLinksForItem",value:(c=a()(i.a.mark((function t(e,r,n){var o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(o=[],!n.withMeta){t.next=7;break}return t.t0=o,t.next=5,this.copyMetaFileForItem(e,r,n).catch(Zt(404));case 5:t.t1=t.sent,t.t0.push.call(t.t0,t.t1);case 7:if(!n.withAcl){t.next=13;break}return t.t2=o,t.next=11,this.copyAclFileForItem(e,r,n).catch(Zt(404));case 11:t.t3=t.sent,t.t2.push.call(t.t2,t.t3);case 13:return t.abrupt("return",o.filter((function(t){return t&&!(t instanceof Error)})));case 14:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return c.apply(this,arguments)})},{key:"copyFolder",value:(s=a()(i.a.mark((function t(e,r,n){var o,a,s,u,c,f,l=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:if(n=Ot({},Kt,{},n),"string"==typeof e&&"string"==typeof r){t.next=3;break}throw qt(new Error("The from and to parameters of copyFolder must be strings. Found: ".concat(e," and ").concat(r)));case 3:if(e.endsWith("/")&&r.endsWith("/")){t.next=5;break}throw qt(new Error("Files are not allowed with copyFolder. Found: ".concat(e," and ").concat(r)));case 5:return t.next=7,this.readFolder(e);case 7:return a=t.sent,s=a.folders,u=a.files,t.next=12,this.createFolder(r,n);case 12:return c=t.sent,t.next=15,this.copyLinksForItem(e,r,n,void 0,c);case 15:return t.next=17,Ut([].concat(x()(s.map((function(t){var i=t.name;return l.copyFolder("".concat(e).concat(i,"/"),"".concat(r).concat(i,"/"),n)}))),x()(u.map((function(t){var i=t.name;return l.copyFile("".concat(e).concat(i),"".concat(r).concat(i),n).catch(Jt((function(t){return t.message.includes("already existed")})))}))))).then((function(t){return t.filter((function(t){return!(t instanceof Bt)}))}));case 17:return f=t.sent,t.abrupt("return",(o=[c]).concat.apply(o,x()(f)));case 19:case"end":return t.stop()}}),t,this)}))),function(t,e,r){return s.apply(this,arguments)})},{key:"copy",value:function(t,e,r){return Ft(t,e)?this.copyFolder(t,e,r):Mt(t,e)?this.copyFile(t,e,r):void qt(new Error("Cannot copy from a folder url to a file url or vice versa"))}},{key:"_deleteItemWithLinks",value:(o=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.getItemLinks(e,{links:Yt.INCLUDE});case 2:if(!(r=t.sent).meta){t.next=6;break}return t.next=6,this._deleteItemWithLinks(r.meta);case 6:if(!r.acl){t.next=9;break}return t.next=9,this.delete(r.acl);case 9:return t.abrupt("return",this.delete(e));case 10:case"end":return t.stop()}}),t,this)}))),function(t){return o.apply(this,arguments)})},{key:"deleteFolderContents",value:(n=a()(i.a.mark((function t(e){var r,n,o,a=this;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.readFolder(e);case 2:return r=t.sent,n=r.folders,o=r.files,t.abrupt("return",Ut([].concat(x()(n.map((function(t){var e=t.url;return a.deleteFolderRecursively(e)}))),x()(o.map((function(t){var e=t.url;return a._deleteItemWithLinks(e)}))))));case 6:case"end":return t.stop()}}),t,this)}))),function(t){return n.apply(this,arguments)})},{key:"deleteFolderRecursively",value:(r=a()(i.a.mark((function t(e){var r;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.deleteFolderContents(e);case 2:return r=t.sent,t.t0=r,t.next=6,this._deleteItemWithLinks(e);case 6:return t.t1=t.sent,t.t0.unshift.call(t.t0,t.t1),t.abrupt("return",r);case 9:case"end":return t.stop()}}),t,this)}))),function(t){return r.apply(this,arguments)})},{key:"move",value:(e=a()(i.a.mark((function t(e,r,n){var o;return i.a.wrap((function(t){for(;;)switch(t.prev=t.next){case 0:return t.next=2,this.copy(e,r,n);case 2:if(o=t.sent,!Ft(e)){t.next=8;break}return t.next=6,this.deleteFolderRecursively(e);case 6:t.next=10;break;case 8:return t.next=10,this._deleteItemWithLinks(e);case 10:return t.abrupt("return",o);case 11:case"end":return t.stop()}}),t,this)}))),function(t,r,n){return e.apply(this,arguments)})},{key:"rename",value:function(t,e,r){var n=At(t)+e+(Ft(t)?"/":"");return this.move(t,n,r)}}]),t}()),te=jt.FetchError,ee=jt.SingleResponseError;Xt.FetchError=te,Xt.SingleResponseError=ee,Xt.LINKS=Yt,Xt.MERGE=zt;e.default=Xt}]).default}));\n//# sourceMappingURL=solid-file-client.bundle.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29saWQtZmlsZS1jbGllbnQvZGlzdC93aW5kb3cvc29saWQtZmlsZS1jbGllbnQuYnVuZGxlLmpzPzdmZWQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxLQUFpRCxvQkFBb0IsU0FBNkgsQ0FBQyxvQkFBb0IsbUJBQW1CLFNBQVMsY0FBYyw0QkFBNEIsWUFBWSxxQkFBcUIsMkRBQTJELHVDQUF1QyxxQ0FBcUMsb0JBQW9CLEVBQUUsaUJBQWlCLDRGQUE0RixlQUFlLHdDQUF3QyxTQUFTLEVBQUUsbUJBQW1CLDhCQUE4QixxREFBcUQsMEJBQTBCLDZDQUE2QyxzQkFBc0IsNkRBQTZELFlBQVksZUFBZSxTQUFTLGlCQUFpQixpQ0FBaUMsaUJBQWlCLFlBQVksVUFBVSxzQkFBc0IsbUJBQW1CLGlEQUFpRCxtQkFBbUIsa0JBQWtCLGdCQUFnQixlQUFlLDBCQUEwQixJQUFJLHdCQUF3QixTQUFTLGlCQUFpQix5Q0FBeUMsc0JBQXNCLGtCQUFrQix1QkFBdUIsa0NBQWtDLG1CQUFtQixjQUFjLHNCQUFzQixjQUFjLHVCQUF1QixVQUFVLEtBQUssaUJBQWlCLDhEQUE4RCx3QkFBd0IsNkNBQTZDLHVCQUF1QixXQUFXLHdCQUF3QixpR0FBaUcsK0JBQStCLE9BQU8saURBQWlELGlCQUFpQixzR0FBc0csc0JBQXNCLCtEQUErRCxpQkFBaUIsYUFBYSxrQkFBa0IsMkJBQTJCLDhLQUE4SyxtQkFBbUIsZUFBZSxzQkFBc0IsSUFBSSxZQUFZLFNBQVMsV0FBVyxpQkFBaUIsYUFBYSw4SEFBOEgsS0FBSyxLQUFLLGdHQUFnRyxNQUFNLGtGQUFrRixNQUFNLDhDQUE4QyxJQUFJLGtEQUFrRCxNQUFNLDBCQUEwQixpQkFBaUIsV0FBVyx5QkFBeUIsa0NBQWtDLE1BQU0sZUFBZSxVQUFVLElBQUksR0FBRyxpQkFBaUIsWUFBWSxzQkFBc0Isd0RBQXdELFVBQVUsaUJBQWlCLCtCQUErQixzQkFBc0Isd0JBQXdC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R0FBRywwRUFBMEUsbUNBQW1DLFVBQVUsb0JBQW9CLCtCQUErQixFQUFFLEVBQUUsaUNBQWlDLG9KQUFvSixFQUFFLGdFQUFnRSxNQUFNLDZCQUE2QixNQUFNLHVCQUF1Qiw0Q0FBNEMsaUJBQWlCLEVBQUUsNEJBQTRCLFNBQVMsTUFBTSxrREFBa0Qsa0JBQWtCLFNBQVMsTUFBTSxtQ0FBbUMsZ0RBQWdELG1DQUFtQyxVQUFVLGdCQUFnQiwrQkFBK0IsRUFBRSxFQUFFLGdFQUFnRSxpQkFBaUIsNkJBQTZCLE1BQU0sdUJBQXVCLDBDQUEwQyxtR0FBbUcsWUFBWSxvQ0FBb0MsMkJBQTJCLFlBQVksaUNBQWlDLE9BQU8sa0NBQWtDLFVBQVUsZ0JBQWdCLCtCQUErQixFQUFFLEVBQUUsbUVBQW1FLE1BQU0sNkJBQTZCLE1BQU0sdUJBQXVCLG9EQUFvRCxvRUFBb0UsNEVBQTRFLGtDQUFrQyxVQUFVLGdCQUFnQiwrQkFBK0IsRUFBRSxFQUFFLG9EQUFvRCxNQUFNLDZCQUE2QixNQUFNLHVCQUF1Qix3Q0FBd0MsMkJBQTJCLFNBQVMsTUFBTSxnREFBZ0QsaUJBQWlCLE1BQU0scURBQXFELG9DQUFvQyxtQ0FBbUMsVUFBVSxvQkFBb0IsK0JBQStCLEVBQUUsRUFBRSxtQ0FBbUMsNkJBQTZCLHlCQUF5QixLQUFLLCtDQUErQyxtRUFBbUUsYUFBYSxXQUFXO0FBQ2o5K0kiLCJmaWxlIjoiNTcuanMiLCJzb3VyY2VzQ29udGVudCI6WyIhZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlNvbGlkRmlsZUNsaWVudD1lKCk6dC5Tb2xpZEZpbGVDbGllbnQ9ZSgpfSh3aW5kb3csKGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Z1bmN0aW9uIHIobil7aWYoZVtuXSlyZXR1cm4gZVtuXS5leHBvcnRzO3ZhciBpPWVbbl09e2k6bixsOiExLGV4cG9ydHM6e319O3JldHVybiB0W25dLmNhbGwoaS5leHBvcnRzLGksaS5leHBvcnRzLHIpLGkubD0hMCxpLmV4cG9ydHN9cmV0dXJuIHIubT10LHIuYz1lLHIuZD1mdW5jdGlvbih0LGUsbil7ci5vKHQsZSl8fE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse2VudW1lcmFibGU6ITAsZ2V0Om59KX0sci5yPWZ1bmN0aW9uKHQpe1widW5kZWZpbmVkXCIhPXR5cGVvZiBTeW1ib2wmJlN5bWJvbC50b1N0cmluZ1RhZyYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsU3ltYm9sLnRvU3RyaW5nVGFnLHt2YWx1ZTpcIk1vZHVsZVwifSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSl9LHIudD1mdW5jdGlvbih0LGUpe2lmKDEmZSYmKHQ9cih0KSksOCZlKXJldHVybiB0O2lmKDQmZSYmXCJvYmplY3RcIj09dHlwZW9mIHQmJnQmJnQuX19lc01vZHVsZSlyZXR1cm4gdDt2YXIgbj1PYmplY3QuY3JlYXRlKG51bGwpO2lmKHIucihuKSxPYmplY3QuZGVmaW5lUHJvcGVydHkobixcImRlZmF1bHRcIix7ZW51bWVyYWJsZTohMCx2YWx1ZTp0fSksMiZlJiZcInN0cmluZ1wiIT10eXBlb2YgdClmb3IodmFyIGkgaW4gdClyLmQobixpLGZ1bmN0aW9uKGUpe3JldHVybiB0W2VdfS5iaW5kKG51bGwsaSkpO3JldHVybiBufSxyLm49ZnVuY3Rpb24odCl7dmFyIGU9dCYmdC5fX2VzTW9kdWxlP2Z1bmN0aW9uKCl7cmV0dXJuIHQuZGVmYXVsdH06ZnVuY3Rpb24oKXtyZXR1cm4gdH07cmV0dXJuIHIuZChlLFwiYVwiLGUpLGV9LHIubz1mdW5jdGlvbih0LGUpe3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKX0sci5wPVwiXCIscihyLnM9MjA1KX0oW2Z1bmN0aW9uKHQsZSxyKXt0LmV4cG9ydHM9cigyOCl9LGZ1bmN0aW9uKHQsZSl7ZnVuY3Rpb24gcih0LGUscixuLGksbyxhKXt0cnl7dmFyIHM9dFtvXShhKSx1PXMudmFsdWV9Y2F0Y2godCl7cmV0dXJuIHZvaWQgcih0KX1zLmRvbmU/ZSh1KTpQcm9taXNlLnJlc29sdmUodSkudGhlbihuLGkpfXQuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt2YXIgZT10aGlzLG49YXJndW1lbnRzO3JldHVybiBuZXcgUHJvbWlzZSgoZnVuY3Rpb24oaSxvKXt2YXIgYT10LmFwcGx5KGUsbik7ZnVuY3Rpb24gcyh0KXtyKGEsaSxvLHMsdSxcIm5leHRcIix0KX1mdW5jdGlvbiB1KHQpe3IoYSxpLG8scyx1LFwidGhyb3dcIix0KX1zKHZvaWQgMCl9KSl9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDIyKS5mLG89cigxNCksYT1yKDE3KSxzPXIoNjIpLHU9cigxMDEpLGM9cig2OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHIsZixsLGgscCxkPXQudGFyZ2V0LHY9dC5nbG9iYWwsZz10LnN0YXQ7aWYocj12P246Zz9uW2RdfHxzKGQse30pOihuW2RdfHx7fSkucHJvdG90eXBlKWZvcihmIGluIGUpe2lmKGg9ZVtmXSxsPXQubm9UYXJnZXRHZXQ/KHA9aShyLGYpKSYmcC52YWx1ZTpyW2ZdLCFjKHY/ZjpkKyhnP1wiLlwiOlwiI1wiKStmLHQuZm9yY2VkKSYmdm9pZCAwIT09bCl7aWYodHlwZW9mIGg9PXR5cGVvZiBsKWNvbnRpbnVlO3UoaCxsKX0odC5zaGFtfHxsJiZsLnNoYW0pJiZvKGgsXCJzaGFtXCIsITApLGEocixmLGgsdCl9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDY0KSxvPXIoMTMpLGE9cig2NSkscz1yKDY5KSx1PXIoMTA3KSxjPWkoXCJ3a3NcIiksZj1uLlN5bWJvbCxsPXU/ZjpmJiZmLndpdGhvdXRTZXR0ZXJ8fGE7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBvKGMsdCl8fChzJiZvKGYsdCk/Y1t0XT1mW3RdOmNbdF09bChcIlN5bWJvbC5cIit0KSksY1t0XX19LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24oZSl7dmFyIHI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJnQuTWF0aD09TWF0aCYmdH07dC5leHBvcnRzPXIoXCJvYmplY3RcIj09dHlwZW9mIGdsb2JhbFRoaXMmJmdsb2JhbFRoaXMpfHxyKFwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyl8fHIoXCJvYmplY3RcIj09dHlwZW9mIHNlbGYmJnNlbGYpfHxyKFwib2JqZWN0XCI9PXR5cGVvZiBlJiZlKXx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfSkuY2FsbCh0aGlzLHIoMjEpKX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybiEhdCgpfWNhdGNoKHQpe3JldHVybiEwfX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIixpPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjXCIsbz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvMTAvc3dhcC9cIjtlLmE9e3hzZDp7ZGVjaW1hbDppK1wiZGVjaW1hbFwiLGJvb2xlYW46aStcImJvb2xlYW5cIixkb3VibGU6aStcImRvdWJsZVwiLGludGVnZXI6aStcImludGVnZXJcIixzdHJpbmc6aStcInN0cmluZ1wifSxyZGY6e3R5cGU6bitcInR5cGVcIixuaWw6bitcIm5pbFwiLGZpcnN0Om4rXCJmaXJzdFwiLHJlc3Q6bitcInJlc3RcIixsYW5nU3RyaW5nOm4rXCJsYW5nU3RyaW5nXCJ9LG93bDp7c2FtZUFzOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMi8wNy9vd2wjc2FtZUFzXCJ9LHI6e2ZvclNvbWU6bytcInJlaWZ5I2ZvclNvbWVcIixmb3JBbGw6bytcInJlaWZ5I2ZvckFsbFwifSxsb2c6e2ltcGxpZXM6bytcImxvZyNpbXBsaWVzXCJ9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNSk7dC5leHBvcnRzPSFuKChmdW5jdGlvbigpe3JldHVybiA3IT1PYmplY3QuZGVmaW5lUHJvcGVydHkoe30sXCJhXCIse2dldDpmdW5jdGlvbigpe3JldHVybiA3fX0pLmF9KSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoIW4odCkpdGhyb3cgVHlwZUVycm9yKFN0cmluZyh0KStcIiBpcyBub3QgYW4gb2JqZWN0XCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTY5KSxpPXIoMTcwKSxvPXIoMTcxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG4odCl8fGkodCl8fG8oKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiB0P251bGwhPT10OlwiZnVuY3Rpb25cIj09dHlwZW9mIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3KSxpPXIoOTkpLG89cig4KSxhPXIoNDMpLHM9T2JqZWN0LmRlZmluZVByb3BlcnR5O2UuZj1uP3M6ZnVuY3Rpb24odCxlLHIpe2lmKG8odCksZT1hKGUsITApLG8ociksaSl0cnl7cmV0dXJuIHModCxlLHIpfWNhdGNoKHQpe31pZihcImdldFwiaW4gcnx8XCJzZXRcImluIHIpdGhyb3cgVHlwZUVycm9yKFwiQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWRcIik7cmV0dXJuXCJ2YWx1ZVwiaW4gciYmKHRbZV09ci52YWx1ZSksdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDYwKSxpPXIoMjApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbihpKHQpKX19LGZ1bmN0aW9uKHQsZSl7dmFyIHI9e30uaGFzT3duUHJvcGVydHk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHIuY2FsbCh0LGUpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKSxvPXIoMzEpO3QuZXhwb3J0cz1uP2Z1bmN0aW9uKHQsZSxyKXtyZXR1cm4gaS5mKHQsZSxvKDEscikpfTpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRbZV09cix0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMzIpLGk9TWF0aC5taW47dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiB0PjA/aShuKHQpLDkwMDcxOTkyNTQ3NDA5OTEpOjB9fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSl7cmV0dXJuIHQuZXhwb3J0cz1yPU9iamVjdC5zZXRQcm90b3R5cGVPZj9PYmplY3QuZ2V0UHJvdG90eXBlT2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHQuX19wcm90b19ffHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCl9LHIoZSl9dC5leHBvcnRzPXJ9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxNCksbz1yKDEzKSxhPXIoNjIpLHM9cig2MyksdT1yKDI0KSxjPXUuZ2V0LGY9dS5lbmZvcmNlLGw9U3RyaW5nKFN0cmluZykuc3BsaXQoXCJTdHJpbmdcIik7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUscixzKXt2YXIgdT0hIXMmJiEhcy51bnNhZmUsYz0hIXMmJiEhcy5lbnVtZXJhYmxlLGg9ISFzJiYhIXMubm9UYXJnZXRHZXQ7XCJmdW5jdGlvblwiPT10eXBlb2YgciYmKFwic3RyaW5nXCIhPXR5cGVvZiBlfHxvKHIsXCJuYW1lXCIpfHxpKHIsXCJuYW1lXCIsZSksZihyKS5zb3VyY2U9bC5qb2luKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6XCJcIikpLHQhPT1uPyh1PyFoJiZ0W2VdJiYoYz0hMCk6ZGVsZXRlIHRbZV0sYz90W2VdPXI6aSh0LGUscikpOmM/dFtlXT1yOmEoZSxyKX0pKEZ1bmN0aW9uLnByb3RvdHlwZSxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdGhpcyYmYyh0aGlzKS5zb3VyY2V8fHModGhpcyl9KSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX19LGZ1bmN0aW9uKHQsZSl7dmFyIHI9e30udG9TdHJpbmc7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiByLmNhbGwodCkuc2xpY2UoOCwtMSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihudWxsPT10KXRocm93IFR5cGVFcnJvcihcIkNhbid0IGNhbGwgbWV0aG9kIG9uIFwiK3QpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlKXt2YXIgcjtyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9KCk7dHJ5e3I9cnx8bmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKX1jYXRjaCh0KXtcIm9iamVjdFwiPT10eXBlb2Ygd2luZG93JiYocj13aW5kb3cpfXQuZXhwb3J0cz1yfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3KSxpPXIoNTkpLG89cigzMSksYT1yKDEyKSxzPXIoNDMpLHU9cigxMyksYz1yKDk5KSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7ZS5mPW4/ZjpmdW5jdGlvbih0LGUpe2lmKHQ9YSh0KSxlPXMoZSwhMCksYyl0cnl7cmV0dXJuIGYodCxlKX1jYXRjaCh0KXt9aWYodSh0LGUpKXJldHVybiBvKCFpLmYuY2FsbCh0LGUpLHRbZV0pfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTUpLGk9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3ZhciBlPVtdO2Zvcih2YXIgciBpbiB0KWUucHVzaChyKTtyZXR1cm4gZX07dC5leHBvcnRzPWw7dmFyIG89cigzOSk7by5pbmhlcml0cz1yKDI5KTt2YXIgYT1yKDEzOCkscz1yKDk1KTtvLmluaGVyaXRzKGwsYSk7Zm9yKHZhciB1PWkocy5wcm90b3R5cGUpLGM9MDtjPHUubGVuZ3RoO2MrKyl7dmFyIGY9dVtjXTtsLnByb3RvdHlwZVtmXXx8KGwucHJvdG90eXBlW2ZdPXMucHJvdG90eXBlW2ZdKX1mdW5jdGlvbiBsKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGwpKXJldHVybiBuZXcgbCh0KTthLmNhbGwodGhpcyx0KSxzLmNhbGwodGhpcyx0KSx0JiYhMT09PXQucmVhZGFibGUmJih0aGlzLnJlYWRhYmxlPSExKSx0JiYhMT09PXQud3JpdGFibGUmJih0aGlzLndyaXRhYmxlPSExKSx0aGlzLmFsbG93SGFsZk9wZW49ITAsdCYmITE9PT10LmFsbG93SGFsZk9wZW4mJih0aGlzLmFsbG93SGFsZk9wZW49ITEpLHRoaXMub25jZShcImVuZFwiLGgpfWZ1bmN0aW9uIGgoKXt0aGlzLmFsbG93SGFsZk9wZW58fHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWR8fG4ubmV4dFRpY2socCx0aGlzKX1mdW5jdGlvbiBwKHQpe3QuZW5kKCl9T2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3JlYWRhYmxlU3RhdGUmJnZvaWQgMCE9PXRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQpfSxzZXQ6ZnVuY3Rpb24odCl7dm9pZCAwIT09dGhpcy5fcmVhZGFibGVTdGF0ZSYmdm9pZCAwIT09dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPXQsdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9dCl9fSksbC5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLnB1c2gobnVsbCksdGhpcy5lbmQoKSxuLm5leHRUaWNrKGUsdCl9fSxmdW5jdGlvbih0LGUscil7dmFyIG4saSxvLGE9cigxNDcpLHM9cig0KSx1PXIoMTApLGM9cigxNCksZj1yKDEzKSxsPXIoNDQpLGg9cig0NSkscD1zLldlYWtNYXA7aWYoYSl7dmFyIGQ9bmV3IHAsdj1kLmdldCxnPWQuaGFzLHk9ZC5zZXQ7bj1mdW5jdGlvbih0LGUpe3JldHVybiB5LmNhbGwoZCx0LGUpLGV9LGk9ZnVuY3Rpb24odCl7cmV0dXJuIHYuY2FsbChkLHQpfHx7fX0sbz1mdW5jdGlvbih0KXtyZXR1cm4gZy5jYWxsKGQsdCl9fWVsc2V7dmFyIGI9bChcInN0YXRlXCIpO2hbYl09ITAsbj1mdW5jdGlvbih0LGUpe3JldHVybiBjKHQsYixlKSxlfSxpPWZ1bmN0aW9uKHQpe3JldHVybiBmKHQsYik/dFtiXTp7fX0sbz1mdW5jdGlvbih0KXtyZXR1cm4gZih0LGIpfX10LmV4cG9ydHM9e3NldDpuLGdldDppLGhhczpvLGVuZm9yY2U6ZnVuY3Rpb24odCl7cmV0dXJuIG8odCk/aSh0KTpuKHQse30pfSxnZXR0ZXJGb3I6ZnVuY3Rpb24odCl7cmV0dXJuIGZ1bmN0aW9uKGUpe3ZhciByO2lmKCF1KGUpfHwocj1pKGUpKS50eXBlIT09dCl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK3QrXCIgcmVxdWlyZWRcIik7cmV0dXJuIHJ9fX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPSExfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMDMpLGk9cig0KSxvPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/dDp2b2lkIDB9O3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/byhuW3RdKXx8byhpW3RdKTpuW3RdJiZuW3RdW2VdfHxpW3RdJiZpW3RdW2VdfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMjApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0KG4odCkpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPWZ1bmN0aW9uKHQpe1widXNlIHN0cmljdFwiO3ZhciBlPU9iamVjdC5wcm90b3R5cGUscj1lLmhhc093blByb3BlcnR5LG49XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sP1N5bWJvbDp7fSxpPW4uaXRlcmF0b3J8fFwiQEBpdGVyYXRvclwiLG89bi5hc3luY0l0ZXJhdG9yfHxcIkBAYXN5bmNJdGVyYXRvclwiLGE9bi50b1N0cmluZ1RhZ3x8XCJAQHRvU3RyaW5nVGFnXCI7ZnVuY3Rpb24gcyh0LGUscixuKXt2YXIgaT1lJiZlLnByb3RvdHlwZSBpbnN0YW5jZW9mIGY/ZTpmLG89T2JqZWN0LmNyZWF0ZShpLnByb3RvdHlwZSksYT1uZXcgeChufHxbXSk7cmV0dXJuIG8uX2ludm9rZT1mdW5jdGlvbih0LGUscil7dmFyIG49XCJzdXNwZW5kZWRTdGFydFwiO3JldHVybiBmdW5jdGlvbihpLG8pe2lmKFwiZXhlY3V0aW5nXCI9PT1uKXRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7aWYoXCJjb21wbGV0ZWRcIj09PW4pe2lmKFwidGhyb3dcIj09PWkpdGhyb3cgbztyZXR1cm4gRSgpfWZvcihyLm1ldGhvZD1pLHIuYXJnPW87Oyl7dmFyIGE9ci5kZWxlZ2F0ZTtpZihhKXt2YXIgcz1fKGEscik7aWYocyl7aWYocz09PWMpY29udGludWU7cmV0dXJuIHN9fWlmKFwibmV4dFwiPT09ci5tZXRob2Qpci5zZW50PXIuX3NlbnQ9ci5hcmc7ZWxzZSBpZihcInRocm93XCI9PT1yLm1ldGhvZCl7aWYoXCJzdXNwZW5kZWRTdGFydFwiPT09bil0aHJvdyBuPVwiY29tcGxldGVkXCIsci5hcmc7ci5kaXNwYXRjaEV4Y2VwdGlvbihyLmFyZyl9ZWxzZVwicmV0dXJuXCI9PT1yLm1ldGhvZCYmci5hYnJ1cHQoXCJyZXR1cm5cIixyLmFyZyk7bj1cImV4ZWN1dGluZ1wiO3ZhciBmPXUodCxlLHIpO2lmKFwibm9ybWFsXCI9PT1mLnR5cGUpe2lmKG49ci5kb25lP1wiY29tcGxldGVkXCI6XCJzdXNwZW5kZWRZaWVsZFwiLGYuYXJnPT09Yyljb250aW51ZTtyZXR1cm57dmFsdWU6Zi5hcmcsZG9uZTpyLmRvbmV9fVwidGhyb3dcIj09PWYudHlwZSYmKG49XCJjb21wbGV0ZWRcIixyLm1ldGhvZD1cInRocm93XCIsci5hcmc9Zi5hcmcpfX19KHQscixhKSxvfWZ1bmN0aW9uIHUodCxlLHIpe3RyeXtyZXR1cm57dHlwZTpcIm5vcm1hbFwiLGFyZzp0LmNhbGwoZSxyKX19Y2F0Y2godCl7cmV0dXJue3R5cGU6XCJ0aHJvd1wiLGFyZzp0fX19dC53cmFwPXM7dmFyIGM9e307ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBsKCl7fWZ1bmN0aW9uIGgoKXt9dmFyIHA9e307cFtpXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt2YXIgZD1PYmplY3QuZ2V0UHJvdG90eXBlT2Ysdj1kJiZkKGQoayhbXSkpKTt2JiZ2IT09ZSYmci5jYWxsKHYsaSkmJihwPXYpO3ZhciBnPWgucHJvdG90eXBlPWYucHJvdG90eXBlPU9iamVjdC5jcmVhdGUocCk7ZnVuY3Rpb24geSh0KXtbXCJuZXh0XCIsXCJ0aHJvd1wiLFwicmV0dXJuXCJdLmZvckVhY2goKGZ1bmN0aW9uKGUpe3RbZV09ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuX2ludm9rZShlLHQpfX0pKX1mdW5jdGlvbiBiKHQpe3ZhciBlO3RoaXMuX2ludm9rZT1mdW5jdGlvbihuLGkpe2Z1bmN0aW9uIG8oKXtyZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKGUsbyl7IWZ1bmN0aW9uIGUobixpLG8sYSl7dmFyIHM9dSh0W25dLHQsaSk7aWYoXCJ0aHJvd1wiIT09cy50eXBlKXt2YXIgYz1zLmFyZyxmPWMudmFsdWU7cmV0dXJuIGYmJlwib2JqZWN0XCI9PXR5cGVvZiBmJiZyLmNhbGwoZixcIl9fYXdhaXRcIik/UHJvbWlzZS5yZXNvbHZlKGYuX19hd2FpdCkudGhlbigoZnVuY3Rpb24odCl7ZShcIm5leHRcIix0LG8sYSl9KSwoZnVuY3Rpb24odCl7ZShcInRocm93XCIsdCxvLGEpfSkpOlByb21pc2UucmVzb2x2ZShmKS50aGVuKChmdW5jdGlvbih0KXtjLnZhbHVlPXQsbyhjKX0pLChmdW5jdGlvbih0KXtyZXR1cm4gZShcInRocm93XCIsdCxvLGEpfSkpfWEocy5hcmcpfShuLGksZSxvKX0pKX1yZXR1cm4gZT1lP2UudGhlbihvLG8pOm8oKX19ZnVuY3Rpb24gXyh0LGUpe3ZhciByPXQuaXRlcmF0b3JbZS5tZXRob2RdO2lmKHZvaWQgMD09PXIpe2lmKGUuZGVsZWdhdGU9bnVsbCxcInRocm93XCI9PT1lLm1ldGhvZCl7aWYodC5pdGVyYXRvci5yZXR1cm4mJihlLm1ldGhvZD1cInJldHVyblwiLGUuYXJnPXZvaWQgMCxfKHQsZSksXCJ0aHJvd1wiPT09ZS5tZXRob2QpKXJldHVybiBjO2UubWV0aG9kPVwidGhyb3dcIixlLmFyZz1uZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKX1yZXR1cm4gY312YXIgbj11KHIsdC5pdGVyYXRvcixlLmFyZyk7aWYoXCJ0aHJvd1wiPT09bi50eXBlKXJldHVybiBlLm1ldGhvZD1cInRocm93XCIsZS5hcmc9bi5hcmcsZS5kZWxlZ2F0ZT1udWxsLGM7dmFyIGk9bi5hcmc7cmV0dXJuIGk/aS5kb25lPyhlW3QucmVzdWx0TmFtZV09aS52YWx1ZSxlLm5leHQ9dC5uZXh0TG9jLFwicmV0dXJuXCIhPT1lLm1ldGhvZCYmKGUubWV0aG9kPVwibmV4dFwiLGUuYXJnPXZvaWQgMCksZS5kZWxlZ2F0ZT1udWxsLGMpOmk6KGUubWV0aG9kPVwidGhyb3dcIixlLmFyZz1uZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksZS5kZWxlZ2F0ZT1udWxsLGMpfWZ1bmN0aW9uIG0odCl7dmFyIGU9e3RyeUxvYzp0WzBdfTsxIGluIHQmJihlLmNhdGNoTG9jPXRbMV0pLDIgaW4gdCYmKGUuZmluYWxseUxvYz10WzJdLGUuYWZ0ZXJMb2M9dFszXSksdGhpcy50cnlFbnRyaWVzLnB1c2goZSl9ZnVuY3Rpb24gdyh0KXt2YXIgZT10LmNvbXBsZXRpb258fHt9O2UudHlwZT1cIm5vcm1hbFwiLGRlbGV0ZSBlLmFyZyx0LmNvbXBsZXRpb249ZX1mdW5jdGlvbiB4KHQpe3RoaXMudHJ5RW50cmllcz1be3RyeUxvYzpcInJvb3RcIn1dLHQuZm9yRWFjaChtLHRoaXMpLHRoaXMucmVzZXQoITApfWZ1bmN0aW9uIGsodCl7aWYodCl7dmFyIGU9dFtpXTtpZihlKXJldHVybiBlLmNhbGwodCk7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5uZXh0KXJldHVybiB0O2lmKCFpc05hTih0Lmxlbmd0aCkpe3ZhciBuPS0xLG89ZnVuY3Rpb24gZSgpe2Zvcig7KytuPHQubGVuZ3RoOylpZihyLmNhbGwodCxuKSlyZXR1cm4gZS52YWx1ZT10W25dLGUuZG9uZT0hMSxlO3JldHVybiBlLnZhbHVlPXZvaWQgMCxlLmRvbmU9ITAsZX07cmV0dXJuIG8ubmV4dD1vfX1yZXR1cm57bmV4dDpFfX1mdW5jdGlvbiBFKCl7cmV0dXJue3ZhbHVlOnZvaWQgMCxkb25lOiEwfX1yZXR1cm4gbC5wcm90b3R5cGU9Zy5jb25zdHJ1Y3Rvcj1oLGguY29uc3RydWN0b3I9bCxoW2FdPWwuZGlzcGxheU5hbWU9XCJHZW5lcmF0b3JGdW5jdGlvblwiLHQuaXNHZW5lcmF0b3JGdW5jdGlvbj1mdW5jdGlvbih0KXt2YXIgZT1cImZ1bmN0aW9uXCI9PXR5cGVvZiB0JiZ0LmNvbnN0cnVjdG9yO3JldHVybiEhZSYmKGU9PT1sfHxcIkdlbmVyYXRvckZ1bmN0aW9uXCI9PT0oZS5kaXNwbGF5TmFtZXx8ZS5uYW1lKSl9LHQubWFyaz1mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mP09iamVjdC5zZXRQcm90b3R5cGVPZih0LGgpOih0Ll9fcHJvdG9fXz1oLGEgaW4gdHx8KHRbYV09XCJHZW5lcmF0b3JGdW5jdGlvblwiKSksdC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShnKSx0fSx0LmF3cmFwPWZ1bmN0aW9uKHQpe3JldHVybntfX2F3YWl0OnR9fSx5KGIucHJvdG90eXBlKSxiLnByb3RvdHlwZVtvXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfSx0LkFzeW5jSXRlcmF0b3I9Yix0LmFzeW5jPWZ1bmN0aW9uKGUscixuLGkpe3ZhciBvPW5ldyBiKHMoZSxyLG4saSkpO3JldHVybiB0LmlzR2VuZXJhdG9yRnVuY3Rpb24ocik/bzpvLm5leHQoKS50aGVuKChmdW5jdGlvbih0KXtyZXR1cm4gdC5kb25lP3QudmFsdWU6by5uZXh0KCl9KSl9LHkoZyksZ1thXT1cIkdlbmVyYXRvclwiLGdbaV09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30sZy50b1N0cmluZz1mdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBHZW5lcmF0b3JdXCJ9LHQua2V5cz1mdW5jdGlvbih0KXt2YXIgZT1bXTtmb3IodmFyIHIgaW4gdCllLnB1c2gocik7cmV0dXJuIGUucmV2ZXJzZSgpLGZ1bmN0aW9uIHIoKXtmb3IoO2UubGVuZ3RoOyl7dmFyIG49ZS5wb3AoKTtpZihuIGluIHQpcmV0dXJuIHIudmFsdWU9bixyLmRvbmU9ITEscn1yZXR1cm4gci5kb25lPSEwLHJ9fSx0LnZhbHVlcz1rLHgucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp4LHJlc2V0OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHJldj0wLHRoaXMubmV4dD0wLHRoaXMuc2VudD10aGlzLl9zZW50PXZvaWQgMCx0aGlzLmRvbmU9ITEsdGhpcy5kZWxlZ2F0ZT1udWxsLHRoaXMubWV0aG9kPVwibmV4dFwiLHRoaXMuYXJnPXZvaWQgMCx0aGlzLnRyeUVudHJpZXMuZm9yRWFjaCh3KSwhdClmb3IodmFyIGUgaW4gdGhpcylcInRcIj09PWUuY2hhckF0KDApJiZyLmNhbGwodGhpcyxlKSYmIWlzTmFOKCtlLnNsaWNlKDEpKSYmKHRoaXNbZV09dm9pZCAwKX0sc3RvcDpmdW5jdGlvbigpe3RoaXMuZG9uZT0hMDt2YXIgdD10aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjtpZihcInRocm93XCI9PT10LnR5cGUpdGhyb3cgdC5hcmc7cmV0dXJuIHRoaXMucnZhbH0sZGlzcGF0Y2hFeGNlcHRpb246ZnVuY3Rpb24odCl7aWYodGhpcy5kb25lKXRocm93IHQ7dmFyIGU9dGhpcztmdW5jdGlvbiBuKHIsbil7cmV0dXJuIGEudHlwZT1cInRocm93XCIsYS5hcmc9dCxlLm5leHQ9cixuJiYoZS5tZXRob2Q9XCJuZXh0XCIsZS5hcmc9dm9pZCAwKSwhIW59Zm9yKHZhciBpPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtpPj0wOy0taSl7dmFyIG89dGhpcy50cnlFbnRyaWVzW2ldLGE9by5jb21wbGV0aW9uO2lmKFwicm9vdFwiPT09by50cnlMb2MpcmV0dXJuIG4oXCJlbmRcIik7aWYoby50cnlMb2M8PXRoaXMucHJldil7dmFyIHM9ci5jYWxsKG8sXCJjYXRjaExvY1wiKSx1PXIuY2FsbChvLFwiZmluYWxseUxvY1wiKTtpZihzJiZ1KXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gbihvLmNhdGNoTG9jLCEwKTtpZih0aGlzLnByZXY8by5maW5hbGx5TG9jKXJldHVybiBuKG8uZmluYWxseUxvYyl9ZWxzZSBpZihzKXtpZih0aGlzLnByZXY8by5jYXRjaExvYylyZXR1cm4gbihvLmNhdGNoTG9jLCEwKX1lbHNle2lmKCF1KXRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpO2lmKHRoaXMucHJldjxvLmZpbmFsbHlMb2MpcmV0dXJuIG4oby5maW5hbGx5TG9jKX19fX0sYWJydXB0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtuPj0wOy0tbil7dmFyIGk9dGhpcy50cnlFbnRyaWVzW25dO2lmKGkudHJ5TG9jPD10aGlzLnByZXYmJnIuY2FsbChpLFwiZmluYWxseUxvY1wiKSYmdGhpcy5wcmV2PGkuZmluYWxseUxvYyl7dmFyIG89aTticmVha319byYmKFwiYnJlYWtcIj09PXR8fFwiY29udGludWVcIj09PXQpJiZvLnRyeUxvYzw9ZSYmZTw9by5maW5hbGx5TG9jJiYobz1udWxsKTt2YXIgYT1vP28uY29tcGxldGlvbjp7fTtyZXR1cm4gYS50eXBlPXQsYS5hcmc9ZSxvPyh0aGlzLm1ldGhvZD1cIm5leHRcIix0aGlzLm5leHQ9by5maW5hbGx5TG9jLGMpOnRoaXMuY29tcGxldGUoYSl9LGNvbXBsZXRlOmZ1bmN0aW9uKHQsZSl7aWYoXCJ0aHJvd1wiPT09dC50eXBlKXRocm93IHQuYXJnO3JldHVyblwiYnJlYWtcIj09PXQudHlwZXx8XCJjb250aW51ZVwiPT09dC50eXBlP3RoaXMubmV4dD10LmFyZzpcInJldHVyblwiPT09dC50eXBlPyh0aGlzLnJ2YWw9dGhpcy5hcmc9dC5hcmcsdGhpcy5tZXRob2Q9XCJyZXR1cm5cIix0aGlzLm5leHQ9XCJlbmRcIik6XCJub3JtYWxcIj09PXQudHlwZSYmZSYmKHRoaXMubmV4dD1lKSxjfSxmaW5pc2g6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMudHJ5RW50cmllcy5sZW5ndGgtMTtlPj0wOy0tZSl7dmFyIHI9dGhpcy50cnlFbnRyaWVzW2VdO2lmKHIuZmluYWxseUxvYz09PXQpcmV0dXJuIHRoaXMuY29tcGxldGUoci5jb21wbGV0aW9uLHIuYWZ0ZXJMb2MpLHcociksY319LGNhdGNoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnRyeUVudHJpZXMubGVuZ3RoLTE7ZT49MDstLWUpe3ZhciByPXRoaXMudHJ5RW50cmllc1tlXTtpZihyLnRyeUxvYz09PXQpe3ZhciBuPXIuY29tcGxldGlvbjtpZihcInRocm93XCI9PT1uLnR5cGUpe3ZhciBpPW4uYXJnO3cocil9cmV0dXJuIGl9fXRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKX0sZGVsZWdhdGVZaWVsZDpmdW5jdGlvbih0LGUscil7cmV0dXJuIHRoaXMuZGVsZWdhdGU9e2l0ZXJhdG9yOmsodCkscmVzdWx0TmFtZTplLG5leHRMb2M6cn0sXCJuZXh0XCI9PT10aGlzLm1ldGhvZCYmKHRoaXMuYXJnPXZvaWQgMCksY319LHR9KHQuZXhwb3J0cyk7dHJ5e3JlZ2VuZXJhdG9yUnVudGltZT1ufWNhdGNoKHQpe0Z1bmN0aW9uKFwiclwiLFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShuKX19LGZ1bmN0aW9uKHQsZSl7XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmNyZWF0ZT90LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt0LnN1cGVyXz1lLHQucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoZS5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTp0LGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pfTp0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt0LnN1cGVyXz1lO3ZhciByPWZ1bmN0aW9uKCl7fTtyLnByb3RvdHlwZT1lLnByb3RvdHlwZSx0LnByb3RvdHlwZT1uZXcgcix0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10fX0sZnVuY3Rpb24odCxlKXtmdW5jdGlvbiByKHQsZSl7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPWVbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LG4ua2V5LG4pfX10LmV4cG9ydHM9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBlJiZyKHQucHJvdG90eXBlLGUpLG4mJnIodCxuKSx0fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtyZXR1cm57ZW51bWVyYWJsZTohKDEmdCksY29uZmlndXJhYmxlOiEoMiZ0KSx3cml0YWJsZTohKDQmdCksdmFsdWU6ZX19fSxmdW5jdGlvbih0LGUpe3ZhciByPU1hdGguY2VpbCxuPU1hdGguZmxvb3I7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybiBpc05hTih0PSt0KT8wOih0PjA/bjpyKSh0KX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcxKSxpPXIoNjApLG89cigyNyksYT1yKDE1KSxzPXIoMTEyKSx1PVtdLnB1c2gsYz1mdW5jdGlvbih0KXt2YXIgZT0xPT10LHI9Mj09dCxjPTM9PXQsZj00PT10LGw9Nj09dCxoPTU9PXR8fGw7cmV0dXJuIGZ1bmN0aW9uKHAsZCx2LGcpe2Zvcih2YXIgeSxiLF89byhwKSxtPWkoXyksdz1uKGQsdiwzKSx4PWEobS5sZW5ndGgpLGs9MCxFPWd8fHMsUz1lP0UocCx4KTpyP0UocCwwKTp2b2lkIDA7eD5rO2srKylpZigoaHx8ayBpbiBtKSYmKGI9dyh5PW1ba10sayxfKSx0KSlpZihlKVNba109YjtlbHNlIGlmKGIpc3dpdGNoKHQpe2Nhc2UgMzpyZXR1cm4hMDtjYXNlIDU6cmV0dXJuIHk7Y2FzZSA2OnJldHVybiBrO2Nhc2UgMjp1LmNhbGwoUyx5KX1lbHNlIGlmKGYpcmV0dXJuITE7cmV0dXJuIGw/LTE6Y3x8Zj9mOlN9fTt0LmV4cG9ydHM9e2ZvckVhY2g6YygwKSxtYXA6YygxKSxmaWx0ZXI6YygyKSxzb21lOmMoMyksZXZlcnk6Yyg0KSxmaW5kOmMoNSksZmluZEluZGV4OmMoNil9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz17fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDUzKTtuKHt0YXJnZXQ6XCJSZWdFeHBcIixwcm90bzohMCxmb3JjZWQ6Ly4vLmV4ZWMhPT1pfSx7ZXhlYzppfSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPVtdW3RdO3JldHVybiFyfHwhbigoZnVuY3Rpb24oKXtyLmNhbGwobnVsbCxlfHxmdW5jdGlvbigpe3Rocm93IDF9LDEpfSkpfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDMzKS5tYXAsbz1yKDUpLGE9cig1NCkoXCJtYXBcIikscz1hJiYhbygoZnVuY3Rpb24oKXtbXS5tYXAuY2FsbCh7bGVuZ3RoOi0xLDA6MX0sKGZ1bmN0aW9uKHQpe3Rocm93IHR9KSl9KSk7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWF8fCFzfSx7bWFwOmZ1bmN0aW9uKHQpe3JldHVybiBpKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpPXQuZXhwb3J0cz17fTtmdW5jdGlvbiBvKCl7dGhyb3cgbmV3IEVycm9yKFwic2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBhKCl7dGhyb3cgbmV3IEVycm9yKFwiY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkXCIpfWZ1bmN0aW9uIHModCl7aWYocj09PXNldFRpbWVvdXQpcmV0dXJuIHNldFRpbWVvdXQodCwwKTtpZigocj09PW98fCFyKSYmc2V0VGltZW91dClyZXR1cm4gcj1zZXRUaW1lb3V0LHNldFRpbWVvdXQodCwwKTt0cnl7cmV0dXJuIHIodCwwKX1jYXRjaChlKXt0cnl7cmV0dXJuIHIuY2FsbChudWxsLHQsMCl9Y2F0Y2goZSl7cmV0dXJuIHIuY2FsbCh0aGlzLHQsMCl9fX0hZnVuY3Rpb24oKXt0cnl7cj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBzZXRUaW1lb3V0P3NldFRpbWVvdXQ6b31jYXRjaCh0KXtyPW99dHJ5e249XCJmdW5jdGlvblwiPT10eXBlb2YgY2xlYXJUaW1lb3V0P2NsZWFyVGltZW91dDphfWNhdGNoKHQpe249YX19KCk7dmFyIHUsYz1bXSxmPSExLGw9LTE7ZnVuY3Rpb24gaCgpe2YmJnUmJihmPSExLHUubGVuZ3RoP2M9dS5jb25jYXQoYyk6bD0tMSxjLmxlbmd0aCYmcCgpKX1mdW5jdGlvbiBwKCl7aWYoIWYpe3ZhciB0PXMoaCk7Zj0hMDtmb3IodmFyIGU9Yy5sZW5ndGg7ZTspe2Zvcih1PWMsYz1bXTsrK2w8ZTspdSYmdVtsXS5ydW4oKTtsPS0xLGU9Yy5sZW5ndGh9dT1udWxsLGY9ITEsZnVuY3Rpb24odCl7aWYobj09PWNsZWFyVGltZW91dClyZXR1cm4gY2xlYXJUaW1lb3V0KHQpO2lmKChuPT09YXx8IW4pJiZjbGVhclRpbWVvdXQpcmV0dXJuIG49Y2xlYXJUaW1lb3V0LGNsZWFyVGltZW91dCh0KTt0cnl7bih0KX1jYXRjaChlKXt0cnl7cmV0dXJuIG4uY2FsbChudWxsLHQpfWNhdGNoKGUpe3JldHVybiBuLmNhbGwodGhpcyx0KX19fSh0KX19ZnVuY3Rpb24gZCh0LGUpe3RoaXMuZnVuPXQsdGhpcy5hcnJheT1lfWZ1bmN0aW9uIHYoKXt9aS5uZXh0VGljaz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aC0xKTtpZihhcmd1bWVudHMubGVuZ3RoPjEpZm9yKHZhciByPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllW3ItMV09YXJndW1lbnRzW3JdO2MucHVzaChuZXcgZCh0LGUpKSwxIT09Yy5sZW5ndGh8fGZ8fHMocCl9LGQucHJvdG90eXBlLnJ1bj1mdW5jdGlvbigpe3RoaXMuZnVuLmFwcGx5KG51bGwsdGhpcy5hcnJheSl9LGkudGl0bGU9XCJicm93c2VyXCIsaS5icm93c2VyPSEwLGkuZW52PXt9LGkuYXJndj1bXSxpLnZlcnNpb249XCJcIixpLnZlcnNpb25zPXt9LGkub249dixpLmFkZExpc3RlbmVyPXYsaS5vbmNlPXYsaS5vZmY9dixpLnJlbW92ZUxpc3RlbmVyPXYsaS5yZW1vdmVBbGxMaXN0ZW5lcnM9dixpLmVtaXQ9dixpLnByZXBlbmRMaXN0ZW5lcj12LGkucHJlcGVuZE9uY2VMaXN0ZW5lcj12LGkubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybltdfSxpLmJpbmRpbmc9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIil9LGkuY3dkPWZ1bmN0aW9uKCl7cmV0dXJuXCIvXCJ9LGkuY2hkaXI9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IEVycm9yKFwicHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkXCIpfSxpLnVtYXNrPWZ1bmN0aW9uKCl7cmV0dXJuIDB9fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe2Z1bmN0aW9uIHIodCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1lLmlzQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIEFycmF5LmlzQXJyYXk/QXJyYXkuaXNBcnJheSh0KTpcIltvYmplY3QgQXJyYXldXCI9PT1yKHQpfSxlLmlzQm9vbGVhbj1mdW5jdGlvbih0KXtyZXR1cm5cImJvb2xlYW5cIj09dHlwZW9mIHR9LGUuaXNOdWxsPWZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dH0sZS5pc051bGxPclVuZGVmaW5lZD1mdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09dH0sZS5pc051bWJlcj1mdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdH0sZS5pc1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdH0sZS5pc1N5bWJvbD1mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH0sZS5pc1VuZGVmaW5lZD1mdW5jdGlvbih0KXtyZXR1cm4gdm9pZCAwPT09dH0sZS5pc1JlZ0V4cD1mdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgUmVnRXhwXVwiPT09cih0KX0sZS5pc09iamVjdD1mdW5jdGlvbih0KXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgdCYmbnVsbCE9PXR9LGUuaXNEYXRlPWZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBEYXRlXVwiPT09cih0KX0sZS5pc0Vycm9yPWZ1bmN0aW9uKHQpe3JldHVyblwiW29iamVjdCBFcnJvcl1cIj09PXIodCl8fHQgaW5zdGFuY2VvZiBFcnJvcn0sZS5pc0Z1bmN0aW9uPWZ1bmN0aW9uKHQpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIHR9LGUuaXNQcmltaXRpdmU9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10fHxcImJvb2xlYW5cIj09dHlwZW9mIHR8fFwibnVtYmVyXCI9PXR5cGVvZiB0fHxcInN0cmluZ1wiPT10eXBlb2YgdHx8XCJzeW1ib2xcIj09dHlwZW9mIHR8fHZvaWQgMD09PXR9LGUuaXNCdWZmZXI9dC5pc0J1ZmZlcn0pLmNhbGwodGhpcyxyKDkyKS5CdWZmZXIpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig5NiksaT1yKDE1NSk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIWV8fFwib2JqZWN0XCIhPT1uKGUpJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiBlP2kodCk6ZX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBlJiZudWxsIT09ZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlJiZlLnByb3RvdHlwZSx7Y29uc3RydWN0b3I6e3ZhbHVlOnQsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGUmJm4odCxlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDE2NiksaT1yKDE2Nyksbz1yKDE2OCk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4odCl8fGkodCxlKXx8bygpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKCFuKHQpKXJldHVybiB0O3ZhciByLGk7aWYoZSYmXCJmdW5jdGlvblwiPT10eXBlb2Yocj10LnRvU3RyaW5nKSYmIW4oaT1yLmNhbGwodCkpKXJldHVybiBpO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mKHI9dC52YWx1ZU9mKSYmIW4oaT1yLmNhbGwodCkpKXJldHVybiBpO2lmKCFlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZihyPXQudG9TdHJpbmcpJiYhbihpPXIuY2FsbCh0KSkpcmV0dXJuIGk7dGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNjQpLGk9cig2NSksbz1uKFwia2V5c1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIG9bdF18fChvW3RdPWkodCkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e319LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwNCksaT1yKDY3KS5jb25jYXQoXCJsZW5ndGhcIixcInByb3RvdHlwZVwiKTtlLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsaSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxOSk7dC5leHBvcnRzPUFycmF5LmlzQXJyYXl8fGZ1bmN0aW9uKHQpe3JldHVyblwiQXJyYXlcIj09bih0KX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwNCksaT1yKDY3KTt0LmV4cG9ydHM9T2JqZWN0LmtleXN8fGZ1bmN0aW9uKHQpe3JldHVybiBuKHQsaSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMSkuZixpPXIoMTMpLG89cigzKShcInRvU3RyaW5nVGFnXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dCYmIWkodD1yP3Q6dC5wcm90b3R5cGUsbykmJm4odCxvLHtjb25maWd1cmFibGU6ITAsdmFsdWU6ZX0pfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKHQpK1wiIGlzIG5vdCBhIGZ1bmN0aW9uXCIpO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTIpLGk9cigxMTMpLG89cigzNCksYT1yKDI0KSxzPXIoMTE0KSx1PWEuc2V0LGM9YS5nZXR0ZXJGb3IoXCJBcnJheSBJdGVyYXRvclwiKTt0LmV4cG9ydHM9cyhBcnJheSxcIkFycmF5XCIsKGZ1bmN0aW9uKHQsZSl7dSh0aGlzLHt0eXBlOlwiQXJyYXkgSXRlcmF0b3JcIix0YXJnZXQ6bih0KSxpbmRleDowLGtpbmQ6ZX0pfSksKGZ1bmN0aW9uKCl7dmFyIHQ9Yyh0aGlzKSxlPXQudGFyZ2V0LHI9dC5raW5kLG49dC5pbmRleCsrO3JldHVybiFlfHxuPj1lLmxlbmd0aD8odC50YXJnZXQ9dm9pZCAwLHt2YWx1ZTp2b2lkIDAsZG9uZTohMH0pOlwia2V5c1wiPT1yP3t2YWx1ZTpuLGRvbmU6ITF9OlwidmFsdWVzXCI9PXI/e3ZhbHVlOmVbbl0sZG9uZTohMX06e3ZhbHVlOltuLGVbbl1dLGRvbmU6ITF9fSksXCJ2YWx1ZXNcIiksby5Bcmd1bWVudHM9by5BcnJheSxpKFwia2V5c1wiKSxpKFwidmFsdWVzXCIpLGkoXCJlbnRyaWVzXCIpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig3MiksaT1yKDE3KSxvPXIoMTU0KTtufHxpKE9iamVjdC5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLG8se3Vuc2FmZTohMH0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvPXIoNzMpLGE9cigxMTkpLHM9UmVnRXhwLnByb3RvdHlwZS5leGVjLHU9U3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlLGM9cyxmPShuPS9hLyxpPS9iKi9nLHMuY2FsbChuLFwiYVwiKSxzLmNhbGwoaSxcImFcIiksMCE9PW4ubGFzdEluZGV4fHwwIT09aS5sYXN0SW5kZXgpLGw9YS5VTlNVUFBPUlRFRF9ZfHxhLkJST0tFTl9DQVJFVCxoPXZvaWQgMCE9PS8oKT8/Ly5leGVjKFwiXCIpWzFdOyhmfHxofHxsKSYmKGM9ZnVuY3Rpb24odCl7dmFyIGUscixuLGksYT10aGlzLGM9bCYmYS5zdGlja3kscD1vLmNhbGwoYSksZD1hLnNvdXJjZSx2PTAsZz10O3JldHVybiBjJiYoLTE9PT0ocD1wLnJlcGxhY2UoXCJ5XCIsXCJcIikpLmluZGV4T2YoXCJnXCIpJiYocCs9XCJnXCIpLGc9U3RyaW5nKHQpLnNsaWNlKGEubGFzdEluZGV4KSxhLmxhc3RJbmRleD4wJiYoIWEubXVsdGlsaW5lfHxhLm11bHRpbGluZSYmXCJcXG5cIiE9PXRbYS5sYXN0SW5kZXgtMV0pJiYoZD1cIig/OiBcIitkK1wiKVwiLGc9XCIgXCIrZyx2KyspLHI9bmV3IFJlZ0V4cChcIl4oPzpcIitkK1wiKVwiLHApKSxoJiYocj1uZXcgUmVnRXhwKFwiXlwiK2QrXCIkKD8hXFxcXHMpXCIscCkpLGYmJihlPWEubGFzdEluZGV4KSxuPXMuY2FsbChjP3I6YSxnKSxjP24/KG4uaW5wdXQ9bi5pbnB1dC5zbGljZSh2KSxuWzBdPW5bMF0uc2xpY2Uodiksbi5pbmRleD1hLmxhc3RJbmRleCxhLmxhc3RJbmRleCs9blswXS5sZW5ndGgpOmEubGFzdEluZGV4PTA6ZiYmbiYmKGEubGFzdEluZGV4PWEuZ2xvYmFsP24uaW5kZXgrblswXS5sZW5ndGg6ZSksaCYmbiYmbi5sZW5ndGg+MSYmdS5jYWxsKG5bMF0sciwoZnVuY3Rpb24oKXtmb3IoaT0xO2k8YXJndW1lbnRzLmxlbmd0aC0yO2krKyl2b2lkIDA9PT1hcmd1bWVudHNbaV0mJihuW2ldPXZvaWQgMCl9KSksbn0pLHQuZXhwb3J0cz1jfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig1KSxpPXIoMyksbz1yKDgzKSxhPWkoXCJzcGVjaWVzXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gbz49NTF8fCFuKChmdW5jdGlvbigpe3ZhciBlPVtdO3JldHVybihlLmNvbnN0cnVjdG9yPXt9KVthXT1mdW5jdGlvbigpe3JldHVybntmb286MX19LDEhPT1lW3RdKEJvb2xlYW4pLmZvb30pKX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSl7IWUudmVyc2lvbnx8MD09PWUudmVyc2lvbi5pbmRleE9mKFwidjAuXCIpfHwwPT09ZS52ZXJzaW9uLmluZGV4T2YoXCJ2MS5cIikmJjAhPT1lLnZlcnNpb24uaW5kZXhPZihcInYxLjguXCIpP3QuZXhwb3J0cz17bmV4dFRpY2s6ZnVuY3Rpb24odCxyLG4saSl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7dmFyIG8sYSxzPWFyZ3VtZW50cy5sZW5ndGg7c3dpdGNoKHMpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIGUubmV4dFRpY2sodCk7Y2FzZSAyOnJldHVybiBlLm5leHRUaWNrKChmdW5jdGlvbigpe3QuY2FsbChudWxsLHIpfSkpO2Nhc2UgMzpyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmNhbGwobnVsbCxyLG4pfSkpO2Nhc2UgNDpyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmNhbGwobnVsbCxyLG4saSl9KSk7ZGVmYXVsdDpmb3Iobz1uZXcgQXJyYXkocy0xKSxhPTA7YTxvLmxlbmd0aDspb1thKytdPWFyZ3VtZW50c1thXTtyZXR1cm4gZS5uZXh0VGljaygoZnVuY3Rpb24oKXt0LmFwcGx5KG51bGwsbyl9KSl9fX06dC5leHBvcnRzPWV9KS5jYWxsKHRoaXMscigzOCkpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig5MiksaT1uLkJ1ZmZlcjtmdW5jdGlvbiBvKHQsZSl7Zm9yKHZhciByIGluIHQpZVtyXT10W3JdfWZ1bmN0aW9uIGEodCxlLHIpe3JldHVybiBpKHQsZSxyKX1pLmZyb20mJmkuYWxsb2MmJmkuYWxsb2NVbnNhZmUmJmkuYWxsb2NVbnNhZmVTbG93P3QuZXhwb3J0cz1uOihvKG4sZSksZS5CdWZmZXI9YSksbyhpLGEpLGEuZnJvbT1mdW5jdGlvbih0LGUscil7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyXCIpO3JldHVybiBpKHQsZSxyKX0sYS5hbGxvYz1mdW5jdGlvbih0LGUscil7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7dmFyIG49aSh0KTtyZXR1cm4gdm9pZCAwIT09ZT9cInN0cmluZ1wiPT10eXBlb2Ygcj9uLmZpbGwoZSxyKTpuLmZpbGwoZSk6bi5maWxsKDApLG59LGEuYWxsb2NVbnNhZmU9ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXJcIik7cmV0dXJuIGkodCl9LGEuYWxsb2NVbnNhZmVTbG93PWZ1bmN0aW9uKHQpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3JldHVybiBuLlNsb3dCdWZmZXIodCl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxNTYpO2Z1bmN0aW9uIGkoZSxyLG8pe3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBSZWZsZWN0JiZSZWZsZWN0LmdldD90LmV4cG9ydHM9aT1SZWZsZWN0LmdldDp0LmV4cG9ydHM9aT1mdW5jdGlvbih0LGUscil7dmFyIGk9bih0LGUpO2lmKGkpe3ZhciBvPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaSxlKTtyZXR1cm4gby5nZXQ/by5nZXQuY2FsbChyKTpvLnZhbHVlfX0saShlLHIsb3x8ZSl9dC5leHBvcnRzPWl9LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24obil7ZS5sb2c9ZnVuY3Rpb24oLi4udCl7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGNvbnNvbGUmJmNvbnNvbGUubG9nJiZjb25zb2xlLmxvZyguLi50KX0sZS5mb3JtYXRBcmdzPWZ1bmN0aW9uKGUpe2lmKGVbMF09KHRoaXMudXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodGhpcy51c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrZVswXSsodGhpcy51c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrdC5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZiksIXRoaXMudXNlQ29sb3JzKXJldHVybjtjb25zdCByPVwiY29sb3I6IFwiK3RoaXMuY29sb3I7ZS5zcGxpY2UoMSwwLHIsXCJjb2xvcjogaW5oZXJpdFwiKTtsZXQgbj0wLGk9MDtlWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZyx0PT57XCIlJVwiIT09dCYmKG4rKyxcIiVjXCI9PT10JiYoaT1uKSl9KSxlLnNwbGljZShpLDAscil9LGUuc2F2ZT1mdW5jdGlvbih0KXt0cnl7dD9lLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsdCk6ZS5zdG9yYWdlLnJlbW92ZUl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaCh0KXt9fSxlLmxvYWQ9ZnVuY3Rpb24oKXtsZXQgdDt0cnl7dD1lLnN0b3JhZ2UuZ2V0SXRlbShcImRlYnVnXCIpfWNhdGNoKHQpe30hdCYmdm9pZCAwIT09biYmXCJlbnZcImluIG4mJih0PW4uZW52LkRFQlVHKTtyZXR1cm4gdH0sZS51c2VDb2xvcnM9ZnVuY3Rpb24oKXtpZihcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cucHJvY2VzcyYmKFwicmVuZGVyZXJcIj09PXdpbmRvdy5wcm9jZXNzLnR5cGV8fHdpbmRvdy5wcm9jZXNzLl9fbndqcykpcmV0dXJuITA7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKXJldHVybiExO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmZpcmVidWd8fHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiYmd2luZG93LmNvbnNvbGUudGFibGUpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmcGFyc2VJbnQoUmVnRXhwLiQxLDEwKT49MzF8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKX0sZS5zdG9yYWdlPWZ1bmN0aW9uKCl7dHJ5e3JldHVybiBsb2NhbFN0b3JhZ2V9Y2F0Y2godCl7fX0oKSxlLmNvbG9ycz1bXCIjMDAwMENDXCIsXCIjMDAwMEZGXCIsXCIjMDAzM0NDXCIsXCIjMDAzM0ZGXCIsXCIjMDA2NkNDXCIsXCIjMDA2NkZGXCIsXCIjMDA5OUNDXCIsXCIjMDA5OUZGXCIsXCIjMDBDQzAwXCIsXCIjMDBDQzMzXCIsXCIjMDBDQzY2XCIsXCIjMDBDQzk5XCIsXCIjMDBDQ0NDXCIsXCIjMDBDQ0ZGXCIsXCIjMzMwMENDXCIsXCIjMzMwMEZGXCIsXCIjMzMzM0NDXCIsXCIjMzMzM0ZGXCIsXCIjMzM2NkNDXCIsXCIjMzM2NkZGXCIsXCIjMzM5OUNDXCIsXCIjMzM5OUZGXCIsXCIjMzNDQzAwXCIsXCIjMzNDQzMzXCIsXCIjMzNDQzY2XCIsXCIjMzNDQzk5XCIsXCIjMzNDQ0NDXCIsXCIjMzNDQ0ZGXCIsXCIjNjYwMENDXCIsXCIjNjYwMEZGXCIsXCIjNjYzM0NDXCIsXCIjNjYzM0ZGXCIsXCIjNjZDQzAwXCIsXCIjNjZDQzMzXCIsXCIjOTkwMENDXCIsXCIjOTkwMEZGXCIsXCIjOTkzM0NDXCIsXCIjOTkzM0ZGXCIsXCIjOTlDQzAwXCIsXCIjOTlDQzMzXCIsXCIjQ0MwMDAwXCIsXCIjQ0MwMDMzXCIsXCIjQ0MwMDY2XCIsXCIjQ0MwMDk5XCIsXCIjQ0MwMENDXCIsXCIjQ0MwMEZGXCIsXCIjQ0MzMzAwXCIsXCIjQ0MzMzMzXCIsXCIjQ0MzMzY2XCIsXCIjQ0MzMzk5XCIsXCIjQ0MzM0NDXCIsXCIjQ0MzM0ZGXCIsXCIjQ0M2NjAwXCIsXCIjQ0M2NjMzXCIsXCIjQ0M5OTAwXCIsXCIjQ0M5OTMzXCIsXCIjQ0NDQzAwXCIsXCIjQ0NDQzMzXCIsXCIjRkYwMDAwXCIsXCIjRkYwMDMzXCIsXCIjRkYwMDY2XCIsXCIjRkYwMDk5XCIsXCIjRkYwMENDXCIsXCIjRkYwMEZGXCIsXCIjRkYzMzAwXCIsXCIjRkYzMzMzXCIsXCIjRkYzMzY2XCIsXCIjRkYzMzk5XCIsXCIjRkYzM0NDXCIsXCIjRkYzM0ZGXCIsXCIjRkY2NjAwXCIsXCIjRkY2NjMzXCIsXCIjRkY5OTAwXCIsXCIjRkY5OTMzXCIsXCIjRkZDQzAwXCIsXCIjRkZDQzMzXCJdLHQuZXhwb3J0cz1yKDE3MikoZSk7Y29uc3R7Zm9ybWF0dGVyczppfT10LmV4cG9ydHM7aS5qPWZ1bmN0aW9uKHQpe3RyeXtyZXR1cm4gSlNPTi5zdHJpbmdpZnkodCl9Y2F0Y2godCl7cmV0dXJuXCJbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogXCIrdC5tZXNzYWdlfX19KS5jYWxsKHRoaXMscigzOCkpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49e30ucHJvcGVydHlJc0VudW1lcmFibGUsaT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLG89aSYmIW4uY2FsbCh7MToyfSwxKTtlLmY9bz9mdW5jdGlvbih0KXt2YXIgZT1pKHRoaXMsdCk7cmV0dXJuISFlJiZlLmVudW1lcmFibGV9Om59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUpLGk9cigxOSksbz1cIlwiLnNwbGl0O3QuZXhwb3J0cz1uKChmdW5jdGlvbigpe3JldHVybiFPYmplY3QoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSkpP2Z1bmN0aW9uKHQpe3JldHVyblwiU3RyaW5nXCI9PWkodCk/by5jYWxsKHQsXCJcIik6T2JqZWN0KHQpfTpPYmplY3R9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxMCksbz1uLmRvY3VtZW50LGE9aShvKSYmaShvLmNyZWF0ZUVsZW1lbnQpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtyZXR1cm4gYT9vLmNyZWF0ZUVsZW1lbnQodCk6e319fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoMTQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3RyeXtpKG4sdCxlKX1jYXRjaChyKXtuW3RdPWV9cmV0dXJuIGV9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMDApLGk9RnVuY3Rpb24udG9TdHJpbmc7XCJmdW5jdGlvblwiIT10eXBlb2Ygbi5pbnNwZWN0U291cmNlJiYobi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKHQpe3JldHVybiBpLmNhbGwodCl9KSx0LmV4cG9ydHM9bi5pbnNwZWN0U291cmNlfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyNSksaT1yKDEwMCk7KHQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3JldHVybiBpW3RdfHwoaVt0XT12b2lkIDAhPT1lP2U6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy42LjFcIixtb2RlOm4/XCJwdXJlXCI6XCJnbG9iYWxcIixjb3B5cmlnaHQ6XCLCqSAyMDE5IERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpXCJ9KX0sZnVuY3Rpb24odCxlKXt2YXIgcj0wLG49TWF0aC5yYW5kb20oKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuXCJTeW1ib2woXCIrU3RyaW5nKHZvaWQgMD09PXQ/XCJcIjp0KStcIilfXCIrKCsrcituKS50b1N0cmluZygzNil9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMiksaT1yKDE1KSxvPXIoMTA1KSxhPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlLHIsYSl7dmFyIHMsdT1uKGUpLGM9aSh1Lmxlbmd0aCksZj1vKGEsYyk7aWYodCYmciE9cil7Zm9yKDtjPmY7KWlmKChzPXVbZisrXSkhPXMpcmV0dXJuITB9ZWxzZSBmb3IoO2M+ZjtmKyspaWYoKHR8fGYgaW4gdSkmJnVbZl09PT1yKXJldHVybiB0fHxmfHwwO3JldHVybiF0JiYtMX19O3QuZXhwb3J0cz17aW5jbHVkZXM6YSghMCksaW5kZXhPZjphKCExKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPVtcImNvbnN0cnVjdG9yXCIsXCJoYXNPd25Qcm9wZXJ0eVwiLFwiaXNQcm90b3R5cGVPZlwiLFwicHJvcGVydHlJc0VudW1lcmFibGVcIixcInRvTG9jYWxlU3RyaW5nXCIsXCJ0b1N0cmluZ1wiLFwidmFsdWVPZlwiXX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNSksaT0vI3xcXC5wcm90b3R5cGVcXC4vLG89ZnVuY3Rpb24odCxlKXt2YXIgcj1zW2EodCldO3JldHVybiByPT1jfHxyIT11JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgZT9uKGUpOiEhZSl9LGE9by5ub3JtYWxpemU9ZnVuY3Rpb24odCl7cmV0dXJuIFN0cmluZyh0KS5yZXBsYWNlKGksXCIuXCIpLnRvTG93ZXJDYXNlKCl9LHM9by5kYXRhPXt9LHU9by5OQVRJVkU9XCJOXCIsYz1vLlBPTFlGSUxMPVwiUFwiO3QuZXhwb3J0cz1vfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig1KTt0LmV4cG9ydHM9ISFPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzJiYhbigoZnVuY3Rpb24oKXtyZXR1cm4hU3RyaW5nKFN5bWJvbCgpKX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9cig4KSxvPXIoMTA4KSxhPXIoNjcpLHM9cig0NSksdT1yKDEwOSksYz1yKDYxKSxmPXIoNDQpLGw9ZihcIklFX1BST1RPXCIpLGg9ZnVuY3Rpb24oKXt9LHA9ZnVuY3Rpb24odCl7cmV0dXJuXCI8c2NyaXB0PlwiK3QrXCI8XFwvc2NyaXB0PlwifSxkPWZ1bmN0aW9uKCl7dHJ5e249ZG9jdW1lbnQuZG9tYWluJiZuZXcgQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpfWNhdGNoKHQpe312YXIgdCxlO2Q9bj9mdW5jdGlvbih0KXt0LndyaXRlKHAoXCJcIikpLHQuY2xvc2UoKTt2YXIgZT10LnBhcmVudFdpbmRvdy5PYmplY3Q7cmV0dXJuIHQ9bnVsbCxlfShuKTooKGU9YyhcImlmcmFtZVwiKSkuc3R5bGUuZGlzcGxheT1cIm5vbmVcIix1LmFwcGVuZENoaWxkKGUpLGUuc3JjPVN0cmluZyhcImphdmFzY3JpcHQ6XCIpLCh0PWUuY29udGVudFdpbmRvdy5kb2N1bWVudCkub3BlbigpLHQud3JpdGUocChcImRvY3VtZW50LkY9T2JqZWN0XCIpKSx0LmNsb3NlKCksdC5GKTtmb3IodmFyIHI9YS5sZW5ndGg7ci0tOylkZWxldGUgZC5wcm90b3R5cGVbYVtyXV07cmV0dXJuIGQoKX07c1tsXT0hMCx0LmV4cG9ydHM9T2JqZWN0LmNyZWF0ZXx8ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gbnVsbCE9PXQ/KGgucHJvdG90eXBlPWkodCkscj1uZXcgaCxoLnByb3RvdHlwZT1udWxsLHJbbF09dCk6cj1kKCksdm9pZCAwPT09ZT9yOm8ocixlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUwKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe2lmKG4odCksdm9pZCAwPT09ZSlyZXR1cm4gdDtzd2l0Y2gocil7Y2FzZSAwOnJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmNhbGwoZSl9O2Nhc2UgMTpyZXR1cm4gZnVuY3Rpb24ocil7cmV0dXJuIHQuY2FsbChlLHIpfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKHIsbil7cmV0dXJuIHQuY2FsbChlLHIsbil9O2Nhc2UgMzpyZXR1cm4gZnVuY3Rpb24ocixuLGkpe3JldHVybiB0LmNhbGwoZSxyLG4saSl9fXJldHVybiBmdW5jdGlvbigpe3JldHVybiB0LmFwcGx5KGUsYXJndW1lbnRzKX19fSxmdW5jdGlvbih0LGUscil7dmFyIG49e307bltyKDMpKFwidG9TdHJpbmdUYWdcIildPVwielwiLHQuZXhwb3J0cz1cIltvYmplY3Qgel1cIj09PVN0cmluZyhuKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoOCk7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dmFyIHQ9bih0aGlzKSxlPVwiXCI7cmV0dXJuIHQuZ2xvYmFsJiYoZSs9XCJnXCIpLHQuaWdub3JlQ2FzZSYmKGUrPVwiaVwiKSx0Lm11bHRpbGluZSYmKGUrPVwibVwiKSx0LmRvdEFsbCYmKGUrPVwic1wiKSx0LnVuaWNvZGUmJihlKz1cInVcIiksdC5zdGlja3kmJihlKz1cInlcIiksZX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDEyMCkuY2hhckF0LGk9cigyNCksbz1yKDExNCksYT1pLnNldCxzPWkuZ2V0dGVyRm9yKFwiU3RyaW5nIEl0ZXJhdG9yXCIpO28oU3RyaW5nLFwiU3RyaW5nXCIsKGZ1bmN0aW9uKHQpe2EodGhpcyx7dHlwZTpcIlN0cmluZyBJdGVyYXRvclwiLHN0cmluZzpTdHJpbmcodCksaW5kZXg6MH0pfSksKGZ1bmN0aW9uKCl7dmFyIHQsZT1zKHRoaXMpLHI9ZS5zdHJpbmcsaT1lLmluZGV4O3JldHVybiBpPj1yLmxlbmd0aD97dmFsdWU6dm9pZCAwLGRvbmU6ITB9Oih0PW4ocixpKSxlLmluZGV4Kz10Lmxlbmd0aCx7dmFsdWU6dCxkb25lOiExfSl9KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDc2KSxpPXIoOCksbz1yKDE1KSxhPXIoMjApLHM9cig3NyksdT1yKDc4KTtuKFwibWF0Y2hcIiwxLChmdW5jdGlvbih0LGUscil7cmV0dXJuW2Z1bmN0aW9uKGUpe3ZhciByPWEodGhpcyksbj1udWxsPT1lP3ZvaWQgMDplW3RdO3JldHVybiB2b2lkIDAhPT1uP24uY2FsbChlLHIpOm5ldyBSZWdFeHAoZSlbdF0oU3RyaW5nKHIpKX0sZnVuY3Rpb24odCl7dmFyIG49cihlLHQsdGhpcyk7aWYobi5kb25lKXJldHVybiBuLnZhbHVlO3ZhciBhPWkodCksYz1TdHJpbmcodGhpcyk7aWYoIWEuZ2xvYmFsKXJldHVybiB1KGEsYyk7dmFyIGY9YS51bmljb2RlO2EubGFzdEluZGV4PTA7Zm9yKHZhciBsLGg9W10scD0wO251bGwhPT0obD11KGEsYykpOyl7dmFyIGQ9U3RyaW5nKGxbMF0pO2hbcF09ZCxcIlwiPT09ZCYmKGEubGFzdEluZGV4PXMoYyxvKGEubGFzdEluZGV4KSxmKSkscCsrfXJldHVybiAwPT09cD9udWxsOmh9XX0pKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTcpLGk9cig1KSxvPXIoMyksYT1yKDUzKSxzPXIoMTQpLHU9byhcInNwZWNpZXNcIiksYz0haSgoZnVuY3Rpb24oKXt2YXIgdD0vLi87cmV0dXJuIHQuZXhlYz1mdW5jdGlvbigpe3ZhciB0PVtdO3JldHVybiB0Lmdyb3Vwcz17YTpcIjdcIn0sdH0sXCI3XCIhPT1cIlwiLnJlcGxhY2UodCxcIiQ8YT5cIil9KSksZj1cIiQwXCI9PT1cImFcIi5yZXBsYWNlKC8uLyxcIiQwXCIpLGw9IWkoKGZ1bmN0aW9uKCl7dmFyIHQ9Lyg/OikvLGU9dC5leGVjO3QuZXhlYz1mdW5jdGlvbigpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07dmFyIHI9XCJhYlwiLnNwbGl0KHQpO3JldHVybiAyIT09ci5sZW5ndGh8fFwiYVwiIT09clswXXx8XCJiXCIhPT1yWzFdfSkpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixoKXt2YXIgcD1vKHQpLGQ9IWkoKGZ1bmN0aW9uKCl7dmFyIGU9e307cmV0dXJuIGVbcF09ZnVuY3Rpb24oKXtyZXR1cm4gN30sNyE9XCJcIlt0XShlKX0pKSx2PWQmJiFpKChmdW5jdGlvbigpe3ZhciBlPSExLHI9L2EvO3JldHVyblwic3BsaXRcIj09PXQmJigocj17fSkuY29uc3RydWN0b3I9e30sci5jb25zdHJ1Y3Rvclt1XT1mdW5jdGlvbigpe3JldHVybiByfSxyLmZsYWdzPVwiXCIscltwXT0vLi9bcF0pLHIuZXhlYz1mdW5jdGlvbigpe3JldHVybiBlPSEwLG51bGx9LHJbcF0oXCJcIiksIWV9KSk7aWYoIWR8fCF2fHxcInJlcGxhY2VcIj09PXQmJighY3x8IWYpfHxcInNwbGl0XCI9PT10JiYhbCl7dmFyIGc9Ly4vW3BdLHk9cihwLFwiXCJbdF0sKGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIGUuZXhlYz09PWE/ZCYmIWk/e2RvbmU6ITAsdmFsdWU6Zy5jYWxsKGUscixuKX06e2RvbmU6ITAsdmFsdWU6dC5jYWxsKHIsZSxuKX06e2RvbmU6ITF9fSkse1JFUExBQ0VfS0VFUFNfJDA6Zn0pLGI9eVswXSxfPXlbMV07bihTdHJpbmcucHJvdG90eXBlLHQsYiksbihSZWdFeHAucHJvdG90eXBlLHAsMj09ZT9mdW5jdGlvbih0LGUpe3JldHVybiBfLmNhbGwodCx0aGlzLGUpfTpmdW5jdGlvbih0KXtyZXR1cm4gXy5jYWxsKHQsdGhpcyl9KX1oJiZzKFJlZ0V4cC5wcm90b3R5cGVbcF0sXCJzaGFtXCIsITApfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMTIwKS5jaGFyQXQ7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gZSsocj9uKHQsZSkubGVuZ3RoOjEpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTkpLGk9cig1Myk7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dC5leGVjO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpe3ZhciBvPXIuY2FsbCh0LGUpO2lmKFwib2JqZWN0XCIhPXR5cGVvZiBvKXRocm93IFR5cGVFcnJvcihcIlJlZ0V4cCBleGVjIG1ldGhvZCByZXR1cm5lZCBzb21ldGhpbmcgb3RoZXIgdGhhbiBhbiBPYmplY3Qgb3IgbnVsbFwiKTtyZXR1cm4gb31pZihcIlJlZ0V4cFwiIT09bih0KSl0aHJvdyBUeXBlRXJyb3IoXCJSZWdFeHAjZXhlYyBjYWxsZWQgb24gaW5jb21wYXRpYmxlIHJlY2VpdmVyXCIpO3JldHVybiBpLmNhbGwodCxlKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpLGk9cigxMjEpLG89cig1MSksYT1yKDE0KSxzPXIoMyksdT1zKFwiaXRlcmF0b3JcIiksYz1zKFwidG9TdHJpbmdUYWdcIiksZj1vLnZhbHVlcztmb3IodmFyIGwgaW4gaSl7dmFyIGg9bltsXSxwPWgmJmgucHJvdG90eXBlO2lmKHApe2lmKHBbdV0hPT1mKXRyeXthKHAsdSxmKX1jYXRjaCh0KXtwW3VdPWZ9aWYocFtjXXx8YShwLGMsbCksaVtsXSlmb3IodmFyIGQgaW4gbylpZihwW2RdIT09b1tkXSl0cnl7YShwLGQsb1tkXSl9Y2F0Y2godCl7cFtkXT1vW2RdfX19fSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSxuKXtyZXR1cm4gdC5leHBvcnRzPXI9T2JqZWN0LnNldFByb3RvdHlwZU9mfHxmdW5jdGlvbih0LGUpe3JldHVybiB0Ll9fcHJvdG9fXz1lLHR9LHIoZSxuKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDUpLG89cig0NyksYT1yKDEwKSxzPXIoMjcpLHU9cigxNSksYz1yKDgyKSxmPXIoMTEyKSxsPXIoNTQpLGg9cigzKSxwPXIoODMpLGQ9aChcImlzQ29uY2F0U3ByZWFkYWJsZVwiKSx2PXA+PTUxfHwhaSgoZnVuY3Rpb24oKXt2YXIgdD1bXTtyZXR1cm4gdFtkXT0hMSx0LmNvbmNhdCgpWzBdIT09dH0pKSxnPWwoXCJjb25jYXRcIikseT1mdW5jdGlvbih0KXtpZighYSh0KSlyZXR1cm4hMTt2YXIgZT10W2RdO3JldHVybiB2b2lkIDAhPT1lPyEhZTpvKHQpfTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohdnx8IWd9LHtjb25jYXQ6ZnVuY3Rpb24odCl7dmFyIGUscixuLGksbyxhPXModGhpcyksbD1mKGEsMCksaD0wO2ZvcihlPS0xLG49YXJndW1lbnRzLmxlbmd0aDtlPG47ZSsrKWlmKG89LTE9PT1lP2E6YXJndW1lbnRzW2VdLHkobykpe2lmKGgrKGk9dShvLmxlbmd0aCkpPjkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgVHlwZUVycm9yKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO2ZvcihyPTA7cjxpO3IrKyxoKyspciBpbiBvJiZjKGwsaCxvW3JdKX1lbHNle2lmKGg+PTkwMDcxOTkyNTQ3NDA5OTEpdGhyb3cgVHlwZUVycm9yKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO2MobCxoKyssbyl9cmV0dXJuIGwubGVuZ3RoPWgsbH19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNDMpLGk9cigxMSksbz1yKDMxKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBhPW4oZSk7YSBpbiB0P2kuZih0LGEsbygwLHIpKTp0W2FdPXJ9fSxmdW5jdGlvbih0LGUscil7dmFyIG4saSxvPXIoNCksYT1yKDEyMikscz1vLnByb2Nlc3MsdT1zJiZzLnZlcnNpb25zLGM9dSYmdS52ODtjP2k9KG49Yy5zcGxpdChcIi5cIikpWzBdK25bMV06YSYmKCEobj1hLm1hdGNoKC9FZGdlXFwvKFxcZCspLykpfHxuWzFdPj03NCkmJihuPWEubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pKSYmKGk9blsxXSksdC5leHBvcnRzPWkmJitpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoMzMpLmZpbHRlcixvPXIoNSksYT1yKDU0KShcImZpbHRlclwiKSxzPWEmJiFvKChmdW5jdGlvbigpe1tdLmZpbHRlci5jYWxsKHtsZW5ndGg6LTEsMDoxfSwoZnVuY3Rpb24odCl7dGhyb3cgdH0pKX0pKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDohYXx8IXN9LHtmaWx0ZXI6ZnVuY3Rpb24odCl7cmV0dXJuIGkodGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEyMyk7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6W10uZm9yRWFjaCE9aX0se2ZvckVhY2g6aX0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoNjYpLmluY2x1ZGVzLG89cigxMTMpO24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtpbmNsdWRlczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pLG8oXCJpbmNsdWRlc1wiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKS5mLG89RnVuY3Rpb24ucHJvdG90eXBlLGE9by50b1N0cmluZyxzPS9eXFxzKmZ1bmN0aW9uIChbXiAoXSopLztuJiYhKFwibmFtZVwiaW4gbykmJmkobyxcIm5hbWVcIix7Y29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3RyeXtyZXR1cm4gYS5jYWxsKHRoaXMpLm1hdGNoKHMpWzFdfWNhdGNoKHQpe3JldHVyblwiXCJ9fX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMCksaT1yKDE5KSxvPXIoMykoXCJtYXRjaFwiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU7cmV0dXJuIG4odCkmJih2b2lkIDAhPT0oZT10W29dKT8hIWU6XCJSZWdFeHBcIj09aSh0KSl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig3NiksaT1yKDgpLG89cigyNyksYT1yKDE1KSxzPXIoMzIpLHU9cigyMCksYz1yKDc3KSxmPXIoNzgpLGw9TWF0aC5tYXgsaD1NYXRoLm1pbixwPU1hdGguZmxvb3IsZD0vXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2csdj0vXFwkKFskJidgXXxcXGRcXGQ/KS9nO24oXCJyZXBsYWNlXCIsMiwoZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuW2Z1bmN0aW9uKHIsbil7dmFyIGk9dSh0aGlzKSxvPW51bGw9PXI/dm9pZCAwOnJbdF07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKHIsaSxuKTplLmNhbGwoU3RyaW5nKGkpLHIsbil9LGZ1bmN0aW9uKHQsbyl7aWYobi5SRVBMQUNFX0tFRVBTXyQwfHxcInN0cmluZ1wiPT10eXBlb2YgbyYmLTE9PT1vLmluZGV4T2YoXCIkMFwiKSl7dmFyIHU9cihlLHQsdGhpcyxvKTtpZih1LmRvbmUpcmV0dXJuIHUudmFsdWV9dmFyIHA9aSh0KSxkPVN0cmluZyh0aGlzKSx2PVwiZnVuY3Rpb25cIj09dHlwZW9mIG87dnx8KG89U3RyaW5nKG8pKTt2YXIgeT1wLmdsb2JhbDtpZih5KXt2YXIgYj1wLnVuaWNvZGU7cC5sYXN0SW5kZXg9MH1mb3IodmFyIF89W107Oyl7dmFyIG09ZihwLGQpO2lmKG51bGw9PT1tKWJyZWFrO2lmKF8ucHVzaChtKSwheSlicmVhaztcIlwiPT09U3RyaW5nKG1bMF0pJiYocC5sYXN0SW5kZXg9YyhkLGEocC5sYXN0SW5kZXgpLGIpKX1mb3IodmFyIHcseD1cIlwiLGs9MCxFPTA7RTxfLmxlbmd0aDtFKyspe209X1tFXTtmb3IodmFyIFM9U3RyaW5nKG1bMF0pLGo9bChoKHMobS5pbmRleCksZC5sZW5ndGgpLDApLFI9W10sQz0xO0M8bS5sZW5ndGg7QysrKVIucHVzaCh2b2lkIDA9PT0odz1tW0NdKT93OlN0cmluZyh3KSk7dmFyIEk9bS5ncm91cHM7aWYodil7dmFyIE89W1NdLmNvbmNhdChSLGosZCk7dm9pZCAwIT09SSYmTy5wdXNoKEkpO3ZhciBUPVN0cmluZyhvLmFwcGx5KHZvaWQgMCxPKSl9ZWxzZSBUPWcoUyxkLGosUixJLG8pO2o+PWsmJih4Kz1kLnNsaWNlKGssaikrVCxrPWorUy5sZW5ndGgpfXJldHVybiB4K2Quc2xpY2Uoayl9XTtmdW5jdGlvbiBnKHQscixuLGksYSxzKXt2YXIgdT1uK3QubGVuZ3RoLGM9aS5sZW5ndGgsZj12O3JldHVybiB2b2lkIDAhPT1hJiYoYT1vKGEpLGY9ZCksZS5jYWxsKHMsZiwoZnVuY3Rpb24oZSxvKXt2YXIgcztzd2l0Y2goby5jaGFyQXQoMCkpe2Nhc2VcIiRcIjpyZXR1cm5cIiRcIjtjYXNlXCImXCI6cmV0dXJuIHQ7Y2FzZVwiYFwiOnJldHVybiByLnNsaWNlKDAsbik7Y2FzZVwiJ1wiOnJldHVybiByLnNsaWNlKHUpO2Nhc2VcIjxcIjpzPWFbby5zbGljZSgxLC0xKV07YnJlYWs7ZGVmYXVsdDp2YXIgZj0rbztpZigwPT09ZilyZXR1cm4gZTtpZihmPmMpe3ZhciBsPXAoZi8xMCk7cmV0dXJuIDA9PT1sP2U6bDw9Yz92b2lkIDA9PT1pW2wtMV0/by5jaGFyQXQoMSk6aVtsLTFdK28uY2hhckF0KDEpOmV9cz1pW2YtMV19cmV0dXJuIHZvaWQgMD09PXM/XCJcIjpzfSkpfX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCksaT1yKDEyMSksbz1yKDEyMyksYT1yKDE0KTtmb3IodmFyIHMgaW4gaSl7dmFyIHU9bltzXSxjPXUmJnUucHJvdG90eXBlO2lmKGMmJmMuZm9yRWFjaCE9PW8pdHJ5e2EoYyxcImZvckVhY2hcIixvKX1jYXRjaCh0KXtjLmZvckVhY2g9b319fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG4saSxvLGEscz1yKDIpLHU9cigyNSksYz1yKDQpLGY9cigyNiksbD1yKDE3NyksaD1yKDE3KSxwPXIoMTc4KSxkPXIoNDkpLHY9cigxMjUpLGc9cigxMCkseT1yKDUwKSxiPXIoMTc5KSxfPXIoMTkpLG09cig2Myksdz1yKDE4MCkseD1yKDE4NCksaz1yKDEzMiksRT1yKDEzMykuc2V0LFM9cigxODUpLGo9cigxODYpLFI9cigxODcpLEM9cigxMzUpLEk9cigxODgpLE89cigyNCksVD1yKDY4KSxQPXIoMyksQT1yKDgzKSxMPVAoXCJzcGVjaWVzXCIpLEY9XCJQcm9taXNlXCIsTT1PLmdldCxOPU8uc2V0LEI9Ty5nZXR0ZXJGb3IoRiksRD1sLFU9Yy5UeXBlRXJyb3IscT1jLmRvY3VtZW50LEc9Yy5wcm9jZXNzLFc9ZihcImZldGNoXCIpLHo9Qy5mLFk9eixRPVwicHJvY2Vzc1wiPT1fKEcpLCQ9ISEocSYmcS5jcmVhdGVFdmVudCYmYy5kaXNwYXRjaEV2ZW50KSxIPVQoRiwoZnVuY3Rpb24oKXtpZighKG0oRCkhPT1TdHJpbmcoRCkpKXtpZig2Nj09PUEpcmV0dXJuITA7aWYoIVEmJlwiZnVuY3Rpb25cIiE9dHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudClyZXR1cm4hMH1pZih1JiYhRC5wcm90b3R5cGUuZmluYWxseSlyZXR1cm4hMDtpZihBPj01MSYmL25hdGl2ZSBjb2RlLy50ZXN0KEQpKXJldHVybiExO3ZhciB0PUQucmVzb2x2ZSgxKSxlPWZ1bmN0aW9uKHQpe3QoKGZ1bmN0aW9uKCl7fSksKGZ1bmN0aW9uKCl7fSkpfTtyZXR1cm4odC5jb25zdHJ1Y3Rvcj17fSlbTF09ZSwhKHQudGhlbigoZnVuY3Rpb24oKXt9KSlpbnN0YW5jZW9mIGUpfSkpLEs9SHx8IXgoKGZ1bmN0aW9uKHQpe0QuYWxsKHQpLmNhdGNoKChmdW5jdGlvbigpe30pKX0pKSxWPWZ1bmN0aW9uKHQpe3ZhciBlO3JldHVybiEoIWcodCl8fFwiZnVuY3Rpb25cIiE9dHlwZW9mKGU9dC50aGVuKSkmJmV9LFo9ZnVuY3Rpb24odCxlLHIpe2lmKCFlLm5vdGlmaWVkKXtlLm5vdGlmaWVkPSEwO3ZhciBuPWUucmVhY3Rpb25zO1MoKGZ1bmN0aW9uKCl7Zm9yKHZhciBpPWUudmFsdWUsbz0xPT1lLnN0YXRlLGE9MDtuLmxlbmd0aD5hOyl7dmFyIHMsdSxjLGY9blthKytdLGw9bz9mLm9rOmYuZmFpbCxoPWYucmVzb2x2ZSxwPWYucmVqZWN0LGQ9Zi5kb21haW47dHJ5e2w/KG98fCgyPT09ZS5yZWplY3Rpb24mJmV0KHQsZSksZS5yZWplY3Rpb249MSksITA9PT1sP3M9aTooZCYmZC5lbnRlcigpLHM9bChpKSxkJiYoZC5leGl0KCksYz0hMCkpLHM9PT1mLnByb21pc2U/cChVKFwiUHJvbWlzZS1jaGFpbiBjeWNsZVwiKSk6KHU9VihzKSk/dS5jYWxsKHMsaCxwKTpoKHMpKTpwKGkpfWNhdGNoKHQpe2QmJiFjJiZkLmV4aXQoKSxwKHQpfX1lLnJlYWN0aW9ucz1bXSxlLm5vdGlmaWVkPSExLHImJiFlLnJlamVjdGlvbiYmWCh0LGUpfSkpfX0sSj1mdW5jdGlvbih0LGUscil7dmFyIG4saTskPygobj1xLmNyZWF0ZUV2ZW50KFwiRXZlbnRcIikpLnByb21pc2U9ZSxuLnJlYXNvbj1yLG4uaW5pdEV2ZW50KHQsITEsITApLGMuZGlzcGF0Y2hFdmVudChuKSk6bj17cHJvbWlzZTplLHJlYXNvbjpyfSwoaT1jW1wib25cIit0XSk/aShuKTpcInVuaGFuZGxlZHJlamVjdGlvblwiPT09dCYmUihcIlVuaGFuZGxlZCBwcm9taXNlIHJlamVjdGlvblwiLHIpfSxYPWZ1bmN0aW9uKHQsZSl7RS5jYWxsKGMsKGZ1bmN0aW9uKCl7dmFyIHIsbj1lLnZhbHVlO2lmKHR0KGUpJiYocj1JKChmdW5jdGlvbigpe1E/Ry5lbWl0KFwidW5oYW5kbGVkUmVqZWN0aW9uXCIsbix0KTpKKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsdCxuKX0pKSxlLnJlamVjdGlvbj1RfHx0dChlKT8yOjEsci5lcnJvcikpdGhyb3cgci52YWx1ZX0pKX0sdHQ9ZnVuY3Rpb24odCl7cmV0dXJuIDEhPT10LnJlamVjdGlvbiYmIXQucGFyZW50fSxldD1mdW5jdGlvbih0LGUpe0UuY2FsbChjLChmdW5jdGlvbigpe1E/Ry5lbWl0KFwicmVqZWN0aW9uSGFuZGxlZFwiLHQpOkooXCJyZWplY3Rpb25oYW5kbGVkXCIsdCxlLnZhbHVlKX0pKX0scnQ9ZnVuY3Rpb24odCxlLHIsbil7cmV0dXJuIGZ1bmN0aW9uKGkpe3QoZSxyLGksbil9fSxudD1mdW5jdGlvbih0LGUscixuKXtlLmRvbmV8fChlLmRvbmU9ITAsbiYmKGU9biksZS52YWx1ZT1yLGUuc3RhdGU9MixaKHQsZSwhMCkpfSxpdD1mdW5jdGlvbih0LGUscixuKXtpZighZS5kb25lKXtlLmRvbmU9ITAsbiYmKGU9bik7dHJ5e2lmKHQ9PT1yKXRocm93IFUoXCJQcm9taXNlIGNhbid0IGJlIHJlc29sdmVkIGl0c2VsZlwiKTt2YXIgaT1WKHIpO2k/UygoZnVuY3Rpb24oKXt2YXIgbj17ZG9uZTohMX07dHJ5e2kuY2FsbChyLHJ0KGl0LHQsbixlKSxydChudCx0LG4sZSkpfWNhdGNoKHIpe250KHQsbixyLGUpfX0pKTooZS52YWx1ZT1yLGUuc3RhdGU9MSxaKHQsZSwhMSkpfWNhdGNoKHIpe250KHQse2RvbmU6ITF9LHIsZSl9fX07SCYmKEQ9ZnVuY3Rpb24odCl7Yih0aGlzLEQsRikseSh0KSxuLmNhbGwodGhpcyk7dmFyIGU9TSh0aGlzKTt0cnl7dChydChpdCx0aGlzLGUpLHJ0KG50LHRoaXMsZSkpfWNhdGNoKHQpe250KHRoaXMsZSx0KX19LChuPWZ1bmN0aW9uKHQpe04odGhpcyx7dHlwZTpGLGRvbmU6ITEsbm90aWZpZWQ6ITEscGFyZW50OiExLHJlYWN0aW9uczpbXSxyZWplY3Rpb246ITEsc3RhdGU6MCx2YWx1ZTp2b2lkIDB9KX0pLnByb3RvdHlwZT1wKEQucHJvdG90eXBlLHt0aGVuOmZ1bmN0aW9uKHQsZSl7dmFyIHI9Qih0aGlzKSxuPXooayh0aGlzLEQpKTtyZXR1cm4gbi5vaz1cImZ1bmN0aW9uXCIhPXR5cGVvZiB0fHx0LG4uZmFpbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiBlJiZlLG4uZG9tYWluPVE/Ry5kb21haW46dm9pZCAwLHIucGFyZW50PSEwLHIucmVhY3Rpb25zLnB1c2gobiksMCE9ci5zdGF0ZSYmWih0aGlzLHIsITEpLG4ucHJvbWlzZX0sY2F0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudGhlbih2b2lkIDAsdCl9fSksaT1mdW5jdGlvbigpe3ZhciB0PW5ldyBuLGU9TSh0KTt0aGlzLnByb21pc2U9dCx0aGlzLnJlc29sdmU9cnQoaXQsdCxlKSx0aGlzLnJlamVjdD1ydChudCx0LGUpfSxDLmY9ej1mdW5jdGlvbih0KXtyZXR1cm4gdD09PUR8fHQ9PT1vP25ldyBpKHQpOlkodCl9LHV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIGx8fChhPWwucHJvdG90eXBlLnRoZW4saChsLnByb3RvdHlwZSxcInRoZW5cIiwoZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzO3JldHVybiBuZXcgRCgoZnVuY3Rpb24odCxlKXthLmNhbGwocix0LGUpfSkpLnRoZW4odCxlKX0pLHt1bnNhZmU6ITB9KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBXJiZzKHtnbG9iYWw6ITAsZW51bWVyYWJsZTohMCxmb3JjZWQ6ITB9LHtmZXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gaihELFcuYXBwbHkoYyxhcmd1bWVudHMpKX19KSkpLHMoe2dsb2JhbDohMCx3cmFwOiEwLGZvcmNlZDpIfSx7UHJvbWlzZTpEfSksZChELEYsITEsITApLHYoRiksbz1mKEYpLHMoe3RhcmdldDpGLHN0YXQ6ITAsZm9yY2VkOkh9LHtyZWplY3Q6ZnVuY3Rpb24odCl7dmFyIGU9eih0aGlzKTtyZXR1cm4gZS5yZWplY3QuY2FsbCh2b2lkIDAsdCksZS5wcm9taXNlfX0pLHMoe3RhcmdldDpGLHN0YXQ6ITAsZm9yY2VkOnV8fEh9LHtyZXNvbHZlOmZ1bmN0aW9uKHQpe3JldHVybiBqKHUmJnRoaXM9PT1vP0Q6dGhpcyx0KX19KSxzKHt0YXJnZXQ6RixzdGF0OiEwLGZvcmNlZDpLfSx7YWxsOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj16KGUpLG49ci5yZXNvbHZlLGk9ci5yZWplY3Qsbz1JKChmdW5jdGlvbigpe3ZhciByPXkoZS5yZXNvbHZlKSxvPVtdLGE9MCxzPTE7dyh0LChmdW5jdGlvbih0KXt2YXIgdT1hKyssYz0hMTtvLnB1c2godm9pZCAwKSxzKyssci5jYWxsKGUsdCkudGhlbigoZnVuY3Rpb24odCl7Y3x8KGM9ITAsb1t1XT10LC0tc3x8bihvKSl9KSxpKX0pKSwtLXN8fG4obyl9KSk7cmV0dXJuIG8uZXJyb3ImJmkoby52YWx1ZSksci5wcm9taXNlfSxyYWNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMscj16KGUpLG49ci5yZWplY3QsaT1JKChmdW5jdGlvbigpe3ZhciBpPXkoZS5yZXNvbHZlKTt3KHQsKGZ1bmN0aW9uKHQpe2kuY2FsbChlLHQpLnRoZW4oci5yZXNvbHZlLG4pfSkpfSkpO3JldHVybiBpLmVycm9yJiZuKGkudmFsdWUpLHIucHJvbWlzZX19KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0KXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG52YXIgbj1yKDE5MCksaT1yKDE5MSksbz1yKDEzNyk7ZnVuY3Rpb24gYSgpe3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/MjE0NzQ4MzY0NzoxMDczNzQxODIzfWZ1bmN0aW9uIHModCxlKXtpZihhKCk8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoXCIpO3JldHVybiB1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHQ9bmV3IFVpbnQ4QXJyYXkoZSkpLl9fcHJvdG9fXz11LnByb3RvdHlwZToobnVsbD09PXQmJih0PW5ldyB1KGUpKSx0Lmxlbmd0aD1lKSx0fWZ1bmN0aW9uIHUodCxlLHIpe2lmKCEodS5UWVBFRF9BUlJBWV9TVVBQT1JUfHx0aGlzIGluc3RhbmNlb2YgdSkpcmV0dXJuIG5ldyB1KHQsZSxyKTtpZihcIm51bWJlclwiPT10eXBlb2YgdCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdGhyb3cgbmV3IEVycm9yKFwiSWYgZW5jb2RpbmcgaXMgc3BlY2lmaWVkIHRoZW4gdGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmdcIik7cmV0dXJuIGwodGhpcyx0KX1yZXR1cm4gYyh0aGlzLHQsZSxyKX1mdW5jdGlvbiBjKHQsZSxyLG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpO3JldHVyblwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyP2Z1bmN0aW9uKHQsZSxyLG4pe2lmKGUuYnl0ZUxlbmd0aCxyPDB8fGUuYnl0ZUxlbmd0aDxyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiJ29mZnNldCcgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihlLmJ5dGVMZW5ndGg8cisobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCInbGVuZ3RoJyBpcyBvdXQgb2YgYm91bmRzXCIpO2U9dm9pZCAwPT09ciYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUscik6bmV3IFVpbnQ4QXJyYXkoZSxyLG4pO3UuVFlQRURfQVJSQVlfU1VQUE9SVD8odD1lKS5fX3Byb3RvX189dS5wcm90b3R5cGU6dD1oKHQsZSk7cmV0dXJuIHR9KHQsZSxyLG4pOlwic3RyaW5nXCI9PXR5cGVvZiBlP2Z1bmN0aW9uKHQsZSxyKXtcInN0cmluZ1wiPT10eXBlb2YgciYmXCJcIiE9PXJ8fChyPVwidXRmOFwiKTtpZighdS5pc0VuY29kaW5nKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJyk7dmFyIG49MHxkKGUsciksaT0odD1zKHQsbikpLndyaXRlKGUscik7aSE9PW4mJih0PXQuc2xpY2UoMCxpKSk7cmV0dXJuIHR9KHQsZSxyKTpmdW5jdGlvbih0LGUpe2lmKHUuaXNCdWZmZXIoZSkpe3ZhciByPTB8cChlLmxlbmd0aCk7cmV0dXJuIDA9PT0odD1zKHQscikpLmxlbmd0aHx8ZS5jb3B5KHQsMCwwLHIpLHR9aWYoZSl7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIEFycmF5QnVmZmVyJiZlLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyfHxcImxlbmd0aFwiaW4gZSlyZXR1cm5cIm51bWJlclwiIT10eXBlb2YgZS5sZW5ndGh8fChuPWUubGVuZ3RoKSE9bj9zKHQsMCk6aCh0LGUpO2lmKFwiQnVmZmVyXCI9PT1lLnR5cGUmJm8oZS5kYXRhKSlyZXR1cm4gaCh0LGUuZGF0YSl9dmFyIG47dGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC5cIil9KHQsZSl9ZnVuY3Rpb24gZih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJyk7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpfWZ1bmN0aW9uIGwodCxlKXtpZihmKGUpLHQ9cyh0LGU8MD8wOjB8cChlKSksIXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IodmFyIHI9MDtyPGU7KytyKXRbcl09MDtyZXR1cm4gdH1mdW5jdGlvbiBoKHQsZSl7dmFyIHI9ZS5sZW5ndGg8MD8wOjB8cChlLmxlbmd0aCk7dD1zKHQscik7Zm9yKHZhciBuPTA7bjxyO24rPTEpdFtuXT0yNTUmZVtuXTtyZXR1cm4gdH1mdW5jdGlvbiBwKHQpe2lmKHQ+PWEoKSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gc2l6ZTogMHhcIithKCkudG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpO3JldHVybiAwfHR9ZnVuY3Rpb24gZCh0LGUpe2lmKHUuaXNCdWZmZXIodCkpcmV0dXJuIHQubGVuZ3RoO2lmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBBcnJheUJ1ZmZlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3JiYoQXJyYXlCdWZmZXIuaXNWaWV3KHQpfHx0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKXJldHVybiB0LmJ5dGVMZW5ndGg7XCJzdHJpbmdcIiE9dHlwZW9mIHQmJih0PVwiXCIrdCk7dmFyIHI9dC5sZW5ndGg7aWYoMD09PXIpcmV0dXJuIDA7Zm9yKHZhciBuPSExOzspc3dpdGNoKGUpe2Nhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHI7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZSB2b2lkIDA6cmV0dXJuIFUodCkubGVuZ3RoO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiAyKnI7Y2FzZVwiaGV4XCI6cmV0dXJuIHI+Pj4xO2Nhc2VcImJhc2U2NFwiOnJldHVybiBxKHQpLmxlbmd0aDtkZWZhdWx0OmlmKG4pcmV0dXJuIFUodCkubGVuZ3RoO2U9KFwiXCIrZSkudG9Mb3dlckNhc2UoKSxuPSEwfX1mdW5jdGlvbiB2KHQsZSxyKXt2YXIgbj0hMTtpZigodm9pZCAwPT09ZXx8ZTwwKSYmKGU9MCksZT50aGlzLmxlbmd0aClyZXR1cm5cIlwiO2lmKCh2b2lkIDA9PT1yfHxyPnRoaXMubGVuZ3RoKSYmKHI9dGhpcy5sZW5ndGgpLHI8PTApcmV0dXJuXCJcIjtpZigocj4+Pj0wKTw9KGU+Pj49MCkpcmV0dXJuXCJcIjtmb3IodHx8KHQ9XCJ1dGY4XCIpOzspc3dpdGNoKHQpe2Nhc2VcImhleFwiOnJldHVybiBJKHRoaXMsZSxyKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gaih0aGlzLGUscik7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gUih0aGlzLGUscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIEModGhpcyxlLHIpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBTKHRoaXMsZSxyKTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gTyh0aGlzLGUscik7ZGVmYXVsdDppZihuKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTt0PSh0K1wiXCIpLnRvTG93ZXJDYXNlKCksbj0hMH19ZnVuY3Rpb24gZyh0LGUscil7dmFyIG49dFtlXTt0W2VdPXRbcl0sdFtyXT1ufWZ1bmN0aW9uIHkodCxlLHIsbixpKXtpZigwPT09dC5sZW5ndGgpcmV0dXJuLTE7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHI/KG49cixyPTApOnI+MjE0NzQ4MzY0Nz9yPTIxNDc0ODM2NDc6cjwtMjE0NzQ4MzY0OCYmKHI9LTIxNDc0ODM2NDgpLHI9K3IsaXNOYU4ocikmJihyPWk/MDp0Lmxlbmd0aC0xKSxyPDAmJihyPXQubGVuZ3RoK3IpLHI+PXQubGVuZ3RoKXtpZihpKXJldHVybi0xO3I9dC5sZW5ndGgtMX1lbHNlIGlmKHI8MCl7aWYoIWkpcmV0dXJuLTE7cj0wfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT11LmZyb20oZSxuKSksdS5pc0J1ZmZlcihlKSlyZXR1cm4gMD09PWUubGVuZ3RoPy0xOmIodCxlLHIsbixpKTtpZihcIm51bWJlclwiPT10eXBlb2YgZSlyZXR1cm4gZSY9MjU1LHUuVFlQRURfQVJSQVlfU1VQUE9SVCYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj9pP1VpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCh0LGUscik6VWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbCh0LGUscik6Yih0LFtlXSxyLG4saSk7dGhyb3cgbmV3IFR5cGVFcnJvcihcInZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlclwiKX1mdW5jdGlvbiBiKHQsZSxyLG4saSl7dmFyIG8sYT0xLHM9dC5sZW5ndGgsdT1lLmxlbmd0aDtpZih2b2lkIDAhPT1uJiYoXCJ1Y3MyXCI9PT0obj1TdHJpbmcobikudG9Mb3dlckNhc2UoKSl8fFwidWNzLTJcIj09PW58fFwidXRmMTZsZVwiPT09bnx8XCJ1dGYtMTZsZVwiPT09bikpe2lmKHQubGVuZ3RoPDJ8fGUubGVuZ3RoPDIpcmV0dXJuLTE7YT0yLHMvPTIsdS89MixyLz0yfWZ1bmN0aW9uIGModCxlKXtyZXR1cm4gMT09PWE/dFtlXTp0LnJlYWRVSW50MTZCRShlKmEpfWlmKGkpe3ZhciBmPS0xO2ZvcihvPXI7bzxzO28rKylpZihjKHQsbyk9PT1jKGUsLTE9PT1mPzA6by1mKSl7aWYoLTE9PT1mJiYoZj1vKSxvLWYrMT09PXUpcmV0dXJuIGYqYX1lbHNlLTEhPT1mJiYoby09by1mKSxmPS0xfWVsc2UgZm9yKHIrdT5zJiYocj1zLXUpLG89cjtvPj0wO28tLSl7Zm9yKHZhciBsPSEwLGg9MDtoPHU7aCsrKWlmKGModCxvK2gpIT09YyhlLGgpKXtsPSExO2JyZWFrfWlmKGwpcmV0dXJuIG99cmV0dXJuLTF9ZnVuY3Rpb24gXyh0LGUscixuKXtyPU51bWJlcihyKXx8MDt2YXIgaT10Lmxlbmd0aC1yO24/KG49TnVtYmVyKG4pKT5pJiYobj1pKTpuPWk7dmFyIG89ZS5sZW5ndGg7aWYobyUyIT0wKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmdcIik7bj5vLzImJihuPW8vMik7Zm9yKHZhciBhPTA7YTxuOysrYSl7dmFyIHM9cGFyc2VJbnQoZS5zdWJzdHIoMiphLDIpLDE2KTtpZihpc05hTihzKSlyZXR1cm4gYTt0W3IrYV09c31yZXR1cm4gYX1mdW5jdGlvbiBtKHQsZSxyLG4pe3JldHVybiBHKFUoZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gdyh0LGUscixuKXtyZXR1cm4gRyhmdW5jdGlvbih0KXtmb3IodmFyIGU9W10scj0wO3I8dC5sZW5ndGg7KytyKWUucHVzaCgyNTUmdC5jaGFyQ29kZUF0KHIpKTtyZXR1cm4gZX0oZSksdCxyLG4pfWZ1bmN0aW9uIHgodCxlLHIsbil7cmV0dXJuIHcodCxlLHIsbil9ZnVuY3Rpb24gayh0LGUscixuKXtyZXR1cm4gRyhxKGUpLHQscixuKX1mdW5jdGlvbiBFKHQsZSxyLG4pe3JldHVybiBHKGZ1bmN0aW9uKHQsZSl7Zm9yKHZhciByLG4saSxvPVtdLGE9MDthPHQubGVuZ3RoJiYhKChlLT0yKTwwKTsrK2Epcj10LmNoYXJDb2RlQXQoYSksbj1yPj44LGk9ciUyNTYsby5wdXNoKGkpLG8ucHVzaChuKTtyZXR1cm4gb30oZSx0Lmxlbmd0aC1yKSx0LHIsbil9ZnVuY3Rpb24gUyh0LGUscil7cmV0dXJuIDA9PT1lJiZyPT09dC5sZW5ndGg/bi5mcm9tQnl0ZUFycmF5KHQpOm4uZnJvbUJ5dGVBcnJheSh0LnNsaWNlKGUscikpfWZ1bmN0aW9uIGoodCxlLHIpe3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBuPVtdLGk9ZTtpPHI7KXt2YXIgbyxhLHMsdSxjPXRbaV0sZj1udWxsLGw9Yz4yMzk/NDpjPjIyMz8zOmM+MTkxPzI6MTtpZihpK2w8PXIpc3dpdGNoKGwpe2Nhc2UgMTpjPDEyOCYmKGY9Yyk7YnJlYWs7Y2FzZSAyOjEyOD09KDE5MiYobz10W2krMV0pKSYmKHU9KDMxJmMpPDw2fDYzJm8pPjEyNyYmKGY9dSk7YnJlYWs7Y2FzZSAzOm89dFtpKzFdLGE9dFtpKzJdLDEyOD09KDE5MiZvKSYmMTI4PT0oMTkyJmEpJiYodT0oMTUmYyk8PDEyfCg2MyZvKTw8Nnw2MyZhKT4yMDQ3JiYodTw1NTI5Nnx8dT41NzM0MykmJihmPXUpO2JyZWFrO2Nhc2UgNDpvPXRbaSsxXSxhPXRbaSsyXSxzPXRbaSszXSwxMjg9PSgxOTImbykmJjEyOD09KDE5MiZhKSYmMTI4PT0oMTkyJnMpJiYodT0oMTUmYyk8PDE4fCg2MyZvKTw8MTJ8KDYzJmEpPDw2fDYzJnMpPjY1NTM1JiZ1PDExMTQxMTImJihmPXUpfW51bGw9PT1mPyhmPTY1NTMzLGw9MSk6Zj42NTUzNSYmKGYtPTY1NTM2LG4ucHVzaChmPj4+MTAmMTAyM3w1NTI5NiksZj01NjMyMHwxMDIzJmYpLG4ucHVzaChmKSxpKz1sfXJldHVybiBmdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aDtpZihlPD00MDk2KXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyx0KTt2YXIgcj1cIlwiLG49MDtmb3IoO248ZTspcis9U3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsdC5zbGljZShuLG4rPTQwOTYpKTtyZXR1cm4gcn0obil9ZS5CdWZmZXI9dSxlLlNsb3dCdWZmZXI9ZnVuY3Rpb24odCl7K3QhPXQmJih0PTApO3JldHVybiB1LmFsbG9jKCt0KX0sZS5JTlNQRUNUX01BWF9CWVRFUz01MCx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ9dm9pZCAwIT09dC5UWVBFRF9BUlJBWV9TVVBQT1JUP3QuVFlQRURfQVJSQVlfU1VQUE9SVDpmdW5jdGlvbigpe3RyeXt2YXIgdD1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4gdC5fX3Byb3RvX189e19fcHJvdG9fXzpVaW50OEFycmF5LnByb3RvdHlwZSxmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fSw0Mj09PXQuZm9vKCkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIHQuc3ViYXJyYXkmJjA9PT10LnN1YmFycmF5KDEsMSkuYnl0ZUxlbmd0aH1jYXRjaCh0KXtyZXR1cm4hMX19KCksZS5rTWF4TGVuZ3RoPWEoKSx1LnBvb2xTaXplPTgxOTIsdS5fYXVnbWVudD1mdW5jdGlvbih0KXtyZXR1cm4gdC5fX3Byb3RvX189dS5wcm90b3R5cGUsdH0sdS5mcm9tPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gYyhudWxsLHQsZSxyKX0sdS5UWVBFRF9BUlJBWV9TVVBQT1JUJiYodS5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHUuX19wcm90b19fPVVpbnQ4QXJyYXksXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnNwZWNpZXMmJnVbU3ltYm9sLnNwZWNpZXNdPT09dSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHUsU3ltYm9sLnNwZWNpZXMse3ZhbHVlOm51bGwsY29uZmlndXJhYmxlOiEwfSkpLHUuYWxsb2M9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gZihlKSxlPD0wP3ModCxlKTp2b2lkIDAhPT1yP1wic3RyaW5nXCI9PXR5cGVvZiBuP3ModCxlKS5maWxsKHIsbik6cyh0LGUpLmZpbGwocik6cyh0LGUpfShudWxsLHQsZSxyKX0sdS5hbGxvY1Vuc2FmZT1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSx1LmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbih0KXtyZXR1cm4gbChudWxsLHQpfSx1LmlzQnVmZmVyPWZ1bmN0aW9uKHQpe3JldHVybiEobnVsbD09dHx8IXQuX2lzQnVmZmVyKX0sdS5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7aWYoIXUuaXNCdWZmZXIodCl8fCF1LmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzXCIpO2lmKHQ9PT1lKXJldHVybiAwO2Zvcih2YXIgcj10Lmxlbmd0aCxuPWUubGVuZ3RoLGk9MCxvPU1hdGgubWluKHIsbik7aTxvOysraSlpZih0W2ldIT09ZVtpXSl7cj10W2ldLG49ZVtpXTticmVha31yZXR1cm4gcjxuPy0xOm48cj8xOjB9LHUuaXNFbmNvZGluZz1mdW5jdGlvbih0KXtzd2l0Y2goU3RyaW5nKHQpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19LHUuY29uY2F0PWZ1bmN0aW9uKHQsZSl7aWYoIW8odCkpdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJyk7aWYoMD09PXQubGVuZ3RoKXJldHVybiB1LmFsbG9jKDApO3ZhciByO2lmKHZvaWQgMD09PWUpZm9yKGU9MCxyPTA7cjx0Lmxlbmd0aDsrK3IpZSs9dFtyXS5sZW5ndGg7dmFyIG49dS5hbGxvY1Vuc2FmZShlKSxpPTA7Zm9yKHI9MDtyPHQubGVuZ3RoOysrcil7dmFyIGE9dFtyXTtpZighdS5pc0J1ZmZlcihhKSl0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKTthLmNvcHkobixpKSxpKz1hLmxlbmd0aH1yZXR1cm4gbn0sdS5ieXRlTGVuZ3RoPWQsdS5wcm90b3R5cGUuX2lzQnVmZmVyPSEwLHUucHJvdG90eXBlLnN3YXAxNj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlMiE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz0yKWcodGhpcyxlLGUrMSk7cmV0dXJuIHRoaXN9LHUucHJvdG90eXBlLnN3YXAzMj1mdW5jdGlvbigpe3ZhciB0PXRoaXMubGVuZ3RoO2lmKHQlNCE9MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzXCIpO2Zvcih2YXIgZT0wO2U8dDtlKz00KWcodGhpcyxlLGUrMyksZyh0aGlzLGUrMSxlKzIpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS5zd2FwNjQ9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxlbmd0aDtpZih0JTghPTApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0c1wiKTtmb3IodmFyIGU9MDtlPHQ7ZSs9OClnKHRoaXMsZSxlKzcpLGcodGhpcyxlKzEsZSs2KSxnKHRoaXMsZSsyLGUrNSksZyh0aGlzLGUrMyxlKzQpO3JldHVybiB0aGlzfSx1LnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbigpe3ZhciB0PTB8dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT10P1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/aih0aGlzLDAsdCk6di5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHUucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbih0KXtpZighdS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PXR8fDA9PT11LmNvbXBhcmUodGhpcyx0KX0sdS5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciB0PVwiXCIscj1lLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiB0aGlzLmxlbmd0aD4wJiYodD10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCxyKS5tYXRjaCgvLnsyfS9nKS5qb2luKFwiIFwiKSx0aGlzLmxlbmd0aD5yJiYodCs9XCIgLi4uIFwiKSksXCI8QnVmZmVyIFwiK3QrXCI+XCJ9LHUucHJvdG90eXBlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLHIsbixpKXtpZighdS5pc0J1ZmZlcih0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtpZih2b2lkIDA9PT1lJiYoZT0wKSx2b2lkIDA9PT1yJiYocj10P3QubGVuZ3RoOjApLHZvaWQgMD09PW4mJihuPTApLHZvaWQgMD09PWkmJihpPXRoaXMubGVuZ3RoKSxlPDB8fHI+dC5sZW5ndGh8fG48MHx8aT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihuPj1pJiZlPj1yKXJldHVybiAwO2lmKG4+PWkpcmV0dXJuLTE7aWYoZT49cilyZXR1cm4gMTtpZih0aGlzPT09dClyZXR1cm4gMDtmb3IodmFyIG89KGk+Pj49MCktKG4+Pj49MCksYT0ocj4+Pj0wKS0oZT4+Pj0wKSxzPU1hdGgubWluKG8sYSksYz10aGlzLnNsaWNlKG4saSksZj10LnNsaWNlKGUsciksbD0wO2w8czsrK2wpaWYoY1tsXSE9PWZbbF0pe289Y1tsXSxhPWZbbF07YnJlYWt9cmV0dXJuIG88YT8tMTphPG8/MTowfSx1LnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbih0LGUscil7cmV0dXJuLTEhPT10aGlzLmluZGV4T2YodCxlLHIpfSx1LnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4geSh0aGlzLHQsZSxyLCEwKX0sdS5wcm90b3R5cGUubGFzdEluZGV4T2Y9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB5KHRoaXMsdCxlLHIsITEpfSx1LnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbih0LGUscixuKXtpZih2b2lkIDA9PT1lKW49XCJ1dGY4XCIscj10aGlzLmxlbmd0aCxlPTA7ZWxzZSBpZih2b2lkIDA9PT1yJiZcInN0cmluZ1wiPT10eXBlb2YgZSluPWUscj10aGlzLmxlbmd0aCxlPTA7ZWxzZXtpZighaXNGaW5pdGUoZSkpdGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7ZXw9MCxpc0Zpbml0ZShyKT8ocnw9MCx2b2lkIDA9PT1uJiYobj1cInV0ZjhcIikpOihuPXIscj12b2lkIDApfXZhciBpPXRoaXMubGVuZ3RoLWU7aWYoKHZvaWQgMD09PXJ8fHI+aSkmJihyPWkpLHQubGVuZ3RoPjAmJihyPDB8fGU8MCl8fGU+dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKTtufHwobj1cInV0ZjhcIik7Zm9yKHZhciBvPSExOzspc3dpdGNoKG4pe2Nhc2VcImhleFwiOnJldHVybiBfKHRoaXMsdCxlLHIpO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBtKHRoaXMsdCxlLHIpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIHcodGhpcyx0LGUscik7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIHgodGhpcyx0LGUscik7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGsodGhpcyx0LGUscik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIEUodGhpcyx0LGUscik7ZGVmYXVsdDppZihvKXRocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIituKTtuPShcIlwiK24pLnRvTG93ZXJDYXNlKCksbz0hMH19LHUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbigpe3JldHVybnt0eXBlOlwiQnVmZmVyXCIsZGF0YTpBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnJ8fHRoaXMsMCl9fTtmdW5jdGlvbiBSKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDEyNyZ0W2ldKTtyZXR1cm4gbn1mdW5jdGlvbiBDKHQsZSxyKXt2YXIgbj1cIlwiO3I9TWF0aC5taW4odC5sZW5ndGgscik7Zm9yKHZhciBpPWU7aTxyOysraSluKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHRbaV0pO3JldHVybiBufWZ1bmN0aW9uIEkodCxlLHIpe3ZhciBuPXQubGVuZ3RoOyghZXx8ZTwwKSYmKGU9MCksKCFyfHxyPDB8fHI+bikmJihyPW4pO2Zvcih2YXIgaT1cIlwiLG89ZTtvPHI7KytvKWkrPUQodFtvXSk7cmV0dXJuIGl9ZnVuY3Rpb24gTyh0LGUscil7Zm9yKHZhciBuPXQuc2xpY2UoZSxyKSxpPVwiXCIsbz0wO288bi5sZW5ndGg7bys9MilpKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG5bb10rMjU2Km5bbysxXSk7cmV0dXJuIGl9ZnVuY3Rpb24gVCh0LGUscil7aWYodCUxIT0wfHx0PDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYodCtlPnIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfWZ1bmN0aW9uIFAodCxlLHIsbixpLG8pe2lmKCF1LmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKGU+aXx8ZTxvKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1mdW5jdGlvbiBBKHQsZSxyLG4pe2U8MCYmKGU9NjU1MzUrZSsxKTtmb3IodmFyIGk9MCxvPU1hdGgubWluKHQubGVuZ3RoLXIsMik7aTxvOysraSl0W3IraV09KGUmMjU1PDw4KihuP2k6MS1pKSk+Pj44KihuP2k6MS1pKX1mdW5jdGlvbiBMKHQsZSxyLG4pe2U8MCYmKGU9NDI5NDk2NzI5NStlKzEpO2Zvcih2YXIgaT0wLG89TWF0aC5taW4odC5sZW5ndGgtciw0KTtpPG87KytpKXRbcitpXT1lPj4+OCoobj9pOjMtaSkmMjU1fWZ1bmN0aW9uIEYodCxlLHIsbixpLG8pe2lmKHIrbj50Lmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihyPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gTSh0LGUscixuLG8pe3JldHVybiBvfHxGKHQsMCxyLDQpLGkud3JpdGUodCxlLHIsbiwyMyw0KSxyKzR9ZnVuY3Rpb24gTih0LGUscixuLG8pe3JldHVybiBvfHxGKHQsMCxyLDgpLGkud3JpdGUodCxlLHIsbiw1Miw4KSxyKzh9dS5wcm90b3R5cGUuc2xpY2U9ZnVuY3Rpb24odCxlKXt2YXIgcixuPXRoaXMubGVuZ3RoO2lmKCh0PX5+dCk8MD8odCs9bik8MCYmKHQ9MCk6dD5uJiYodD1uKSwoZT12b2lkIDA9PT1lP246fn5lKTwwPyhlKz1uKTwwJiYoZT0wKTplPm4mJihlPW4pLGU8dCYmKGU9dCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUKShyPXRoaXMuc3ViYXJyYXkodCxlKSkuX19wcm90b19fPXUucHJvdG90eXBlO2Vsc2V7dmFyIGk9ZS10O3I9bmV3IHUoaSx2b2lkIDApO2Zvcih2YXIgbz0wO288aTsrK28pcltvXT10aGlzW28rdF19cmV0dXJuIHJ9LHUucHJvdG90eXBlLnJlYWRVSW50TEU9ZnVuY3Rpb24odCxlLHIpe3R8PTAsZXw9MCxyfHxUKHQsZSx0aGlzLmxlbmd0aCk7Zm9yKHZhciBuPXRoaXNbdF0saT0xLG89MDsrK288ZSYmKGkqPTI1Nik7KW4rPXRoaXNbdCtvXSppO3JldHVybiBufSx1LnByb3RvdHlwZS5yZWFkVUludEJFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8VCh0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3QrLS1lXSxpPTE7ZT4wJiYoaSo9MjU2KTspbis9dGhpc1t0Ky0tZV0qaTtyZXR1cm4gbn0sdS5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCwxLHRoaXMubGVuZ3RoKSx0aGlzW3RdfSx1LnByb3RvdHlwZS5yZWFkVUludDE2TEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF18dGhpc1t0KzFdPDw4fSx1LnByb3RvdHlwZS5yZWFkVUludDE2QkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDIsdGhpcy5sZW5ndGgpLHRoaXNbdF08PDh8dGhpc1t0KzFdfSx1LnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDQsdGhpcy5sZW5ndGgpLCh0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2KSsxNjc3NzIxNip0aGlzW3QrM119LHUucHJvdG90eXBlLnJlYWRVSW50MzJCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxUKHQsNCx0aGlzLmxlbmd0aCksMTY3NzcyMTYqdGhpc1t0XSsodGhpc1t0KzFdPDwxNnx0aGlzW3QrMl08PDh8dGhpc1t0KzNdKX0sdS5wcm90b3R5cGUucmVhZEludExFPWZ1bmN0aW9uKHQsZSxyKXt0fD0wLGV8PTAscnx8VCh0LGUsdGhpcy5sZW5ndGgpO2Zvcih2YXIgbj10aGlzW3RdLGk9MSxvPTA7KytvPGUmJihpKj0yNTYpOyluKz10aGlzW3Qrb10qaTtyZXR1cm4gbj49KGkqPTEyOCkmJihuLT1NYXRoLnBvdygyLDgqZSkpLG59LHUucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbih0LGUscil7dHw9MCxlfD0wLHJ8fFQodCxlLHRoaXMubGVuZ3RoKTtmb3IodmFyIG49ZSxpPTEsbz10aGlzW3QrLS1uXTtuPjAmJihpKj0yNTYpOylvKz10aGlzW3QrLS1uXSppO3JldHVybiBvPj0oaSo9MTI4KSYmKG8tPU1hdGgucG93KDIsOCplKSksb30sdS5wcm90b3R5cGUucmVhZEludDg9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW3RdPy0xKigyNTUtdGhpc1t0XSsxKTp0aGlzW3RdfSx1LnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbih0LGUpe2V8fFQodCwyLHRoaXMubGVuZ3RoKTt2YXIgcj10aGlzW3RdfHRoaXNbdCsxXTw8ODtyZXR1cm4gMzI3Njgmcj80Mjk0OTAxNzYwfHI6cn0sdS5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24odCxlKXtlfHxUKHQsMix0aGlzLmxlbmd0aCk7dmFyIHI9dGhpc1t0KzFdfHRoaXNbdF08PDg7cmV0dXJuIDMyNzY4JnI/NDI5NDkwMTc2MHxyOnJ9LHUucHJvdG90eXBlLnJlYWRJbnQzMkxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdfHRoaXNbdCsxXTw8OHx0aGlzW3QrMl08PDE2fHRoaXNbdCszXTw8MjR9LHUucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSx0aGlzW3RdPDwyNHx0aGlzW3QrMV08PDE2fHRoaXNbdCsyXTw8OHx0aGlzW3QrM119LHUucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw0LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDIzLDQpfSx1LnByb3RvdHlwZS5yZWFkRmxvYXRCRT1mdW5jdGlvbih0LGUpe3JldHVybiBlfHxUKHQsNCx0aGlzLmxlbmd0aCksaS5yZWFkKHRoaXMsdCwhMSwyMyw0KX0sdS5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGV8fFQodCw4LHRoaXMubGVuZ3RoKSxpLnJlYWQodGhpcyx0LCEwLDUyLDgpfSx1LnByb3RvdHlwZS5yZWFkRG91YmxlQkU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZXx8VCh0LDgsdGhpcy5sZW5ndGgpLGkucmVhZCh0aGlzLHQsITEsNTIsOCl9LHUucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uKHQsZSxyLG4peyh0PSt0LGV8PTAscnw9MCxuKXx8UCh0aGlzLHQsZSxyLE1hdGgucG93KDIsOCpyKS0xLDApO3ZhciBpPTEsbz0wO2Zvcih0aGlzW2VdPTI1NSZ0OysrbzxyJiYoaSo9MjU2KTspdGhpc1tlK29dPXQvaSYyNTU7cmV0dXJuIGUrcn0sdS5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24odCxlLHIsbil7KHQ9K3QsZXw9MCxyfD0wLG4pfHxQKHRoaXMsdCxlLHIsTWF0aC5wb3coMiw4KnIpLTEsMCk7dmFyIGk9ci0xLG89MTtmb3IodGhpc1tlK2ldPTI1NSZ0Oy0taT49MCYmKG8qPTI1Nik7KXRoaXNbZStpXT10L28mMjU1O3JldHVybiBlK3J9LHUucHJvdG90eXBlLndyaXRlVUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwxLDI1NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHRoaXNbZV09MjU1JnQsZSsxfSx1LnByb3RvdHlwZS53cml0ZVVJbnQxNkxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsMiw2NTUzNSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTpBKHRoaXMsdCxlLCEwKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwyLDY1NTM1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+OCx0aGlzW2UrMV09MjU1JnQpOkEodGhpcyx0LGUsITEpLGUrMn0sdS5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDQsNDI5NDk2NzI5NSwwKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZSszXT10Pj4+MjQsdGhpc1tlKzJdPXQ+Pj4xNix0aGlzW2UrMV09dD4+PjgsdGhpc1tlXT0yNTUmdCk6TCh0aGlzLHQsZSwhMCksZSs0fSx1LnByb3RvdHlwZS53cml0ZVVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsNCw0Mjk0OTY3Mjk1LDApLHUuVFlQRURfQVJSQVlfU1VQUE9SVD8odGhpc1tlXT10Pj4+MjQsdGhpc1tlKzFdPXQ+Pj4xNix0aGlzW2UrMl09dD4+PjgsdGhpc1tlKzNdPTI1NSZ0KTpMKHRoaXMsdCxlLCExKSxlKzR9LHUucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24odCxlLHIsbil7aWYodD0rdCxlfD0wLCFuKXt2YXIgaT1NYXRoLnBvdygyLDgqci0xKTtQKHRoaXMsdCxlLHIsaS0xLC1pKX12YXIgbz0wLGE9MSxzPTA7Zm9yKHRoaXNbZV09MjU1JnQ7KytvPHImJihhKj0yNTYpOyl0PDAmJjA9PT1zJiYwIT09dGhpc1tlK28tMV0mJihzPTEpLHRoaXNbZStvXT0odC9hPj4wKS1zJjI1NTtyZXR1cm4gZStyfSx1LnByb3RvdHlwZS53cml0ZUludEJFPWZ1bmN0aW9uKHQsZSxyLG4pe2lmKHQ9K3QsZXw9MCwhbil7dmFyIGk9TWF0aC5wb3coMiw4KnItMSk7UCh0aGlzLHQsZSxyLGktMSwtaSl9dmFyIG89ci0xLGE9MSxzPTA7Zm9yKHRoaXNbZStvXT0yNTUmdDstLW8+PTAmJihhKj0yNTYpOyl0PDAmJjA9PT1zJiYwIT09dGhpc1tlK28rMV0mJihzPTEpLHRoaXNbZStvXT0odC9hPj4wKS1zJjI1NTtyZXR1cm4gZStyfSx1LnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24odCxlLHIpe3JldHVybiB0PSt0LGV8PTAscnx8UCh0aGlzLHQsZSwxLDEyNywtMTI4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlR8fCh0PU1hdGguZmxvb3IodCkpLHQ8MCYmKHQ9MjU1K3QrMSksdGhpc1tlXT0yNTUmdCxlKzF9LHUucHJvdG90eXBlLndyaXRlSW50MTZMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09MjU1JnQsdGhpc1tlKzFdPXQ+Pj44KTpBKHRoaXMsdCxlLCEwKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDIsMzI3NjcsLTMyNzY4KSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjgsdGhpc1tlKzFdPTI1NSZ0KTpBKHRoaXMsdCxlLCExKSxlKzJ9LHUucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIHQ9K3QsZXw9MCxyfHxQKHRoaXMsdCxlLDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksdS5UWVBFRF9BUlJBWV9TVVBQT1JUPyh0aGlzW2VdPTI1NSZ0LHRoaXNbZSsxXT10Pj4+OCx0aGlzW2UrMl09dD4+PjE2LHRoaXNbZSszXT10Pj4+MjQpOkwodGhpcyx0LGUsITApLGUrNH0sdS5wcm90b3R5cGUud3JpdGVJbnQzMkJFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gdD0rdCxlfD0wLHJ8fFAodGhpcyx0LGUsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx0PDAmJih0PTQyOTQ5NjcyOTUrdCsxKSx1LlRZUEVEX0FSUkFZX1NVUFBPUlQ/KHRoaXNbZV09dD4+PjI0LHRoaXNbZSsxXT10Pj4+MTYsdGhpc1tlKzJdPXQ+Pj44LHRoaXNbZSszXT0yNTUmdCk6TCh0aGlzLHQsZSwhMSksZSs0fSx1LnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBNKHRoaXMsdCxlLCEwLHIpfSx1LnByb3RvdHlwZS53cml0ZUZsb2F0QkU9ZnVuY3Rpb24odCxlLHIpe3JldHVybiBNKHRoaXMsdCxlLCExLHIpfSx1LnByb3RvdHlwZS53cml0ZURvdWJsZUxFPWZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gTih0aGlzLHQsZSwhMCxyKX0sdS5wcm90b3R5cGUud3JpdGVEb3VibGVCRT1mdW5jdGlvbih0LGUscil7cmV0dXJuIE4odGhpcyx0LGUsITEscil9LHUucHJvdG90eXBlLmNvcHk9ZnVuY3Rpb24odCxlLHIsbil7aWYocnx8KHI9MCksbnx8MD09PW58fChuPXRoaXMubGVuZ3RoKSxlPj10Lmxlbmd0aCYmKGU9dC5sZW5ndGgpLGV8fChlPTApLG4+MCYmbjxyJiYobj1yKSxuPT09cilyZXR1cm4gMDtpZigwPT09dC5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZihlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKHI8MHx8cj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKG48MCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInNvdXJjZUVuZCBvdXQgb2YgYm91bmRzXCIpO24+dGhpcy5sZW5ndGgmJihuPXRoaXMubGVuZ3RoKSx0Lmxlbmd0aC1lPG4tciYmKG49dC5sZW5ndGgtZStyKTt2YXIgaSxvPW4tcjtpZih0aGlzPT09dCYmcjxlJiZlPG4pZm9yKGk9by0xO2k+PTA7LS1pKXRbaStlXT10aGlzW2krcl07ZWxzZSBpZihvPDFlM3x8IXUuVFlQRURfQVJSQVlfU1VQUE9SVClmb3IoaT0wO2k8bzsrK2kpdFtpK2VdPXRoaXNbaStyXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKHQsdGhpcy5zdWJhcnJheShyLHIrbyksZSk7cmV0dXJuIG99LHUucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCxlLHIsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlPyhuPWUsZT0wLHI9dGhpcy5sZW5ndGgpOlwic3RyaW5nXCI9PXR5cGVvZiByJiYobj1yLHI9dGhpcy5sZW5ndGgpLDE9PT10Lmxlbmd0aCl7dmFyIGk9dC5jaGFyQ29kZUF0KDApO2k8MjU2JiYodD1pKX1pZih2b2lkIDAhPT1uJiZcInN0cmluZ1wiIT10eXBlb2Ygbil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgbiYmIXUuaXNFbmNvZGluZyhuKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrbil9ZWxzZVwibnVtYmVyXCI9PXR5cGVvZiB0JiYodCY9MjU1KTtpZihlPDB8fHRoaXMubGVuZ3RoPGV8fHRoaXMubGVuZ3RoPHIpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJPdXQgb2YgcmFuZ2UgaW5kZXhcIik7aWYocjw9ZSlyZXR1cm4gdGhpczt2YXIgbztpZihlPj4+PTAscj12b2lkIDA9PT1yP3RoaXMubGVuZ3RoOnI+Pj4wLHR8fCh0PTApLFwibnVtYmVyXCI9PXR5cGVvZiB0KWZvcihvPWU7bzxyOysrbyl0aGlzW29dPXQ7ZWxzZXt2YXIgYT11LmlzQnVmZmVyKHQpP3Q6VShuZXcgdSh0LG4pLnRvU3RyaW5nKCkpLHM9YS5sZW5ndGg7Zm9yKG89MDtvPHItZTsrK28pdGhpc1tvK2VdPWFbbyVzXX1yZXR1cm4gdGhpc307dmFyIEI9L1teK1xcLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIEQodCl7cmV0dXJuIHQ8MTY/XCIwXCIrdC50b1N0cmluZygxNik6dC50b1N0cmluZygxNil9ZnVuY3Rpb24gVSh0LGUpe3ZhciByO2U9ZXx8MS8wO2Zvcih2YXIgbj10Lmxlbmd0aCxpPW51bGwsbz1bXSxhPTA7YTxuOysrYSl7aWYoKHI9dC5jaGFyQ29kZUF0KGEpKT41NTI5NSYmcjw1NzM0NCl7aWYoIWkpe2lmKHI+NTYzMTkpeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KTtjb250aW51ZX1pZihhKzE9PT1uKXsoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9aT1yO2NvbnRpbnVlfWlmKHI8NTYzMjApeyhlLT0zKT4tMSYmby5wdXNoKDIzOSwxOTEsMTg5KSxpPXI7Y29udGludWV9cj02NTUzNisoaS01NTI5Njw8MTB8ci01NjMyMCl9ZWxzZSBpJiYoZS09Myk+LTEmJm8ucHVzaCgyMzksMTkxLDE4OSk7aWYoaT1udWxsLHI8MTI4KXtpZigoZS09MSk8MClicmVhaztvLnB1c2gocil9ZWxzZSBpZihyPDIwNDgpe2lmKChlLT0yKTwwKWJyZWFrO28ucHVzaChyPj42fDE5Miw2MyZyfDEyOCl9ZWxzZSBpZihyPDY1NTM2KXtpZigoZS09Myk8MClicmVhaztvLnB1c2gocj4+MTJ8MjI0LHI+PjYmNjN8MTI4LDYzJnJ8MTI4KX1lbHNle2lmKCEocjwxMTE0MTEyKSl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNvZGUgcG9pbnRcIik7aWYoKGUtPTQpPDApYnJlYWs7by5wdXNoKHI+PjE4fDI0MCxyPj4xMiY2M3wxMjgscj4+NiY2M3wxMjgsNjMmcnwxMjgpfX1yZXR1cm4gb31mdW5jdGlvbiBxKHQpe3JldHVybiBuLnRvQnl0ZUFycmF5KGZ1bmN0aW9uKHQpe2lmKCh0PWZ1bmN0aW9uKHQpe3JldHVybiB0LnRyaW0/dC50cmltKCk6dC5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLFwiXCIpfSh0KS5yZXBsYWNlKEIsXCJcIikpLmxlbmd0aDwyKXJldHVyblwiXCI7Zm9yKDt0Lmxlbmd0aCU0IT0wOyl0Kz1cIj1cIjtyZXR1cm4gdH0odCkpfWZ1bmN0aW9uIEcodCxlLHIsbil7Zm9yKHZhciBpPTA7aTxuJiYhKGkrcj49ZS5sZW5ndGh8fGk+PXQubGVuZ3RoKTsrK2kpZVtpK3JdPXRbaV07cmV0dXJuIGl9fSkuY2FsbCh0aGlzLHIoMjEpKX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGk9XCJvYmplY3RcIj09dHlwZW9mIFJlZmxlY3Q/UmVmbGVjdDpudWxsLG89aSYmXCJmdW5jdGlvblwiPT10eXBlb2YgaS5hcHBseT9pLmFwcGx5OmZ1bmN0aW9uKHQsZSxyKXtyZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodCxlLHIpfTtuPWkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGkub3duS2V5cz9pLm93bktleXM6T2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scz9mdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCkuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCkpfTpmdW5jdGlvbih0KXtyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModCl9O3ZhciBhPU51bWJlci5pc05hTnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQhPXR9O2Z1bmN0aW9uIHMoKXtzLmluaXQuY2FsbCh0aGlzKX10LmV4cG9ydHM9cyxzLkV2ZW50RW1pdHRlcj1zLHMucHJvdG90eXBlLl9ldmVudHM9dm9pZCAwLHMucHJvdG90eXBlLl9ldmVudHNDb3VudD0wLHMucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnM9dm9pZCAwO3ZhciB1PTEwO2Z1bmN0aW9uIGModCl7aWYoXCJmdW5jdGlvblwiIT10eXBlb2YgdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnK3R5cGVvZiB0KX1mdW5jdGlvbiBmKHQpe3JldHVybiB2b2lkIDA9PT10Ll9tYXhMaXN0ZW5lcnM/cy5kZWZhdWx0TWF4TGlzdGVuZXJzOnQuX21heExpc3RlbmVyc31mdW5jdGlvbiBsKHQsZSxyLG4pe3ZhciBpLG8sYSxzO2lmKGMociksdm9pZCAwPT09KG89dC5fZXZlbnRzKT8obz10Ll9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0Ll9ldmVudHNDb3VudD0wKToodm9pZCAwIT09by5uZXdMaXN0ZW5lciYmKHQuZW1pdChcIm5ld0xpc3RlbmVyXCIsZSxyLmxpc3RlbmVyP3IubGlzdGVuZXI6ciksbz10Ll9ldmVudHMpLGE9b1tlXSksdm9pZCAwPT09YSlhPW9bZV09ciwrK3QuX2V2ZW50c0NvdW50O2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgYT9hPW9bZV09bj9bcixhXTpbYSxyXTpuP2EudW5zaGlmdChyKTphLnB1c2gociksKGk9Zih0KSk+MCYmYS5sZW5ndGg+aSYmIWEud2FybmVkKXthLndhcm5lZD0hMDt2YXIgdT1uZXcgRXJyb3IoXCJQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuIFwiK2EubGVuZ3RoK1wiIFwiK1N0cmluZyhlKStcIiBsaXN0ZW5lcnMgYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0XCIpO3UubmFtZT1cIk1heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZ1wiLHUuZW1pdHRlcj10LHUudHlwZT1lLHUuY291bnQ9YS5sZW5ndGgscz11LGNvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKHMpfXJldHVybiB0fWZ1bmN0aW9uIGgoKXtpZighdGhpcy5maXJlZClyZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKSx0aGlzLmZpcmVkPSEwLDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk6dGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCxhcmd1bWVudHMpfWZ1bmN0aW9uIHAodCxlLHIpe3ZhciBuPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDp0LHR5cGU6ZSxsaXN0ZW5lcjpyfSxpPWguYmluZChuKTtyZXR1cm4gaS5saXN0ZW5lcj1yLG4ud3JhcEZuPWksaX1mdW5jdGlvbiBkKHQsZSxyKXt2YXIgbj10Ll9ldmVudHM7aWYodm9pZCAwPT09bilyZXR1cm5bXTt2YXIgaT1uW2VdO3JldHVybiB2b2lkIDA9PT1pP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIGk/cj9baS5saXN0ZW5lcnx8aV06W2ldOnI/ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0Lmxlbmd0aCkscj0wO3I8ZS5sZW5ndGg7KytyKWVbcl09dFtyXS5saXN0ZW5lcnx8dFtyXTtyZXR1cm4gZX0oaSk6ZyhpLGkubGVuZ3RoKX1mdW5jdGlvbiB2KHQpe3ZhciBlPXRoaXMuX2V2ZW50cztpZih2b2lkIDAhPT1lKXt2YXIgcj1lW3RdO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHIpcmV0dXJuIDE7aWYodm9pZCAwIT09cilyZXR1cm4gci5sZW5ndGh9cmV0dXJuIDB9ZnVuY3Rpb24gZyh0LGUpe2Zvcih2YXIgcj1uZXcgQXJyYXkoZSksbj0wO248ZTsrK24pcltuXT10W25dO3JldHVybiByfU9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLFwiZGVmYXVsdE1heExpc3RlbmVyc1wiLHtlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiB1fSxzZXQ6ZnVuY3Rpb24odCl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIHR8fHQ8MHx8YSh0KSl0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcrdCtcIi5cIik7dT10fX0pLHMuaW5pdD1mdW5jdGlvbigpe3ZvaWQgMCE9PXRoaXMuX2V2ZW50cyYmdGhpcy5fZXZlbnRzIT09T2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHN8fCh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LHMucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbih0KXtpZihcIm51bWJlclwiIT10eXBlb2YgdHx8dDwwfHxhKHQpKXRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyt0K1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPXQsdGhpc30scy5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIGYodGhpcyl9LHMucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTtyPGFyZ3VtZW50cy5sZW5ndGg7cisrKWUucHVzaChhcmd1bWVudHNbcl0pO3ZhciBuPVwiZXJyb3JcIj09PXQsaT10aGlzLl9ldmVudHM7aWYodm9pZCAwIT09aSluPW4mJnZvaWQgMD09PWkuZXJyb3I7ZWxzZSBpZighbilyZXR1cm4hMTtpZihuKXt2YXIgYTtpZihlLmxlbmd0aD4wJiYoYT1lWzBdKSxhIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgYTt2YXIgcz1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKGE/XCIgKFwiK2EubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgcy5jb250ZXh0PWEsc312YXIgdT1pW3RdO2lmKHZvaWQgMD09PXUpcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdSlvKHUsdGhpcyxlKTtlbHNle3ZhciBjPXUubGVuZ3RoLGY9Zyh1LGMpO2ZvcihyPTA7cjxjOysrcilvKGZbcl0sdGhpcyxlKX1yZXR1cm4hMH0scy5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbCh0aGlzLHQsZSwhMSl9LHMucHJvdG90eXBlLm9uPXMucHJvdG90eXBlLmFkZExpc3RlbmVyLHMucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBsKHRoaXMsdCxlLCEwKX0scy5wcm90b3R5cGUub25jZT1mdW5jdGlvbih0LGUpe3JldHVybiBjKGUpLHRoaXMub24odCxwKHRoaXMsdCxlKSksdGhpc30scy5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbih0LGUpe3JldHVybiBjKGUpLHRoaXMucHJlcGVuZExpc3RlbmVyKHQscCh0aGlzLHQsZSkpLHRoaXN9LHMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYTtpZihjKGUpLHZvaWQgMD09PShuPXRoaXMuX2V2ZW50cykpcmV0dXJuIHRoaXM7aWYodm9pZCAwPT09KHI9blt0XSkpcmV0dXJuIHRoaXM7aWYocj09PWV8fHIubGlzdGVuZXI9PT1lKTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSBuW3RdLG4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxyLmxpc3RlbmVyfHxlKSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiByKXtmb3IoaT0tMSxvPXIubGVuZ3RoLTE7bz49MDtvLS0paWYocltvXT09PWV8fHJbb10ubGlzdGVuZXI9PT1lKXthPXJbb10ubGlzdGVuZXIsaT1vO2JyZWFrfWlmKGk8MClyZXR1cm4gdGhpczswPT09aT9yLnNoaWZ0KCk6ZnVuY3Rpb24odCxlKXtmb3IoO2UrMTx0Lmxlbmd0aDtlKyspdFtlXT10W2UrMV07dC5wb3AoKX0ocixpKSwxPT09ci5sZW5ndGgmJihuW3RdPXJbMF0pLHZvaWQgMCE9PW4ucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsdCxhfHxlKX1yZXR1cm4gdGhpc30scy5wcm90b3R5cGUub2ZmPXMucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLHMucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycz1mdW5jdGlvbih0KXt2YXIgZSxyLG47aWYodm9pZCAwPT09KHI9dGhpcy5fZXZlbnRzKSlyZXR1cm4gdGhpcztpZih2b2lkIDA9PT1yLnJlbW92ZUxpc3RlbmVyKXJldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD8odGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCk6dm9pZCAwIT09clt0XSYmKDA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6ZGVsZXRlIHJbdF0pLHRoaXM7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpLG89T2JqZWN0LmtleXMocik7Zm9yKG49MDtuPG8ubGVuZ3RoOysrbilcInJlbW92ZUxpc3RlbmVyXCIhPT0oaT1vW25dKSYmdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoaSk7cmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVtb3ZlTGlzdGVuZXJcIiksdGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fZXZlbnRzQ291bnQ9MCx0aGlzfWlmKFwiZnVuY3Rpb25cIj09dHlwZW9mKGU9clt0XSkpdGhpcy5yZW1vdmVMaXN0ZW5lcih0LGUpO2Vsc2UgaWYodm9pZCAwIT09ZSlmb3Iobj1lLmxlbmd0aC0xO24+PTA7bi0tKXRoaXMucmVtb3ZlTGlzdGVuZXIodCxlW25dKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKHQpe3JldHVybiBkKHRoaXMsdCwhMCl9LHMucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbih0KXtyZXR1cm4gZCh0aGlzLHQsITEpfSxzLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiB0Lmxpc3RlbmVyQ291bnQ/dC5saXN0ZW5lckNvdW50KGUpOnYuY2FsbCh0LGUpfSxzLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PXYscy5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiB0aGlzLl9ldmVudHNDb3VudD4wP24odGhpcy5fZXZlbnRzKTpbXX19LGZ1bmN0aW9uKHQsZSxyKXsoZT10LmV4cG9ydHM9cigxMzgpKS5TdHJlYW09ZSxlLlJlYWRhYmxlPWUsZS5Xcml0YWJsZT1yKDk1KSxlLkR1cGxleD1yKDIzKSxlLlRyYW5zZm9ybT1yKDE0MiksZS5QYXNzVGhyb3VnaD1yKDE5Nil9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSxuLGkpe3ZhciBvPXIoNTUpO2Z1bmN0aW9uIGEodCl7dmFyIGU9dGhpczt0aGlzLm5leHQ9bnVsbCx0aGlzLmVudHJ5PW51bGwsdGhpcy5maW5pc2g9ZnVuY3Rpb24oKXshZnVuY3Rpb24odCxlLHIpe3ZhciBuPXQuZW50cnk7dC5lbnRyeT1udWxsO2Zvcig7bjspe3ZhciBpPW4uY2FsbGJhY2s7ZS5wZW5kaW5nY2ItLSxpKHIpLG49bi5uZXh0fWUuY29ya2VkUmVxdWVzdHNGcmVlP2UuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQ9dDplLmNvcmtlZFJlcXVlc3RzRnJlZT10fShlLHQpfX10LmV4cG9ydHM9Yjt2YXIgcyx1PSFlLmJyb3dzZXImJltcInYwLjEwXCIsXCJ2MC45LlwiXS5pbmRleE9mKGUudmVyc2lvbi5zbGljZSgwLDUpKT4tMT9uOm8ubmV4dFRpY2s7Yi5Xcml0YWJsZVN0YXRlPXk7dmFyIGM9cigzOSk7Yy5pbmhlcml0cz1yKDI5KTt2YXIgZj17ZGVwcmVjYXRlOnIoMTk1KX0sbD1yKDEzOSksaD1yKDU2KS5CdWZmZXIscD1pLlVpbnQ4QXJyYXl8fGZ1bmN0aW9uKCl7fTt2YXIgZCx2PXIoMTQwKTtmdW5jdGlvbiBnKCl7fWZ1bmN0aW9uIHkodCxlKXtzPXN8fHIoMjMpLHQ9dHx8e307dmFyIG49ZSBpbnN0YW5jZW9mIHM7dGhpcy5vYmplY3RNb2RlPSEhdC5vYmplY3RNb2RlLG4mJih0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIXQud3JpdGFibGVPYmplY3RNb2RlKTt2YXIgaT10LmhpZ2hXYXRlck1hcmssYz10LndyaXRhYmxlSGlnaFdhdGVyTWFyayxmPXRoaXMub2JqZWN0TW9kZT8xNjoxNjM4NDt0aGlzLmhpZ2hXYXRlck1hcms9aXx8MD09PWk/aTpuJiYoY3x8MD09PWMpP2M6Zix0aGlzLmhpZ2hXYXRlck1hcms9TWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspLHRoaXMuZmluYWxDYWxsZWQ9ITEsdGhpcy5uZWVkRHJhaW49ITEsdGhpcy5lbmRpbmc9ITEsdGhpcy5lbmRlZD0hMSx0aGlzLmZpbmlzaGVkPSExLHRoaXMuZGVzdHJveWVkPSExO3ZhciBsPSExPT09dC5kZWNvZGVTdHJpbmdzO3RoaXMuZGVjb2RlU3RyaW5ncz0hbCx0aGlzLmRlZmF1bHRFbmNvZGluZz10LmRlZmF1bHRFbmNvZGluZ3x8XCJ1dGY4XCIsdGhpcy5sZW5ndGg9MCx0aGlzLndyaXRpbmc9ITEsdGhpcy5jb3JrZWQ9MCx0aGlzLnN5bmM9ITAsdGhpcy5idWZmZXJQcm9jZXNzaW5nPSExLHRoaXMub253cml0ZT1mdW5jdGlvbih0KXshZnVuY3Rpb24odCxlKXt2YXIgcj10Ll93cml0YWJsZVN0YXRlLG49ci5zeW5jLGk9ci53cml0ZWNiO2lmKGZ1bmN0aW9uKHQpe3Qud3JpdGluZz0hMSx0LndyaXRlY2I9bnVsbCx0Lmxlbmd0aC09dC53cml0ZWxlbix0LndyaXRlbGVuPTB9KHIpLGUpIWZ1bmN0aW9uKHQsZSxyLG4saSl7LS1lLnBlbmRpbmdjYixyPyhvLm5leHRUaWNrKGksbiksby5uZXh0VGljayhFLHQsZSksdC5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ITAsdC5lbWl0KFwiZXJyb3JcIixuKSk6KGkobiksdC5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQ9ITAsdC5lbWl0KFwiZXJyb3JcIixuKSxFKHQsZSkpfSh0LHIsbixlLGkpO2Vsc2V7dmFyIGE9eChyKTthfHxyLmNvcmtlZHx8ci5idWZmZXJQcm9jZXNzaW5nfHwhci5idWZmZXJlZFJlcXVlc3R8fHcodCxyKSxuP3UobSx0LHIsYSxpKTptKHQscixhLGkpfX0oZSx0KX0sdGhpcy53cml0ZWNiPW51bGwsdGhpcy53cml0ZWxlbj0wLHRoaXMuYnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwsdGhpcy5wZW5kaW5nY2I9MCx0aGlzLnByZWZpbmlzaGVkPSExLHRoaXMuZXJyb3JFbWl0dGVkPSExLHRoaXMuYnVmZmVyZWRSZXF1ZXN0Q291bnQ9MCx0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZT1uZXcgYSh0aGlzKX1mdW5jdGlvbiBiKHQpe2lmKHM9c3x8cigyMyksIShkLmNhbGwoYix0aGlzKXx8dGhpcyBpbnN0YW5jZW9mIHMpKXJldHVybiBuZXcgYih0KTt0aGlzLl93cml0YWJsZVN0YXRlPW5ldyB5KHQsdGhpcyksdGhpcy53cml0YWJsZT0hMCx0JiYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC53cml0ZSYmKHRoaXMuX3dyaXRlPXQud3JpdGUpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQud3JpdGV2JiYodGhpcy5fd3JpdGV2PXQud3JpdGV2KSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmRlc3Ryb3kmJih0aGlzLl9kZXN0cm95PXQuZGVzdHJveSksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5maW5hbCYmKHRoaXMuX2ZpbmFsPXQuZmluYWwpKSxsLmNhbGwodGhpcyl9ZnVuY3Rpb24gXyh0LGUscixuLGksbyxhKXtlLndyaXRlbGVuPW4sZS53cml0ZWNiPWEsZS53cml0aW5nPSEwLGUuc3luYz0hMCxyP3QuX3dyaXRldihpLGUub253cml0ZSk6dC5fd3JpdGUoaSxvLGUub253cml0ZSksZS5zeW5jPSExfWZ1bmN0aW9uIG0odCxlLHIsbil7cnx8ZnVuY3Rpb24odCxlKXswPT09ZS5sZW5ndGgmJmUubmVlZERyYWluJiYoZS5uZWVkRHJhaW49ITEsdC5lbWl0KFwiZHJhaW5cIikpfSh0LGUpLGUucGVuZGluZ2NiLS0sbigpLEUodCxlKX1mdW5jdGlvbiB3KHQsZSl7ZS5idWZmZXJQcm9jZXNzaW5nPSEwO3ZhciByPWUuYnVmZmVyZWRSZXF1ZXN0O2lmKHQuX3dyaXRldiYmciYmci5uZXh0KXt2YXIgbj1lLmJ1ZmZlcmVkUmVxdWVzdENvdW50LGk9bmV3IEFycmF5KG4pLG89ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7by5lbnRyeT1yO2Zvcih2YXIgcz0wLHU9ITA7cjspaVtzXT1yLHIuaXNCdWZ8fCh1PSExKSxyPXIubmV4dCxzKz0xO2kuYWxsQnVmZmVycz11LF8odCxlLCEwLGUubGVuZ3RoLGksXCJcIixvLmZpbmlzaCksZS5wZW5kaW5nY2IrKyxlLmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCxvLm5leHQ/KGUuY29ya2VkUmVxdWVzdHNGcmVlPW8ubmV4dCxvLm5leHQ9bnVsbCk6ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEoZSksZS5idWZmZXJlZFJlcXVlc3RDb3VudD0wfWVsc2V7Zm9yKDtyOyl7dmFyIGM9ci5jaHVuayxmPXIuZW5jb2RpbmcsbD1yLmNhbGxiYWNrO2lmKF8odCxlLCExLGUub2JqZWN0TW9kZT8xOmMubGVuZ3RoLGMsZixsKSxyPXIubmV4dCxlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS0sZS53cml0aW5nKWJyZWFrfW51bGw9PT1yJiYoZS5sYXN0QnVmZmVyZWRSZXF1ZXN0PW51bGwpfWUuYnVmZmVyZWRSZXF1ZXN0PXIsZS5idWZmZXJQcm9jZXNzaW5nPSExfWZ1bmN0aW9uIHgodCl7cmV0dXJuIHQuZW5kaW5nJiYwPT09dC5sZW5ndGgmJm51bGw9PT10LmJ1ZmZlcmVkUmVxdWVzdCYmIXQuZmluaXNoZWQmJiF0LndyaXRpbmd9ZnVuY3Rpb24gayh0LGUpe3QuX2ZpbmFsKChmdW5jdGlvbihyKXtlLnBlbmRpbmdjYi0tLHImJnQuZW1pdChcImVycm9yXCIsciksZS5wcmVmaW5pc2hlZD0hMCx0LmVtaXQoXCJwcmVmaW5pc2hcIiksRSh0LGUpfSkpfWZ1bmN0aW9uIEUodCxlKXt2YXIgcj14KGUpO3JldHVybiByJiYoIWZ1bmN0aW9uKHQsZSl7ZS5wcmVmaW5pc2hlZHx8ZS5maW5hbENhbGxlZHx8KFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuX2ZpbmFsPyhlLnBlbmRpbmdjYisrLGUuZmluYWxDYWxsZWQ9ITAsby5uZXh0VGljayhrLHQsZSkpOihlLnByZWZpbmlzaGVkPSEwLHQuZW1pdChcInByZWZpbmlzaFwiKSkpfSh0LGUpLDA9PT1lLnBlbmRpbmdjYiYmKGUuZmluaXNoZWQ9ITAsdC5lbWl0KFwiZmluaXNoXCIpKSkscn1jLmluaGVyaXRzKGIsbCkseS5wcm90b3R5cGUuZ2V0QnVmZmVyPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuYnVmZmVyZWRSZXF1ZXN0LGU9W107dDspZS5wdXNoKHQpLHQ9dC5uZXh0O3JldHVybiBlfSxmdW5jdGlvbigpe3RyeXtPYmplY3QuZGVmaW5lUHJvcGVydHkoeS5wcm90b3R5cGUsXCJidWZmZXJcIix7Z2V0OmYuZGVwcmVjYXRlKChmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEJ1ZmZlcigpfSksXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBpbnN0ZWFkLlwiLFwiREVQMDAwM1wiKX0pfWNhdGNoKHQpe319KCksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaGFzSW5zdGFuY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdPyhkPUZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24odCl7cmV0dXJuISFkLmNhbGwodGhpcyx0KXx8dGhpcz09PWImJih0JiZ0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgeSl9fSkpOmQ9ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiB0aGlzfSxiLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKCl7dGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpKX0sYi5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCxlLHIpe3ZhciBuLGk9dGhpcy5fd3JpdGFibGVTdGF0ZSxhPSExLHM9IWkub2JqZWN0TW9kZSYmKG49dCxoLmlzQnVmZmVyKG4pfHxuIGluc3RhbmNlb2YgcCk7cmV0dXJuIHMmJiFoLmlzQnVmZmVyKHQpJiYodD1mdW5jdGlvbih0KXtyZXR1cm4gaC5mcm9tKHQpfSh0KSksXCJmdW5jdGlvblwiPT10eXBlb2YgZSYmKHI9ZSxlPW51bGwpLHM/ZT1cImJ1ZmZlclwiOmV8fChlPWkuZGVmYXVsdEVuY29kaW5nKSxcImZ1bmN0aW9uXCIhPXR5cGVvZiByJiYocj1nKSxpLmVuZGVkP2Z1bmN0aW9uKHQsZSl7dmFyIHI9bmV3IEVycm9yKFwid3JpdGUgYWZ0ZXIgZW5kXCIpO3QuZW1pdChcImVycm9yXCIsciksby5uZXh0VGljayhlLHIpfSh0aGlzLHIpOihzfHxmdW5jdGlvbih0LGUscixuKXt2YXIgaT0hMCxhPSExO3JldHVybiBudWxsPT09cj9hPW5ldyBUeXBlRXJyb3IoXCJNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbVwiKTpcInN0cmluZ1wiPT10eXBlb2Ygcnx8dm9pZCAwPT09cnx8ZS5vYmplY3RNb2RlfHwoYT1uZXcgVHlwZUVycm9yKFwiSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVua1wiKSksYSYmKHQuZW1pdChcImVycm9yXCIsYSksby5uZXh0VGljayhuLGEpLGk9ITEpLGl9KHRoaXMsaSx0LHIpKSYmKGkucGVuZGluZ2NiKyssYT1mdW5jdGlvbih0LGUscixuLGksbyl7aWYoIXIpe3ZhciBhPWZ1bmN0aW9uKHQsZSxyKXt0Lm9iamVjdE1vZGV8fCExPT09dC5kZWNvZGVTdHJpbmdzfHxcInN0cmluZ1wiIT10eXBlb2YgZXx8KGU9aC5mcm9tKGUscikpO3JldHVybiBlfShlLG4saSk7biE9PWEmJihyPSEwLGk9XCJidWZmZXJcIixuPWEpfXZhciBzPWUub2JqZWN0TW9kZT8xOm4ubGVuZ3RoO2UubGVuZ3RoKz1zO3ZhciB1PWUubGVuZ3RoPGUuaGlnaFdhdGVyTWFyazt1fHwoZS5uZWVkRHJhaW49ITApO2lmKGUud3JpdGluZ3x8ZS5jb3JrZWQpe3ZhciBjPWUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtlLmxhc3RCdWZmZXJlZFJlcXVlc3Q9e2NodW5rOm4sZW5jb2Rpbmc6aSxpc0J1ZjpyLGNhbGxiYWNrOm8sbmV4dDpudWxsfSxjP2MubmV4dD1lLmxhc3RCdWZmZXJlZFJlcXVlc3Q6ZS5idWZmZXJlZFJlcXVlc3Q9ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0LGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQrPTF9ZWxzZSBfKHQsZSwhMSxzLG4saSxvKTtyZXR1cm4gdX0odGhpcyxpLHMsdCxlLHIpKSxhfSxiLnByb3RvdHlwZS5jb3JrPWZ1bmN0aW9uKCl7dGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrK30sYi5wcm90b3R5cGUudW5jb3JrPWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5fd3JpdGFibGVTdGF0ZTt0LmNvcmtlZCYmKHQuY29ya2VkLS0sdC53cml0aW5nfHx0LmNvcmtlZHx8dC5maW5pc2hlZHx8dC5idWZmZXJQcm9jZXNzaW5nfHwhdC5idWZmZXJlZFJlcXVlc3R8fHcodGhpcyx0KSl9LGIucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZz1mdW5jdGlvbih0KXtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9dC50b0xvd2VyQ2FzZSgpKSwhKFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigodCtcIlwiKS50b0xvd2VyQ2FzZSgpKT4tMSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZz10LHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShiLnByb3RvdHlwZSxcIndyaXRhYmxlSGlnaFdhdGVyTWFya1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSksYi5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSxyKXtyKG5ldyBFcnJvcihcIl93cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKSl9LGIucHJvdG90eXBlLl93cml0ZXY9bnVsbCxiLnByb3RvdHlwZS5lbmQ9ZnVuY3Rpb24odCxlLHIpe3ZhciBuPXRoaXMuX3dyaXRhYmxlU3RhdGU7XCJmdW5jdGlvblwiPT10eXBlb2YgdD8ocj10LHQ9bnVsbCxlPW51bGwpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGUmJihyPWUsZT1udWxsKSxudWxsIT10JiZ0aGlzLndyaXRlKHQsZSksbi5jb3JrZWQmJihuLmNvcmtlZD0xLHRoaXMudW5jb3JrKCkpLG4uZW5kaW5nfHxuLmZpbmlzaGVkfHxmdW5jdGlvbih0LGUscil7ZS5lbmRpbmc9ITAsRSh0LGUpLHImJihlLmZpbmlzaGVkP28ubmV4dFRpY2socik6dC5vbmNlKFwiZmluaXNoXCIscikpO2UuZW5kZWQ9ITAsdC53cml0YWJsZT0hMX0odGhpcyxuLHIpfSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYi5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3dyaXRhYmxlU3RhdGUmJnRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX0pLGIucHJvdG90eXBlLmRlc3Ryb3k9di5kZXN0cm95LGIucHJvdG90eXBlLl91bmRlc3Ryb3k9di51bmRlc3Ryb3ksYi5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLmVuZCgpLGUodCl9fSkuY2FsbCh0aGlzLHIoMzgpLHIoMTM2KS5zZXRJbW1lZGlhdGUscigyMSkpfSxmdW5jdGlvbih0LGUpe2Z1bmN0aW9uIHIoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZcInN5bWJvbFwiPT10eXBlb2YgU3ltYm9sLml0ZXJhdG9yP3QuZXhwb3J0cz1yPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdH06dC5leHBvcnRzPXI9ZnVuY3Rpb24odCl7cmV0dXJuIHQmJlwiZnVuY3Rpb25cIj09dHlwZW9mIFN5bWJvbCYmdC5jb25zdHJ1Y3Rvcj09PVN5bWJvbCYmdCE9PVN5bWJvbC5wcm90b3R5cGU/XCJzeW1ib2xcIjp0eXBlb2YgdH0scihlKX10LmV4cG9ydHM9cn0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTYpLGk9cig4MCksbz1yKDIwMiksYT1yKDIwMyk7ZnVuY3Rpb24gcyhlKXt2YXIgcj1cImZ1bmN0aW9uXCI9PXR5cGVvZiBNYXA/bmV3IE1hcDp2b2lkIDA7cmV0dXJuIHQuZXhwb3J0cz1zPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10fHwhbyh0KSlyZXR1cm4gdDtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtpZih2b2lkIDAhPT1yKXtpZihyLmhhcyh0KSlyZXR1cm4gci5nZXQodCk7ci5zZXQodCxlKX1mdW5jdGlvbiBlKCl7cmV0dXJuIGEodCxhcmd1bWVudHMsbih0aGlzKS5jb25zdHJ1Y3Rvcil9cmV0dXJuIGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pLGkoZSx0KX0scyhlKX10LmV4cG9ydHM9c30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDQpLG89cigyNiksYT1yKDI1KSxzPXIoNyksdT1yKDY5KSxjPXIoMTA3KSxmPXIoNSksbD1yKDEzKSxoPXIoNDcpLHA9cigxMCksZD1yKDgpLHY9cigyNyksZz1yKDEyKSx5PXIoNDMpLGI9cigzMSksXz1yKDcwKSxtPXIoNDgpLHc9cig0NikseD1yKDE0OCksaz1yKDEwNiksRT1yKDIyKSxTPXIoMTEpLGo9cig1OSksUj1yKDE0KSxDPXIoMTcpLEk9cig2NCksTz1yKDQ0KSxUPXIoNDUpLFA9cig2NSksQT1yKDMpLEw9cigxMTApLEY9cigxMTEpLE09cig0OSksTj1yKDI0KSxCPXIoMzMpLmZvckVhY2gsRD1PKFwiaGlkZGVuXCIpLFU9QShcInRvUHJpbWl0aXZlXCIpLHE9Ti5zZXQsRz1OLmdldHRlckZvcihcIlN5bWJvbFwiKSxXPU9iamVjdC5wcm90b3R5cGUsej1pLlN5bWJvbCxZPW8oXCJKU09OXCIsXCJzdHJpbmdpZnlcIiksUT1FLmYsJD1TLmYsSD14LmYsSz1qLmYsVj1JKFwic3ltYm9sc1wiKSxaPUkoXCJvcC1zeW1ib2xzXCIpLEo9SShcInN0cmluZy10by1zeW1ib2wtcmVnaXN0cnlcIiksWD1JKFwic3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeVwiKSx0dD1JKFwid2tzXCIpLGV0PWkuUU9iamVjdCxydD0hZXR8fCFldC5wcm90b3R5cGV8fCFldC5wcm90b3R5cGUuZmluZENoaWxkLG50PXMmJmYoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPV8oJCh7fSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuICQodGhpcyxcImFcIix7dmFsdWU6N30pLmF9fSkpLmF9KSk/ZnVuY3Rpb24odCxlLHIpe3ZhciBuPVEoVyxlKTtuJiZkZWxldGUgV1tlXSwkKHQsZSxyKSxuJiZ0IT09VyYmJChXLGUsbil9OiQsaXQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1WW3RdPV8oei5wcm90b3R5cGUpO3JldHVybiBxKHIse3R5cGU6XCJTeW1ib2xcIix0YWc6dCxkZXNjcmlwdGlvbjplfSksc3x8KHIuZGVzY3JpcHRpb249ZSkscn0sb3Q9Yz9mdW5jdGlvbih0KXtyZXR1cm5cInN5bWJvbFwiPT10eXBlb2YgdH06ZnVuY3Rpb24odCl7cmV0dXJuIE9iamVjdCh0KWluc3RhbmNlb2Ygen0sYXQ9ZnVuY3Rpb24odCxlLHIpe3Q9PT1XJiZhdChaLGUsciksZCh0KTt2YXIgbj15KGUsITApO3JldHVybiBkKHIpLGwoVixuKT8oci5lbnVtZXJhYmxlPyhsKHQsRCkmJnRbRF1bbl0mJih0W0RdW25dPSExKSxyPV8ocix7ZW51bWVyYWJsZTpiKDAsITEpfSkpOihsKHQsRCl8fCQodCxELGIoMSx7fSkpLHRbRF1bbl09ITApLG50KHQsbixyKSk6JCh0LG4scil9LHN0PWZ1bmN0aW9uKHQsZSl7ZCh0KTt2YXIgcj1nKGUpLG49bShyKS5jb25jYXQobHQocikpO3JldHVybiBCKG4sKGZ1bmN0aW9uKGUpe3MmJiF1dC5jYWxsKHIsZSl8fGF0KHQsZSxyW2VdKX0pKSx0fSx1dD1mdW5jdGlvbih0KXt2YXIgZT15KHQsITApLHI9Sy5jYWxsKHRoaXMsZSk7cmV0dXJuISh0aGlzPT09VyYmbChWLGUpJiYhbChaLGUpKSYmKCEocnx8IWwodGhpcyxlKXx8IWwoVixlKXx8bCh0aGlzLEQpJiZ0aGlzW0RdW2VdKXx8cil9LGN0PWZ1bmN0aW9uKHQsZSl7dmFyIHI9Zyh0KSxuPXkoZSwhMCk7aWYociE9PVd8fCFsKFYsbil8fGwoWixuKSl7dmFyIGk9UShyLG4pO3JldHVybiFpfHwhbChWLG4pfHxsKHIsRCkmJnJbRF1bbl18fChpLmVudW1lcmFibGU9ITApLGl9fSxmdD1mdW5jdGlvbih0KXt2YXIgZT1IKGcodCkpLHI9W107cmV0dXJuIEIoZSwoZnVuY3Rpb24odCl7bChWLHQpfHxsKFQsdCl8fHIucHVzaCh0KX0pKSxyfSxsdD1mdW5jdGlvbih0KXt2YXIgZT10PT09VyxyPUgoZT9aOmcodCkpLG49W107cmV0dXJuIEIociwoZnVuY3Rpb24odCl7IWwoVix0KXx8ZSYmIWwoVyx0KXx8bi5wdXNoKFZbdF0pfSkpLG59Oyh1fHwoQygoej1mdW5jdGlvbigpe2lmKHRoaXMgaW5zdGFuY2VvZiB6KXRocm93IFR5cGVFcnJvcihcIlN5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvclwiKTt2YXIgdD1hcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMF0/U3RyaW5nKGFyZ3VtZW50c1swXSk6dm9pZCAwLGU9UCh0KSxyPWZ1bmN0aW9uKHQpe3RoaXM9PT1XJiZyLmNhbGwoWix0KSxsKHRoaXMsRCkmJmwodGhpc1tEXSxlKSYmKHRoaXNbRF1bZV09ITEpLG50KHRoaXMsZSxiKDEsdCkpfTtyZXR1cm4gcyYmcnQmJm50KFcsZSx7Y29uZmlndXJhYmxlOiEwLHNldDpyfSksaXQoZSx0KX0pLnByb3RvdHlwZSxcInRvU3RyaW5nXCIsKGZ1bmN0aW9uKCl7cmV0dXJuIEcodGhpcykudGFnfSkpLEMoeixcIndpdGhvdXRTZXR0ZXJcIiwoZnVuY3Rpb24odCl7cmV0dXJuIGl0KFAodCksdCl9KSksai5mPXV0LFMuZj1hdCxFLmY9Y3Qsdy5mPXguZj1mdCxrLmY9bHQsTC5mPWZ1bmN0aW9uKHQpe3JldHVybiBpdChBKHQpLHQpfSxzJiYoJCh6LnByb3RvdHlwZSxcImRlc2NyaXB0aW9uXCIse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRyh0aGlzKS5kZXNjcmlwdGlvbn19KSxhfHxDKFcsXCJwcm9wZXJ0eUlzRW51bWVyYWJsZVwiLHV0LHt1bnNhZmU6ITB9KSkpLG4oe2dsb2JhbDohMCx3cmFwOiEwLGZvcmNlZDohdSxzaGFtOiF1fSx7U3ltYm9sOnp9KSxCKG0odHQpLChmdW5jdGlvbih0KXtGKHQpfSkpLG4oe3RhcmdldDpcIlN5bWJvbFwiLHN0YXQ6ITAsZm9yY2VkOiF1fSx7Zm9yOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh0KTtpZihsKEosZSkpcmV0dXJuIEpbZV07dmFyIHI9eihlKTtyZXR1cm4gSltlXT1yLFhbcl09ZSxyfSxrZXlGb3I6ZnVuY3Rpb24odCl7aWYoIW90KHQpKXRocm93IFR5cGVFcnJvcih0K1wiIGlzIG5vdCBhIHN5bWJvbFwiKTtpZihsKFgsdCkpcmV0dXJuIFhbdF19LHVzZVNldHRlcjpmdW5jdGlvbigpe3J0PSEwfSx1c2VTaW1wbGU6ZnVuY3Rpb24oKXtydD0hMX19KSxuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDohdSxzaGFtOiFzfSx7Y3JlYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHZvaWQgMD09PWU/Xyh0KTpzdChfKHQpLGUpfSxkZWZpbmVQcm9wZXJ0eTphdCxkZWZpbmVQcm9wZXJ0aWVzOnN0LGdldE93blByb3BlcnR5RGVzY3JpcHRvcjpjdH0pLG4oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiF1fSx7Z2V0T3duUHJvcGVydHlOYW1lczpmdCxnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6bHR9KSxuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwLGZvcmNlZDpmKChmdW5jdGlvbigpe2suZigxKX0pKX0se2dldE93blByb3BlcnR5U3ltYm9sczpmdW5jdGlvbih0KXtyZXR1cm4gay5mKHYodCkpfX0pLFkpJiZuKHt0YXJnZXQ6XCJKU09OXCIsc3RhdDohMCxmb3JjZWQ6IXV8fGYoKGZ1bmN0aW9uKCl7dmFyIHQ9eigpO3JldHVyblwiW251bGxdXCIhPVkoW3RdKXx8XCJ7fVwiIT1ZKHthOnR9KXx8XCJ7fVwiIT1ZKE9iamVjdCh0KSl9KSl9LHtzdHJpbmdpZnk6ZnVuY3Rpb24odCxlLHIpe2Zvcih2YXIgbixpPVt0XSxvPTE7YXJndW1lbnRzLmxlbmd0aD5vOylpLnB1c2goYXJndW1lbnRzW28rK10pO2lmKG49ZSwocChlKXx8dm9pZCAwIT09dCkmJiFvdCh0KSlyZXR1cm4gaChlKXx8KGU9ZnVuY3Rpb24odCxlKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBuJiYoZT1uLmNhbGwodGhpcyx0LGUpKSwhb3QoZSkpcmV0dXJuIGV9KSxpWzFdPWUsWS5hcHBseShudWxsLGkpfX0pO3oucHJvdG90eXBlW1VdfHxSKHoucHJvdG90eXBlLFUsei5wcm90b3R5cGUudmFsdWVPZiksTSh6LFwiU3ltYm9sXCIpLFRbRF09ITB9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcpLGk9cig1KSxvPXIoNjEpO3QuZXhwb3J0cz0hbiYmIWkoKGZ1bmN0aW9uKCl7cmV0dXJuIDchPU9iamVjdC5kZWZpbmVQcm9wZXJ0eShvKFwiZGl2XCIpLFwiYVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gN319KS5hfSkpfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoNjIpLG89bltcIl9fY29yZS1qc19zaGFyZWRfX1wiXXx8aShcIl9fY29yZS1qc19zaGFyZWRfX1wiLHt9KTt0LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTMpLGk9cigxMDIpLG89cigyMiksYT1yKDExKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIHI9aShlKSxzPWEuZix1PW8uZixjPTA7YzxyLmxlbmd0aDtjKyspe3ZhciBmPXJbY107bih0LGYpfHxzKHQsZix1KGUsZikpfX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDI2KSxpPXIoNDYpLG89cigxMDYpLGE9cig4KTt0LmV4cG9ydHM9bihcIlJlZmxlY3RcIixcIm93bktleXNcIil8fGZ1bmN0aW9uKHQpe3ZhciBlPWkuZihhKHQpKSxyPW8uZjtyZXR1cm4gcj9lLmNvbmNhdChyKHQpKTplfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCk7dC5leHBvcnRzPW59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEzKSxpPXIoMTIpLG89cig2NikuaW5kZXhPZixhPXIoNDUpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByLHM9aSh0KSx1PTAsYz1bXTtmb3IociBpbiBzKSFuKGEscikmJm4ocyxyKSYmYy5wdXNoKHIpO2Zvcig7ZS5sZW5ndGg+dTspbihzLHI9ZVt1KytdKSYmKH5vKGMscil8fGMucHVzaChyKSk7cmV0dXJuIGN9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigzMiksaT1NYXRoLm1heCxvPU1hdGgubWluO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPW4odCk7cmV0dXJuIHI8MD9pKHIrZSwwKTpvKHIsZSl9fSxmdW5jdGlvbih0LGUpe2UuZj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzfSxmdW5jdGlvbih0LGUscil7dmFyIG49cig2OSk7dC5leHBvcnRzPW4mJiFTeW1ib2wuc2hhbSYmXCJzeW1ib2xcIj09dHlwZW9mIFN5bWJvbC5pdGVyYXRvcn0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDExKSxvPXIoOCksYT1yKDQ4KTt0LmV4cG9ydHM9bj9PYmplY3QuZGVmaW5lUHJvcGVydGllczpmdW5jdGlvbih0LGUpe28odCk7Zm9yKHZhciByLG49YShlKSxzPW4ubGVuZ3RoLHU9MDtzPnU7KWkuZih0LHI9blt1KytdLGVbcl0pO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMjYpO3QuZXhwb3J0cz1uKFwiZG9jdW1lbnRcIixcImRvY3VtZW50RWxlbWVudFwiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMyk7ZS5mPW59LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEwMyksaT1yKDEzKSxvPXIoMTEwKSxhPXIoMTEpLmY7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPW4uU3ltYm9sfHwobi5TeW1ib2w9e30pO2koZSx0KXx8YShlLHQse3ZhbHVlOm8uZih0KX0pfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApLGk9cig0Nyksbz1yKDMpKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcjtyZXR1cm4gaSh0KSYmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKHI9dC5jb25zdHJ1Y3Rvcil8fHIhPT1BcnJheSYmIWkoci5wcm90b3R5cGUpP24ocikmJm51bGw9PT0ocj1yW29dKSYmKHI9dm9pZCAwKTpyPXZvaWQgMCksbmV3KHZvaWQgMD09PXI/QXJyYXk6cikoMD09PWU/MDplKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDMpLGk9cig3MCksbz1yKDExKSxhPW4oXCJ1bnNjb3BhYmxlc1wiKSxzPUFycmF5LnByb3RvdHlwZTtudWxsPT1zW2FdJiZvLmYocyxhLHtjb25maWd1cmFibGU6ITAsdmFsdWU6aShudWxsKX0pLHQuZXhwb3J0cz1mdW5jdGlvbih0KXtzW2FdW3RdPSEwfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDE1MSksbz1yKDExNiksYT1yKDExNykscz1yKDQ5KSx1PXIoMTQpLGM9cigxNyksZj1yKDMpLGw9cigyNSksaD1yKDM0KSxwPXIoMTE1KSxkPXAuSXRlcmF0b3JQcm90b3R5cGUsdj1wLkJVR0dZX1NBRkFSSV9JVEVSQVRPUlMsZz1mKFwiaXRlcmF0b3JcIikseT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsZixwLGIsXyl7aShyLGUsZik7dmFyIG0sdyx4LGs9ZnVuY3Rpb24odCl7aWYodD09PXAmJkMpcmV0dXJuIEM7aWYoIXYmJnQgaW4gailyZXR1cm4galt0XTtzd2l0Y2godCl7Y2FzZVwia2V5c1wiOmNhc2VcInZhbHVlc1wiOmNhc2VcImVudHJpZXNcIjpyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHIodGhpcyx0KX19cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyByKHRoaXMpfX0sRT1lK1wiIEl0ZXJhdG9yXCIsUz0hMSxqPXQucHJvdG90eXBlLFI9altnXXx8altcIkBAaXRlcmF0b3JcIl18fHAmJmpbcF0sQz0hdiYmUnx8ayhwKSxJPVwiQXJyYXlcIj09ZSYmai5lbnRyaWVzfHxSO2lmKEkmJihtPW8oSS5jYWxsKG5ldyB0KSksZCE9PU9iamVjdC5wcm90b3R5cGUmJm0ubmV4dCYmKGx8fG8obSk9PT1kfHwoYT9hKG0sZCk6XCJmdW5jdGlvblwiIT10eXBlb2YgbVtnXSYmdShtLGcseSkpLHMobSxFLCEwLCEwKSxsJiYoaFtFXT15KSkpLFwidmFsdWVzXCI9PXAmJlImJlwidmFsdWVzXCIhPT1SLm5hbWUmJihTPSEwLEM9ZnVuY3Rpb24oKXtyZXR1cm4gUi5jYWxsKHRoaXMpfSksbCYmIV98fGpbZ109PT1DfHx1KGosZyxDKSxoW2VdPUMscClpZih3PXt2YWx1ZXM6ayhcInZhbHVlc1wiKSxrZXlzOmI/QzprKFwia2V5c1wiKSxlbnRyaWVzOmsoXCJlbnRyaWVzXCIpfSxfKWZvcih4IGluIHcpKHZ8fFN8fCEoeCBpbiBqKSkmJmMoaix4LHdbeF0pO2Vsc2Ugbih7dGFyZ2V0OmUscHJvdG86ITAsZm9yY2VkOnZ8fFN9LHcpO3JldHVybiB3fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuLGksbyxhPXIoMTE2KSxzPXIoMTQpLHU9cigxMyksYz1yKDMpLGY9cigyNSksbD1jKFwiaXRlcmF0b3JcIiksaD0hMTtbXS5rZXlzJiYoXCJuZXh0XCJpbihvPVtdLmtleXMoKSk/KGk9YShhKG8pKSkhPT1PYmplY3QucHJvdG90eXBlJiYobj1pKTpoPSEwKSxudWxsPT1uJiYobj17fSksZnx8dShuLGwpfHxzKG4sbCwoZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pKSx0LmV4cG9ydHM9e0l0ZXJhdG9yUHJvdG90eXBlOm4sQlVHR1lfU0FGQVJJX0lURVJBVE9SUzpofX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTMpLGk9cigyNyksbz1yKDQ0KSxhPXIoMTUyKSxzPW8oXCJJRV9QUk9UT1wiKSx1PU9iamVjdC5wcm90b3R5cGU7dC5leHBvcnRzPWE/T2JqZWN0LmdldFByb3RvdHlwZU9mOmZ1bmN0aW9uKHQpe3JldHVybiB0PWkodCksbih0LHMpP3Rbc106XCJmdW5jdGlvblwiPT10eXBlb2YgdC5jb25zdHJ1Y3RvciYmdCBpbnN0YW5jZW9mIHQuY29uc3RydWN0b3I/dC5jb25zdHJ1Y3Rvci5wcm90b3R5cGU6dCBpbnN0YW5jZW9mIE9iamVjdD91Om51bGx9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig4KSxpPXIoMTUzKTt0LmV4cG9ydHM9T2JqZWN0LnNldFByb3RvdHlwZU9mfHwoXCJfX3Byb3RvX19cImlue30/ZnVuY3Rpb24oKXt2YXIgdCxlPSExLHI9e307dHJ5eyh0PU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0LnByb3RvdHlwZSxcIl9fcHJvdG9fX1wiKS5zZXQpLmNhbGwocixbXSksZT1yIGluc3RhbmNlb2YgQXJyYXl9Y2F0Y2godCl7fXJldHVybiBmdW5jdGlvbihyLG8pe3JldHVybiBuKHIpLGkobyksZT90LmNhbGwocixvKTpyLl9fcHJvdG9fXz1vLHJ9fSgpOnZvaWQgMCl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDcyKSxpPXIoMTkpLG89cigzKShcInRvU3RyaW5nVGFnXCIpLGE9XCJBcmd1bWVudHNcIj09aShmdW5jdGlvbigpe3JldHVybiBhcmd1bWVudHN9KCkpO3QuZXhwb3J0cz1uP2k6ZnVuY3Rpb24odCl7dmFyIGUscixuO3JldHVybiB2b2lkIDA9PT10P1wiVW5kZWZpbmVkXCI6bnVsbD09PXQ/XCJOdWxsXCI6XCJzdHJpbmdcIj09dHlwZW9mKHI9ZnVuY3Rpb24odCxlKXt0cnl7cmV0dXJuIHRbZV19Y2F0Y2godCl7fX0oZT1PYmplY3QodCksbykpP3I6YT9pKGUpOlwiT2JqZWN0XCI9PShuPWkoZSkpJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmNhbGxlZT9cIkFyZ3VtZW50c1wiOm59fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig1KTtmdW5jdGlvbiBpKHQsZSl7cmV0dXJuIFJlZ0V4cCh0LGUpfWUuVU5TVVBQT1JURURfWT1uKChmdW5jdGlvbigpe3ZhciB0PWkoXCJhXCIsXCJ5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcImFiY2RcIil9KSksZS5CUk9LRU5fQ0FSRVQ9bigoZnVuY3Rpb24oKXt2YXIgdD1pKFwiXnJcIixcImd5XCIpO3JldHVybiB0Lmxhc3RJbmRleD0yLG51bGwhPXQuZXhlYyhcInN0clwiKX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMzIpLGk9cigyMCksbz1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oZSxyKXt2YXIgbyxhLHM9U3RyaW5nKGkoZSkpLHU9bihyKSxjPXMubGVuZ3RoO3JldHVybiB1PDB8fHU+PWM/dD9cIlwiOnZvaWQgMDoobz1zLmNoYXJDb2RlQXQodSkpPDU1Mjk2fHxvPjU2MzE5fHx1KzE9PT1jfHwoYT1zLmNoYXJDb2RlQXQodSsxKSk8NTYzMjB8fGE+NTczNDM/dD9zLmNoYXJBdCh1KTpvOnQ/cy5zbGljZSh1LHUrMik6YS01NjMyMCsoby01NTI5Njw8MTApKzY1NTM2fX07dC5leHBvcnRzPXtjb2RlQXQ6byghMSksY2hhckF0Om8oITApfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9e0NTU1J1bGVMaXN0OjAsQ1NTU3R5bGVEZWNsYXJhdGlvbjowLENTU1ZhbHVlTGlzdDowLENsaWVudFJlY3RMaXN0OjAsRE9NUmVjdExpc3Q6MCxET01TdHJpbmdMaXN0OjAsRE9NVG9rZW5MaXN0OjEsRGF0YVRyYW5zZmVySXRlbUxpc3Q6MCxGaWxlTGlzdDowLEhUTUxBbGxDb2xsZWN0aW9uOjAsSFRNTENvbGxlY3Rpb246MCxIVE1MRm9ybUVsZW1lbnQ6MCxIVE1MU2VsZWN0RWxlbWVudDowLE1lZGlhTGlzdDowLE1pbWVUeXBlQXJyYXk6MCxOYW1lZE5vZGVNYXA6MCxOb2RlTGlzdDoxLFBhaW50UmVxdWVzdExpc3Q6MCxQbHVnaW46MCxQbHVnaW5BcnJheTowLFNWR0xlbmd0aExpc3Q6MCxTVkdOdW1iZXJMaXN0OjAsU1ZHUGF0aFNlZ0xpc3Q6MCxTVkdQb2ludExpc3Q6MCxTVkdTdHJpbmdMaXN0OjAsU1ZHVHJhbnNmb3JtTGlzdDowLFNvdXJjZUJ1ZmZlckxpc3Q6MCxTdHlsZVNoZWV0TGlzdDowLFRleHRUcmFja0N1ZUxpc3Q6MCxUZXh0VHJhY2tMaXN0OjAsVG91Y2hMaXN0OjB9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyNik7dC5leHBvcnRzPW4oXCJuYXZpZ2F0b3JcIixcInVzZXJBZ2VudFwiKXx8XCJcIn0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMzMpLmZvckVhY2gsaT1yKDM2KTt0LmV4cG9ydHM9aShcImZvckVhY2hcIik/ZnVuY3Rpb24odCl7cmV0dXJuIG4odGhpcyx0LGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKX06W10uZm9yRWFjaH0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDI3KSxvPXIoNDgpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOnIoNSkoKGZ1bmN0aW9uKCl7bygxKX0pKX0se2tleXM6ZnVuY3Rpb24odCl7cmV0dXJuIG8oaSh0KSl9fSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDI2KSxpPXIoMTEpLG89cigzKSxhPXIoNykscz1vKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dmFyIGU9bih0KSxyPWkuZjthJiZlJiYhZVtzXSYmcihlLHMse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc319KX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbixpPXIoMiksbz1yKDIyKS5mLGE9cigxNSkscz1yKDEyNyksdT1yKDIwKSxjPXIoMTI4KSxmPXIoMjUpLGw9XCJcIi5lbmRzV2l0aCxoPU1hdGgubWluLHA9YyhcImVuZHNXaXRoXCIpO2koe3RhcmdldDpcIlN0cmluZ1wiLHByb3RvOiEwLGZvcmNlZDohIShmfHxwfHwobj1vKFN0cmluZy5wcm90b3R5cGUsXCJlbmRzV2l0aFwiKSwhbnx8bi53cml0YWJsZSkpJiYhcH0se2VuZHNXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPVN0cmluZyh1KHRoaXMpKTtzKHQpO3ZhciByPWFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwLG49YShlLmxlbmd0aCksaT12b2lkIDA9PT1yP246aChhKHIpLG4pLG89U3RyaW5nKHQpO3JldHVybiBsP2wuY2FsbChlLG8saSk6ZS5zbGljZShpLW8ubGVuZ3RoLGkpPT09b319KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoODgpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihuKHQpKXRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDMpKFwibWF0Y2hcIik7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3ZhciBlPS8uLzt0cnl7XCIvLi9cIlt0XShlKX1jYXRjaChyKXt0cnl7cmV0dXJuIGVbbl09ITEsXCIvLi9cIlt0XShlKX1jYXRjaCh0KXt9fXJldHVybiExfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEyNyksbz1yKDIwKTtuKHt0YXJnZXQ6XCJTdHJpbmdcIixwcm90bzohMCxmb3JjZWQ6IXIoMTI4KShcImluY2x1ZGVzXCIpfSx7aW5jbHVkZXM6ZnVuY3Rpb24odCl7cmV0dXJuISF+U3RyaW5nKG8odGhpcykpLmluZGV4T2YoaSh0KSxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDIpLGk9cigxNzUpO24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOmkhPT1bXS5sYXN0SW5kZXhPZn0se2xhc3RJbmRleE9mOml9KX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDEwKSxvPXIoNDcpLGE9cigxMDUpLHM9cigxNSksdT1yKDEyKSxjPXIoODIpLGY9cig1NCksbD1yKDMpKFwic3BlY2llc1wiKSxoPVtdLnNsaWNlLHA9TWF0aC5tYXg7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6IWYoXCJzbGljZVwiKX0se3NsaWNlOmZ1bmN0aW9uKHQsZSl7dmFyIHIsbixmLGQ9dSh0aGlzKSx2PXMoZC5sZW5ndGgpLGc9YSh0LHYpLHk9YSh2b2lkIDA9PT1lP3Y6ZSx2KTtpZihvKGQpJiYoXCJmdW5jdGlvblwiIT10eXBlb2Yocj1kLmNvbnN0cnVjdG9yKXx8ciE9PUFycmF5JiYhbyhyLnByb3RvdHlwZSk/aShyKSYmbnVsbD09PShyPXJbbF0pJiYocj12b2lkIDApOnI9dm9pZCAwLHI9PT1BcnJheXx8dm9pZCAwPT09cikpcmV0dXJuIGguY2FsbChkLGcseSk7Zm9yKG49bmV3KHZvaWQgMD09PXI/QXJyYXk6cikocCh5LWcsMCkpLGY9MDtnPHk7ZysrLGYrKylnIGluIGQmJmMobixmLGRbZ10pO3JldHVybiBuLmxlbmd0aD1mLG59fSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgpLGk9cig1MCksbz1yKDMpKFwic3BlY2llc1wiKTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXt2YXIgcixhPW4odCkuY29uc3RydWN0b3I7cmV0dXJuIHZvaWQgMD09PWF8fG51bGw9PShyPW4oYSlbb10pP2U6aShyKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbixpLG8sYT1yKDQpLHM9cig1KSx1PXIoMTkpLGM9cig3MSksZj1yKDEwOSksbD1yKDYxKSxoPXIoMTM0KSxwPWEubG9jYXRpb24sZD1hLnNldEltbWVkaWF0ZSx2PWEuY2xlYXJJbW1lZGlhdGUsZz1hLnByb2Nlc3MseT1hLk1lc3NhZ2VDaGFubmVsLGI9YS5EaXNwYXRjaCxfPTAsbT17fSx3PWZ1bmN0aW9uKHQpe2lmKG0uaGFzT3duUHJvcGVydHkodCkpe3ZhciBlPW1bdF07ZGVsZXRlIG1bdF0sZSgpfX0seD1mdW5jdGlvbih0KXtyZXR1cm4gZnVuY3Rpb24oKXt3KHQpfX0saz1mdW5jdGlvbih0KXt3KHQuZGF0YSl9LEU9ZnVuY3Rpb24odCl7YS5wb3N0TWVzc2FnZSh0K1wiXCIscC5wcm90b2NvbCtcIi8vXCIrcC5ob3N0KX07ZCYmdnx8KGQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLHI9MTthcmd1bWVudHMubGVuZ3RoPnI7KWUucHVzaChhcmd1bWVudHNbcisrXSk7cmV0dXJuIG1bKytfXT1mdW5jdGlvbigpeyhcImZ1bmN0aW9uXCI9PXR5cGVvZiB0P3Q6RnVuY3Rpb24odCkpLmFwcGx5KHZvaWQgMCxlKX0sbihfKSxffSx2PWZ1bmN0aW9uKHQpe2RlbGV0ZSBtW3RdfSxcInByb2Nlc3NcIj09dShnKT9uPWZ1bmN0aW9uKHQpe2cubmV4dFRpY2soeCh0KSl9OmImJmIubm93P249ZnVuY3Rpb24odCl7Yi5ub3coeCh0KSl9OnkmJiFoPyhvPShpPW5ldyB5KS5wb3J0MixpLnBvcnQxLm9ubWVzc2FnZT1rLG49YyhvLnBvc3RNZXNzYWdlLG8sMSkpOiFhLmFkZEV2ZW50TGlzdGVuZXJ8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHBvc3RNZXNzYWdlfHxhLmltcG9ydFNjcmlwdHN8fHMoRSk/bj1cIm9ucmVhZHlzdGF0ZWNoYW5nZVwiaW4gbChcInNjcmlwdFwiKT9mdW5jdGlvbih0KXtmLmFwcGVuZENoaWxkKGwoXCJzY3JpcHRcIikpLm9ucmVhZHlzdGF0ZWNoYW5nZT1mdW5jdGlvbigpe2YucmVtb3ZlQ2hpbGQodGhpcyksdyh0KX19OmZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoeCh0KSwwKX06KG49RSxhLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsaywhMSkpKSx0LmV4cG9ydHM9e3NldDpkLGNsZWFyOnZ9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxMjIpO3QuZXhwb3J0cz0vKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3Qobil9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDUwKSxpPWZ1bmN0aW9uKHQpe3ZhciBlLHI7dGhpcy5wcm9taXNlPW5ldyB0KChmdW5jdGlvbih0LG4pe2lmKHZvaWQgMCE9PWV8fHZvaWQgMCE9PXIpdGhyb3cgVHlwZUVycm9yKFwiQmFkIFByb21pc2UgY29uc3RydWN0b3JcIik7ZT10LHI9bn0pKSx0aGlzLnJlc29sdmU9bihlKSx0aGlzLnJlamVjdD1uKHIpfTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGkodCl9fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQpe3ZhciBuPXZvaWQgMCE9PXQmJnR8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmfHx3aW5kb3csaT1GdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7ZnVuY3Rpb24gbyh0LGUpe3RoaXMuX2lkPXQsdGhpcy5fY2xlYXJGbj1lfWUuc2V0VGltZW91dD1mdW5jdGlvbigpe3JldHVybiBuZXcgbyhpLmNhbGwoc2V0VGltZW91dCxuLGFyZ3VtZW50cyksY2xlYXJUaW1lb3V0KX0sZS5zZXRJbnRlcnZhbD1mdW5jdGlvbigpe3JldHVybiBuZXcgbyhpLmNhbGwoc2V0SW50ZXJ2YWwsbixhcmd1bWVudHMpLGNsZWFySW50ZXJ2YWwpfSxlLmNsZWFyVGltZW91dD1lLmNsZWFySW50ZXJ2YWw9ZnVuY3Rpb24odCl7dCYmdC5jbG9zZSgpfSxvLnByb3RvdHlwZS51bnJlZj1vLnByb3RvdHlwZS5yZWY9ZnVuY3Rpb24oKXt9LG8ucHJvdG90eXBlLmNsb3NlPWZ1bmN0aW9uKCl7dGhpcy5fY2xlYXJGbi5jYWxsKG4sdGhpcy5faWQpfSxlLmVucm9sbD1mdW5jdGlvbih0LGUpe2NsZWFyVGltZW91dCh0Ll9pZGxlVGltZW91dElkKSx0Ll9pZGxlVGltZW91dD1lfSxlLnVuZW5yb2xsPWZ1bmN0aW9uKHQpe2NsZWFyVGltZW91dCh0Ll9pZGxlVGltZW91dElkKSx0Ll9pZGxlVGltZW91dD0tMX0sZS5fdW5yZWZBY3RpdmU9ZS5hY3RpdmU9ZnVuY3Rpb24odCl7Y2xlYXJUaW1lb3V0KHQuX2lkbGVUaW1lb3V0SWQpO3ZhciBlPXQuX2lkbGVUaW1lb3V0O2U+PTAmJih0Ll9pZGxlVGltZW91dElkPXNldFRpbWVvdXQoKGZ1bmN0aW9uKCl7dC5fb25UaW1lb3V0JiZ0Ll9vblRpbWVvdXQoKX0pLGUpKX0scigxODkpLGUuc2V0SW1tZWRpYXRlPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmJiZzZWxmLnNldEltbWVkaWF0ZXx8dm9pZCAwIT09dCYmdC5zZXRJbW1lZGlhdGV8fHRoaXMmJnRoaXMuc2V0SW1tZWRpYXRlLGUuY2xlYXJJbW1lZGlhdGU9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGYmJnNlbGYuY2xlYXJJbW1lZGlhdGV8fHZvaWQgMCE9PXQmJnQuY2xlYXJJbW1lZGlhdGV8fHRoaXMmJnRoaXMuY2xlYXJJbW1lZGlhdGV9KS5jYWxsKHRoaXMscigyMSkpfSxmdW5jdGlvbih0LGUpe3ZhciByPXt9LnRvU3RyaW5nO3QuZXhwb3J0cz1BcnJheS5pc0FycmF5fHxmdW5jdGlvbih0KXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PXIuY2FsbCh0KX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjsoZnVuY3Rpb24oZSxuKXt2YXIgaT1yKDU1KTt0LmV4cG9ydHM9Xzt2YXIgbyxhPXIoMTM3KTtfLlJlYWRhYmxlU3RhdGU9YjtyKDkzKS5FdmVudEVtaXR0ZXI7dmFyIHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5saXN0ZW5lcnMoZSkubGVuZ3RofSx1PXIoMTM5KSxjPXIoNTYpLkJ1ZmZlcixmPWUuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9O3ZhciBsPXIoMzkpO2wuaW5oZXJpdHM9cigyOSk7dmFyIGg9cigxOTIpLHA9dm9pZCAwO3A9aCYmaC5kZWJ1Z2xvZz9oLmRlYnVnbG9nKFwic3RyZWFtXCIpOmZ1bmN0aW9uKCl7fTt2YXIgZCx2PXIoMTkzKSxnPXIoMTQwKTtsLmluaGVyaXRzKF8sdSk7dmFyIHk9W1wiZXJyb3JcIixcImNsb3NlXCIsXCJkZXN0cm95XCIsXCJwYXVzZVwiLFwicmVzdW1lXCJdO2Z1bmN0aW9uIGIodCxlKXt0PXR8fHt9O3ZhciBuPWUgaW5zdGFuY2VvZihvPW98fHIoMjMpKTt0aGlzLm9iamVjdE1vZGU9ISF0Lm9iamVjdE1vZGUsbiYmKHRoaXMub2JqZWN0TW9kZT10aGlzLm9iamVjdE1vZGV8fCEhdC5yZWFkYWJsZU9iamVjdE1vZGUpO3ZhciBpPXQuaGlnaFdhdGVyTWFyayxhPXQucmVhZGFibGVIaWdoV2F0ZXJNYXJrLHM9dGhpcy5vYmplY3RNb2RlPzE2OjE2Mzg0O3RoaXMuaGlnaFdhdGVyTWFyaz1pfHwwPT09aT9pOm4mJihhfHwwPT09YSk/YTpzLHRoaXMuaGlnaFdhdGVyTWFyaz1NYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayksdGhpcy5idWZmZXI9bmV3IHYsdGhpcy5sZW5ndGg9MCx0aGlzLnBpcGVzPW51bGwsdGhpcy5waXBlc0NvdW50PTAsdGhpcy5mbG93aW5nPW51bGwsdGhpcy5lbmRlZD0hMSx0aGlzLmVuZEVtaXR0ZWQ9ITEsdGhpcy5yZWFkaW5nPSExLHRoaXMuc3luYz0hMCx0aGlzLm5lZWRSZWFkYWJsZT0hMSx0aGlzLmVtaXR0ZWRSZWFkYWJsZT0hMSx0aGlzLnJlYWRhYmxlTGlzdGVuaW5nPSExLHRoaXMucmVzdW1lU2NoZWR1bGVkPSExLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVmYXVsdEVuY29kaW5nPXQuZGVmYXVsdEVuY29kaW5nfHxcInV0ZjhcIix0aGlzLmF3YWl0RHJhaW49MCx0aGlzLnJlYWRpbmdNb3JlPSExLHRoaXMuZGVjb2Rlcj1udWxsLHRoaXMuZW5jb2Rpbmc9bnVsbCx0LmVuY29kaW5nJiYoZHx8KGQ9cigxNDEpLlN0cmluZ0RlY29kZXIpLHRoaXMuZGVjb2Rlcj1uZXcgZCh0LmVuY29kaW5nKSx0aGlzLmVuY29kaW5nPXQuZW5jb2RpbmcpfWZ1bmN0aW9uIF8odCl7aWYobz1vfHxyKDIzKSwhKHRoaXMgaW5zdGFuY2VvZiBfKSlyZXR1cm4gbmV3IF8odCk7dGhpcy5fcmVhZGFibGVTdGF0ZT1uZXcgYih0LHRoaXMpLHRoaXMucmVhZGFibGU9ITAsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQucmVhZCYmKHRoaXMuX3JlYWQ9dC5yZWFkKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmRlc3Ryb3kmJih0aGlzLl9kZXN0cm95PXQuZGVzdHJveSkpLHUuY2FsbCh0aGlzKX1mdW5jdGlvbiBtKHQsZSxyLG4saSl7dmFyIG8sYT10Ll9yZWFkYWJsZVN0YXRlO251bGw9PT1lPyhhLnJlYWRpbmc9ITEsZnVuY3Rpb24odCxlKXtpZihlLmVuZGVkKXJldHVybjtpZihlLmRlY29kZXIpe3ZhciByPWUuZGVjb2Rlci5lbmQoKTtyJiZyLmxlbmd0aCYmKGUuYnVmZmVyLnB1c2gociksZS5sZW5ndGgrPWUub2JqZWN0TW9kZT8xOnIubGVuZ3RoKX1lLmVuZGVkPSEwLGsodCl9KHQsYSkpOihpfHwobz1mdW5jdGlvbih0LGUpe3ZhciByO249ZSxjLmlzQnVmZmVyKG4pfHxuIGluc3RhbmNlb2YgZnx8XCJzdHJpbmdcIj09dHlwZW9mIGV8fHZvaWQgMD09PWV8fHQub2JqZWN0TW9kZXx8KHI9bmV3IFR5cGVFcnJvcihcIkludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmtcIikpO3ZhciBuO3JldHVybiByfShhLGUpKSxvP3QuZW1pdChcImVycm9yXCIsbyk6YS5vYmplY3RNb2RlfHxlJiZlLmxlbmd0aD4wPyhcInN0cmluZ1wiPT10eXBlb2YgZXx8YS5vYmplY3RNb2RlfHxPYmplY3QuZ2V0UHJvdG90eXBlT2YoZSk9PT1jLnByb3RvdHlwZXx8KGU9ZnVuY3Rpb24odCl7cmV0dXJuIGMuZnJvbSh0KX0oZSkpLG4/YS5lbmRFbWl0dGVkP3QuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwic3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnRcIikpOncodCxhLGUsITApOmEuZW5kZWQ/dC5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRlwiKSk6KGEucmVhZGluZz0hMSxhLmRlY29kZXImJiFyPyhlPWEuZGVjb2Rlci53cml0ZShlKSxhLm9iamVjdE1vZGV8fDAhPT1lLmxlbmd0aD93KHQsYSxlLCExKTpTKHQsYSkpOncodCxhLGUsITEpKSk6bnx8KGEucmVhZGluZz0hMSkpO3JldHVybiBmdW5jdGlvbih0KXtyZXR1cm4hdC5lbmRlZCYmKHQubmVlZFJlYWRhYmxlfHx0Lmxlbmd0aDx0LmhpZ2hXYXRlck1hcmt8fDA9PT10Lmxlbmd0aCl9KGEpfWZ1bmN0aW9uIHcodCxlLHIsbil7ZS5mbG93aW5nJiYwPT09ZS5sZW5ndGgmJiFlLnN5bmM/KHQuZW1pdChcImRhdGFcIixyKSx0LnJlYWQoMCkpOihlLmxlbmd0aCs9ZS5vYmplY3RNb2RlPzE6ci5sZW5ndGgsbj9lLmJ1ZmZlci51bnNoaWZ0KHIpOmUuYnVmZmVyLnB1c2gociksZS5uZWVkUmVhZGFibGUmJmsodCkpLFModCxlKX1PYmplY3QuZGVmaW5lUHJvcGVydHkoXy5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMCE9PXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkfSxzZXQ6ZnVuY3Rpb24odCl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPXQpfX0pLF8ucHJvdG90eXBlLmRlc3Ryb3k9Zy5kZXN0cm95LF8ucHJvdG90eXBlLl91bmRlc3Ryb3k9Zy51bmRlc3Ryb3ksXy5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24odCxlKXt0aGlzLnB1c2gobnVsbCksZSh0KX0sXy5wcm90b3R5cGUucHVzaD1mdW5jdGlvbih0LGUpe3ZhciByLG49dGhpcy5fcmVhZGFibGVTdGF0ZTtyZXR1cm4gbi5vYmplY3RNb2RlP3I9ITA6XCJzdHJpbmdcIj09dHlwZW9mIHQmJigoZT1lfHxuLmRlZmF1bHRFbmNvZGluZykhPT1uLmVuY29kaW5nJiYodD1jLmZyb20odCxlKSxlPVwiXCIpLHI9ITApLG0odGhpcyx0LGUsITEscil9LF8ucHJvdG90eXBlLnVuc2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG0odGhpcyx0LG51bGwsITAsITEpfSxfLnByb3RvdHlwZS5pc1BhdXNlZD1mdW5jdGlvbigpe3JldHVybiExPT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nfSxfLnByb3RvdHlwZS5zZXRFbmNvZGluZz1mdW5jdGlvbih0KXtyZXR1cm4gZHx8KGQ9cigxNDEpLlN0cmluZ0RlY29kZXIpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlcj1uZXcgZCh0KSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nPXQsdGhpc307ZnVuY3Rpb24geCh0LGUpe3JldHVybiB0PD0wfHwwPT09ZS5sZW5ndGgmJmUuZW5kZWQ/MDplLm9iamVjdE1vZGU/MTp0IT10P2UuZmxvd2luZyYmZS5sZW5ndGg/ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDplLmxlbmd0aDoodD5lLmhpZ2hXYXRlck1hcmsmJihlLmhpZ2hXYXRlck1hcms9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PTgzODg2MDg/dD04Mzg4NjA4Oih0LS0sdHw9dD4+PjEsdHw9dD4+PjIsdHw9dD4+PjQsdHw9dD4+PjgsdHw9dD4+PjE2LHQrKyksdH0odCkpLHQ8PWUubGVuZ3RoP3Q6ZS5lbmRlZD9lLmxlbmd0aDooZS5uZWVkUmVhZGFibGU9ITAsMCkpfWZ1bmN0aW9uIGsodCl7dmFyIGU9dC5fcmVhZGFibGVTdGF0ZTtlLm5lZWRSZWFkYWJsZT0hMSxlLmVtaXR0ZWRSZWFkYWJsZXx8KHAoXCJlbWl0UmVhZGFibGVcIixlLmZsb3dpbmcpLGUuZW1pdHRlZFJlYWRhYmxlPSEwLGUuc3luYz9pLm5leHRUaWNrKEUsdCk6RSh0KSl9ZnVuY3Rpb24gRSh0KXtwKFwiZW1pdCByZWFkYWJsZVwiKSx0LmVtaXQoXCJyZWFkYWJsZVwiKSxJKHQpfWZ1bmN0aW9uIFModCxlKXtlLnJlYWRpbmdNb3JlfHwoZS5yZWFkaW5nTW9yZT0hMCxpLm5leHRUaWNrKGosdCxlKSl9ZnVuY3Rpb24gaih0LGUpe2Zvcih2YXIgcj1lLmxlbmd0aDshZS5yZWFkaW5nJiYhZS5mbG93aW5nJiYhZS5lbmRlZCYmZS5sZW5ndGg8ZS5oaWdoV2F0ZXJNYXJrJiYocChcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpLHQucmVhZCgwKSxyIT09ZS5sZW5ndGgpOylyPWUubGVuZ3RoO2UucmVhZGluZ01vcmU9ITF9ZnVuY3Rpb24gUih0KXtwKFwicmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwXCIpLHQucmVhZCgwKX1mdW5jdGlvbiBDKHQsZSl7ZS5yZWFkaW5nfHwocChcInJlc3VtZSByZWFkIDBcIiksdC5yZWFkKDApKSxlLnJlc3VtZVNjaGVkdWxlZD0hMSxlLmF3YWl0RHJhaW49MCx0LmVtaXQoXCJyZXN1bWVcIiksSSh0KSxlLmZsb3dpbmcmJiFlLnJlYWRpbmcmJnQucmVhZCgwKX1mdW5jdGlvbiBJKHQpe3ZhciBlPXQuX3JlYWRhYmxlU3RhdGU7Zm9yKHAoXCJmbG93XCIsZS5mbG93aW5nKTtlLmZsb3dpbmcmJm51bGwhPT10LnJlYWQoKTspO31mdW5jdGlvbiBPKHQsZSl7cmV0dXJuIDA9PT1lLmxlbmd0aD9udWxsOihlLm9iamVjdE1vZGU/cj1lLmJ1ZmZlci5zaGlmdCgpOiF0fHx0Pj1lLmxlbmd0aD8ocj1lLmRlY29kZXI/ZS5idWZmZXIuam9pbihcIlwiKToxPT09ZS5idWZmZXIubGVuZ3RoP2UuYnVmZmVyLmhlYWQuZGF0YTplLmJ1ZmZlci5jb25jYXQoZS5sZW5ndGgpLGUuYnVmZmVyLmNsZWFyKCkpOnI9ZnVuY3Rpb24odCxlLHIpe3ZhciBuO3Q8ZS5oZWFkLmRhdGEubGVuZ3RoPyhuPWUuaGVhZC5kYXRhLnNsaWNlKDAsdCksZS5oZWFkLmRhdGE9ZS5oZWFkLmRhdGEuc2xpY2UodCkpOm49dD09PWUuaGVhZC5kYXRhLmxlbmd0aD9lLnNoaWZ0KCk6cj9mdW5jdGlvbih0LGUpe3ZhciByPWUuaGVhZCxuPTEsaT1yLmRhdGE7dC09aS5sZW5ndGg7Zm9yKDtyPXIubmV4dDspe3ZhciBvPXIuZGF0YSxhPXQ+by5sZW5ndGg/by5sZW5ndGg6dDtpZihhPT09by5sZW5ndGg/aSs9bzppKz1vLnNsaWNlKDAsdCksMD09PSh0LT1hKSl7YT09PW8ubGVuZ3RoPygrK24sci5uZXh0P2UuaGVhZD1yLm5leHQ6ZS5oZWFkPWUudGFpbD1udWxsKTooZS5oZWFkPXIsci5kYXRhPW8uc2xpY2UoYSkpO2JyZWFrfSsrbn1yZXR1cm4gZS5sZW5ndGgtPW4saX0odCxlKTpmdW5jdGlvbih0LGUpe3ZhciByPWMuYWxsb2NVbnNhZmUodCksbj1lLmhlYWQsaT0xO24uZGF0YS5jb3B5KHIpLHQtPW4uZGF0YS5sZW5ndGg7Zm9yKDtuPW4ubmV4dDspe3ZhciBvPW4uZGF0YSxhPXQ+by5sZW5ndGg/by5sZW5ndGg6dDtpZihvLmNvcHkocixyLmxlbmd0aC10LDAsYSksMD09PSh0LT1hKSl7YT09PW8ubGVuZ3RoPygrK2ksbi5uZXh0P2UuaGVhZD1uLm5leHQ6ZS5oZWFkPWUudGFpbD1udWxsKTooZS5oZWFkPW4sbi5kYXRhPW8uc2xpY2UoYSkpO2JyZWFrfSsraX1yZXR1cm4gZS5sZW5ndGgtPWkscn0odCxlKTtyZXR1cm4gbn0odCxlLmJ1ZmZlcixlLmRlY29kZXIpLHIpO3ZhciByfWZ1bmN0aW9uIFQodCl7dmFyIGU9dC5fcmVhZGFibGVTdGF0ZTtpZihlLmxlbmd0aD4wKXRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtlLmVuZEVtaXR0ZWR8fChlLmVuZGVkPSEwLGkubmV4dFRpY2soUCxlLHQpKX1mdW5jdGlvbiBQKHQsZSl7dC5lbmRFbWl0dGVkfHwwIT09dC5sZW5ndGh8fCh0LmVuZEVtaXR0ZWQ9ITAsZS5yZWFkYWJsZT0hMSxlLmVtaXQoXCJlbmRcIikpfWZ1bmN0aW9uIEEodCxlKXtmb3IodmFyIHI9MCxuPXQubGVuZ3RoO3I8bjtyKyspaWYodFtyXT09PWUpcmV0dXJuIHI7cmV0dXJuLTF9Xy5wcm90b3R5cGUucmVhZD1mdW5jdGlvbih0KXtwKFwicmVhZFwiLHQpLHQ9cGFyc2VJbnQodCwxMCk7dmFyIGU9dGhpcy5fcmVhZGFibGVTdGF0ZSxyPXQ7aWYoMCE9PXQmJihlLmVtaXR0ZWRSZWFkYWJsZT0hMSksMD09PXQmJmUubmVlZFJlYWRhYmxlJiYoZS5sZW5ndGg+PWUuaGlnaFdhdGVyTWFya3x8ZS5lbmRlZCkpcmV0dXJuIHAoXCJyZWFkOiBlbWl0UmVhZGFibGVcIixlLmxlbmd0aCxlLmVuZGVkKSwwPT09ZS5sZW5ndGgmJmUuZW5kZWQ/VCh0aGlzKTprKHRoaXMpLG51bGw7aWYoMD09PSh0PXgodCxlKSkmJmUuZW5kZWQpcmV0dXJuIDA9PT1lLmxlbmd0aCYmVCh0aGlzKSxudWxsO3ZhciBuLGk9ZS5uZWVkUmVhZGFibGU7cmV0dXJuIHAoXCJuZWVkIHJlYWRhYmxlXCIsaSksKDA9PT1lLmxlbmd0aHx8ZS5sZW5ndGgtdDxlLmhpZ2hXYXRlck1hcmspJiZwKFwibGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmtcIixpPSEwKSxlLmVuZGVkfHxlLnJlYWRpbmc/cChcInJlYWRpbmcgb3IgZW5kZWRcIixpPSExKTppJiYocChcImRvIHJlYWRcIiksZS5yZWFkaW5nPSEwLGUuc3luYz0hMCwwPT09ZS5sZW5ndGgmJihlLm5lZWRSZWFkYWJsZT0hMCksdGhpcy5fcmVhZChlLmhpZ2hXYXRlck1hcmspLGUuc3luYz0hMSxlLnJlYWRpbmd8fCh0PXgocixlKSkpLG51bGw9PT0obj10PjA/Tyh0LGUpOm51bGwpPyhlLm5lZWRSZWFkYWJsZT0hMCx0PTApOmUubGVuZ3RoLT10LDA9PT1lLmxlbmd0aCYmKGUuZW5kZWR8fChlLm5lZWRSZWFkYWJsZT0hMCksciE9PXQmJmUuZW5kZWQmJlQodGhpcykpLG51bGwhPT1uJiZ0aGlzLmVtaXQoXCJkYXRhXCIsbiksbn0sXy5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24odCl7dGhpcy5lbWl0KFwiZXJyb3JcIixuZXcgRXJyb3IoXCJfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKSl9LF8ucHJvdG90eXBlLnBpcGU9ZnVuY3Rpb24odCxlKXt2YXIgcj10aGlzLG89dGhpcy5fcmVhZGFibGVTdGF0ZTtzd2l0Y2goby5waXBlc0NvdW50KXtjYXNlIDA6by5waXBlcz10O2JyZWFrO2Nhc2UgMTpvLnBpcGVzPVtvLnBpcGVzLHRdO2JyZWFrO2RlZmF1bHQ6by5waXBlcy5wdXNoKHQpfW8ucGlwZXNDb3VudCs9MSxwKFwicGlwZSBjb3VudD0lZCBvcHRzPSVqXCIsby5waXBlc0NvdW50LGUpO3ZhciB1PSghZXx8ITEhPT1lLmVuZCkmJnQhPT1uLnN0ZG91dCYmdCE9PW4uc3RkZXJyP2Y6XztmdW5jdGlvbiBjKGUsbil7cChcIm9udW5waXBlXCIpLGU9PT1yJiZuJiYhMT09PW4uaGFzVW5waXBlZCYmKG4uaGFzVW5waXBlZD0hMCxwKFwiY2xlYW51cFwiKSx0LnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIix5KSx0LnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIsYiksdC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsbCksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsZyksdC5yZW1vdmVMaXN0ZW5lcihcInVucGlwZVwiLGMpLHIucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIixmKSxyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsXyksci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIix2KSxoPSEwLCFvLmF3YWl0RHJhaW58fHQuX3dyaXRhYmxlU3RhdGUmJiF0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbnx8bCgpKX1mdW5jdGlvbiBmKCl7cChcIm9uZW5kXCIpLHQuZW5kKCl9by5lbmRFbWl0dGVkP2kubmV4dFRpY2sodSk6ci5vbmNlKFwiZW5kXCIsdSksdC5vbihcInVucGlwZVwiLGMpO3ZhciBsPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3ZhciBlPXQuX3JlYWRhYmxlU3RhdGU7cChcInBpcGVPbkRyYWluXCIsZS5hd2FpdERyYWluKSxlLmF3YWl0RHJhaW4mJmUuYXdhaXREcmFpbi0tLDA9PT1lLmF3YWl0RHJhaW4mJnModCxcImRhdGFcIikmJihlLmZsb3dpbmc9ITAsSSh0KSl9fShyKTt0Lm9uKFwiZHJhaW5cIixsKTt2YXIgaD0hMTt2YXIgZD0hMTtmdW5jdGlvbiB2KGUpe3AoXCJvbmRhdGFcIiksZD0hMSwhMSE9PXQud3JpdGUoZSl8fGR8fCgoMT09PW8ucGlwZXNDb3VudCYmby5waXBlcz09PXR8fG8ucGlwZXNDb3VudD4xJiYtMSE9PUEoby5waXBlcyx0KSkmJiFoJiYocChcImZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZVwiLHIuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbiksci5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKyssZD0hMCksci5wYXVzZSgpKX1mdW5jdGlvbiBnKGUpe3AoXCJvbmVycm9yXCIsZSksXygpLHQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLGcpLDA9PT1zKHQsXCJlcnJvclwiKSYmdC5lbWl0KFwiZXJyb3JcIixlKX1mdW5jdGlvbiB5KCl7dC5yZW1vdmVMaXN0ZW5lcihcImZpbmlzaFwiLGIpLF8oKX1mdW5jdGlvbiBiKCl7cChcIm9uZmluaXNoXCIpLHQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLHkpLF8oKX1mdW5jdGlvbiBfKCl7cChcInVucGlwZVwiKSxyLnVucGlwZSh0KX1yZXR1cm4gci5vbihcImRhdGFcIix2KSxmdW5jdGlvbih0LGUscil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC5wcmVwZW5kTGlzdGVuZXIpcmV0dXJuIHQucHJlcGVuZExpc3RlbmVyKGUscik7dC5fZXZlbnRzJiZ0Ll9ldmVudHNbZV0/YSh0Ll9ldmVudHNbZV0pP3QuX2V2ZW50c1tlXS51bnNoaWZ0KHIpOnQuX2V2ZW50c1tlXT1bcix0Ll9ldmVudHNbZV1dOnQub24oZSxyKX0odCxcImVycm9yXCIsZyksdC5vbmNlKFwiY2xvc2VcIix5KSx0Lm9uY2UoXCJmaW5pc2hcIixiKSx0LmVtaXQoXCJwaXBlXCIsciksby5mbG93aW5nfHwocChcInBpcGUgcmVzdW1lXCIpLHIucmVzdW1lKCkpLHR9LF8ucHJvdG90eXBlLnVucGlwZT1mdW5jdGlvbih0KXt2YXIgZT10aGlzLl9yZWFkYWJsZVN0YXRlLHI9e2hhc1VucGlwZWQ6ITF9O2lmKDA9PT1lLnBpcGVzQ291bnQpcmV0dXJuIHRoaXM7aWYoMT09PWUucGlwZXNDb3VudClyZXR1cm4gdCYmdCE9PWUucGlwZXN8fCh0fHwodD1lLnBpcGVzKSxlLnBpcGVzPW51bGwsZS5waXBlc0NvdW50PTAsZS5mbG93aW5nPSExLHQmJnQuZW1pdChcInVucGlwZVwiLHRoaXMscikpLHRoaXM7aWYoIXQpe3ZhciBuPWUucGlwZXMsaT1lLnBpcGVzQ291bnQ7ZS5waXBlcz1udWxsLGUucGlwZXNDb3VudD0wLGUuZmxvd2luZz0hMTtmb3IodmFyIG89MDtvPGk7bysrKW5bb10uZW1pdChcInVucGlwZVwiLHRoaXMscik7cmV0dXJuIHRoaXN9dmFyIGE9QShlLnBpcGVzLHQpO3JldHVybi0xPT09YXx8KGUucGlwZXMuc3BsaWNlKGEsMSksZS5waXBlc0NvdW50LT0xLDE9PT1lLnBpcGVzQ291bnQmJihlLnBpcGVzPWUucGlwZXNbMF0pLHQuZW1pdChcInVucGlwZVwiLHRoaXMscikpLHRoaXN9LF8ucHJvdG90eXBlLm9uPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dS5wcm90b3R5cGUub24uY2FsbCh0aGlzLHQsZSk7aWYoXCJkYXRhXCI9PT10KSExIT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nJiZ0aGlzLnJlc3VtZSgpO2Vsc2UgaWYoXCJyZWFkYWJsZVwiPT09dCl7dmFyIG49dGhpcy5fcmVhZGFibGVTdGF0ZTtuLmVuZEVtaXR0ZWR8fG4ucmVhZGFibGVMaXN0ZW5pbmd8fChuLnJlYWRhYmxlTGlzdGVuaW5nPW4ubmVlZFJlYWRhYmxlPSEwLG4uZW1pdHRlZFJlYWRhYmxlPSExLG4ucmVhZGluZz9uLmxlbmd0aCYmayh0aGlzKTppLm5leHRUaWNrKFIsdGhpcykpfXJldHVybiByfSxfLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1fLnByb3RvdHlwZS5vbixfLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiB0LmZsb3dpbmd8fChwKFwicmVzdW1lXCIpLHQuZmxvd2luZz0hMCxmdW5jdGlvbih0LGUpe2UucmVzdW1lU2NoZWR1bGVkfHwoZS5yZXN1bWVTY2hlZHVsZWQ9ITAsaS5uZXh0VGljayhDLHQsZSkpfSh0aGlzLHQpKSx0aGlzfSxfLnByb3RvdHlwZS5wYXVzZT1mdW5jdGlvbigpe3JldHVybiBwKFwiY2FsbCBwYXVzZSBmbG93aW5nPSVqXCIsdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSwhMSE9PXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyYmKHAoXCJwYXVzZVwiKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc9ITEsdGhpcy5lbWl0KFwicGF1c2VcIikpLHRoaXN9LF8ucHJvdG90eXBlLndyYXA9ZnVuY3Rpb24odCl7dmFyIGU9dGhpcyxyPXRoaXMuX3JlYWRhYmxlU3RhdGUsbj0hMTtmb3IodmFyIGkgaW4gdC5vbihcImVuZFwiLChmdW5jdGlvbigpe2lmKHAoXCJ3cmFwcGVkIGVuZFwiKSxyLmRlY29kZXImJiFyLmVuZGVkKXt2YXIgdD1yLmRlY29kZXIuZW5kKCk7dCYmdC5sZW5ndGgmJmUucHVzaCh0KX1lLnB1c2gobnVsbCl9KSksdC5vbihcImRhdGFcIiwoZnVuY3Rpb24oaSl7KHAoXCJ3cmFwcGVkIGRhdGFcIiksci5kZWNvZGVyJiYoaT1yLmRlY29kZXIud3JpdGUoaSkpLHIub2JqZWN0TW9kZSYmbnVsbD09aSl8fChyLm9iamVjdE1vZGV8fGkmJmkubGVuZ3RoKSYmKGUucHVzaChpKXx8KG49ITAsdC5wYXVzZSgpKSl9KSksdCl2b2lkIDA9PT10aGlzW2ldJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0W2ldJiYodGhpc1tpXT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gdFtlXS5hcHBseSh0LGFyZ3VtZW50cyl9fShpKSk7Zm9yKHZhciBvPTA7bzx5Lmxlbmd0aDtvKyspdC5vbih5W29dLHRoaXMuZW1pdC5iaW5kKHRoaXMseVtvXSkpO3JldHVybiB0aGlzLl9yZWFkPWZ1bmN0aW9uKGUpe3AoXCJ3cmFwcGVkIF9yZWFkXCIsZSksbiYmKG49ITEsdC5yZXN1bWUoKSl9LHRoaXN9LE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLnByb3RvdHlwZSxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcmt9fSksXy5fZnJvbUxpc3Q9T30pLmNhbGwodGhpcyxyKDIxKSxyKDM4KSl9LGZ1bmN0aW9uKHQsZSxyKXt0LmV4cG9ydHM9cig5MykuRXZlbnRFbWl0dGVyfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cig1NSk7ZnVuY3Rpb24gaSh0LGUpe3QuZW1pdChcImVycm9yXCIsZSl9dC5leHBvcnRzPXtkZXN0cm95OmZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcyxvPXRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkLGE9dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7cmV0dXJuIG98fGE/KGU/ZSh0KTohdHx8dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWR8fG4ubmV4dFRpY2soaSx0aGlzLHQpLHRoaXMpOih0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ITApLHRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD0hMCksdGhpcy5fZGVzdHJveSh0fHxudWxsLChmdW5jdGlvbih0KXshZSYmdD8obi5uZXh0VGljayhpLHIsdCksci5fd3JpdGFibGVTdGF0ZSYmKHIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwKSk6ZSYmZSh0KX0pKSx0aGlzKX0sdW5kZXN0cm95OmZ1bmN0aW9uKCl7dGhpcy5fcmVhZGFibGVTdGF0ZSYmKHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZz0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZD0hMSksdGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmc9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMSl9fX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTYpLkJ1ZmZlcixpPW4uaXNFbmNvZGluZ3x8ZnVuY3Rpb24odCl7c3dpdGNoKCh0PVwiXCIrdCkmJnQudG9Mb3dlckNhc2UoKSl7Y2FzZVwiaGV4XCI6Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6Y2FzZVwiYXNjaWlcIjpjYXNlXCJiaW5hcnlcIjpjYXNlXCJiYXNlNjRcIjpjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpjYXNlXCJyYXdcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX07ZnVuY3Rpb24gbyh0KXt2YXIgZTtzd2l0Y2godGhpcy5lbmNvZGluZz1mdW5jdGlvbih0KXt2YXIgZT1mdW5jdGlvbih0KXtpZighdClyZXR1cm5cInV0ZjhcIjtmb3IodmFyIGU7Oylzd2l0Y2godCl7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiB0O2RlZmF1bHQ6aWYoZSlyZXR1cm47dD0oXCJcIit0KS50b0xvd2VyQ2FzZSgpLGU9ITB9fSh0KTtpZihcInN0cmluZ1wiIT10eXBlb2YgZSYmKG4uaXNFbmNvZGluZz09PWl8fCFpKHQpKSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIit0KTtyZXR1cm4gZXx8dH0odCksdGhpcy5lbmNvZGluZyl7Y2FzZVwidXRmMTZsZVwiOnRoaXMudGV4dD11LHRoaXMuZW5kPWMsZT00O2JyZWFrO2Nhc2VcInV0ZjhcIjp0aGlzLmZpbGxMYXN0PXMsZT00O2JyZWFrO2Nhc2VcImJhc2U2NFwiOnRoaXMudGV4dD1mLHRoaXMuZW5kPWwsZT0zO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMud3JpdGU9aCx2b2lkKHRoaXMuZW5kPXApfXRoaXMubGFzdE5lZWQ9MCx0aGlzLmxhc3RUb3RhbD0wLHRoaXMubGFzdENoYXI9bi5hbGxvY1Vuc2FmZShlKX1mdW5jdGlvbiBhKHQpe3JldHVybiB0PD0xMjc/MDp0Pj41PT02PzI6dD4+ND09MTQ/Mzp0Pj4zPT0zMD80OnQ+PjY9PTI/LTE6LTJ9ZnVuY3Rpb24gcyh0KXt2YXIgZT10aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLHI9ZnVuY3Rpb24odCxlLHIpe2lmKDEyOCE9KDE5MiZlWzBdKSlyZXR1cm4gdC5sYXN0TmVlZD0wLFwi77+9XCI7aWYodC5sYXN0TmVlZD4xJiZlLmxlbmd0aD4xKXtpZigxMjghPSgxOTImZVsxXSkpcmV0dXJuIHQubGFzdE5lZWQ9MSxcIu+/vVwiO2lmKHQubGFzdE5lZWQ+MiYmZS5sZW5ndGg+MiYmMTI4IT0oMTkyJmVbMl0pKXJldHVybiB0Lmxhc3ROZWVkPTIsXCLvv71cIn19KHRoaXMsdCk7cmV0dXJuIHZvaWQgMCE9PXI/cjp0aGlzLmxhc3ROZWVkPD10Lmxlbmd0aD8odC5jb3B5KHRoaXMubGFzdENoYXIsZSwwLHRoaXMubGFzdE5lZWQpLHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKSk6KHQuY29weSh0aGlzLmxhc3RDaGFyLGUsMCx0Lmxlbmd0aCksdm9pZCh0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aCkpfWZ1bmN0aW9uIHUodCxlKXtpZigodC5sZW5ndGgtZSklMj09MCl7dmFyIHI9dC50b1N0cmluZyhcInV0ZjE2bGVcIixlKTtpZihyKXt2YXIgbj1yLmNoYXJDb2RlQXQoci5sZW5ndGgtMSk7aWYobj49NTUyOTYmJm48PTU2MzE5KXJldHVybiB0aGlzLmxhc3ROZWVkPTIsdGhpcy5sYXN0VG90YWw9NCx0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT10W3QubGVuZ3RoLTFdLHIuc2xpY2UoMCwtMSl9cmV0dXJuIHJ9cmV0dXJuIHRoaXMubGFzdE5lZWQ9MSx0aGlzLmxhc3RUb3RhbD0yLHRoaXMubGFzdENoYXJbMF09dFt0Lmxlbmd0aC0xXSx0LnRvU3RyaW5nKFwidXRmMTZsZVwiLGUsdC5sZW5ndGgtMSl9ZnVuY3Rpb24gYyh0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7aWYodGhpcy5sYXN0TmVlZCl7dmFyIHI9dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDtyZXR1cm4gZSt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwidXRmMTZsZVwiLDAscil9cmV0dXJuIGV9ZnVuY3Rpb24gZih0LGUpe3ZhciByPSh0Lmxlbmd0aC1lKSUzO3JldHVybiAwPT09cj90LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSk6KHRoaXMubGFzdE5lZWQ9My1yLHRoaXMubGFzdFRvdGFsPTMsMT09PXI/dGhpcy5sYXN0Q2hhclswXT10W3QubGVuZ3RoLTFdOih0aGlzLmxhc3RDaGFyWzBdPXRbdC5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT10W3QubGVuZ3RoLTFdKSx0LnRvU3RyaW5nKFwiYmFzZTY0XCIsZSx0Lmxlbmd0aC1yKSl9ZnVuY3Rpb24gbCh0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7cmV0dXJuIHRoaXMubGFzdE5lZWQ/ZSt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwiYmFzZTY0XCIsMCwzLXRoaXMubGFzdE5lZWQpOmV9ZnVuY3Rpb24gaCh0KXtyZXR1cm4gdC50b1N0cmluZyh0aGlzLmVuY29kaW5nKX1mdW5jdGlvbiBwKHQpe3JldHVybiB0JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCJ9ZS5TdHJpbmdEZWNvZGVyPW8sby5wcm90b3R5cGUud3JpdGU9ZnVuY3Rpb24odCl7aWYoMD09PXQubGVuZ3RoKXJldHVyblwiXCI7dmFyIGUscjtpZih0aGlzLmxhc3ROZWVkKXtpZih2b2lkIDA9PT0oZT10aGlzLmZpbGxMYXN0KHQpKSlyZXR1cm5cIlwiO3I9dGhpcy5sYXN0TmVlZCx0aGlzLmxhc3ROZWVkPTB9ZWxzZSByPTA7cmV0dXJuIHI8dC5sZW5ndGg/ZT9lK3RoaXMudGV4dCh0LHIpOnRoaXMudGV4dCh0LHIpOmV8fFwiXCJ9LG8ucHJvdG90eXBlLmVuZD1mdW5jdGlvbih0KXt2YXIgZT10JiZ0Lmxlbmd0aD90aGlzLndyaXRlKHQpOlwiXCI7cmV0dXJuIHRoaXMubGFzdE5lZWQ/ZStcIu+/vVwiOmV9LG8ucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24odCxlKXt2YXIgcj1mdW5jdGlvbih0LGUscil7dmFyIG49ZS5sZW5ndGgtMTtpZihuPHIpcmV0dXJuIDA7dmFyIGk9YShlW25dKTtpZihpPj0wKXJldHVybiBpPjAmJih0Lmxhc3ROZWVkPWktMSksaTtpZigtLW48cnx8LTI9PT1pKXJldHVybiAwO2lmKChpPWEoZVtuXSkpPj0wKXJldHVybiBpPjAmJih0Lmxhc3ROZWVkPWktMiksaTtpZigtLW48cnx8LTI9PT1pKXJldHVybiAwO2lmKChpPWEoZVtuXSkpPj0wKXJldHVybiBpPjAmJigyPT09aT9pPTA6dC5sYXN0TmVlZD1pLTMpLGk7cmV0dXJuIDB9KHRoaXMsdCxlKTtpZighdGhpcy5sYXN0TmVlZClyZXR1cm4gdC50b1N0cmluZyhcInV0ZjhcIixlKTt0aGlzLmxhc3RUb3RhbD1yO3ZhciBuPXQubGVuZ3RoLShyLXRoaXMubGFzdE5lZWQpO3JldHVybiB0LmNvcHkodGhpcy5sYXN0Q2hhciwwLG4pLHQudG9TdHJpbmcoXCJ1dGY4XCIsZSxuKX0sby5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24odCl7aWYodGhpcy5sYXN0TmVlZDw9dC5sZW5ndGgpcmV0dXJuIHQuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCx0aGlzLmxhc3ROZWVkKSx0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsMCx0aGlzLmxhc3RUb3RhbCk7dC5jb3B5KHRoaXMubGFzdENoYXIsdGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZCwwLHQubGVuZ3RoKSx0aGlzLmxhc3ROZWVkLT10Lmxlbmd0aH19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9YTt2YXIgbj1yKDIzKSxpPXIoMzkpO2Z1bmN0aW9uIG8odCxlKXt2YXIgcj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtyLnRyYW5zZm9ybWluZz0hMTt2YXIgbj1yLndyaXRlY2I7aWYoIW4pcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsbmV3IEVycm9yKFwid3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzXCIpKTtyLndyaXRlY2h1bms9bnVsbCxyLndyaXRlY2I9bnVsbCxudWxsIT1lJiZ0aGlzLnB1c2goZSksbih0KTt2YXIgaT10aGlzLl9yZWFkYWJsZVN0YXRlO2kucmVhZGluZz0hMSwoaS5uZWVkUmVhZGFibGV8fGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoaS5oaWdoV2F0ZXJNYXJrKX1mdW5jdGlvbiBhKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIGEpKXJldHVybiBuZXcgYSh0KTtuLmNhbGwodGhpcyx0KSx0aGlzLl90cmFuc2Zvcm1TdGF0ZT17YWZ0ZXJUcmFuc2Zvcm06by5iaW5kKHRoaXMpLG5lZWRUcmFuc2Zvcm06ITEsdHJhbnNmb3JtaW5nOiExLHdyaXRlY2I6bnVsbCx3cml0ZWNodW5rOm51bGwsd3JpdGVlbmNvZGluZzpudWxsfSx0aGlzLl9yZWFkYWJsZVN0YXRlLm5lZWRSZWFkYWJsZT0hMCx0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmM9ITEsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudHJhbnNmb3JtJiYodGhpcy5fdHJhbnNmb3JtPXQudHJhbnNmb3JtKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LmZsdXNoJiYodGhpcy5fZmx1c2g9dC5mbHVzaCkpLHRoaXMub24oXCJwcmVmaW5pc2hcIixzKX1mdW5jdGlvbiBzKCl7dmFyIHQ9dGhpcztcImZ1bmN0aW9uXCI9PXR5cGVvZiB0aGlzLl9mbHVzaD90aGlzLl9mbHVzaCgoZnVuY3Rpb24oZSxyKXt1KHQsZSxyKX0pKTp1KHRoaXMsbnVsbCxudWxsKX1mdW5jdGlvbiB1KHQsZSxyKXtpZihlKXJldHVybiB0LmVtaXQoXCJlcnJvclwiLGUpO2lmKG51bGwhPXImJnQucHVzaChyKSx0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDBcIik7aWYodC5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKXRocm93IG5ldyBFcnJvcihcIkNhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmdcIik7cmV0dXJuIHQucHVzaChudWxsKX1pLmluaGVyaXRzPXIoMjkpLGkuaW5oZXJpdHMoYSxuKSxhLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm09ITEsbi5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsdCxlKX0sYS5wcm90b3R5cGUuX3RyYW5zZm9ybT1mdW5jdGlvbih0LGUscil7dGhyb3cgbmV3IEVycm9yKFwiX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZFwiKX0sYS5wcm90b3R5cGUuX3dyaXRlPWZ1bmN0aW9uKHQsZSxyKXt2YXIgbj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtpZihuLndyaXRlY2I9cixuLndyaXRlY2h1bms9dCxuLndyaXRlZW5jb2Rpbmc9ZSwhbi50cmFuc2Zvcm1pbmcpe3ZhciBpPXRoaXMuX3JlYWRhYmxlU3RhdGU7KG4ubmVlZFRyYW5zZm9ybXx8aS5uZWVkUmVhZGFibGV8fGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFyaykmJnRoaXMuX3JlYWQoaS5oaWdoV2F0ZXJNYXJrKX19LGEucHJvdG90eXBlLl9yZWFkPWZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuX3RyYW5zZm9ybVN0YXRlO251bGwhPT1lLndyaXRlY2h1bmsmJmUud3JpdGVjYiYmIWUudHJhbnNmb3JtaW5nPyhlLnRyYW5zZm9ybWluZz0hMCx0aGlzLl90cmFuc2Zvcm0oZS53cml0ZWNodW5rLGUud3JpdGVlbmNvZGluZyxlLmFmdGVyVHJhbnNmb3JtKSk6ZS5uZWVkVHJhbnNmb3JtPSEwfSxhLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbih0LGUpe3ZhciByPXRoaXM7bi5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLHQsKGZ1bmN0aW9uKHQpe2UodCksci5lbWl0KFwiY2xvc2VcIil9KSl9fSxmdW5jdGlvbih0LGUpe3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7cmV0dXJuIGUgaW4gdD9PYmplY3QuZGVmaW5lUHJvcGVydHkodCxlLHt2YWx1ZTpyLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6dFtlXT1yLHR9fSxmdW5jdGlvbih0LGUpe2NvbnN0IHI9e2FjbDpcImh0dHA6Ly93d3cudzMub3JnL25zL2F1dGgvYWNsI1wiLGFyZzpcImh0dHA6Ly93d3cudzMub3JnL25zL3BpbS9hcmcjXCIsY2FsOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMi8xMi9jYWwvaWNhbCNcIixjb250YWN0OlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8xMC9zd2FwL3BpbS9jb250YWN0I1wiLGRjOlwiaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS9cIixkY3Q6XCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvXCIsZG9hcDpcImh0dHA6Ly91c2VmdWxpbmMuY29tL25zL2RvYXAjXCIsZm9hZjpcImh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvXCIsaHR0cDpcImh0dHA6Ly93d3cudzMub3JnLzIwMDcvb250L2h0dHAjXCIsaHR0cGg6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA3L29udC9odHRwaCNcIixpY2FsVFo6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzEyL2NhbC9pY2FsdHpkI1wiLGxkcDpcImh0dHA6Ly93d3cudzMub3JnL25zL2xkcCNcIixsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNy9vbnQvbGluayNcIixsb2c6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzEwL3N3YXAvbG9nI1wiLG1lZXRpbmc6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vbWVldGluZyNcIixtbzpcImh0dHA6Ly9wdXJsLm9yZy9vbnRvbG9neS9tby9cIixvd2w6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAyLzA3L293bCNcIixwYWQ6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vcGFkI1wiLHBhdGNoOlwiaHR0cDovL3d3dy53My5vcmcvbnMvcGltL3BhdGNoI1wiLHF1OlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8xMC9zd2FwL3BpbS9xaWYjXCIsdHJpcDpcImh0dHA6Ly93d3cudzMub3JnL25zL3BpbS90cmlwI1wiLHJkZjpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIixyZGZzOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI1wiLHJzczpcImh0dHA6Ly9wdXJsLm9yZy9yc3MvMS4wL1wiLHNjaGVkOlwiaHR0cDovL3d3dy53My5vcmcvbnMvcGltL3NjaGVkdWxlI1wiLHNjaGVtYTpcImh0dHA6L3NjaGVtYS5vcmcvXCIsc2lvYzpcImh0dHA6Ly9yZGZzLm9yZy9zaW9jL25zI1wiLHNvbGlkOlwiaHR0cDovL3d3dy53My5vcmcvbnMvc29saWQvdGVybXMjXCIsc3BhY2U6XCJodHRwOi8vd3d3LnczLm9yZy9ucy9waW0vc3BhY2UjXCIsc3RhdDpcImh0dHA6Ly93d3cudzMub3JnL25zL3Bvc2l4L3N0YXQjXCIsdGFiOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNy9vbnQvbGluayNcIix0YWJvbnQ6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA3L29udC9saW5rI1wiLHVpOlwiaHR0cDovL3d3dy53My5vcmcvbnMvdWkjXCIsdmNhcmQ6XCJodHRwOi8vd3d3LnczLm9yZy8yMDA2L3ZjYXJkL25zI1wiLHdmOlwiaHR0cDovL3d3dy53My5vcmcvMjAwNS8wMS93Zi9mbG93I1wiLHhzZDpcImh0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI1wifTt0LmV4cG9ydHM9ZnVuY3Rpb24odD17bmFtZWROb2RlOnQ9PnR9KXtjb25zdCBlPXt9O2Zvcihjb25zdCBuIGluIHIpe2NvbnN0IGk9cltuXTtlW25dPWZ1bmN0aW9uKGU9XCJcIil7cmV0dXJuIHQubmFtZWROb2RlKGkrZSl9fXJldHVybiBlfX0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiOyhmdW5jdGlvbih0LG4pe3IuZChlLFwiYVwiLChmdW5jdGlvbigpe3JldHVybiBofSkpO3ZhciBpPXIoNik7Y29uc3R7eHNkOm99PWkuYSx7ZnJvbUNoYXJDb2RlOmF9PVN0cmluZzt2YXIgcz0vXFxcXHUoW2EtZkEtRjAtOV17NH0pfFxcXFxVKFthLWZBLUYwLTldezh9KXxcXFxcW3VVXXxcXFxcKC4pL2csdT17XCJcXFxcXCI6XCJcXFxcXCIsXCInXCI6XCInXCIsJ1wiJzonXCInLG46XCJcXG5cIixyOlwiXFxyXCIsdDpcIlxcdFwiLGY6XCJcXGZcIixiOlwiXFxiXCIsXzpcIl9cIixcIn5cIjpcIn5cIixcIi5cIjpcIi5cIixcIi1cIjpcIi1cIixcIiFcIjpcIiFcIiwkOlwiJFwiLFwiJlwiOlwiJlwiLFwiKFwiOlwiKFwiLFwiKVwiOlwiKVwiLFwiKlwiOlwiKlwiLFwiK1wiOlwiK1wiLFwiLFwiOlwiLFwiLFwiO1wiOlwiO1wiLFwiPVwiOlwiPVwiLFwiL1wiOlwiL1wiLFwiP1wiOlwiP1wiLFwiI1wiOlwiI1wiLFwiQFwiOlwiQFwiLFwiJVwiOlwiJVwifSxjPS9bXFx4MDAtXFx4MjA8PlxcXFxcIlxce1xcfVxcfFxcXlxcYF0vLGY9e19pcmk6ITAsX3VuZXNjYXBlZElyaTohMCxfc2ltcGxlUXVvdGVkU3RyaW5nOiEwLF9sYW5nY29kZTohMCxfYmxhbms6ITAsX25ld2xpbmU6ITAsX2NvbW1lbnQ6ITAsX3doaXRlc3BhY2U6ITAsX2VuZE9mRmlsZTohMH0sbD0vJDBeLztjbGFzcyBoe2NvbnN0cnVjdG9yKHQpe2lmKHRoaXMuX2lyaT0vXjwoKD86W14gPD57fVxcXFxdfFxcXFxbdVVdKSspPlsgXFx0XSovLHRoaXMuX3VuZXNjYXBlZElyaT0vXjwoW15cXHgwMC1cXHgyMDw+XFxcXFwiXFx7XFx9XFx8XFxeXFxgXSopPlsgXFx0XSovLHRoaXMuX3NpbXBsZVF1b3RlZFN0cmluZz0vXlwiKFteXCJcXFxcXFxyXFxuXSopXCIoPz1bXlwiXSkvLHRoaXMuX3NpbXBsZUFwb3N0cm9waGVTdHJpbmc9L14nKFteJ1xcXFxcXHJcXG5dKiknKD89W14nXSkvLHRoaXMuX2xhbmdjb2RlPS9eQChbYS16XSsoPzotW2EtejAtOV0rKSopKD89W15hLXowLTlcXC1dKS9pLHRoaXMuX3ByZWZpeD0vXigoPzpbQS1aYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKT86KD89WyNcXHM8XSkvLHRoaXMuX3ByZWZpeGVkPS9eKCg/OltBLVphLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopPzooKD86KD86WzAtOkEtWl9hLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKD86KD86W1xcLlxcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXXwlWzAtOWEtZkEtRl17Mn18XFxcXFshIy1cXC87PT9cXC1AX35dKSooPzpbXFwtMC06QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdfCVbMC05YS1mQS1GXXsyfXxcXFxcWyEjLVxcLzs9P1xcLUBffl0pKT8pPykoPzpbIFxcdF0rfCg/PVxcLj9bLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPF0pKS8sdGhpcy5fdmFyaWFibGU9L15cXD8oPzooPzpbQS1aX2EtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86W1xcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/PVsuLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9ibGFuaz0vXl86KCg/OlswLTlBLVpfYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/OlsgXFx0XSt8KD89XFwuP1ssOzpcXHMjKClcXFtcXF1cXHtcXH1cIic8XSkpLyx0aGlzLl9udW1iZXI9L15bXFwtK10/KD86XFxkK1xcLj9cXGQqKFtlRV0oPzpbXFwtXFwrXSk/XFxkKyl8XFxkKlxcLj9cXGQrKSg/PVxcLj9bLDs6XFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9ib29sZWFuPS9eKD86dHJ1ZXxmYWxzZSkoPz1bLiw7XFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLyx0aGlzLl9rZXl3b3JkPS9eQFthLXpdKyg/PVtcXHMjPDpdKS9pLHRoaXMuX3NwYXJxbEtleXdvcmQ9L14oPzpQUkVGSVh8QkFTRXxHUkFQSCkoPz1bXFxzIzxdKS9pLHRoaXMuX3Nob3J0UHJlZGljYXRlcz0vXmEoPz1bXFxzKClcXFtcXF1cXHtcXH1cIic8XSkvLHRoaXMuX25ld2xpbmU9L15bIFxcdF0qKD86I1teXFxuXFxyXSopPyg/OlxcclxcbnxcXG58XFxyKVsgXFx0XSovLHRoaXMuX2NvbW1lbnQ9LyMoW15cXG5cXHJdKikvLHRoaXMuX3doaXRlc3BhY2U9L15bIFxcdF0rLyx0aGlzLl9lbmRPZkZpbGU9L14oPzojW15cXG5cXHJdKik/JC8sdD10fHx7fSx0aGlzLl9saW5lTW9kZT0hIXQubGluZU1vZGUpZm9yKHZhciBlIGluIHRoaXMuX24zTW9kZT0hMSx0aGlzKSEoZSBpbiBmKSYmdGhpc1tlXWluc3RhbmNlb2YgUmVnRXhwJiYodGhpc1tlXT1sKTtlbHNlIHRoaXMuX24zTW9kZT0hMSE9PXQubjM7dGhpcy5fY29tbWVudHM9ISF0LmNvbW1lbnRzLHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPTB9X3Rva2VuaXplVG9FbmQodCxlKXtmb3IodmFyIHI9dGhpcy5faW5wdXQsbj10aGlzLl9jb21tZW50czs7KXtmb3IodmFyIGksYTtpPXRoaXMuX25ld2xpbmUuZXhlYyhyKTspbiYmKGE9dGhpcy5fY29tbWVudC5leGVjKGlbMF0pKSYmdChudWxsLHtsaW5lOnRoaXMuX2xpbmUsdHlwZTpcImNvbW1lbnRcIix2YWx1ZTphWzFdLHByZWZpeDpcIlwifSkscj1yLnN1YnN0cihpWzBdLmxlbmd0aCxyLmxlbmd0aCksdGhpcy5fbGluZSsrO2lmKCFpJiYoaT10aGlzLl93aGl0ZXNwYWNlLmV4ZWMocikpJiYocj1yLnN1YnN0cihpWzBdLmxlbmd0aCxyLmxlbmd0aCkpLHRoaXMuX2VuZE9mRmlsZS50ZXN0KHIpKXJldHVybiBlJiYobiYmKGE9dGhpcy5fY29tbWVudC5leGVjKHIpKSYmdChudWxsLHtsaW5lOnRoaXMuX2xpbmUsdHlwZTpcImNvbW1lbnRcIix2YWx1ZTphWzFdLHByZWZpeDpcIlwifSksdChyPW51bGwse2xpbmU6dGhpcy5fbGluZSx0eXBlOlwiZW9mXCIsdmFsdWU6XCJcIixwcmVmaXg6XCJcIn0pKSx0aGlzLl9pbnB1dD1yO3ZhciBzPXRoaXMuX2xpbmUsdT1cIlwiLGY9XCJcIixsPVwiXCIsaD1yWzBdLHA9bnVsbCxkPTAsdj0hMTtzd2l0Y2goaCl7Y2FzZVwiXlwiOmlmKHIubGVuZ3RoPDMpYnJlYWs7aWYoXCJeXCIhPT1yWzFdKXt0aGlzLl9uM01vZGUmJihkPTEsdT1cIl5cIik7YnJlYWt9aWYodGhpcy5fcHJldmlvdXNNYXJrZXI9XCJeXlwiLFwiPFwiIT09KHI9ci5zdWJzdHIoMikpWzBdKXt2PSEwO2JyZWFrfWNhc2VcIjxcIjppZihwPXRoaXMuX3VuZXNjYXBlZElyaS5leGVjKHIpKXU9XCJJUklcIixmPXBbMV07ZWxzZSBpZihwPXRoaXMuX2lyaS5leGVjKHIpKXtpZihudWxsPT09KGY9dGhpcy5fdW5lc2NhcGUocFsxXSkpfHxjLnRlc3QoZikpcmV0dXJuIHkodGhpcyk7dT1cIklSSVwifWVsc2UgdGhpcy5fbjNNb2RlJiZyLmxlbmd0aD4xJiZcIj1cIj09PXJbMV0mJih1PVwiaW52ZXJzZVwiLGQ9MixmPVwiPlwiKTticmVhaztjYXNlXCJfXCI6KChwPXRoaXMuX2JsYW5rLmV4ZWMocikpfHxlJiYocD10aGlzLl9ibGFuay5leGVjKHIrXCIgXCIpKSkmJih1PVwiYmxhbmtcIixsPVwiX1wiLGY9cFsxXSk7YnJlYWs7Y2FzZSdcIic6aWYocD10aGlzLl9zaW1wbGVRdW90ZWRTdHJpbmcuZXhlYyhyKSlmPXBbMV07ZWxzZSBpZigoe3ZhbHVlOmYsbWF0Y2hMZW5ndGg6ZH09dGhpcy5fcGFyc2VMaXRlcmFsKHIpKSxudWxsPT09ZilyZXR1cm4geSh0aGlzKTtudWxsPT09cCYmMD09PWR8fCh1PVwibGl0ZXJhbFwiLHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPTApO2JyZWFrO2Nhc2VcIidcIjppZighdGhpcy5fbGluZU1vZGUpe2lmKHA9dGhpcy5fc2ltcGxlQXBvc3Ryb3BoZVN0cmluZy5leGVjKHIpKWY9cFsxXTtlbHNlIGlmKCh7dmFsdWU6ZixtYXRjaExlbmd0aDpkfT10aGlzLl9wYXJzZUxpdGVyYWwocikpLG51bGw9PT1mKXJldHVybiB5KHRoaXMpO251bGw9PT1wJiYwPT09ZHx8KHU9XCJsaXRlcmFsXCIsdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3M9MCl9YnJlYWs7Y2FzZVwiP1wiOnRoaXMuX24zTW9kZSYmKHA9dGhpcy5fdmFyaWFibGUuZXhlYyhyKSkmJih1PVwidmFyXCIsZj1wWzBdKTticmVhaztjYXNlXCJAXCI6XCJsaXRlcmFsXCI9PT10aGlzLl9wcmV2aW91c01hcmtlciYmKHA9dGhpcy5fbGFuZ2NvZGUuZXhlYyhyKSk/KHU9XCJsYW5nY29kZVwiLGY9cFsxXSk6KHA9dGhpcy5fa2V5d29yZC5leGVjKHIpKSYmKHU9cFswXSk7YnJlYWs7Y2FzZVwiLlwiOmlmKDE9PT1yLmxlbmd0aD9lOnJbMV08XCIwXCJ8fHJbMV0+XCI5XCIpe3U9XCIuXCIsZD0xO2JyZWFrfWNhc2VcIjBcIjpjYXNlXCIxXCI6Y2FzZVwiMlwiOmNhc2VcIjNcIjpjYXNlXCI0XCI6Y2FzZVwiNVwiOmNhc2VcIjZcIjpjYXNlXCI3XCI6Y2FzZVwiOFwiOmNhc2VcIjlcIjpjYXNlXCIrXCI6Y2FzZVwiLVwiOihwPXRoaXMuX251bWJlci5leGVjKHIpfHxlJiYocD10aGlzLl9udW1iZXIuZXhlYyhyK1wiIFwiKSkpJiYodT1cImxpdGVyYWxcIixmPXBbMF0sbD1wWzFdP28uZG91YmxlOi9eWytcXC1dP1xcZCskLy50ZXN0KHBbMF0pP28uaW50ZWdlcjpvLmRlY2ltYWwpO2JyZWFrO2Nhc2VcIkJcIjpjYXNlXCJiXCI6Y2FzZVwicFwiOmNhc2VcIlBcIjpjYXNlXCJHXCI6Y2FzZVwiZ1wiOihwPXRoaXMuX3NwYXJxbEtleXdvcmQuZXhlYyhyKSk/dT1wWzBdLnRvVXBwZXJDYXNlKCk6dj0hMDticmVhaztjYXNlXCJmXCI6Y2FzZVwidFwiOihwPXRoaXMuX2Jvb2xlYW4uZXhlYyhyKSk/KHU9XCJsaXRlcmFsXCIsZj1wWzBdLGw9by5ib29sZWFuKTp2PSEwO2JyZWFrO2Nhc2VcImFcIjoocD10aGlzLl9zaG9ydFByZWRpY2F0ZXMuZXhlYyhyKSk/KHU9XCJhYmJyZXZpYXRpb25cIixmPVwiYVwiKTp2PSEwO2JyZWFrO2Nhc2VcIj1cIjp0aGlzLl9uM01vZGUmJnIubGVuZ3RoPjEmJih1PVwiYWJicmV2aWF0aW9uXCIsXCI+XCIhPT1yWzFdPyhkPTEsZj1cIj1cIik6KGQ9MixmPVwiPlwiKSk7YnJlYWs7Y2FzZVwiIVwiOmlmKCF0aGlzLl9uM01vZGUpYnJlYWs7Y2FzZVwiLFwiOmNhc2VcIjtcIjpjYXNlXCJbXCI6Y2FzZVwiXVwiOmNhc2VcIihcIjpjYXNlXCIpXCI6Y2FzZVwie1wiOmNhc2VcIn1cIjp0aGlzLl9saW5lTW9kZXx8KGQ9MSx1PWgpO2JyZWFrO2RlZmF1bHQ6dj0hMH1pZih2JiYoXCJAcHJlZml4XCIhPT10aGlzLl9wcmV2aW91c01hcmtlciYmXCJQUkVGSVhcIiE9PXRoaXMuX3ByZXZpb3VzTWFya2VyfHwhKHA9dGhpcy5fcHJlZml4LmV4ZWMocikpPygocD10aGlzLl9wcmVmaXhlZC5leGVjKHIpKXx8ZSYmKHA9dGhpcy5fcHJlZml4ZWQuZXhlYyhyK1wiIFwiKSkpJiYodT1cInByZWZpeGVkXCIsbD1wWzFdfHxcIlwiLGY9dGhpcy5fdW5lc2NhcGUocFsyXSkpOih1PVwicHJlZml4XCIsZj1wWzFdfHxcIlwiKSksXCJeXlwiPT09dGhpcy5fcHJldmlvdXNNYXJrZXIpc3dpdGNoKHUpe2Nhc2VcInByZWZpeGVkXCI6dT1cInR5cGVcIjticmVhaztjYXNlXCJJUklcIjp1PVwidHlwZUlSSVwiO2JyZWFrO2RlZmF1bHQ6dT1cIlwifWlmKCF1KXJldHVybiBlfHwhL14nJyd8XlwiXCJcIi8udGVzdChyKSYmL1xcbnxcXHIvLnRlc3Qocik/eSh0aGlzKTp0aGlzLl9pbnB1dD1yO3ZhciBnPXtsaW5lOnMsdHlwZTp1LHZhbHVlOmYscHJlZml4Omx9O3QobnVsbCxnKSx0aGlzLnByZXZpb3VzVG9rZW49Zyx0aGlzLl9wcmV2aW91c01hcmtlcj11LHI9ci5zdWJzdHIoZHx8cFswXS5sZW5ndGgsci5sZW5ndGgpfWZ1bmN0aW9uIHkoZSl7dChlLl9zeW50YXhFcnJvcigvXlxcUyovLmV4ZWMocilbMF0pKX19X3VuZXNjYXBlKHQpe3RyeXtyZXR1cm4gdC5yZXBsYWNlKHMsKGZ1bmN0aW9uKHQsZSxyLG4pe3ZhciBpO2lmKGUpe2lmKGk9cGFyc2VJbnQoZSwxNiksaXNOYU4oaSkpdGhyb3cgbmV3IEVycm9yO3JldHVybiBhKGkpfWlmKHIpe2lmKGk9cGFyc2VJbnQociwxNiksaXNOYU4oaSkpdGhyb3cgbmV3IEVycm9yO3JldHVybiBpPD02NTUzNT9hKGkpOmEoNTUyOTYrKGktPTY1NTM2KS8xMDI0LDU2MzIwKygxMDIzJmkpKX12YXIgbz11W25dO2lmKCFvKXRocm93IG5ldyBFcnJvcjtyZXR1cm4gb30pKX1jYXRjaCh0KXtyZXR1cm4gbnVsbH19X3BhcnNlTGl0ZXJhbCh0KXtpZih0Lmxlbmd0aD49Myl7Y29uc3QgZT10Lm1hdGNoKC9eKD86XCJcIlwifFwifCcnJ3wnfCkvKVswXSxyPWUubGVuZ3RoO2xldCBuPU1hdGgubWF4KHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zLHIpO2Zvcig7KG49dC5pbmRleE9mKGUsbikpPjA7KXtsZXQgZT0wO2Zvcig7XCJcXFxcXCI9PT10W24tZS0xXTspZSsrO2lmKGUlMj09MCl7Y29uc3QgZT10LnN1YnN0cmluZyhyLG4pLGk9ZS5zcGxpdCgvXFxyXFxufFxccnxcXG4vKS5sZW5ndGgtMSxvPW4rcjtpZigxPT09ciYmMCE9PWl8fDM9PT1yJiZ0aGlzLl9saW5lTW9kZSlicmVhaztyZXR1cm4gdGhpcy5fbGluZSs9aSx7dmFsdWU6dGhpcy5fdW5lc2NhcGUoZSksbWF0Y2hMZW5ndGg6b319bisrfXRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zPXQubGVuZ3RoLXIrMX1yZXR1cm57dmFsdWU6XCJcIixtYXRjaExlbmd0aDowfX1fc3ludGF4RXJyb3IodCl7dGhpcy5faW5wdXQ9bnVsbDt2YXIgZT1uZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgXCInK3QrJ1wiIG9uIGxpbmUgJyt0aGlzLl9saW5lK1wiLlwiKTtyZXR1cm4gZS5jb250ZXh0PXt0b2tlbjp2b2lkIDAsbGluZTp0aGlzLl9saW5lLHByZXZpb3VzVG9rZW46dGhpcy5wcmV2aW91c1Rva2VufSxlfXRva2VuaXplKGUscil7dmFyIGk9dGhpcztpZih0aGlzLl9saW5lPTEsXCJzdHJpbmdcIj09dHlwZW9mIGUpe2lmKHRoaXMuX2lucHV0PWUsXCJmdW5jdGlvblwiIT10eXBlb2Ygcil7dmFyIG8sYT1bXTtpZih0aGlzLl90b2tlbml6ZVRvRW5kKChmdW5jdGlvbih0LGUpe3Q/bz10OmEucHVzaChlKX0pLCEwKSxvKXRocm93IG87cmV0dXJuIGF9dCgoZnVuY3Rpb24oKXtpLl90b2tlbml6ZVRvRW5kKHIsITApfSkpfWVsc2UgdGhpcy5faW5wdXQ9XCJcIix0aGlzLl9wZW5kaW5nQnVmZmVyPW51bGwsXCJmdW5jdGlvblwiPT10eXBlb2YgZS5zZXRFbmNvZGluZyYmZS5zZXRFbmNvZGluZyhcInV0ZjhcIiksZS5vbihcImRhdGFcIiwoZnVuY3Rpb24odCl7bnVsbCE9PWkuX2lucHV0JiYwIT09dC5sZW5ndGgmJihpLl9wZW5kaW5nQnVmZmVyJiYodD1uLmNvbmNhdChbaS5fcGVuZGluZ0J1ZmZlcix0XSksaS5fcGVuZGluZ0J1ZmZlcj1udWxsKSwxMjgmdFt0Lmxlbmd0aC0xXT9pLl9wZW5kaW5nQnVmZmVyPXQ6KGkuX2lucHV0Kz10LGkuX3Rva2VuaXplVG9FbmQociwhMSkpKX0pKSxlLm9uKFwiZW5kXCIsKGZ1bmN0aW9uKCl7bnVsbCE9PWkuX2lucHV0JiZpLl90b2tlbml6ZVRvRW5kKHIsITApfSkpLGUub24oXCJlcnJvclwiLHIpfX19KS5jYWxsKHRoaXMscigxMzYpLnNldEltbWVkaWF0ZSxyKDkyKS5CdWZmZXIpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPWk7dmFyIG49cig5MykuRXZlbnRFbWl0dGVyO2Z1bmN0aW9uIGkoKXtuLmNhbGwodGhpcyl9cigyOSkoaSxuKSxpLlJlYWRhYmxlPXIoOTQpLGkuV3JpdGFibGU9cigxOTcpLGkuRHVwbGV4PXIoMTk4KSxpLlRyYW5zZm9ybT1yKDE5OSksaS5QYXNzVGhyb3VnaD1yKDIwMCksaS5TdHJlYW09aSxpLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKHQsZSl7dmFyIHI9dGhpcztmdW5jdGlvbiBpKGUpe3Qud3JpdGFibGUmJiExPT09dC53cml0ZShlKSYmci5wYXVzZSYmci5wYXVzZSgpfWZ1bmN0aW9uIG8oKXtyLnJlYWRhYmxlJiZyLnJlc3VtZSYmci5yZXN1bWUoKX1yLm9uKFwiZGF0YVwiLGkpLHQub24oXCJkcmFpblwiLG8pLHQuX2lzU3RkaW98fGUmJiExPT09ZS5lbmR8fChyLm9uKFwiZW5kXCIscyksci5vbihcImNsb3NlXCIsdSkpO3ZhciBhPSExO2Z1bmN0aW9uIHMoKXthfHwoYT0hMCx0LmVuZCgpKX1mdW5jdGlvbiB1KCl7YXx8KGE9ITAsXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiZ0LmRlc3Ryb3koKSl9ZnVuY3Rpb24gYyh0KXtpZihmKCksMD09PW4ubGlzdGVuZXJDb3VudCh0aGlzLFwiZXJyb3JcIikpdGhyb3cgdH1mdW5jdGlvbiBmKCl7ci5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIixpKSx0LnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixvKSxyLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIscyksci5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsdSksci5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsYyksdC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsYyksci5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGYpLHIucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGYpLHQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGYpfXJldHVybiByLm9uKFwiZXJyb3JcIixjKSx0Lm9uKFwiZXJyb3JcIixjKSxyLm9uKFwiZW5kXCIsZiksci5vbihcImNsb3NlXCIsZiksdC5vbihcImNsb3NlXCIsZiksdC5lbWl0KFwicGlwZVwiLHIpLHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig0KSxpPXIoNjMpLG89bi5XZWFrTWFwO3QuZXhwb3J0cz1cImZ1bmN0aW9uXCI9PXR5cGVvZiBvJiYvbmF0aXZlIGNvZGUvLnRlc3QoaShvKSl9LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDEyKSxpPXIoNDYpLmYsbz17fS50b1N0cmluZyxhPVwib2JqZWN0XCI9PXR5cGVvZiB3aW5kb3cmJndpbmRvdyYmT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM/T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KTpbXTt0LmV4cG9ydHMuZj1mdW5jdGlvbih0KXtyZXR1cm4gYSYmXCJbb2JqZWN0IFdpbmRvd11cIj09by5jYWxsKHQpP2Z1bmN0aW9uKHQpe3RyeXtyZXR1cm4gaSh0KX1jYXRjaCh0KXtyZXR1cm4gYS5zbGljZSgpfX0odCk6aShuKHQpKX19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDIpLGk9cig3KSxvPXIoNCksYT1yKDEzKSxzPXIoMTApLHU9cigxMSkuZixjPXIoMTAxKSxmPW8uU3ltYm9sO2lmKGkmJlwiZnVuY3Rpb25cIj09dHlwZW9mIGYmJighKFwiZGVzY3JpcHRpb25cImluIGYucHJvdG90eXBlKXx8dm9pZCAwIT09ZigpLmRlc2NyaXB0aW9uKSl7dmFyIGw9e30saD1mdW5jdGlvbigpe3ZhciB0PWFyZ3VtZW50cy5sZW5ndGg8MXx8dm9pZCAwPT09YXJndW1lbnRzWzBdP3ZvaWQgMDpTdHJpbmcoYXJndW1lbnRzWzBdKSxlPXRoaXMgaW5zdGFuY2VvZiBoP25ldyBmKHQpOnZvaWQgMD09PXQ/ZigpOmYodCk7cmV0dXJuXCJcIj09PXQmJihsW2VdPSEwKSxlfTtjKGgsZik7dmFyIHA9aC5wcm90b3R5cGU9Zi5wcm90b3R5cGU7cC5jb25zdHJ1Y3Rvcj1oO3ZhciBkPXAudG9TdHJpbmcsdj1cIlN5bWJvbCh0ZXN0KVwiPT1TdHJpbmcoZihcInRlc3RcIikpLGc9L15TeW1ib2xcXCgoLiopXFwpW14pXSskLzt1KHAsXCJkZXNjcmlwdGlvblwiLHtjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7dmFyIHQ9cyh0aGlzKT90aGlzLnZhbHVlT2YoKTp0aGlzLGU9ZC5jYWxsKHQpO2lmKGEobCx0KSlyZXR1cm5cIlwiO3ZhciByPXY/ZS5zbGljZSg3LC0xKTplLnJlcGxhY2UoZyxcIiQxXCIpO3JldHVyblwiXCI9PT1yP3ZvaWQgMDpyfX0pLG4oe2dsb2JhbDohMCxmb3JjZWQ6ITB9LHtTeW1ib2w6aH0pfX0sZnVuY3Rpb24odCxlLHIpe3IoMTExKShcIml0ZXJhdG9yXCIpfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxMTUpLkl0ZXJhdG9yUHJvdG90eXBlLGk9cig3MCksbz1yKDMxKSxhPXIoNDkpLHM9cigzNCksdT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIpe3ZhciBjPWUrXCIgSXRlcmF0b3JcIjtyZXR1cm4gdC5wcm90b3R5cGU9aShuLHtuZXh0Om8oMSxyKX0pLGEodCxjLCExLCEwKSxzW2NdPXUsdH19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDUpO3QuZXhwb3J0cz0hbigoZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7fXJldHVybiB0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1udWxsLE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgdCkhPT10LnByb3RvdHlwZX0pKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZighbih0KSYmbnVsbCE9PXQpdGhyb3cgVHlwZUVycm9yKFwiQ2FuJ3Qgc2V0IFwiK1N0cmluZyh0KStcIiBhcyBhIHByb3RvdHlwZVwiKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDcyKSxpPXIoMTE4KTt0LmV4cG9ydHM9bj97fS50b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiW29iamVjdCBcIitpKHRoaXMpK1wiXVwifX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dCl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigxNik7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7Zm9yKDshT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHQsZSkmJm51bGwhPT0odD1uKHQpKTspO3JldHVybiB0fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDcpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFpLHNoYW06IWl9LHtkZWZpbmVQcm9wZXJ0aWVzOnIoMTA4KX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNyk7bih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxmb3JjZWQ6IWksc2hhbTohaX0se2RlZmluZVByb3BlcnR5OnIoMTEpLmZ9KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMiksaT1yKDE2MCkuZW50cmllcztuKHt0YXJnZXQ6XCJPYmplY3RcIixzdGF0OiEwfSx7ZW50cmllczpmdW5jdGlvbih0KXtyZXR1cm4gaSh0KX19KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDQ4KSxvPXIoMTIpLGE9cig1OSkuZixzPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbihlKXtmb3IodmFyIHIscz1vKGUpLHU9aShzKSxjPXUubGVuZ3RoLGY9MCxsPVtdO2M+Zjspcj11W2YrK10sbiYmIWEuY2FsbChzLHIpfHxsLnB1c2godD9bcixzW3JdXTpzW3JdKTtyZXR1cm4gbH19O3QuZXhwb3J0cz17ZW50cmllczpzKCEwKSx2YWx1ZXM6cyghMSl9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNSksbz1yKDEyKSxhPXIoMjIpLmYscz1yKDcpLHU9aSgoZnVuY3Rpb24oKXthKDEpfSkpO24oe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITAsZm9yY2VkOiFzfHx1LHNoYW06IXN9LHtnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I6ZnVuY3Rpb24odCxlKXtyZXR1cm4gYShvKHQpLGUpfX0pfSxmdW5jdGlvbih0LGUscil7dmFyIG49cigyKSxpPXIoNyksbz1yKDEwMiksYT1yKDEyKSxzPXIoMjIpLHU9cig4Mik7bih7dGFyZ2V0OlwiT2JqZWN0XCIsc3RhdDohMCxzaGFtOiFpfSx7Z2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczpmdW5jdGlvbih0KXtmb3IodmFyIGUscixuPWEodCksaT1zLmYsYz1vKG4pLGY9e30sbD0wO2MubGVuZ3RoPmw7KXZvaWQgMCE9PShyPWkobixlPWNbbCsrXSkpJiZ1KGYsZSxyKTtyZXR1cm4gZn19KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNyksaT1yKDQpLG89cig2OCksYT1yKDE2NCkscz1yKDExKS5mLHU9cig0NikuZixjPXIoODgpLGY9cig3MyksbD1yKDExOSksaD1yKDE3KSxwPXIoNSksZD1yKDI0KS5zZXQsdj1yKDEyNSksZz1yKDMpKFwibWF0Y2hcIikseT1pLlJlZ0V4cCxiPXkucHJvdG90eXBlLF89L2EvZyxtPS9hL2csdz1uZXcgeShfKSE9PV8seD1sLlVOU1VQUE9SVEVEX1k7aWYobiYmbyhcIlJlZ0V4cFwiLCF3fHx4fHxwKChmdW5jdGlvbigpe3JldHVybiBtW2ddPSExLHkoXykhPV98fHkobSk9PW18fFwiL2EvaVwiIT15KF8sXCJpXCIpfSkpKSl7Zm9yKHZhciBrPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbj10aGlzIGluc3RhbmNlb2YgayxpPWModCksbz12b2lkIDA9PT1lO2lmKCFuJiZpJiZ0LmNvbnN0cnVjdG9yPT09ayYmbylyZXR1cm4gdDt3P2kmJiFvJiYodD10LnNvdXJjZSk6dCBpbnN0YW5jZW9mIGsmJihvJiYoZT1mLmNhbGwodCkpLHQ9dC5zb3VyY2UpLHgmJihyPSEhZSYmZS5pbmRleE9mKFwieVwiKT4tMSkmJihlPWUucmVwbGFjZSgveS9nLFwiXCIpKTt2YXIgcz1hKHc/bmV3IHkodCxlKTp5KHQsZSksbj90aGlzOmIsayk7cmV0dXJuIHgmJnImJmQocyx7c3RpY2t5OnJ9KSxzfSxFPWZ1bmN0aW9uKHQpe3QgaW4ga3x8cyhrLHQse2NvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4geVt0XX0sc2V0OmZ1bmN0aW9uKGUpe3lbdF09ZX19KX0sUz11KHkpLGo9MDtTLmxlbmd0aD5qOylFKFNbaisrXSk7Yi5jb25zdHJ1Y3Rvcj1rLGsucHJvdG90eXBlPWIsaChpLFwiUmVnRXhwXCIsayl9dihcIlJlZ0V4cFwiKX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTApLGk9cigxMTcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7dmFyIG8sYTtyZXR1cm4gaSYmXCJmdW5jdGlvblwiPT10eXBlb2Yobz1lLmNvbnN0cnVjdG9yKSYmbyE9PXImJm4oYT1vLnByb3RvdHlwZSkmJmEhPT1yLnByb3RvdHlwZSYmaSh0LGEpLHR9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxNyksaT1yKDgpLG89cig1KSxhPXIoNzMpLHM9UmVnRXhwLnByb3RvdHlwZSx1PXMudG9TdHJpbmcsYz1vKChmdW5jdGlvbigpe3JldHVyblwiL2EvYlwiIT11LmNhbGwoe3NvdXJjZTpcImFcIixmbGFnczpcImJcIn0pfSkpLGY9XCJ0b1N0cmluZ1wiIT11Lm5hbWU7KGN8fGYpJiZuKFJlZ0V4cC5wcm90b3R5cGUsXCJ0b1N0cmluZ1wiLChmdW5jdGlvbigpe3ZhciB0PWkodGhpcyksZT1TdHJpbmcodC5zb3VyY2UpLHI9dC5mbGFncztyZXR1cm5cIi9cIitlK1wiL1wiK1N0cmluZyh2b2lkIDA9PT1yJiZ0IGluc3RhbmNlb2YgUmVnRXhwJiYhKFwiZmxhZ3NcImluIHMpP2EuY2FsbCh0KTpyKX0pLHt1bnNhZmU6ITB9KX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoQXJyYXkuaXNBcnJheSh0KSlyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSl7dmFyIHI9W10sbj0hMCxpPSExLG89dm9pZCAwO3RyeXtmb3IodmFyIGEscz10W1N5bWJvbC5pdGVyYXRvcl0oKTshKG49KGE9cy5uZXh0KCkpLmRvbmUpJiYoci5wdXNoKGEudmFsdWUpLCFlfHxyLmxlbmd0aCE9PWUpO249ITApO31jYXRjaCh0KXtpPSEwLG89dH1maW5hbGx5e3RyeXtufHxudWxsPT1zLnJldHVybnx8cy5yZXR1cm4oKX1maW5hbGx5e2lmKGkpdGhyb3cgb319cmV0dXJuIHJ9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZVwiKX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe2lmKEFycmF5LmlzQXJyYXkodCkpe2Zvcih2YXIgZT0wLHI9bmV3IEFycmF5KHQubGVuZ3RoKTtlPHQubGVuZ3RoO2UrKylyW2VdPXRbZV07cmV0dXJuIHJ9fX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7aWYoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdCh0KXx8XCJbb2JqZWN0IEFyZ3VtZW50c11cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KSlyZXR1cm4gQXJyYXkuZnJvbSh0KX19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlXCIpfX0sZnVuY3Rpb24odCxlLHIpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe2xldCBlPTA7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspZT0oZTw8NSktZSt0LmNoYXJDb2RlQXQociksZXw9MDtyZXR1cm4gbi5jb2xvcnNbTWF0aC5hYnMoZSklbi5jb2xvcnMubGVuZ3RoXX1mdW5jdGlvbiBuKHQpe2xldCByO2Z1bmN0aW9uIGEoLi4udCl7aWYoIWEuZW5hYmxlZClyZXR1cm47Y29uc3QgZT1hLGk9TnVtYmVyKG5ldyBEYXRlKSxvPWktKHJ8fGkpO2UuZGlmZj1vLGUucHJldj1yLGUuY3Vycj1pLHI9aSx0WzBdPW4uY29lcmNlKHRbMF0pLFwic3RyaW5nXCIhPXR5cGVvZiB0WzBdJiZ0LnVuc2hpZnQoXCIlT1wiKTtsZXQgcz0wO3RbMF09dFswXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywocixpKT0+e2lmKFwiJSVcIj09PXIpcmV0dXJuIHI7cysrO2NvbnN0IG89bi5mb3JtYXR0ZXJzW2ldO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIG8pe2NvbnN0IG49dFtzXTtyPW8uY2FsbChlLG4pLHQuc3BsaWNlKHMsMSkscy0tfXJldHVybiByfSksbi5mb3JtYXRBcmdzLmNhbGwoZSx0KSwoZS5sb2d8fG4ubG9nKS5hcHBseShlLHQpfXJldHVybiBhLm5hbWVzcGFjZT10LGEuZW5hYmxlZD1uLmVuYWJsZWQodCksYS51c2VDb2xvcnM9bi51c2VDb2xvcnMoKSxhLmNvbG9yPWUodCksYS5kZXN0cm95PWksYS5leHRlbmQ9byxcImZ1bmN0aW9uXCI9PXR5cGVvZiBuLmluaXQmJm4uaW5pdChhKSxuLmluc3RhbmNlcy5wdXNoKGEpLGF9ZnVuY3Rpb24gaSgpe2NvbnN0IHQ9bi5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtyZXR1cm4tMSE9PXQmJihuLmluc3RhbmNlcy5zcGxpY2UodCwxKSwhMCl9ZnVuY3Rpb24gbyh0LGUpe2NvbnN0IHI9bih0aGlzLm5hbWVzcGFjZSsodm9pZCAwPT09ZT9cIjpcIjplKSt0KTtyZXR1cm4gci5sb2c9dGhpcy5sb2cscn1mdW5jdGlvbiBhKHQpe3JldHVybiB0LnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIsdC50b1N0cmluZygpLmxlbmd0aC0yKS5yZXBsYWNlKC9cXC5cXCpcXD8kLyxcIipcIil9cmV0dXJuIG4uZGVidWc9bixuLmRlZmF1bHQ9bixuLmNvZXJjZT1mdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgRXJyb3IpcmV0dXJuIHQuc3RhY2t8fHQubWVzc2FnZTtyZXR1cm4gdH0sbi5kaXNhYmxlPWZ1bmN0aW9uKCl7Y29uc3QgdD1bLi4ubi5uYW1lcy5tYXAoYSksLi4ubi5za2lwcy5tYXAoYSkubWFwKHQ9PlwiLVwiK3QpXS5qb2luKFwiLFwiKTtyZXR1cm4gbi5lbmFibGUoXCJcIiksdH0sbi5lbmFibGU9ZnVuY3Rpb24odCl7bGV0IGU7bi5zYXZlKHQpLG4ubmFtZXM9W10sbi5za2lwcz1bXTtjb25zdCByPShcInN0cmluZ1wiPT10eXBlb2YgdD90OlwiXCIpLnNwbGl0KC9bXFxzLF0rLyksaT1yLmxlbmd0aDtmb3IoZT0wO2U8aTtlKyspcltlXSYmKFwiLVwiPT09KHQ9cltlXS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKSlbMF0/bi5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrdC5zdWJzdHIoMSkrXCIkXCIpKTpuLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIit0K1wiJFwiKSkpO2ZvcihlPTA7ZTxuLmluc3RhbmNlcy5sZW5ndGg7ZSsrKXtjb25zdCB0PW4uaW5zdGFuY2VzW2VdO3QuZW5hYmxlZD1uLmVuYWJsZWQodC5uYW1lc3BhY2UpfX0sbi5lbmFibGVkPWZ1bmN0aW9uKHQpe2lmKFwiKlwiPT09dFt0Lmxlbmd0aC0xXSlyZXR1cm4hMDtsZXQgZSxyO2ZvcihlPTAscj1uLnNraXBzLmxlbmd0aDtlPHI7ZSsrKWlmKG4uc2tpcHNbZV0udGVzdCh0KSlyZXR1cm4hMTtmb3IoZT0wLHI9bi5uYW1lcy5sZW5ndGg7ZTxyO2UrKylpZihuLm5hbWVzW2VdLnRlc3QodCkpcmV0dXJuITA7cmV0dXJuITF9LG4uaHVtYW5pemU9cigxNzMpLE9iamVjdC5rZXlzKHQpLmZvckVhY2goZT0+e25bZV09dFtlXX0pLG4uaW5zdGFuY2VzPVtdLG4ubmFtZXM9W10sbi5za2lwcz1bXSxuLmZvcm1hdHRlcnM9e30sbi5zZWxlY3RDb2xvcj1lLG4uZW5hYmxlKG4ubG9hZCgpKSxufX0sZnVuY3Rpb24odCxlKXt2YXIgcj0xZTMsbj02ZTQsaT02MCpuLG89MjQqaTtmdW5jdGlvbiBhKHQsZSxyLG4pe3ZhciBpPWU+PTEuNSpyO3JldHVybiBNYXRoLnJvdW5kKHQvcikrXCIgXCIrbisoaT9cInNcIjpcIlwiKX10LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtlPWV8fHt9O3ZhciBzPXR5cGVvZiB0O2lmKFwic3RyaW5nXCI9PT1zJiZ0Lmxlbmd0aD4wKXJldHVybiBmdW5jdGlvbih0KXtpZigodD1TdHJpbmcodCkpLmxlbmd0aD4xMDApcmV0dXJuO3ZhciBlPS9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyh0KTtpZighZSlyZXR1cm47dmFyIGE9cGFyc2VGbG9hdChlWzFdKTtzd2l0Y2goKGVbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKSl7Y2FzZVwieWVhcnNcIjpjYXNlXCJ5ZWFyXCI6Y2FzZVwieXJzXCI6Y2FzZVwieXJcIjpjYXNlXCJ5XCI6cmV0dXJuIDMxNTU3NmU1KmE7Y2FzZVwid2Vla3NcIjpjYXNlXCJ3ZWVrXCI6Y2FzZVwid1wiOnJldHVybiA2MDQ4ZTUqYTtjYXNlXCJkYXlzXCI6Y2FzZVwiZGF5XCI6Y2FzZVwiZFwiOnJldHVybiBhKm87Y2FzZVwiaG91cnNcIjpjYXNlXCJob3VyXCI6Y2FzZVwiaHJzXCI6Y2FzZVwiaHJcIjpjYXNlXCJoXCI6cmV0dXJuIGEqaTtjYXNlXCJtaW51dGVzXCI6Y2FzZVwibWludXRlXCI6Y2FzZVwibWluc1wiOmNhc2VcIm1pblwiOmNhc2VcIm1cIjpyZXR1cm4gYSpuO2Nhc2VcInNlY29uZHNcIjpjYXNlXCJzZWNvbmRcIjpjYXNlXCJzZWNzXCI6Y2FzZVwic2VjXCI6Y2FzZVwic1wiOnJldHVybiBhKnI7Y2FzZVwibWlsbGlzZWNvbmRzXCI6Y2FzZVwibWlsbGlzZWNvbmRcIjpjYXNlXCJtc2Vjc1wiOmNhc2VcIm1zZWNcIjpjYXNlXCJtc1wiOnJldHVybiBhO2RlZmF1bHQ6cmV0dXJufX0odCk7aWYoXCJudW1iZXJcIj09PXMmJmlzRmluaXRlKHQpKXJldHVybiBlLmxvbmc/ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hYnModCk7aWYoZT49bylyZXR1cm4gYSh0LGUsbyxcImRheVwiKTtpZihlPj1pKXJldHVybiBhKHQsZSxpLFwiaG91clwiKTtpZihlPj1uKXJldHVybiBhKHQsZSxuLFwibWludXRlXCIpO2lmKGU+PXIpcmV0dXJuIGEodCxlLHIsXCJzZWNvbmRcIik7cmV0dXJuIHQrXCIgbXNcIn0odCk6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hYnModCk7aWYoZT49bylyZXR1cm4gTWF0aC5yb3VuZCh0L28pK1wiZFwiO2lmKGU+PWkpcmV0dXJuIE1hdGgucm91bmQodC9pKStcImhcIjtpZihlPj1uKXJldHVybiBNYXRoLnJvdW5kKHQvbikrXCJtXCI7aWYoZT49cilyZXR1cm4gTWF0aC5yb3VuZCh0L3IpK1wic1wiO3JldHVybiB0K1wibXNcIn0odCk7dGhyb3cgbmV3IEVycm9yKFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIitKU09OLnN0cmluZ2lmeSh0KSl9fSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigyKSxpPXIoMzMpLmV2ZXJ5O24oe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITAsZm9yY2VkOnIoMzYpKFwiZXZlcnlcIil9LHtldmVyeTpmdW5jdGlvbih0KXtyZXR1cm4gaSh0aGlzLHQsYXJndW1lbnRzLmxlbmd0aD4xP2FyZ3VtZW50c1sxXTp2b2lkIDApfX0pfSxmdW5jdGlvbih0LGUscil7XCJ1c2Ugc3RyaWN0XCI7dmFyIG49cigxMiksaT1yKDMyKSxvPXIoMTUpLGE9cigzNikscz1NYXRoLm1pbix1PVtdLmxhc3RJbmRleE9mLGM9ISF1JiYxL1sxXS5sYXN0SW5kZXhPZigxLC0wKTwwLGY9YShcImxhc3RJbmRleE9mXCIpO3QuZXhwb3J0cz1jfHxmP2Z1bmN0aW9uKHQpe2lmKGMpcmV0dXJuIHUuYXBwbHkodGhpcyxhcmd1bWVudHMpfHwwO3ZhciBlPW4odGhpcykscj1vKGUubGVuZ3RoKSxhPXItMTtmb3IoYXJndW1lbnRzLmxlbmd0aD4xJiYoYT1zKGEsaShhcmd1bWVudHNbMV0pKSksYTwwJiYoYT1yK2EpO2E+PTA7YS0tKWlmKGEgaW4gZSYmZVthXT09PXQpcmV0dXJuIGF8fDA7cmV0dXJuLTF9OnV9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt2YXIgbj1yKDc2KSxpPXIoODgpLG89cig4KSxhPXIoMjApLHM9cigxMzIpLHU9cig3NyksYz1yKDE1KSxmPXIoNzgpLGw9cig1MyksaD1yKDUpLHA9W10ucHVzaCxkPU1hdGgubWluLHY9IWgoKGZ1bmN0aW9uKCl7cmV0dXJuIVJlZ0V4cCg0Mjk0OTY3Mjk1LFwieVwiKX0pKTtuKFwic3BsaXRcIiwyLChmdW5jdGlvbih0LGUscil7dmFyIG47cmV0dXJuIG49XCJjXCI9PVwiYWJiY1wiLnNwbGl0KC8oYikqLylbMV18fDQhPVwidGVzdFwiLnNwbGl0KC8oPzopLywtMSkubGVuZ3RofHwyIT1cImFiXCIuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGh8fDQhPVwiLlwiLnNwbGl0KC8oLj8pKC4/KS8pLmxlbmd0aHx8XCIuXCIuc3BsaXQoLygpKCkvKS5sZW5ndGg+MXx8XCJcIi5zcGxpdCgvLj8vKS5sZW5ndGg/ZnVuY3Rpb24odCxyKXt2YXIgbj1TdHJpbmcoYSh0aGlzKSksbz12b2lkIDA9PT1yPzQyOTQ5NjcyOTU6cj4+PjA7aWYoMD09PW8pcmV0dXJuW107aWYodm9pZCAwPT09dClyZXR1cm5bbl07aWYoIWkodCkpcmV0dXJuIGUuY2FsbChuLHQsbyk7Zm9yKHZhciBzLHUsYyxmPVtdLGg9KHQuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsodC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKHQudW5pY29kZT9cInVcIjpcIlwiKSsodC5zdGlja3k/XCJ5XCI6XCJcIiksZD0wLHY9bmV3IFJlZ0V4cCh0LnNvdXJjZSxoK1wiZ1wiKTsocz1sLmNhbGwodixuKSkmJiEoKHU9di5sYXN0SW5kZXgpPmQmJihmLnB1c2gobi5zbGljZShkLHMuaW5kZXgpKSxzLmxlbmd0aD4xJiZzLmluZGV4PG4ubGVuZ3RoJiZwLmFwcGx5KGYscy5zbGljZSgxKSksYz1zWzBdLmxlbmd0aCxkPXUsZi5sZW5ndGg+PW8pKTspdi5sYXN0SW5kZXg9PT1zLmluZGV4JiZ2Lmxhc3RJbmRleCsrO3JldHVybiBkPT09bi5sZW5ndGg/IWMmJnYudGVzdChcIlwiKXx8Zi5wdXNoKFwiXCIpOmYucHVzaChuLnNsaWNlKGQpKSxmLmxlbmd0aD5vP2Yuc2xpY2UoMCxvKTpmfTpcIjBcIi5zcGxpdCh2b2lkIDAsMCkubGVuZ3RoP2Z1bmN0aW9uKHQscil7cmV0dXJuIHZvaWQgMD09PXQmJjA9PT1yP1tdOmUuY2FsbCh0aGlzLHQscil9OmUsW2Z1bmN0aW9uKGUscil7dmFyIGk9YSh0aGlzKSxvPW51bGw9PWU/dm9pZCAwOmVbdF07cmV0dXJuIHZvaWQgMCE9PW8/by5jYWxsKGUsaSxyKTpuLmNhbGwoU3RyaW5nKGkpLGUscil9LGZ1bmN0aW9uKHQsaSl7dmFyIGE9cihuLHQsdGhpcyxpLG4hPT1lKTtpZihhLmRvbmUpcmV0dXJuIGEudmFsdWU7dmFyIGw9byh0KSxoPVN0cmluZyh0aGlzKSxwPXMobCxSZWdFeHApLGc9bC51bmljb2RlLHk9KGwuaWdub3JlQ2FzZT9cImlcIjpcIlwiKSsobC5tdWx0aWxpbmU/XCJtXCI6XCJcIikrKGwudW5pY29kZT9cInVcIjpcIlwiKSsodj9cInlcIjpcImdcIiksYj1uZXcgcCh2P2w6XCJeKD86XCIrbC5zb3VyY2UrXCIpXCIseSksXz12b2lkIDA9PT1pPzQyOTQ5NjcyOTU6aT4+PjA7aWYoMD09PV8pcmV0dXJuW107aWYoMD09PWgubGVuZ3RoKXJldHVybiBudWxsPT09ZihiLGgpP1toXTpbXTtmb3IodmFyIG09MCx3PTAseD1bXTt3PGgubGVuZ3RoOyl7Yi5sYXN0SW5kZXg9dj93OjA7dmFyIGssRT1mKGIsdj9oOmguc2xpY2UodykpO2lmKG51bGw9PT1FfHwoaz1kKGMoYi5sYXN0SW5kZXgrKHY/MDp3KSksaC5sZW5ndGgpKT09PW0pdz11KGgsdyxnKTtlbHNle2lmKHgucHVzaChoLnNsaWNlKG0sdykpLHgubGVuZ3RoPT09XylyZXR1cm4geDtmb3IodmFyIFM9MTtTPD1FLmxlbmd0aC0xO1MrKylpZih4LnB1c2goRVtTXSkseC5sZW5ndGg9PT1fKXJldHVybiB4O3c9bT1rfX1yZXR1cm4geC5wdXNoKGguc2xpY2UobSkpLHh9XX0pLCF2KX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoNCk7dC5leHBvcnRzPW4uUHJvbWlzZX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTcpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscil7Zm9yKHZhciBpIGluIGUpbih0LGksZVtpXSxyKTtyZXR1cm4gdH19LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQsZSxyKXtpZighKHQgaW5zdGFuY2VvZiBlKSl0aHJvdyBUeXBlRXJyb3IoXCJJbmNvcnJlY3QgXCIrKHI/citcIiBcIjpcIlwiKStcImludm9jYXRpb25cIik7cmV0dXJuIHR9fSxmdW5jdGlvbih0LGUscil7dmFyIG49cig4KSxpPXIoMTgxKSxvPXIoMTUpLGE9cig3MSkscz1yKDE4MiksdT1yKDE4MyksYz1mdW5jdGlvbih0LGUpe3RoaXMuc3RvcHBlZD10LHRoaXMucmVzdWx0PWV9Oyh0LmV4cG9ydHM9ZnVuY3Rpb24odCxlLHIsZixsKXt2YXIgaCxwLGQsdixnLHksYixfPWEoZSxyLGY/MjoxKTtpZihsKWg9dDtlbHNle2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mKHA9cyh0KSkpdGhyb3cgVHlwZUVycm9yKFwiVGFyZ2V0IGlzIG5vdCBpdGVyYWJsZVwiKTtpZihpKHApKXtmb3IoZD0wLHY9byh0Lmxlbmd0aCk7dj5kO2QrKylpZigoZz1mP18obihiPXRbZF0pWzBdLGJbMV0pOl8odFtkXSkpJiZnIGluc3RhbmNlb2YgYylyZXR1cm4gZztyZXR1cm4gbmV3IGMoITEpfWg9cC5jYWxsKHQpfWZvcih5PWgubmV4dDshKGI9eS5jYWxsKGgpKS5kb25lOylpZihcIm9iamVjdFwiPT10eXBlb2YoZz11KGgsXyxiLnZhbHVlLGYpKSYmZyYmZyBpbnN0YW5jZW9mIGMpcmV0dXJuIGc7cmV0dXJuIG5ldyBjKCExKX0pLnN0b3A9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBjKCEwLHQpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMyksaT1yKDM0KSxvPW4oXCJpdGVyYXRvclwiKSxhPUFycmF5LnByb3RvdHlwZTt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7cmV0dXJuIHZvaWQgMCE9PXQmJihpLkFycmF5PT09dHx8YVtvXT09PXQpfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMTE4KSxpPXIoMzQpLG89cigzKShcIml0ZXJhdG9yXCIpO3QuZXhwb3J0cz1mdW5jdGlvbih0KXtpZihudWxsIT10KXJldHVybiB0W29dfHx0W1wiQEBpdGVyYXRvclwiXXx8aVtuKHQpXX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUscixpKXt0cnl7cmV0dXJuIGk/ZShuKHIpWzBdLHJbMV0pOmUocil9Y2F0Y2goZSl7dmFyIG89dC5yZXR1cm47dGhyb3cgdm9pZCAwIT09byYmbihvLmNhbGwodCkpLGV9fX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoMykoXCJpdGVyYXRvclwiKSxpPSExO3RyeXt2YXIgbz0wLGE9e25leHQ6ZnVuY3Rpb24oKXtyZXR1cm57ZG9uZTohIW8rK319LHJldHVybjpmdW5jdGlvbigpe2k9ITB9fTthW25dPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LEFycmF5LmZyb20oYSwoZnVuY3Rpb24oKXt0aHJvdyAyfSkpfWNhdGNoKHQpe310LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZighZSYmIWkpcmV0dXJuITE7dmFyIHI9ITE7dHJ5e3ZhciBvPXt9O29bbl09ZnVuY3Rpb24oKXtyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybntkb25lOnI9ITB9fX19LHQobyl9Y2F0Y2godCl7fXJldHVybiByfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuLGksbyxhLHMsdSxjLGYsbD1yKDQpLGg9cigyMikuZixwPXIoMTkpLGQ9cigxMzMpLnNldCx2PXIoMTM0KSxnPWwuTXV0YXRpb25PYnNlcnZlcnx8bC5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHk9bC5wcm9jZXNzLGI9bC5Qcm9taXNlLF89XCJwcm9jZXNzXCI9PXAoeSksbT1oKGwsXCJxdWV1ZU1pY3JvdGFza1wiKSx3PW0mJm0udmFsdWU7d3x8KG49ZnVuY3Rpb24oKXt2YXIgdCxlO2ZvcihfJiYodD15LmRvbWFpbikmJnQuZXhpdCgpO2k7KXtlPWkuZm4saT1pLm5leHQ7dHJ5e2UoKX1jYXRjaCh0KXt0aHJvdyBpP2EoKTpvPXZvaWQgMCx0fX1vPXZvaWQgMCx0JiZ0LmVudGVyKCl9LF8/YT1mdW5jdGlvbigpe3kubmV4dFRpY2sobil9OmcmJiF2PyhzPSEwLHU9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIiksbmV3IGcobikub2JzZXJ2ZSh1LHtjaGFyYWN0ZXJEYXRhOiEwfSksYT1mdW5jdGlvbigpe3UuZGF0YT1zPSFzfSk6YiYmYi5yZXNvbHZlPyhjPWIucmVzb2x2ZSh2b2lkIDApLGY9Yy50aGVuLGE9ZnVuY3Rpb24oKXtmLmNhbGwoYyxuKX0pOmE9ZnVuY3Rpb24oKXtkLmNhbGwobCxuKX0pLHQuZXhwb3J0cz13fHxmdW5jdGlvbih0KXt2YXIgZT17Zm46dCxuZXh0OnZvaWQgMH07byYmKG8ubmV4dD1lKSxpfHwoaT1lLGEoKSksbz1lfX0sZnVuY3Rpb24odCxlLHIpe3ZhciBuPXIoOCksaT1yKDEwKSxvPXIoMTM1KTt0LmV4cG9ydHM9ZnVuY3Rpb24odCxlKXtpZihuKHQpLGkoZSkmJmUuY29uc3RydWN0b3I9PT10KXJldHVybiBlO3ZhciByPW8uZih0KTtyZXR1cm4oMCxyLnJlc29sdmUpKGUpLHIucHJvbWlzZX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDQpO3QuZXhwb3J0cz1mdW5jdGlvbih0LGUpe3ZhciByPW4uY29uc29sZTtyJiZyLmVycm9yJiYoMT09PWFyZ3VtZW50cy5sZW5ndGg/ci5lcnJvcih0KTpyLmVycm9yKHQsZSkpfX0sZnVuY3Rpb24odCxlKXt0LmV4cG9ydHM9ZnVuY3Rpb24odCl7dHJ5e3JldHVybntlcnJvcjohMSx2YWx1ZTp0KCl9fWNhdGNoKHQpe3JldHVybntlcnJvcjohMCx2YWx1ZTp0fX19fSxmdW5jdGlvbih0LGUscil7KGZ1bmN0aW9uKHQsZSl7IWZ1bmN0aW9uKHQscil7XCJ1c2Ugc3RyaWN0XCI7aWYoIXQuc2V0SW1tZWRpYXRlKXt2YXIgbixpLG8sYSxzLHU9MSxjPXt9LGY9ITEsbD10LmRvY3VtZW50LGg9T2JqZWN0LmdldFByb3RvdHlwZU9mJiZPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7aD1oJiZoLnNldFRpbWVvdXQ/aDp0LFwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbCh0LnByb2Nlc3MpP249ZnVuY3Rpb24odCl7ZS5uZXh0VGljaygoZnVuY3Rpb24oKXtkKHQpfSkpfTohZnVuY3Rpb24oKXtpZih0LnBvc3RNZXNzYWdlJiYhdC5pbXBvcnRTY3JpcHRzKXt2YXIgZT0hMCxyPXQub25tZXNzYWdlO3JldHVybiB0Lm9ubWVzc2FnZT1mdW5jdGlvbigpe2U9ITF9LHQucG9zdE1lc3NhZ2UoXCJcIixcIipcIiksdC5vbm1lc3NhZ2U9cixlfX0oKT90Lk1lc3NhZ2VDaGFubmVsPygobz1uZXcgTWVzc2FnZUNoYW5uZWwpLnBvcnQxLm9ubWVzc2FnZT1mdW5jdGlvbih0KXtkKHQuZGF0YSl9LG49ZnVuY3Rpb24odCl7by5wb3J0Mi5wb3N0TWVzc2FnZSh0KX0pOmwmJlwib25yZWFkeXN0YXRlY2hhbmdlXCJpbiBsLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik/KGk9bC5kb2N1bWVudEVsZW1lbnQsbj1mdW5jdGlvbih0KXt2YXIgZT1sLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7ZS5vbnJlYWR5c3RhdGVjaGFuZ2U9ZnVuY3Rpb24oKXtkKHQpLGUub25yZWFkeXN0YXRlY2hhbmdlPW51bGwsaS5yZW1vdmVDaGlsZChlKSxlPW51bGx9LGkuYXBwZW5kQ2hpbGQoZSl9KTpuPWZ1bmN0aW9uKHQpe3NldFRpbWVvdXQoZCwwLHQpfTooYT1cInNldEltbWVkaWF0ZSRcIitNYXRoLnJhbmRvbSgpK1wiJFwiLHM9ZnVuY3Rpb24oZSl7ZS5zb3VyY2U9PT10JiZcInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYwPT09ZS5kYXRhLmluZGV4T2YoYSkmJmQoK2UuZGF0YS5zbGljZShhLmxlbmd0aCkpfSx0LmFkZEV2ZW50TGlzdGVuZXI/dC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLHMsITEpOnQuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIixzKSxuPWZ1bmN0aW9uKGUpe3QucG9zdE1lc3NhZ2UoYStlLFwiKlwiKX0pLGguc2V0SW1tZWRpYXRlPWZ1bmN0aW9uKHQpe1wiZnVuY3Rpb25cIiE9dHlwZW9mIHQmJih0PW5ldyBGdW5jdGlvbihcIlwiK3QpKTtmb3IodmFyIGU9bmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSkscj0wO3I8ZS5sZW5ndGg7cisrKWVbcl09YXJndW1lbnRzW3IrMV07dmFyIGk9e2NhbGxiYWNrOnQsYXJnczplfTtyZXR1cm4gY1t1XT1pLG4odSksdSsrfSxoLmNsZWFySW1tZWRpYXRlPXB9ZnVuY3Rpb24gcCh0KXtkZWxldGUgY1t0XX1mdW5jdGlvbiBkKHQpe2lmKGYpc2V0VGltZW91dChkLDAsdCk7ZWxzZXt2YXIgZT1jW3RdO2lmKGUpe2Y9ITA7dHJ5eyFmdW5jdGlvbih0KXt2YXIgZT10LmNhbGxiYWNrLHI9dC5hcmdzO3N3aXRjaChyLmxlbmd0aCl7Y2FzZSAwOmUoKTticmVhaztjYXNlIDE6ZShyWzBdKTticmVhaztjYXNlIDI6ZShyWzBdLHJbMV0pO2JyZWFrO2Nhc2UgMzplKHJbMF0sclsxXSxyWzJdKTticmVhaztkZWZhdWx0OmUuYXBwbHkodm9pZCAwLHIpfX0oZSl9ZmluYWxseXtwKHQpLGY9ITF9fX19fShcInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj92b2lkIDA9PT10P3RoaXM6dDpzZWxmKX0pLmNhbGwodGhpcyxyKDIxKSxyKDM4KSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtlLmJ5dGVMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGU9Yyh0KSxyPWVbMF0sbj1lWzFdO3JldHVybiAzKihyK24pLzQtbn0sZS50b0J5dGVBcnJheT1mdW5jdGlvbih0KXt2YXIgZSxyLG49Yyh0KSxhPW5bMF0scz1uWzFdLHU9bmV3IG8oZnVuY3Rpb24odCxlLHIpe3JldHVybiAzKihlK3IpLzQtcn0oMCxhLHMpKSxmPTAsbD1zPjA/YS00OmE7Zm9yKHI9MDtyPGw7cis9NCllPWlbdC5jaGFyQ29kZUF0KHIpXTw8MTh8aVt0LmNoYXJDb2RlQXQocisxKV08PDEyfGlbdC5jaGFyQ29kZUF0KHIrMildPDw2fGlbdC5jaGFyQ29kZUF0KHIrMyldLHVbZisrXT1lPj4xNiYyNTUsdVtmKytdPWU+PjgmMjU1LHVbZisrXT0yNTUmZTsyPT09cyYmKGU9aVt0LmNoYXJDb2RlQXQocildPDwyfGlbdC5jaGFyQ29kZUF0KHIrMSldPj40LHVbZisrXT0yNTUmZSk7MT09PXMmJihlPWlbdC5jaGFyQ29kZUF0KHIpXTw8MTB8aVt0LmNoYXJDb2RlQXQocisxKV08PDR8aVt0LmNoYXJDb2RlQXQocisyKV0+PjIsdVtmKytdPWU+PjgmMjU1LHVbZisrXT0yNTUmZSk7cmV0dXJuIHV9LGUuZnJvbUJ5dGVBcnJheT1mdW5jdGlvbih0KXtmb3IodmFyIGUscj10Lmxlbmd0aCxpPXIlMyxvPVtdLGE9MCxzPXItaTthPHM7YSs9MTYzODMpby5wdXNoKGYodCxhLGErMTYzODM+cz9zOmErMTYzODMpKTsxPT09aT8oZT10W3ItMV0sby5wdXNoKG5bZT4+Ml0rbltlPDw0JjYzXStcIj09XCIpKToyPT09aSYmKGU9KHRbci0yXTw8OCkrdFtyLTFdLG8ucHVzaChuW2U+PjEwXStuW2U+PjQmNjNdK25bZTw8MiY2M10rXCI9XCIpKTtyZXR1cm4gby5qb2luKFwiXCIpfTtmb3IodmFyIG49W10saT1bXSxvPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBVaW50OEFycmF5P1VpbnQ4QXJyYXk6QXJyYXksYT1cIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIixzPTAsdT1hLmxlbmd0aDtzPHU7KytzKW5bc109YVtzXSxpW2EuY2hhckNvZGVBdChzKV09cztmdW5jdGlvbiBjKHQpe3ZhciBlPXQubGVuZ3RoO2lmKGUlND4wKXRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIik7dmFyIHI9dC5pbmRleE9mKFwiPVwiKTtyZXR1cm4tMT09PXImJihyPWUpLFtyLHI9PT1lPzA6NC1yJTRdfWZ1bmN0aW9uIGYodCxlLHIpe2Zvcih2YXIgaSxvLGE9W10scz1lO3M8cjtzKz0zKWk9KHRbc108PDE2JjE2NzExNjgwKSsodFtzKzFdPDw4JjY1MjgwKSsoMjU1JnRbcysyXSksYS5wdXNoKG5bKG89aSk+PjE4JjYzXStuW28+PjEyJjYzXStuW28+PjYmNjNdK25bNjMmb10pO3JldHVybiBhLmpvaW4oXCJcIil9aVtcIi1cIi5jaGFyQ29kZUF0KDApXT02MixpW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzfSxmdW5jdGlvbih0LGUpe2UucmVhZD1mdW5jdGlvbih0LGUscixuLGkpe3ZhciBvLGEscz04Kmktbi0xLHU9KDE8PHMpLTEsYz11Pj4xLGY9LTcsbD1yP2ktMTowLGg9cj8tMToxLHA9dFtlK2xdO2ZvcihsKz1oLG89cCYoMTw8LWYpLTEscD4+PS1mLGYrPXM7Zj4wO289MjU2Km8rdFtlK2xdLGwrPWgsZi09OCk7Zm9yKGE9byYoMTw8LWYpLTEsbz4+PS1mLGYrPW47Zj4wO2E9MjU2KmErdFtlK2xdLGwrPWgsZi09OCk7aWYoMD09PW8pbz0xLWM7ZWxzZXtpZihvPT09dSlyZXR1cm4gYT9OYU46MS8wKihwPy0xOjEpO2ErPU1hdGgucG93KDIsbiksby09Y31yZXR1cm4ocD8tMToxKSphKk1hdGgucG93KDIsby1uKX0sZS53cml0ZT1mdW5jdGlvbih0LGUscixuLGksbyl7dmFyIGEscyx1LGM9OCpvLWktMSxmPSgxPDxjKS0xLGw9Zj4+MSxoPTIzPT09aT9NYXRoLnBvdygyLC0yNCktTWF0aC5wb3coMiwtNzcpOjAscD1uPzA6by0xLGQ9bj8xOi0xLHY9ZTwwfHwwPT09ZSYmMS9lPDA/MTowO2ZvcihlPU1hdGguYWJzKGUpLGlzTmFOKGUpfHxlPT09MS8wPyhzPWlzTmFOKGUpPzE6MCxhPWYpOihhPU1hdGguZmxvb3IoTWF0aC5sb2coZSkvTWF0aC5MTjIpLGUqKHU9TWF0aC5wb3coMiwtYSkpPDEmJihhLS0sdSo9MiksKGUrPWErbD49MT9oL3U6aCpNYXRoLnBvdygyLDEtbCkpKnU+PTImJihhKyssdS89MiksYStsPj1mPyhzPTAsYT1mKTphK2w+PTE/KHM9KGUqdS0xKSpNYXRoLnBvdygyLGkpLGErPWwpOihzPWUqTWF0aC5wb3coMixsLTEpKk1hdGgucG93KDIsaSksYT0wKSk7aT49ODt0W3IrcF09MjU1JnMscCs9ZCxzLz0yNTYsaS09OCk7Zm9yKGE9YTw8aXxzLGMrPWk7Yz4wO3RbcitwXT0yNTUmYSxwKz1kLGEvPTI1NixjLT04KTt0W3IrcC1kXXw9MTI4KnZ9fSxmdW5jdGlvbih0LGUpe30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoNTYpLkJ1ZmZlcixpPXIoMTk0KTt0LmV4cG9ydHM9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KCl7IWZ1bmN0aW9uKHQsZSl7aWYoISh0IGluc3RhbmNlb2YgZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKX0odGhpcyx0KSx0aGlzLmhlYWQ9bnVsbCx0aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfXJldHVybiB0LnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3ZhciBlPXtkYXRhOnQsbmV4dDpudWxsfTt0aGlzLmxlbmd0aD4wP3RoaXMudGFpbC5uZXh0PWU6dGhpcy5oZWFkPWUsdGhpcy50YWlsPWUsKyt0aGlzLmxlbmd0aH0sdC5wcm90b3R5cGUudW5zaGlmdD1mdW5jdGlvbih0KXt2YXIgZT17ZGF0YTp0LG5leHQ6dGhpcy5oZWFkfTswPT09dGhpcy5sZW5ndGgmJih0aGlzLnRhaWw9ZSksdGhpcy5oZWFkPWUsKyt0aGlzLmxlbmd0aH0sdC5wcm90b3R5cGUuc2hpZnQ9ZnVuY3Rpb24oKXtpZigwIT09dGhpcy5sZW5ndGgpe3ZhciB0PXRoaXMuaGVhZC5kYXRhO3JldHVybiAxPT09dGhpcy5sZW5ndGg/dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsOnRoaXMuaGVhZD10aGlzLmhlYWQubmV4dCwtLXRoaXMubGVuZ3RoLHR9fSx0LnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuaGVhZD10aGlzLnRhaWw9bnVsbCx0aGlzLmxlbmd0aD0wfSx0LnByb3RvdHlwZS5qb2luPWZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm5cIlwiO2Zvcih2YXIgZT10aGlzLmhlYWQscj1cIlwiK2UuZGF0YTtlPWUubmV4dDspcis9dCtlLmRhdGE7cmV0dXJuIHJ9LHQucHJvdG90eXBlLmNvbmNhdD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5sZW5ndGgpcmV0dXJuIG4uYWxsb2MoMCk7aWYoMT09PXRoaXMubGVuZ3RoKXJldHVybiB0aGlzLmhlYWQuZGF0YTtmb3IodmFyIGUscixpLG89bi5hbGxvY1Vuc2FmZSh0Pj4+MCksYT10aGlzLmhlYWQscz0wO2E7KWU9YS5kYXRhLHI9byxpPXMsZS5jb3B5KHIsaSkscys9YS5kYXRhLmxlbmd0aCxhPWEubmV4dDtyZXR1cm4gb30sdH0oKSxpJiZpLmluc3BlY3QmJmkuaW5zcGVjdC5jdXN0b20mJih0LmV4cG9ydHMucHJvdG90eXBlW2kuaW5zcGVjdC5jdXN0b21dPWZ1bmN0aW9uKCl7dmFyIHQ9aS5pbnNwZWN0KHtsZW5ndGg6dGhpcy5sZW5ndGh9KTtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lK1wiIFwiK3R9KX0sZnVuY3Rpb24odCxlKXt9LGZ1bmN0aW9uKHQsZSxyKXsoZnVuY3Rpb24oZSl7ZnVuY3Rpb24gcih0KXt0cnl7aWYoIWUubG9jYWxTdG9yYWdlKXJldHVybiExfWNhdGNoKHQpe3JldHVybiExfXZhciByPWUubG9jYWxTdG9yYWdlW3RdO3JldHVybiBudWxsIT1yJiZcInRydWVcIj09PVN0cmluZyhyKS50b0xvd2VyQ2FzZSgpfXQuZXhwb3J0cz1mdW5jdGlvbih0LGUpe2lmKHIoXCJub0RlcHJlY2F0aW9uXCIpKXJldHVybiB0O3ZhciBuPSExO3JldHVybiBmdW5jdGlvbigpe2lmKCFuKXtpZihyKFwidGhyb3dEZXByZWNhdGlvblwiKSl0aHJvdyBuZXcgRXJyb3IoZSk7cihcInRyYWNlRGVwcmVjYXRpb25cIik/Y29uc29sZS50cmFjZShlKTpjb25zb2xlLndhcm4oZSksbj0hMH1yZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fX0pLmNhbGwodGhpcyxyKDIxKSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjt0LmV4cG9ydHM9bzt2YXIgbj1yKDE0MiksaT1yKDM5KTtmdW5jdGlvbiBvKHQpe2lmKCEodGhpcyBpbnN0YW5jZW9mIG8pKXJldHVybiBuZXcgbyh0KTtuLmNhbGwodGhpcyx0KX1pLmluaGVyaXRzPXIoMjkpLGkuaW5oZXJpdHMobyxuKSxvLnByb3RvdHlwZS5fdHJhbnNmb3JtPWZ1bmN0aW9uKHQsZSxyKXtyKG51bGwsdCl9fSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoOTUpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoMjMpfSxmdW5jdGlvbih0LGUscil7dC5leHBvcnRzPXIoOTQpLlRyYW5zZm9ybX0sZnVuY3Rpb24odCxlLHIpe3QuZXhwb3J0cz1yKDk0KS5QYXNzVGhyb3VnaH0sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDYwKSxvPXIoMTIpLGE9cigzNikscz1bXS5qb2luLHU9aSE9T2JqZWN0LGM9YShcImpvaW5cIixcIixcIik7bih7dGFyZ2V0OlwiQXJyYXlcIixwcm90bzohMCxmb3JjZWQ6dXx8Y30se2pvaW46ZnVuY3Rpb24odCl7cmV0dXJuIHMuY2FsbChvKHRoaXMpLHZvaWQgMD09PXQ/XCIsXCI6dCl9fSl9LGZ1bmN0aW9uKHQsZSl7dC5leHBvcnRzPWZ1bmN0aW9uKHQpe3JldHVybi0xIT09RnVuY3Rpb24udG9TdHJpbmcuY2FsbCh0KS5pbmRleE9mKFwiW25hdGl2ZSBjb2RlXVwiKX19LGZ1bmN0aW9uKHQsZSxyKXt2YXIgbj1yKDgwKTtmdW5jdGlvbiBpKCl7aWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIFJlZmxlY3R8fCFSZWZsZWN0LmNvbnN0cnVjdClyZXR1cm4hMTtpZihSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKXJldHVybiExO2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIFByb3h5KXJldHVybiEwO3RyeXtyZXR1cm4gRGF0ZS5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChEYXRlLFtdLChmdW5jdGlvbigpe30pKSksITB9Y2F0Y2godCl7cmV0dXJuITF9fWZ1bmN0aW9uIG8oZSxyLGEpe3JldHVybiBpKCk/dC5leHBvcnRzPW89UmVmbGVjdC5jb25zdHJ1Y3Q6dC5leHBvcnRzPW89ZnVuY3Rpb24odCxlLHIpe3ZhciBpPVtudWxsXTtpLnB1c2guYXBwbHkoaSxlKTt2YXIgbz1uZXcoRnVuY3Rpb24uYmluZC5hcHBseSh0LGkpKTtyZXR1cm4gciYmbihvLHIucHJvdG90eXBlKSxvfSxvLmFwcGx5KG51bGwsYXJndW1lbnRzKX10LmV4cG9ydHM9b30sZnVuY3Rpb24odCxlLHIpe1widXNlIHN0cmljdFwiO3ZhciBuPXIoMiksaT1yKDY2KS5pbmRleE9mLG89cigzNiksYT1bXS5pbmRleE9mLHM9ISFhJiYxL1sxXS5pbmRleE9mKDEsLTApPDAsdT1vKFwiaW5kZXhPZlwiKTtuKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwLGZvcmNlZDpzfHx1fSx7aW5kZXhPZjpmdW5jdGlvbih0KXtyZXR1cm4gcz9hLmFwcGx5KHRoaXMsYXJndW1lbnRzKXx8MDppKHRoaXMsdCxhcmd1bWVudHMubGVuZ3RoPjE/YXJndW1lbnRzWzFdOnZvaWQgMCl9fSl9LGZ1bmN0aW9uKHQsZSxyKXtcInVzZSBzdHJpY3RcIjtyLnIoZSk7cig5OCkscigxNDkpLHIoMTUwKSxyKDUxKSxyKDUyKSxyKDM1KSxyKDc0KSxyKDc1KSxyKDc5KTt2YXIgbj1yKDApLGk9ci5uKG4pLG89KHIoMjgpLHIoMSkpLGE9ci5uKG8pLHM9cigxOCksdT1yLm4ocyksYz1yKDMwKSxmPXIubihjKSxsPXIoNDApLGg9ci5uKGwpLHA9cigxNiksZD1yLm4ocCksdj1yKDU3KSxnPXIubih2KSx5PXIoNDEpLGI9ci5uKHkpLF89KHIoODEpLHIoODQpLHIoODUpLHIoODYpLHIoMzcpLHIoODcpLHIoMTU3KSxyKDE1OCkscigxNTkpLHIoMTYxKSxyKDE2MikscigxMjQpLHIoMTYzKSxyKDE2NSkscigxMjYpLHIoMTI5KSxyKDg5KSxyKDkwKSxyKDQyKSksbT1yLm4oXyksdz1yKDkpLHg9ci5uKHcpLGs9cigxNDMpLEU9ci5uKGspLFM9cig1OCksaj1yLm4oUyksUj0ocigxNzQpLHIoMTMwKSxyKDEzMSkscigxNzYpLGZ1bmN0aW9uKHQpe2Zvcig7dC5lbmRzV2l0aChcIi9cIik7KXQ9dC5zbGljZSgwLC0xKTtyZXR1cm4gdH0pLEM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc3BsaXQoXCIvXCIpLHI9ZVswXSxuPTAsaT0xO2k8ZS5sZW5ndGgtMTtpKyspe249aSxcIlwiPT09ZVtpXSYmKHIrPVwiL1wiKTticmVha31yZXR1cm4gcj1yK1wiL1wiK2VbbisxXStcIi9cIn0sST1mdW5jdGlvbih0KXtyZXR1cm4odD1SKHQpKS5zdWJzdHJpbmcoMCx0Lmxhc3RJbmRleE9mKFwiL1wiKSsxKX0sTz1mdW5jdGlvbih0KXtyZXR1cm4odD1SKHQpKS5zdWJzdHIodC5sYXN0SW5kZXhPZihcIi9cIikrMSl9LFQ9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9YXJndW1lbnRzLmxlbmd0aCxlPW5ldyBBcnJheSh0KSxyPTA7cjx0O3IrKyllW3JdPWFyZ3VtZW50c1tyXTtyZXR1cm4gZS5ldmVyeSgoZnVuY3Rpb24odCl7cmV0dXJuIHQuZW5kc1dpdGgoXCIvXCIpfSkpfSxQPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1uZXcgQXJyYXkodCkscj0wO3I8dDtyKyspZVtyXT1hcmd1bWVudHNbcl07cmV0dXJuIGUuZXZlcnkoKGZ1bmN0aW9uKHQpe3JldHVybiF0LmVuZHNXaXRoKFwiL1wiKX0pKX0sQT17Q09OVEFJTkVSOic8aHR0cDovL3d3dy53My5vcmcvbnMvbGRwI0Jhc2ljQ29udGFpbmVyPjsgcmVsPVwidHlwZVwiJyxSRVNPVVJDRTonPGh0dHA6Ly93d3cudzMub3JnL25zL2xkcCNSZXNvdXJjZT47IHJlbD1cInR5cGVcIid9LEw9KHIoOTEpLHIoOTYpKSxGPXIubihMKSxNPXIoNik7Y29uc3R7cmRmOk4seHNkOkJ9PU0uYTt2YXIgRCxVLHE9MDtjbGFzcyBHe2NvbnN0cnVjdG9yKHQpe3RoaXMuaWQ9dH1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5pZH1lcXVhbHModCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBHP3RoaXMuaWQ9PT10LmlkOiEhdCYmdGhpcy50ZXJtVHlwZT09PXQudGVybVR5cGUmJnRoaXMudmFsdWU9PT10LnZhbHVlfXRvSlNPTigpe3JldHVybnt0ZXJtVHlwZTp0aGlzLnRlcm1UeXBlLHZhbHVlOnRoaXMudmFsdWV9fX1jbGFzcyBXIGV4dGVuZHMgR3tnZXQgdGVybVR5cGUoKXtyZXR1cm5cIk5hbWVkTm9kZVwifX1jbGFzcyB6IGV4dGVuZHMgR3tnZXQgdGVybVR5cGUoKXtyZXR1cm5cIkxpdGVyYWxcIn1nZXQgdmFsdWUoKXtyZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcoMSx0aGlzLmlkLmxhc3RJbmRleE9mKCdcIicpKX1nZXQgbGFuZ3VhZ2UoKXt2YXIgdD10aGlzLmlkLGU9dC5sYXN0SW5kZXhPZignXCInKSsxO3JldHVybiBlPHQubGVuZ3RoJiZcIkBcIj09PXRbZSsrXT90LnN1YnN0cihlKS50b0xvd2VyQ2FzZSgpOlwiXCJ9Z2V0IGRhdGF0eXBlKCl7cmV0dXJuIG5ldyBXKHRoaXMuZGF0YXR5cGVTdHJpbmcpfWdldCBkYXRhdHlwZVN0cmluZygpe3ZhciB0LGU9dGhpcy5pZCxyPWUubGFzdEluZGV4T2YoJ1wiJykrMTtyZXR1cm4gcjxlLmxlbmd0aCYmXCJeXCI9PT0odD1lW3JdKT9lLnN1YnN0cihyKzIpOlwiQFwiIT09dD9CLnN0cmluZzpOLmxhbmdTdHJpbmd9ZXF1YWxzKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygej90aGlzLmlkPT09dC5pZDohIXQmJiEhdC5kYXRhdHlwZSYmdGhpcy50ZXJtVHlwZT09PXQudGVybVR5cGUmJnRoaXMudmFsdWU9PT10LnZhbHVlJiZ0aGlzLmxhbmd1YWdlPT09dC5sYW5ndWFnZSYmdGhpcy5kYXRhdHlwZS52YWx1ZT09PXQuZGF0YXR5cGUudmFsdWV9dG9KU09OKCl7cmV0dXJue3Rlcm1UeXBlOnRoaXMudGVybVR5cGUsdmFsdWU6dGhpcy52YWx1ZSxsYW5ndWFnZTp0aGlzLmxhbmd1YWdlLGRhdGF0eXBlOnt0ZXJtVHlwZTpcIk5hbWVkTm9kZVwiLHZhbHVlOnRoaXMuZGF0YXR5cGVTdHJpbmd9fX19Y2xhc3MgWSBleHRlbmRzIEd7Y29uc3RydWN0b3IodCl7c3VwZXIoXCJfOlwiK3QpfWdldCB0ZXJtVHlwZSgpe3JldHVyblwiQmxhbmtOb2RlXCJ9Z2V0IHZhbHVlKCl7cmV0dXJuIHRoaXMuaWQuc3Vic3RyKDIpfX1jbGFzcyBRIGV4dGVuZHMgR3tjb25zdHJ1Y3Rvcih0KXtzdXBlcihcIj9cIit0KX1nZXQgdGVybVR5cGUoKXtyZXR1cm5cIlZhcmlhYmxlXCJ9Z2V0IHZhbHVlKCl7cmV0dXJuIHRoaXMuaWQuc3Vic3RyKDEpfX1jbGFzcyAkIGV4dGVuZHMgR3tjb25zdHJ1Y3Rvcigpe3JldHVybiBzdXBlcihcIlwiKSxVfHx0aGlzfWdldCB0ZXJtVHlwZSgpe3JldHVyblwiRGVmYXVsdEdyYXBoXCJ9ZXF1YWxzKHQpe3JldHVybiB0aGlzPT09dHx8ISF0JiZ0aGlzLnRlcm1UeXBlPT09dC50ZXJtVHlwZX19VT1uZXcgJDtjbGFzcyBIe2NvbnN0cnVjdG9yKHQsZSxyLG4pe3RoaXMuc3ViamVjdD10LHRoaXMucHJlZGljYXRlPWUsdGhpcy5vYmplY3Q9cix0aGlzLmdyYXBoPW58fFV9dG9KU09OKCl7cmV0dXJue3N1YmplY3Q6dGhpcy5zdWJqZWN0LnRvSlNPTigpLHByZWRpY2F0ZTp0aGlzLnByZWRpY2F0ZS50b0pTT04oKSxvYmplY3Q6dGhpcy5vYmplY3QudG9KU09OKCksZ3JhcGg6dGhpcy5ncmFwaC50b0pTT04oKX19ZXF1YWxzKHQpe3JldHVybiEhdCYmdGhpcy5zdWJqZWN0LmVxdWFscyh0LnN1YmplY3QpJiZ0aGlzLnByZWRpY2F0ZS5lcXVhbHModC5wcmVkaWNhdGUpJiZ0aGlzLm9iamVjdC5lcXVhbHModC5vYmplY3QpJiZ0aGlzLmdyYXBoLmVxdWFscyh0LmdyYXBoKX19dmFyIEs9RD17bmFtZWROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVyh0KX0sYmxhbmtOb2RlOmZ1bmN0aW9uKHQpe3R8fCh0PVwibjMtXCIrcSsrKTtyZXR1cm4gbmV3IFkodCl9LHZhcmlhYmxlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgUSh0KX0sbGl0ZXJhbDpmdW5jdGlvbih0LGUpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXJldHVybiBuZXcgeignXCInK3QrJ1wiQCcrZS50b0xvd2VyQ2FzZSgpKTtsZXQgcj1lP2UudmFsdWU6XCJcIjtcIlwiPT09ciYmKFwiYm9vbGVhblwiPT10eXBlb2YgdD9yPUIuYm9vbGVhbjpcIm51bWJlclwiPT10eXBlb2YgdCYmKE51bWJlci5pc0Zpbml0ZSh0KT9yPU51bWJlci5pc0ludGVnZXIodCk/Qi5pbnRlZ2VyOkIuZG91YmxlOihyPUIuZG91YmxlLE51bWJlci5pc05hTih0KXx8KHQ9dD4wP1wiSU5GXCI6XCItSU5GXCIpKSkpO3JldHVyblwiXCI9PT1yfHxyPT09Qi5zdHJpbmc/bmV3IHooJ1wiJyt0KydcIicpOm5ldyB6KCdcIicrdCsnXCJeXicrcil9LGRlZmF1bHRHcmFwaDpmdW5jdGlvbigpe3JldHVybiBVfSxxdWFkOlYsdHJpcGxlOlYsaW50ZXJuYWw6e1Rlcm06RyxOYW1lZE5vZGU6VyxCbGFua05vZGU6WSxWYXJpYWJsZTpRLExpdGVyYWw6eixEZWZhdWx0R3JhcGg6JCxRdWFkOkgsVHJpcGxlOkgsZnJvbUlkOmZ1bmN0aW9uKHQsZSl7aWYoZT1lfHxELCF0KXJldHVybiBlLmRlZmF1bHRHcmFwaCgpO3N3aXRjaCh0WzBdKXtjYXNlXCJfXCI6cmV0dXJuIGUuYmxhbmtOb2RlKHQuc3Vic3RyKDIpKTtjYXNlXCI/XCI6cmV0dXJuIGUudmFyaWFibGUodC5zdWJzdHIoMSkpO2Nhc2UnXCInOmlmKGU9PT1EKXJldHVybiBuZXcgeih0KTtpZignXCInPT09dFt0Lmxlbmd0aC0xXSlyZXR1cm4gZS5saXRlcmFsKHQuc3Vic3RyKDEsdC5sZW5ndGgtMikpO3ZhciByPXQubGFzdEluZGV4T2YoJ1wiJyx0Lmxlbmd0aC0xKTtyZXR1cm4gZS5saXRlcmFsKHQuc3Vic3RyKDEsci0xKSxcIkBcIj09PXRbcisxXT90LnN1YnN0cihyKzIpOmUubmFtZWROb2RlKHQuc3Vic3RyKHIrMykpKTtkZWZhdWx0OnJldHVybiBlLm5hbWVkTm9kZSh0KX19LHRvSWQ6ZnVuY3Rpb24odCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpcmV0dXJuIHQ7aWYodCBpbnN0YW5jZW9mIEcpcmV0dXJuIHQuaWQ7aWYoIXQpcmV0dXJuIFUuaWQ7c3dpdGNoKHQudGVybVR5cGUpe2Nhc2VcIk5hbWVkTm9kZVwiOnJldHVybiB0LnZhbHVlO2Nhc2VcIkJsYW5rTm9kZVwiOnJldHVyblwiXzpcIit0LnZhbHVlO2Nhc2VcIlZhcmlhYmxlXCI6cmV0dXJuXCI/XCIrdC52YWx1ZTtjYXNlXCJEZWZhdWx0R3JhcGhcIjpyZXR1cm5cIlwiO2Nhc2VcIkxpdGVyYWxcIjpyZXR1cm4nXCInK3QudmFsdWUrJ1wiJysodC5sYW5ndWFnZT9cIkBcIit0Lmxhbmd1YWdlOnQuZGF0YXR5cGUmJnQuZGF0YXR5cGUudmFsdWUhPT1CLnN0cmluZz9cIl5eXCIrdC5kYXRhdHlwZS52YWx1ZTpcIlwiKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdGVybVR5cGU6IFwiK3QudGVybVR5cGUpfX19fTtmdW5jdGlvbiBWKHQsZSxyLG4pe3JldHVybiBuZXcgSCh0LGUscixuKX12YXIgWj1yKDE0NSksSj0wLFg9MDtjbGFzcyB0dHtjb25zdHJ1Y3Rvcih0KXt0aGlzLl9jb250ZXh0U3RhY2s9W10sdGhpcy5fZ3JhcGg9bnVsbCx0PXR8fHt9LHRoaXMuX3NldEJhc2UodC5iYXNlSVJJKSx0LmZhY3RvcnkmJnJ0KHRoaXMsdC5mYWN0b3J5KTt2YXIgZT1cInN0cmluZ1wiPT10eXBlb2YgdC5mb3JtYXQ/dC5mb3JtYXQubWF0Y2goL1xcdyokLylbMF0udG9Mb3dlckNhc2UoKTpcIlwiLHI9XCJ0dXJ0bGVcIj09PWUsbj1cInRyaWdcIj09PWUsaT0vdHJpcGxlLy50ZXN0KGUpLG89L3F1YWQvLnRlc3QoZSksYT10aGlzLl9uM01vZGU9L24zLy50ZXN0KGUpLHM9aXx8bzsodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocz0hKHJ8fGEpKXx8KHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGg9dGhpcy5fcmVhZFByZWRpY2F0ZSksdGhpcy5fc3VwcG9ydHNRdWFkcz0hKHJ8fG58fGl8fGEpLHMmJih0aGlzLl9yZXNvbHZlUmVsYXRpdmVJUkk9ZnVuY3Rpb24odCl7cmV0dXJuIG51bGx9KSx0aGlzLl9ibGFua05vZGVQcmVmaXg9XCJzdHJpbmdcIiE9dHlwZW9mIHQuYmxhbmtOb2RlUHJlZml4P1wiXCI6dC5ibGFua05vZGVQcmVmaXgucmVwbGFjZSgvXig/IV86KS8sXCJfOlwiKSx0aGlzLl9sZXhlcj10LmxleGVyfHxuZXcgWi5hKHtsaW5lTW9kZTpzLG4zOmF9KSx0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzPSEhdC5leHBsaWNpdFF1YW50aWZpZXJzfXN0YXRpYyBfcmVzZXRCbGFua05vZGVJZHMoKXtKPVg9MH1fYmxhbmsoKXtyZXR1cm4gdGhpcy5fYmxhbmtOb2RlKFwiYlwiK1grKyl9X3NldEJhc2UodCl7aWYodCl7dmFyIGU9dC5pbmRleE9mKFwiI1wiKTtlPj0wJiYodD10LnN1YnN0cigwLGUpKSx0aGlzLl9iYXNlPXQsdGhpcy5fYmFzZVBhdGg9dC5pbmRleE9mKFwiL1wiKTwwP3Q6dC5yZXBsYWNlKC9bXlxcLz9dKig/OlxcPy4qKT8kLyxcIlwiKSx0PXQubWF0Y2goL14oPzooW2Etel1bYS16MC05Ky4tXSo6KSk/KD86XFwvXFwvW15cXC9dKik/L2kpLHRoaXMuX2Jhc2VSb290PXRbMF0sdGhpcy5fYmFzZVNjaGVtZT10WzFdfWVsc2UgdGhpcy5fYmFzZT1cIlwiLHRoaXMuX2Jhc2VQYXRoPVwiXCJ9X3NhdmVDb250ZXh0KHQsZSxyLG4saSl7dmFyIG89dGhpcy5fbjNNb2RlO3RoaXMuX2NvbnRleHRTdGFjay5wdXNoKHtzdWJqZWN0OnIscHJlZGljYXRlOm4sb2JqZWN0OmksZ3JhcGg6ZSx0eXBlOnQsaW52ZXJzZTohIW8mJnRoaXMuX2ludmVyc2VQcmVkaWNhdGUsYmxhbmtQcmVmaXg6bz90aGlzLl9wcmVmaXhlcy5fOlwiXCIscXVhbnRpZmllZDpvP3RoaXMuX3F1YW50aWZpZWQ6bnVsbH0pLG8mJih0aGlzLl9pbnZlcnNlUHJlZGljYXRlPSExLHRoaXMuX3ByZWZpeGVzLl89dGhpcy5fZ3JhcGg/dGhpcy5fZ3JhcGguaWQuc3Vic3RyKDIpK1wiLlwiOlwiLlwiLHRoaXMuX3F1YW50aWZpZWQ9T2JqZWN0LmNyZWF0ZSh0aGlzLl9xdWFudGlmaWVkKSl9X3Jlc3RvcmVDb250ZXh0KCl7dmFyIHQ9dGhpcy5fY29udGV4dFN0YWNrLnBvcCgpLGU9dGhpcy5fbjNNb2RlO3RoaXMuX3N1YmplY3Q9dC5zdWJqZWN0LHRoaXMuX3ByZWRpY2F0ZT10LnByZWRpY2F0ZSx0aGlzLl9vYmplY3Q9dC5vYmplY3QsdGhpcy5fZ3JhcGg9dC5ncmFwaCxlJiYodGhpcy5faW52ZXJzZVByZWRpY2F0ZT10LmludmVyc2UsdGhpcy5fcHJlZml4ZXMuXz10LmJsYW5rUHJlZml4LHRoaXMuX3F1YW50aWZpZWQ9dC5xdWFudGlmaWVkKX1fcmVhZEluVG9wQ29udGV4dCh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJlb2ZcIjpyZXR1cm4gbnVsbCE9PXRoaXMuX2dyYXBoP3RoaXMuX2Vycm9yKFwiVW5jbG9zZWQgZ3JhcGhcIix0KTooZGVsZXRlIHRoaXMuX3ByZWZpeGVzLl8sdGhpcy5fY2FsbGJhY2sobnVsbCxudWxsLHRoaXMuX3ByZWZpeGVzKSk7Y2FzZVwiUFJFRklYXCI6dGhpcy5fc3BhcnFsU3R5bGU9ITA7Y2FzZVwiQHByZWZpeFwiOnJldHVybiB0aGlzLl9yZWFkUHJlZml4O2Nhc2VcIkJBU0VcIjp0aGlzLl9zcGFycWxTdHlsZT0hMDtjYXNlXCJAYmFzZVwiOnJldHVybiB0aGlzLl9yZWFkQmFzZUlSSTtjYXNlXCJ7XCI6aWYodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocylyZXR1cm4gdGhpcy5fZ3JhcGg9XCJcIix0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcmVhZFN1YmplY3Q7Y2FzZVwiR1JBUEhcIjppZih0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzKXJldHVybiB0aGlzLl9yZWFkTmFtZWRHcmFwaExhYmVsO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0KHQpfX1fcmVhZEVudGl0eSh0LGUpe3ZhciByO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcInR5cGVJUklcIjp2YXIgbj10aGlzLl9yZXNvbHZlSVJJKHQudmFsdWUpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLl9lcnJvcihcIkludmFsaWQgSVJJXCIsdCk7cj10aGlzLl9uYW1lZE5vZGUobik7YnJlYWs7Y2FzZVwidHlwZVwiOmNhc2VcInByZWZpeGVkXCI6dmFyIGk9dGhpcy5fcHJlZml4ZXNbdC5wcmVmaXhdO2lmKHZvaWQgMD09PWkpcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmRlZmluZWQgcHJlZml4IFwiJyt0LnByZWZpeCsnOlwiJyx0KTtyPXRoaXMuX25hbWVkTm9kZShpK3QudmFsdWUpO2JyZWFrO2Nhc2VcImJsYW5rXCI6cj10aGlzLl9ibGFua05vZGUodGhpcy5fcHJlZml4ZXNbdC5wcmVmaXhdK3QudmFsdWUpO2JyZWFrO2Nhc2VcInZhclwiOnI9dGhpcy5fdmFyaWFibGUodC52YWx1ZS5zdWJzdHIoMSkpO2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgZW50aXR5IGJ1dCBnb3QgXCIrdC50eXBlLHQpfXJldHVybiFlJiZ0aGlzLl9uM01vZGUmJnIuaWQgaW4gdGhpcy5fcXVhbnRpZmllZCYmKHI9dGhpcy5fcXVhbnRpZmllZFtyLmlkXSkscn1fcmVhZFN1YmplY3QodCl7c3dpdGNoKHRoaXMuX3ByZWRpY2F0ZT1udWxsLHQudHlwZSl7Y2FzZVwiW1wiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdD10aGlzLl9ibGFuaygpLG51bGwsbnVsbCksdGhpcy5fcmVhZEJsYW5rTm9kZUhlYWQ7Y2FzZVwiKFwiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImxpc3RcIix0aGlzLl9ncmFwaCx0aGlzLlJERl9OSUwsbnVsbCxudWxsKSx0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcmVhZExpc3RJdGVtO2Nhc2VcIntcIjpyZXR1cm4gdGhpcy5fbjNNb2RlPyh0aGlzLl9zYXZlQ29udGV4dChcImZvcm11bGFcIix0aGlzLl9ncmFwaCx0aGlzLl9ncmFwaD10aGlzLl9ibGFuaygpLG51bGwsbnVsbCksdGhpcy5fcmVhZFN1YmplY3QpOnRoaXMuX2Vycm9yKFwiVW5leHBlY3RlZCBncmFwaFwiLHQpO2Nhc2VcIn1cIjpyZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uKHQpO2Nhc2VcIkBmb3JTb21lXCI6cmV0dXJuIHRoaXMuX24zTW9kZT8odGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3ByZWRpY2F0ZT10aGlzLk4zX0ZPUlNPTUUsdGhpcy5fcXVhbnRpZmllcj10aGlzLl9ibGFua05vZGUsdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0KTp0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JTb21lXCInLHQpO2Nhc2VcIkBmb3JBbGxcIjpyZXR1cm4gdGhpcy5fbjNNb2RlPyh0aGlzLl9zdWJqZWN0PW51bGwsdGhpcy5fcHJlZGljYXRlPXRoaXMuTjNfRk9SQUxMLHRoaXMuX3F1YW50aWZpZXI9dGhpcy5fdmFyaWFibGUsdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0KTp0aGlzLl9lcnJvcignVW5leHBlY3RlZCBcIkBmb3JBbGxcIicsdCk7ZGVmYXVsdDppZih2b2lkIDA9PT0odGhpcy5fc3ViamVjdD10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm47aWYodGhpcy5fbjNNb2RlKXJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGgpfXJldHVybiB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBofV9yZWFkUHJlZGljYXRlKHQpe3ZhciBlPXQudHlwZTtzd2l0Y2goZSl7Y2FzZVwiaW52ZXJzZVwiOnRoaXMuX2ludmVyc2VQcmVkaWNhdGU9ITA7Y2FzZVwiYWJicmV2aWF0aW9uXCI6dGhpcy5fcHJlZGljYXRlPXRoaXMuQUJCUkVWSUFUSU9OU1t0LnZhbHVlXTticmVhaztjYXNlXCIuXCI6Y2FzZVwiXVwiOmNhc2VcIn1cIjpyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT90aGlzLl9lcnJvcihcIlVuZXhwZWN0ZWQgXCIrZSx0KToodGhpcy5fc3ViamVjdD1udWxsLFwiXVwiPT09ZT90aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0KTp0aGlzLl9yZWFkUHVuY3R1YXRpb24odCkpO2Nhc2VcIjtcIjpyZXR1cm4gbnVsbCE9PXRoaXMuX3ByZWRpY2F0ZT90aGlzLl9yZWFkUHJlZGljYXRlOnRoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgcHJlZGljYXRlIGJ1dCBnb3QgO1wiLHQpO2Nhc2VcImJsYW5rXCI6aWYoIXRoaXMuX24zTW9kZSlyZXR1cm4gdGhpcy5fZXJyb3IoXCJEaXNhbGxvd2VkIGJsYW5rIG5vZGUgYXMgcHJlZGljYXRlXCIsdCk7ZGVmYXVsdDppZih2b2lkIDA9PT0odGhpcy5fcHJlZGljYXRlPXRoaXMuX3JlYWRFbnRpdHkodCkpKXJldHVybn1yZXR1cm4gdGhpcy5fcmVhZE9iamVjdH1fcmVhZE9iamVjdCh0KXtzd2l0Y2godC50eXBlKXtjYXNlXCJsaXRlcmFsXCI6aWYoMD09PXQucHJlZml4Lmxlbmd0aClyZXR1cm4gdGhpcy5fbGl0ZXJhbFZhbHVlPXQudmFsdWUsdGhpcy5fcmVhZERhdGFUeXBlT3JMYW5nO3RoaXMuX29iamVjdD10aGlzLl9saXRlcmFsKHQudmFsdWUsdGhpcy5fbmFtZWROb2RlKHQucHJlZml4KSk7YnJlYWs7Y2FzZVwiW1wiOnJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdCx0aGlzLl9wcmVkaWNhdGUsdGhpcy5fc3ViamVjdD10aGlzLl9ibGFuaygpKSx0aGlzLl9yZWFkQmxhbmtOb2RlSGVhZDtjYXNlXCIoXCI6cmV0dXJuIHRoaXMuX3NhdmVDb250ZXh0KFwibGlzdFwiLHRoaXMuX2dyYXBoLHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuUkRGX05JTCksdGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3JlYWRMaXN0SXRlbTtjYXNlXCJ7XCI6cmV0dXJuIHRoaXMuX24zTW9kZT8odGhpcy5fc2F2ZUNvbnRleHQoXCJmb3JtdWxhXCIsdGhpcy5fZ3JhcGgsdGhpcy5fc3ViamVjdCx0aGlzLl9wcmVkaWNhdGUsdGhpcy5fZ3JhcGg9dGhpcy5fYmxhbmsoKSksdGhpcy5fcmVhZFN1YmplY3QpOnRoaXMuX2Vycm9yKFwiVW5leHBlY3RlZCBncmFwaFwiLHQpO2RlZmF1bHQ6aWYodm9pZCAwPT09KHRoaXMuX29iamVjdD10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm47aWYodGhpcy5fbjNNb2RlKXJldHVybiB0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKSl9cmV0dXJuIHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKX1fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaCh0KXtyZXR1cm5cIntcIj09PXQudHlwZT90aGlzLl9yZWFkR3JhcGgodCk6dGhpcy5fcmVhZFByZWRpY2F0ZSh0KX1fcmVhZEdyYXBoKHQpe3JldHVyblwie1wiIT09dC50eXBlP3RoaXMuX2Vycm9yKFwiRXhwZWN0ZWQgZ3JhcGggYnV0IGdvdCBcIit0LnR5cGUsdCk6KHRoaXMuX2dyYXBoPXRoaXMuX3N1YmplY3QsdGhpcy5fc3ViamVjdD1udWxsLHRoaXMuX3JlYWRTdWJqZWN0KX1fcmVhZEJsYW5rTm9kZUhlYWQodCl7cmV0dXJuXCJdXCI9PT10LnR5cGU/KHRoaXMuX3N1YmplY3Q9bnVsbCx0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0KSk6KHRoaXMuX3ByZWRpY2F0ZT1udWxsLHRoaXMuX3JlYWRQcmVkaWNhdGUodCkpfV9yZWFkQmxhbmtOb2RlVGFpbCh0KXtpZihcIl1cIiE9PXQudHlwZSlyZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uKHQpO251bGwhPT10aGlzLl9zdWJqZWN0JiZ0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCk7dmFyIGU9bnVsbD09PXRoaXMuX3ByZWRpY2F0ZTtyZXR1cm4gdGhpcy5fcmVzdG9yZUNvbnRleHQoKSxudWxsPT09dGhpcy5fb2JqZWN0P2U/dGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaDp0aGlzLl9yZWFkUHJlZGljYXRlQWZ0ZXJCbGFuazp0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCl9X3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIi5cIjpjYXNlXCJ9XCI6cmV0dXJuIHRoaXMuX3N1YmplY3Q9bnVsbCx0aGlzLl9yZWFkUHVuY3R1YXRpb24odCk7ZGVmYXVsdDpyZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZSh0KX19X3JlYWRMaXN0SXRlbSh0KXt2YXIgZT1udWxsLHI9bnVsbCxuPXRoaXMuX3N1YmplY3QsaT10aGlzLl9jb250ZXh0U3RhY2ssbz1pW2kubGVuZ3RoLTFdLGE9dGhpcy5fcmVhZExpc3RJdGVtO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIltcIjp0aGlzLl9zYXZlQ29udGV4dChcImJsYW5rXCIsdGhpcy5fZ3JhcGgscj10aGlzLl9ibGFuaygpLHRoaXMuUkRGX0ZJUlNULHRoaXMuX3N1YmplY3Q9ZT10aGlzLl9ibGFuaygpKSxhPXRoaXMuX3JlYWRCbGFua05vZGVIZWFkO2JyZWFrO2Nhc2VcIihcIjp0aGlzLl9zYXZlQ29udGV4dChcImxpc3RcIix0aGlzLl9ncmFwaCxyPXRoaXMuX2JsYW5rKCksdGhpcy5SREZfRklSU1QsdGhpcy5SREZfTklMKSx0aGlzLl9zdWJqZWN0PW51bGw7YnJlYWs7Y2FzZVwiKVwiOmlmKHRoaXMuX3Jlc3RvcmVDb250ZXh0KCksMCE9PWkubGVuZ3RoJiZcImxpc3RcIj09PWlbaS5sZW5ndGgtMV0udHlwZSYmdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuX3ByZWRpY2F0ZSx0aGlzLl9vYmplY3QsdGhpcy5fZ3JhcGgpLG51bGw9PT10aGlzLl9wcmVkaWNhdGUpe2lmKGE9dGhpcy5fcmVhZFByZWRpY2F0ZSx0aGlzLl9zdWJqZWN0PT09dGhpcy5SREZfTklMKXJldHVybiBhfWVsc2UgaWYoYT10aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCksdGhpcy5fb2JqZWN0PT09dGhpcy5SREZfTklMKXJldHVybiBhO3I9dGhpcy5SREZfTklMO2JyZWFrO2Nhc2VcImxpdGVyYWxcIjowPT09dC5wcmVmaXgubGVuZ3RoPyh0aGlzLl9saXRlcmFsVmFsdWU9dC52YWx1ZSxhPXRoaXMuX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nKTooZT10aGlzLl9saXRlcmFsKHQudmFsdWUsdGhpcy5fbmFtZWROb2RlKHQucHJlZml4KSksYT10aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCkpO2JyZWFrO2RlZmF1bHQ6aWYodm9pZCAwPT09KGU9dGhpcy5fcmVhZEVudGl0eSh0KSkpcmV0dXJufWlmKG51bGw9PT1yJiYodGhpcy5fc3ViamVjdD1yPXRoaXMuX2JsYW5rKCkpLG51bGw9PT1uP251bGw9PT1vLnByZWRpY2F0ZT9vLnN1YmplY3Q9cjpvLm9iamVjdD1yOnRoaXMuX2VtaXQobix0aGlzLlJERl9SRVNULHIsdGhpcy5fZ3JhcGgpLG51bGwhPT1lKXtpZih0aGlzLl9uM01vZGUmJihcIklSSVwiPT09dC50eXBlfHxcInByZWZpeGVkXCI9PT10LnR5cGUpKXJldHVybiB0aGlzLl9zYXZlQ29udGV4dChcIml0ZW1cIix0aGlzLl9ncmFwaCxyLHRoaXMuUkRGX0ZJUlNULGUpLHRoaXMuX3N1YmplY3Q9ZSx0aGlzLl9wcmVkaWNhdGU9bnVsbCx0aGlzLl9nZXRQYXRoUmVhZGVyKHRoaXMuX3JlYWRMaXN0SXRlbSk7dGhpcy5fZW1pdChyLHRoaXMuUkRGX0ZJUlNULGUsdGhpcy5fZ3JhcGgpfXJldHVybiBhfV9yZWFkRGF0YVR5cGVPckxhbmcodCl7cmV0dXJuIHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0LCExKX1fcmVhZExpc3RJdGVtRGF0YVR5cGVPckxhbmcodCl7cmV0dXJuIHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0LCEwKX1fY29tcGxldGVMaXRlcmFsKHQsZSl7c3dpdGNoKHQudHlwZSl7Y2FzZVwidHlwZVwiOmNhc2VcInR5cGVJUklcIjp2YXIgcj10aGlzLl9yZWFkRW50aXR5KHQpO2lmKHZvaWQgMD09PXIpcmV0dXJuO3RoaXMuX29iamVjdD10aGlzLl9saXRlcmFsKHRoaXMuX2xpdGVyYWxWYWx1ZSxyKSx0PW51bGw7YnJlYWs7Y2FzZVwibGFuZ2NvZGVcIjp0aGlzLl9vYmplY3Q9dGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUsdC52YWx1ZSksdD1udWxsO2JyZWFrO2RlZmF1bHQ6dGhpcy5fb2JqZWN0PXRoaXMuX2xpdGVyYWwodGhpcy5fbGl0ZXJhbFZhbHVlKX1yZXR1cm4gZSYmdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX0ZJUlNULHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksbnVsbD09PXQ/dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpOih0aGlzLl9yZWFkQ2FsbGJhY2s9dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpLHRoaXMuX3JlYWRDYWxsYmFjayh0KSl9X3JlYWRGb3JtdWxhVGFpbCh0KXtyZXR1cm5cIn1cIiE9PXQudHlwZT90aGlzLl9yZWFkUHVuY3R1YXRpb24odCk6KG51bGwhPT10aGlzLl9zdWJqZWN0JiZ0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksdGhpcy5fcmVzdG9yZUNvbnRleHQoKSxudWxsPT09dGhpcy5fb2JqZWN0P3RoaXMuX3JlYWRQcmVkaWNhdGU6dGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpKX1fcmVhZFB1bmN0dWF0aW9uKHQpe3ZhciBlLHI9dGhpcy5fc3ViamVjdCxuPXRoaXMuX2dyYXBoLGk9dGhpcy5faW52ZXJzZVByZWRpY2F0ZTtzd2l0Y2godC50eXBlKXtjYXNlXCJ9XCI6aWYobnVsbD09PXRoaXMuX2dyYXBoKXJldHVybiB0aGlzLl9lcnJvcihcIlVuZXhwZWN0ZWQgZ3JhcGggY2xvc2luZ1wiLHQpO2lmKHRoaXMuX24zTW9kZSlyZXR1cm4gdGhpcy5fcmVhZEZvcm11bGFUYWlsKHQpO3RoaXMuX2dyYXBoPW51bGw7Y2FzZVwiLlwiOnRoaXMuX3N1YmplY3Q9bnVsbCxlPXRoaXMuX2NvbnRleHRTdGFjay5sZW5ndGg/dGhpcy5fcmVhZFN1YmplY3Q6dGhpcy5fcmVhZEluVG9wQ29udGV4dCxpJiYodGhpcy5faW52ZXJzZVByZWRpY2F0ZT0hMSk7YnJlYWs7Y2FzZVwiO1wiOmU9dGhpcy5fcmVhZFByZWRpY2F0ZTticmVhaztjYXNlXCIsXCI6ZT10aGlzLl9yZWFkT2JqZWN0O2JyZWFrO2RlZmF1bHQ6aWYodGhpcy5fc3VwcG9ydHNRdWFkcyYmbnVsbD09PXRoaXMuX2dyYXBoJiZ2b2lkIDAhPT0obj10aGlzLl9yZWFkRW50aXR5KHQpKSl7ZT10aGlzLl9yZWFkUXVhZFB1bmN0dWF0aW9uO2JyZWFrfXJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHVuY3R1YXRpb24gdG8gZm9sbG93IFwiJyt0aGlzLl9vYmplY3QuaWQrJ1wiJyx0KX1pZihudWxsIT09cil7dmFyIG89dGhpcy5fcHJlZGljYXRlLGE9dGhpcy5fb2JqZWN0O2k/dGhpcy5fZW1pdChhLG8scixuKTp0aGlzLl9lbWl0KHIsbyxhLG4pfXJldHVybiBlfV9yZWFkQmxhbmtOb2RlUHVuY3R1YXRpb24odCl7dmFyIGU7c3dpdGNoKHQudHlwZSl7Y2FzZVwiO1wiOmU9dGhpcy5fcmVhZFByZWRpY2F0ZTticmVhaztjYXNlXCIsXCI6ZT10aGlzLl9yZWFkT2JqZWN0O2JyZWFrO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwdW5jdHVhdGlvbiB0byBmb2xsb3cgXCInK3RoaXMuX29iamVjdC5pZCsnXCInLHQpfXJldHVybiB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5fcHJlZGljYXRlLHRoaXMuX29iamVjdCx0aGlzLl9ncmFwaCksZX1fcmVhZFF1YWRQdW5jdHVhdGlvbih0KXtyZXR1cm5cIi5cIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIGRvdCB0byBmb2xsb3cgcXVhZFwiLHQpOnRoaXMuX3JlYWRJblRvcENvbnRleHR9X3JlYWRQcmVmaXgodCl7cmV0dXJuXCJwcmVmaXhcIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIHByZWZpeCB0byBmb2xsb3cgQHByZWZpeFwiLHQpOih0aGlzLl9wcmVmaXg9dC52YWx1ZSx0aGlzLl9yZWFkUHJlZml4SVJJKX1fcmVhZFByZWZpeElSSSh0KXtpZihcIklSSVwiIT09dC50eXBlKXJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgSVJJIHRvIGZvbGxvdyBwcmVmaXggXCInK3RoaXMuX3ByZWZpeCsnOlwiJyx0KTt2YXIgZT10aGlzLl9yZWFkRW50aXR5KHQpO3JldHVybiB0aGlzLl9wcmVmaXhlc1t0aGlzLl9wcmVmaXhdPWUudmFsdWUsdGhpcy5fcHJlZml4Q2FsbGJhY2sodGhpcy5fcHJlZml4LGUpLHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9ufV9yZWFkQmFzZUlSSSh0KXt2YXIgZT1cIklSSVwiPT09dC50eXBlJiZ0aGlzLl9yZXNvbHZlSVJJKHQudmFsdWUpO3JldHVybiBlPyh0aGlzLl9zZXRCYXNlKGUpLHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uKTp0aGlzLl9lcnJvcihcIkV4cGVjdGVkIHZhbGlkIElSSSB0byBmb2xsb3cgYmFzZSBkZWNsYXJhdGlvblwiLHQpfV9yZWFkTmFtZWRHcmFwaExhYmVsKHQpe3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcImJsYW5rXCI6Y2FzZVwicHJlZml4ZWRcIjpyZXR1cm4gdGhpcy5fcmVhZFN1YmplY3QodCksdGhpcy5fcmVhZEdyYXBoO2Nhc2VcIltcIjpyZXR1cm4gdGhpcy5fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsO2RlZmF1bHQ6cmV0dXJuIHRoaXMuX2Vycm9yKFwiSW52YWxpZCBncmFwaCBsYWJlbFwiLHQpfX1fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsKHQpe3JldHVyblwiXVwiIT09dC50eXBlP3RoaXMuX2Vycm9yKFwiSW52YWxpZCBncmFwaCBsYWJlbFwiLHQpOih0aGlzLl9zdWJqZWN0PXRoaXMuX2JsYW5rKCksdGhpcy5fcmVhZEdyYXBoKX1fcmVhZERlY2xhcmF0aW9uUHVuY3R1YXRpb24odCl7cmV0dXJuIHRoaXMuX3NwYXJxbFN0eWxlPyh0aGlzLl9zcGFycWxTdHlsZT0hMSx0aGlzLl9yZWFkSW5Ub3BDb250ZXh0KHQpKTpcIi5cIiE9PXQudHlwZT90aGlzLl9lcnJvcihcIkV4cGVjdGVkIGRlY2xhcmF0aW9uIHRvIGVuZCB3aXRoIGEgZG90XCIsdCk6dGhpcy5fcmVhZEluVG9wQ29udGV4dH1fcmVhZFF1YW50aWZpZXJMaXN0KHQpe3ZhciBlO3N3aXRjaCh0LnR5cGUpe2Nhc2VcIklSSVwiOmNhc2VcInByZWZpeGVkXCI6aWYodm9pZCAwIT09KGU9dGhpcy5fcmVhZEVudGl0eSh0LCEwKSkpYnJlYWs7ZGVmYXVsdDpyZXR1cm4gdGhpcy5fZXJyb3IoXCJVbmV4cGVjdGVkIFwiK3QudHlwZSx0KX1yZXR1cm4gdGhpcy5fZXhwbGljaXRRdWFudGlmaWVycz8obnVsbD09PXRoaXMuX3N1YmplY3Q/dGhpcy5fZW1pdCh0aGlzLl9ncmFwaHx8dGhpcy5ERUZBVUxUR1JBUEgsdGhpcy5fcHJlZGljYXRlLHRoaXMuX3N1YmplY3Q9dGhpcy5fYmxhbmsoKSx0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTp0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5SREZfUkVTVCx0aGlzLl9zdWJqZWN0PXRoaXMuX2JsYW5rKCksdGhpcy5RVUFOVElGSUVSU19HUkFQSCksdGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX0ZJUlNULGUsdGhpcy5RVUFOVElGSUVSU19HUkFQSCkpOnRoaXMuX3F1YW50aWZpZWRbZS5pZF09dGhpcy5fcXVhbnRpZmllcihcImJcIitYKyspLHRoaXMuX3JlYWRRdWFudGlmaWVyUHVuY3R1YXRpb259X3JlYWRRdWFudGlmaWVyUHVuY3R1YXRpb24odCl7cmV0dXJuXCIsXCI9PT10LnR5cGU/dGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0Oih0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzJiYodGhpcy5fZW1pdCh0aGlzLl9zdWJqZWN0LHRoaXMuUkRGX1JFU1QsdGhpcy5SREZfTklMLHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpLHRoaXMuX3N1YmplY3Q9bnVsbCksdGhpcy5fcmVhZENhbGxiYWNrPXRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKSx0aGlzLl9yZWFkQ2FsbGJhY2sodCkpfV9nZXRQYXRoUmVhZGVyKHQpe3JldHVybiB0aGlzLl9hZnRlclBhdGg9dCx0aGlzLl9yZWFkUGF0aH1fcmVhZFBhdGgodCl7c3dpdGNoKHQudHlwZSl7Y2FzZVwiIVwiOnJldHVybiB0aGlzLl9yZWFkRm9yd2FyZFBhdGg7Y2FzZVwiXlwiOnJldHVybiB0aGlzLl9yZWFkQmFja3dhcmRQYXRoO2RlZmF1bHQ6dmFyIGU9dGhpcy5fY29udGV4dFN0YWNrLHI9ZS5sZW5ndGgmJmVbZS5sZW5ndGgtMV07aWYociYmXCJpdGVtXCI9PT1yLnR5cGUpe3ZhciBuPXRoaXMuX3N1YmplY3Q7dGhpcy5fcmVzdG9yZUNvbnRleHQoKSx0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsdGhpcy5SREZfRklSU1Qsbix0aGlzLl9ncmFwaCl9cmV0dXJuIHRoaXMuX2FmdGVyUGF0aCh0KX19X3JlYWRGb3J3YXJkUGF0aCh0KXt2YXIgZSxyLG49dGhpcy5fYmxhbmsoKTtpZih2b2lkIDAhPT0ocj10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT8oZT10aGlzLl9zdWJqZWN0LHRoaXMuX3N1YmplY3Q9bik6KGU9dGhpcy5fb2JqZWN0LHRoaXMuX29iamVjdD1uKSx0aGlzLl9lbWl0KGUscixuLHRoaXMuX2dyYXBoKSx0aGlzLl9yZWFkUGF0aH1fcmVhZEJhY2t3YXJkUGF0aCh0KXt2YXIgZSxyLG49dGhpcy5fYmxhbmsoKTtpZih2b2lkIDAhPT0oZT10aGlzLl9yZWFkRW50aXR5KHQpKSlyZXR1cm4gbnVsbD09PXRoaXMuX3ByZWRpY2F0ZT8ocj10aGlzLl9zdWJqZWN0LHRoaXMuX3N1YmplY3Q9bik6KHI9dGhpcy5fb2JqZWN0LHRoaXMuX29iamVjdD1uKSx0aGlzLl9lbWl0KG4sZSxyLHRoaXMuX2dyYXBoKSx0aGlzLl9yZWFkUGF0aH1fZ2V0Q29udGV4dEVuZFJlYWRlcigpe3ZhciB0PXRoaXMuX2NvbnRleHRTdGFjaztpZighdC5sZW5ndGgpcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbjtzd2l0Y2godFt0Lmxlbmd0aC0xXS50eXBlKXtjYXNlXCJibGFua1wiOnJldHVybiB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbDtjYXNlXCJsaXN0XCI6cmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtjYXNlXCJmb3JtdWxhXCI6cmV0dXJuIHRoaXMuX3JlYWRGb3JtdWxhVGFpbH19X2VtaXQodCxlLHIsbil7dGhpcy5fY2FsbGJhY2sobnVsbCx0aGlzLl9xdWFkKHQsZSxyLG58fHRoaXMuREVGQVVMVEdSQVBIKSl9X2Vycm9yKHQsZSl7dmFyIHI9bmV3IEVycm9yKHQrXCIgb24gbGluZSBcIitlLmxpbmUrXCIuXCIpO3IuY29udGV4dD17dG9rZW46ZSxsaW5lOmUubGluZSxwcmV2aW91c1Rva2VuOnRoaXMuX2xleGVyLnByZXZpb3VzVG9rZW59LHRoaXMuX2NhbGxiYWNrKHIpLHRoaXMuX2NhbGxiYWNrPWV0fV9yZXNvbHZlSVJJKHQpe3JldHVybi9eW2Etel1bYS16MC05Ky4tXSo6L2kudGVzdCh0KT90OnRoaXMuX3Jlc29sdmVSZWxhdGl2ZUlSSSh0KX1fcmVzb2x2ZVJlbGF0aXZlSVJJKHQpe2lmKCF0Lmxlbmd0aClyZXR1cm4gdGhpcy5fYmFzZTtzd2l0Y2godFswXSl7Y2FzZVwiI1wiOnJldHVybiB0aGlzLl9iYXNlK3Q7Y2FzZVwiP1wiOnJldHVybiB0aGlzLl9iYXNlLnJlcGxhY2UoLyg/OlxcPy4qKT8kLyx0KTtjYXNlXCIvXCI6cmV0dXJuKFwiL1wiPT09dFsxXT90aGlzLl9iYXNlU2NoZW1lOnRoaXMuX2Jhc2VSb290KSt0aGlzLl9yZW1vdmVEb3RTZWdtZW50cyh0KTtkZWZhdWx0OnJldHVybi9eW14vOl0qOi8udGVzdCh0KT9udWxsOnRoaXMuX3JlbW92ZURvdFNlZ21lbnRzKHRoaXMuX2Jhc2VQYXRoK3QpfX1fcmVtb3ZlRG90U2VnbWVudHModCl7aWYoIS8oXnxcXC8pXFwuXFwuPygkfFsvIz9dKS8udGVzdCh0KSlyZXR1cm4gdDtmb3IodmFyIGU9XCJcIixyPXQubGVuZ3RoLG49LTEsaT0tMSxvPTAsYT1cIi9cIjtuPHI7KXtzd2l0Y2goYSl7Y2FzZVwiOlwiOmlmKGk8MCYmXCIvXCI9PT10Wysrbl0mJlwiL1wiPT09dFsrK25dKWZvcig7KGk9bisxKTxyJiZcIi9cIiE9PXRbaV07KW49aTticmVhaztjYXNlXCI/XCI6Y2FzZVwiI1wiOm49cjticmVhaztjYXNlXCIvXCI6aWYoXCIuXCI9PT10W24rMV0pc3dpdGNoKGE9dFsxKyArK25dKXtjYXNlXCIvXCI6ZSs9dC5zdWJzdHJpbmcobyxuLTEpLG89bisxO2JyZWFrO2Nhc2Ugdm9pZCAwOmNhc2VcIj9cIjpjYXNlXCIjXCI6cmV0dXJuIGUrdC5zdWJzdHJpbmcobyxuKSt0LnN1YnN0cihuKzEpO2Nhc2VcIi5cIjppZih2b2lkIDA9PT0oYT10WzErICsrbl0pfHxcIi9cIj09PWF8fFwiP1wiPT09YXx8XCIjXCI9PT1hKXtpZigobz0oZSs9dC5zdWJzdHJpbmcobyxuLTIpKS5sYXN0SW5kZXhPZihcIi9cIikpPj1pJiYoZT1lLnN1YnN0cigwLG8pKSxcIi9cIiE9PWEpcmV0dXJuIGUrXCIvXCIrdC5zdWJzdHIobisxKTtvPW4rMX19fWE9dFsrK25dfXJldHVybiBlK3Quc3Vic3RyaW5nKG8pfXBhcnNlKHQsZSxyKXt2YXIgbj10aGlzO2lmKHRoaXMuX3JlYWRDYWxsYmFjaz10aGlzLl9yZWFkSW5Ub3BDb250ZXh0LHRoaXMuX3NwYXJxbFN0eWxlPSExLHRoaXMuX3ByZWZpeGVzPU9iamVjdC5jcmVhdGUobnVsbCksdGhpcy5fcHJlZml4ZXMuXz10aGlzLl9ibGFua05vZGVQcmVmaXg/dGhpcy5fYmxhbmtOb2RlUHJlZml4LnN1YnN0cigyKTpcImJcIitKKysrXCJfXCIsdGhpcy5fcHJlZml4Q2FsbGJhY2s9cnx8ZXQsdGhpcy5faW52ZXJzZVByZWRpY2F0ZT0hMSx0aGlzLl9xdWFudGlmaWVkPU9iamVjdC5jcmVhdGUobnVsbCksIWUpe3ZhciBpLG89W107aWYodGhpcy5fY2FsbGJhY2s9ZnVuY3Rpb24odCxlKXt0P2k9dDplJiZvLnB1c2goZSl9LHRoaXMuX2xleGVyLnRva2VuaXplKHQpLmV2ZXJ5KChmdW5jdGlvbih0KXtyZXR1cm4gbi5fcmVhZENhbGxiYWNrPW4uX3JlYWRDYWxsYmFjayh0KX0pKSxpKXRocm93IGk7cmV0dXJuIG99dGhpcy5fY2FsbGJhY2s9ZSx0aGlzLl9sZXhlci50b2tlbml6ZSh0LChmdW5jdGlvbih0LGUpe251bGwhPT10PyhuLl9jYWxsYmFjayh0KSxuLl9jYWxsYmFjaz1ldCk6bi5fcmVhZENhbGxiYWNrJiYobi5fcmVhZENhbGxiYWNrPW4uX3JlYWRDYWxsYmFjayhlKSl9KSl9fWZ1bmN0aW9uIGV0KCl7fWZ1bmN0aW9uIHJ0KHQsZSl7dmFyIHI9ZS5uYW1lZE5vZGU7dC5fbmFtZWROb2RlPXIsdC5fYmxhbmtOb2RlPWUuYmxhbmtOb2RlLHQuX2xpdGVyYWw9ZS5saXRlcmFsLHQuX3ZhcmlhYmxlPWUudmFyaWFibGUsdC5fcXVhZD1lLnF1YWQsdC5ERUZBVUxUR1JBUEg9ZS5kZWZhdWx0R3JhcGgoKSx0LlJERl9GSVJTVD1yKE0uYS5yZGYuZmlyc3QpLHQuUkRGX1JFU1Q9cihNLmEucmRmLnJlc3QpLHQuUkRGX05JTD1yKE0uYS5yZGYubmlsKSx0Lk4zX0ZPUkFMTD1yKE0uYS5yLmZvckFsbCksdC5OM19GT1JTT01FPXIoTS5hLnIuZm9yU29tZSksdC5BQkJSRVZJQVRJT05TPXthOnIoTS5hLnJkZi50eXBlKSxcIj1cIjpyKE0uYS5vd2wuc2FtZUFzKSxcIj5cIjpyKE0uYS5sb2cuaW1wbGllcyl9LHQuUVVBTlRJRklFUlNfR1JBUEg9cihcInVybjpuMzpxdWFudGlmaWVyc1wiKX1ydCh0dC5wcm90b3R5cGUsSyk7dmFyIG50PXIoMTQ2KTtjb25zdHt0b0lkOml0LGZyb21JZDpvdH09Sy5pbnRlcm5hbDtjbGFzcyBhdHtjb25zdHJ1Y3Rvcih0LGUpe3RoaXMuX3NpemU9MCx0aGlzLl9ncmFwaHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9pZD0wLHRoaXMuX2lkcz1PYmplY3QuY3JlYXRlKG51bGwpLHRoaXMuX2lkc1tcIj48XCJdPTAsdGhpcy5fZW50aXRpZXM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ibGFua05vZGVJbmRleD0wLGV8fCF0fHx0WzBdfHwoZT10LHQ9bnVsbCksZT1lfHx7fSx0aGlzLl9mYWN0b3J5PWUuZmFjdG9yeXx8Syx0JiZ0aGlzLmFkZFF1YWRzKHQpfWdldCBzaXplKCl7dmFyIHQ9dGhpcy5fc2l6ZTtpZihudWxsIT09dClyZXR1cm4gdDt0PTA7dmFyIGUscixuPXRoaXMuX2dyYXBocztmb3IodmFyIGkgaW4gbilmb3IodmFyIG8gaW4gZT1uW2ldLnN1YmplY3RzKWZvcih2YXIgYSBpbiByPWVbb10pdCs9T2JqZWN0LmtleXMoclthXSkubGVuZ3RoO3JldHVybiB0aGlzLl9zaXplPXR9X2FkZFRvSW5kZXgodCxlLHIsbil7dmFyIGk9dFtlXXx8KHRbZV09e30pLG89aVtyXXx8KGlbcl09e30pLGE9biBpbiBvO3JldHVybiBhfHwob1tuXT1udWxsKSwhYX1fcmVtb3ZlRnJvbUluZGV4KHQsZSxyLG4pe3ZhciBpLG89dFtlXSxhPW9bcl07Zm9yKGkgaW4gZGVsZXRlIGFbbl0sYSlyZXR1cm47Zm9yKGkgaW4gZGVsZXRlIG9bcl0sbylyZXR1cm47ZGVsZXRlIHRbZV19X2ZpbmRJbkluZGV4KHQsZSxyLG4saSxvLGEscyx1LGMpe3ZhciBmLGwsaCxwPSFlKyFyKyFuPjE/T2JqZWN0LmtleXModGhpcy5faWRzKTp0aGlzLl9lbnRpdGllcztmb3IodmFyIGQgaW4gZSYmKChmPXQsdD17fSlbZV09ZltlXSksdCl7dmFyIHY9cFtkXTtpZihsPXRbZF0pZm9yKHZhciBnIGluIHImJigoZj1sLGw9e30pW3JdPWZbcl0pLGwpe3ZhciB5PXBbZ107aWYoaD1sW2ddKWZvcih2YXIgYj0obj9uIGluIGg/W25dOltdOk9iamVjdC5rZXlzKGgpKSxfPTA7XzxiLmxlbmd0aDtfKyspe3ZhciBtPXtzdWJqZWN0Om51bGwscHJlZGljYXRlOm51bGwsb2JqZWN0Om51bGx9O21baV09b3Qodix0aGlzLl9mYWN0b3J5KSxtW29dPW90KHksdGhpcy5fZmFjdG9yeSksbVthXT1vdChwW2JbX11dLHRoaXMuX2ZhY3RvcnkpO3ZhciB3PXRoaXMuX2ZhY3RvcnkucXVhZChtLnN1YmplY3QsbS5wcmVkaWNhdGUsbS5vYmplY3Qsb3Qocyx0aGlzLl9mYWN0b3J5KSk7aWYoYyljLnB1c2godyk7ZWxzZSBpZih1KHcpKXJldHVybiEwfX19cmV0dXJuIGN9X2xvb3AodCxlKXtmb3IodmFyIHIgaW4gdCllKHIpfV9sb29wQnlLZXkwKHQsZSxyKXt2YXIgbixpO2lmKG49dFtlXSlmb3IoaSBpbiBuKXIoaSl9X2xvb3BCeUtleTEodCxlLHIpe3ZhciBuO2ZvcihuIGluIHQpdFtuXVtlXSYmcihuKX1fbG9vcEJ5MktleXModCxlLHIsbil7dmFyIGksbyxhO2lmKChpPXRbZV0pJiYobz1pW3JdKSlmb3IoYSBpbiBvKW4oYSl9X2NvdW50SW5JbmRleCh0LGUscixuKXt2YXIgaSxvLGEscz0wO2Zvcih2YXIgdSBpbiBlJiYoKGk9dCx0PXt9KVtlXT1pW2VdKSx0KWlmKG89dFt1XSlmb3IodmFyIGMgaW4gciYmKChpPW8sbz17fSlbcl09aVtyXSksbykoYT1vW2NdKSYmKG4/biBpbiBhJiZzKys6cys9T2JqZWN0LmtleXMoYSkubGVuZ3RoKTtyZXR1cm4gc31fZ2V0R3JhcGhzKHQpe2lmKCFzdCh0KSlyZXR1cm4gdGhpcy5fZ3JhcGhzO3ZhciBlPXt9O3JldHVybiBlW3RdPXRoaXMuX2dyYXBoc1t0XSxlfV91bmlxdWVFbnRpdGllcyh0KXt2YXIgZT1PYmplY3QuY3JlYXRlKG51bGwpLHI9dGhpcy5fZW50aXRpZXM7cmV0dXJuIGZ1bmN0aW9uKG4pe24gaW4gZXx8KGVbbl09ITAsdChvdChyW25dKSkpfX1hZGRRdWFkKHQsZSxyLG4pe2V8fChuPXQuZ3JhcGgscj10Lm9iamVjdCxlPXQucHJlZGljYXRlLHQ9dC5zdWJqZWN0KSx0PWl0KHQpLGU9aXQoZSkscj1pdChyKSxuPWl0KG4pO3ZhciBpPXRoaXMuX2dyYXBoc1tuXTtpfHwoaT10aGlzLl9ncmFwaHNbbl09e3N1YmplY3RzOnt9LHByZWRpY2F0ZXM6e30sb2JqZWN0czp7fX0sT2JqZWN0LmZyZWV6ZShpKSk7dmFyIG89dGhpcy5faWRzLGE9dGhpcy5fZW50aXRpZXM7dD1vW3RdfHwob1thWysrdGhpcy5faWRdPXRdPXRoaXMuX2lkKSxlPW9bZV18fChvW2FbKyt0aGlzLl9pZF09ZV09dGhpcy5faWQpLHI9b1tyXXx8KG9bYVsrK3RoaXMuX2lkXT1yXT10aGlzLl9pZCk7dmFyIHM9dGhpcy5fYWRkVG9JbmRleChpLnN1YmplY3RzLHQsZSxyKTtyZXR1cm4gdGhpcy5fYWRkVG9JbmRleChpLnByZWRpY2F0ZXMsZSxyLHQpLHRoaXMuX2FkZFRvSW5kZXgoaS5vYmplY3RzLHIsdCxlKSx0aGlzLl9zaXplPW51bGwsc31hZGRRdWFkcyh0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLmFkZFF1YWQodFtlXSl9aW1wb3J0KHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsKGZ1bmN0aW9uKHQpe2UuYWRkUXVhZCh0KX0pKSx0fXJlbW92ZVF1YWQodCxlLHIsbil7ZXx8KG49dC5ncmFwaCxyPXQub2JqZWN0LGU9dC5wcmVkaWNhdGUsdD10LnN1YmplY3QpLHQ9aXQodCksZT1pdChlKSxyPWl0KHIpLG49aXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ3JhcGhzO2lmKCEoKHQ9c1t0XSkmJihlPXNbZV0pJiYocj1zW3JdKSYmKGk9dVtuXSkmJihvPWkuc3ViamVjdHNbdF0pJiYoYT1vW2VdKSYmciBpbiBhKSlyZXR1cm4hMTtmb3IodCBpbiB0aGlzLl9yZW1vdmVGcm9tSW5kZXgoaS5zdWJqZWN0cyx0LGUsciksdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGkucHJlZGljYXRlcyxlLHIsdCksdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGkub2JqZWN0cyxyLHQsZSksbnVsbCE9PXRoaXMuX3NpemUmJnRoaXMuX3NpemUtLSxpLnN1YmplY3RzKXJldHVybiEwO3JldHVybiBkZWxldGUgdVtuXSwhMH1yZW1vdmVRdWFkcyh0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKyl0aGlzLnJlbW92ZVF1YWQodFtlXSl9cmVtb3ZlKHQpe3ZhciBlPXRoaXM7cmV0dXJuIHQub24oXCJkYXRhXCIsKGZ1bmN0aW9uKHQpe2UucmVtb3ZlUXVhZCh0KX0pKSx0fXJlbW92ZU1hdGNoZXModCxlLHIsbil7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMubWF0Y2godCxlLHIsbikpfWRlbGV0ZUdyYXBoKHQpe3JldHVybiB0aGlzLnJlbW92ZU1hdGNoZXMobnVsbCxudWxsLG51bGwsdCl9Z2V0UXVhZHModCxlLHIsbil7dD10JiZpdCh0KSxlPWUmJml0KGUpLHI9ciYmaXQociksbj1uJiZpdChuKTt2YXIgaSxvLGEscyx1PVtdLGM9dGhpcy5fZ2V0R3JhcGhzKG4pLGY9dGhpcy5faWRzO2lmKHN0KHQpJiYhKG89Zlt0XSl8fHN0KGUpJiYhKGE9ZltlXSl8fHN0KHIpJiYhKHM9ZltyXSkpcmV0dXJuIHU7Zm9yKHZhciBsIGluIGMpKGk9Y1tsXSkmJihvP3M/dGhpcy5fZmluZEluSW5kZXgoaS5vYmplY3RzLHMsbyxhLFwib2JqZWN0XCIsXCJzdWJqZWN0XCIsXCJwcmVkaWNhdGVcIixsLG51bGwsdSk6dGhpcy5fZmluZEluSW5kZXgoaS5zdWJqZWN0cyxvLGEsbnVsbCxcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLFwib2JqZWN0XCIsbCxudWxsLHUpOmE/dGhpcy5fZmluZEluSW5kZXgoaS5wcmVkaWNhdGVzLGEscyxudWxsLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixcInN1YmplY3RcIixsLG51bGwsdSk6cz90aGlzLl9maW5kSW5JbmRleChpLm9iamVjdHMscyxudWxsLG51bGwsXCJvYmplY3RcIixcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLGwsbnVsbCx1KTp0aGlzLl9maW5kSW5JbmRleChpLnN1YmplY3RzLG51bGwsbnVsbCxudWxsLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixsLG51bGwsdSkpO3JldHVybiB1fW1hdGNoKHQsZSxyLG4pe3ZhciBpPW5ldyBudC5SZWFkYWJsZSh7b2JqZWN0TW9kZTohMH0pO3JldHVybiBpLl9yZWFkPSgpPT57Zm9yKHZhciBvIG9mIHRoaXMuZ2V0UXVhZHModCxlLHIsbikpaS5wdXNoKG8pO2kucHVzaChudWxsKX0saX1jb3VudFF1YWRzKHQsZSxyLG4pe3Q9dCYmaXQodCksZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHMsdT0wLGM9dGhpcy5fZ2V0R3JhcGhzKG4pLGY9dGhpcy5faWRzO2lmKHN0KHQpJiYhKG89Zlt0XSl8fHN0KGUpJiYhKGE9ZltlXSl8fHN0KHIpJiYhKHM9ZltyXSkpcmV0dXJuIDA7Zm9yKHZhciBsIGluIGMpKGk9Y1tsXSkmJih1Kz10P3I/dGhpcy5fY291bnRJbkluZGV4KGkub2JqZWN0cyxzLG8sYSk6dGhpcy5fY291bnRJbkluZGV4KGkuc3ViamVjdHMsbyxhLHMpOmU/dGhpcy5fY291bnRJbkluZGV4KGkucHJlZGljYXRlcyxhLHMsbyk6dGhpcy5fY291bnRJbkluZGV4KGkub2JqZWN0cyxzLG8sYSkpO3JldHVybiB1fWZvckVhY2godCxlLHIsbixpKXt0aGlzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiB0KGUpLCExfSksZSxyLG4saSl9ZXZlcnkodCxlLHIsbixpKXt2YXIgbz0hMSxhPSF0aGlzLnNvbWUoKGZ1bmN0aW9uKGUpe3JldHVybiBvPSEwLCF0KGUpfSksZSxyLG4saSk7cmV0dXJuIG8mJmF9c29tZSh0LGUscixuLGkpe2U9ZSYmaXQoZSkscj1yJiZpdChyKSxuPW4mJml0KG4pLGk9aSYmaXQoaSk7dmFyIG8sYSxzLHUsYz10aGlzLl9nZXRHcmFwaHMoaSksZj10aGlzLl9pZHM7aWYoc3QoZSkmJiEoYT1mW2VdKXx8c3QocikmJiEocz1mW3JdKXx8c3QobikmJiEodT1mW25dKSlyZXR1cm4hMTtmb3IodmFyIGwgaW4gYylpZihvPWNbbF0paWYoYSl7aWYodSl7aWYodGhpcy5fZmluZEluSW5kZXgoby5vYmplY3RzLHUsYSxzLFwib2JqZWN0XCIsXCJzdWJqZWN0XCIsXCJwcmVkaWNhdGVcIixsLHQsbnVsbCkpcmV0dXJuITB9ZWxzZSBpZih0aGlzLl9maW5kSW5JbmRleChvLnN1YmplY3RzLGEscyxudWxsLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsXCJvYmplY3RcIixsLHQsbnVsbCkpcmV0dXJuITB9ZWxzZSBpZihzKXtpZih0aGlzLl9maW5kSW5JbmRleChvLnByZWRpY2F0ZXMscyx1LG51bGwsXCJwcmVkaWNhdGVcIixcIm9iamVjdFwiLFwic3ViamVjdFwiLGwsdCxudWxsKSlyZXR1cm4hMH1lbHNlIGlmKHUpe2lmKHRoaXMuX2ZpbmRJbkluZGV4KG8ub2JqZWN0cyx1LG51bGwsbnVsbCxcIm9iamVjdFwiLFwic3ViamVjdFwiLFwicHJlZGljYXRlXCIsbCx0LG51bGwpKXJldHVybiEwfWVsc2UgaWYodGhpcy5fZmluZEluSW5kZXgoby5zdWJqZWN0cyxudWxsLG51bGwsbnVsbCxcInN1YmplY3RcIixcInByZWRpY2F0ZVwiLFwib2JqZWN0XCIsbCx0LG51bGwpKXJldHVybiEwO3JldHVybiExfWdldFN1YmplY3RzKHQsZSxyKXt2YXIgbj1bXTtyZXR1cm4gdGhpcy5mb3JTdWJqZWN0cygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yU3ViamVjdHModCxlLHIsbil7ZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ2V0R3JhcGhzKG4pO2lmKHQ9dGhpcy5fdW5pcXVlRW50aXRpZXModCksIShzdChlKSYmIShvPXNbZV0pfHxzdChyKSYmIShhPXNbcl0pKSlmb3IobiBpbiB1KShpPXVbbl0pJiYobz9hP3RoaXMuX2xvb3BCeTJLZXlzKGkucHJlZGljYXRlcyxvLGEsdCk6dGhpcy5fbG9vcEJ5S2V5MShpLnN1YmplY3RzLG8sdCk6YT90aGlzLl9sb29wQnlLZXkwKGkub2JqZWN0cyxhLHQpOnRoaXMuX2xvb3AoaS5zdWJqZWN0cyx0KSl9Z2V0UHJlZGljYXRlcyh0LGUscil7dmFyIG49W107cmV0dXJuIHRoaXMuZm9yUHJlZGljYXRlcygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yUHJlZGljYXRlcyh0LGUscixuKXtlPWUmJml0KGUpLHI9ciYmaXQociksbj1uJiZpdChuKTt2YXIgaSxvLGEscz10aGlzLl9pZHMsdT10aGlzLl9nZXRHcmFwaHMobik7aWYodD10aGlzLl91bmlxdWVFbnRpdGllcyh0KSwhKHN0KGUpJiYhKG89c1tlXSl8fHN0KHIpJiYhKGE9c1tyXSkpKWZvcihuIGluIHUpKGk9dVtuXSkmJihvP2E/dGhpcy5fbG9vcEJ5MktleXMoaS5vYmplY3RzLGEsbyx0KTp0aGlzLl9sb29wQnlLZXkwKGkuc3ViamVjdHMsbyx0KTphP3RoaXMuX2xvb3BCeUtleTEoaS5wcmVkaWNhdGVzLGEsdCk6dGhpcy5fbG9vcChpLnByZWRpY2F0ZXMsdCkpfWdldE9iamVjdHModCxlLHIpe3ZhciBuPVtdO3JldHVybiB0aGlzLmZvck9iamVjdHMoKGZ1bmN0aW9uKHQpe24ucHVzaCh0KX0pLHQsZSxyKSxufWZvck9iamVjdHModCxlLHIsbil7ZT1lJiZpdChlKSxyPXImJml0KHIpLG49biYmaXQobik7dmFyIGksbyxhLHM9dGhpcy5faWRzLHU9dGhpcy5fZ2V0R3JhcGhzKG4pO2lmKHQ9dGhpcy5fdW5pcXVlRW50aXRpZXModCksIShzdChlKSYmIShvPXNbZV0pfHxzdChyKSYmIShhPXNbcl0pKSlmb3IobiBpbiB1KShpPXVbbl0pJiYobz9hP3RoaXMuX2xvb3BCeTJLZXlzKGkuc3ViamVjdHMsbyxhLHQpOnRoaXMuX2xvb3BCeUtleTEoaS5vYmplY3RzLG8sdCk6YT90aGlzLl9sb29wQnlLZXkwKGkucHJlZGljYXRlcyxhLHQpOnRoaXMuX2xvb3AoaS5vYmplY3RzLHQpKX1nZXRHcmFwaHModCxlLHIpe3ZhciBuPVtdO3JldHVybiB0aGlzLmZvckdyYXBocygoZnVuY3Rpb24odCl7bi5wdXNoKHQpfSksdCxlLHIpLG59Zm9yR3JhcGhzKHQsZSxyLG4pe2Zvcih2YXIgaSBpbiB0aGlzLl9ncmFwaHMpdGhpcy5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdChlLmdyYXBoKSwhMH0pLGUscixuLGkpfWNyZWF0ZUJsYW5rTm9kZSh0KXt2YXIgZSxyO2lmKHQpZm9yKGU9dD1cIl86XCIrdCxyPTE7dGhpcy5faWRzW2VdOyllPXQrcisrO2Vsc2UgZG97ZT1cIl86YlwiK3RoaXMuX2JsYW5rTm9kZUluZGV4Kyt9d2hpbGUodGhpcy5faWRzW2VdKTtyZXR1cm4gdGhpcy5faWRzW2VdPSsrdGhpcy5faWQsdGhpcy5fZW50aXRpZXNbdGhpcy5faWRdPWUsdGhpcy5fZmFjdG9yeS5ibGFua05vZGUoZS5zdWJzdHIoMikpfWV4dHJhY3RMaXN0cyh7cmVtb3ZlOnQ9ITEsaWdub3JlRXJyb3JzOmU9ITF9PXt9KXt2YXIgcj17fSxuPWU/KCk9PiEwOih0LGUpPT57dGhyb3cgbmV3IEVycm9yKGAke3QudmFsdWV9ICR7ZX1gKX0saT10aGlzLmdldFF1YWRzKG51bGwsTS5hLnJkZi5yZXN0LE0uYS5yZGYubmlsLG51bGwpLG89dD9bLi4uaV06W107cmV0dXJuIGkuZm9yRWFjaChlPT57Zm9yKHZhciBpLGEscz1bXSx1PSExLGM9ZS5ncmFwaCxmPWUuc3ViamVjdDtmJiYhdTspe3ZhciBsLGgscD10aGlzLmdldFF1YWRzKG51bGwsbnVsbCxmLG51bGwpLGQ9dGhpcy5nZXRRdWFkcyhmLG51bGwsbnVsbCxudWxsKSx2PW51bGwsZz1udWxsLHk9bnVsbDtmb3IobD0wO2w8ZC5sZW5ndGgmJiF1O2wrKykoaD1kW2xdKS5ncmFwaC5lcXVhbHMoYyk/aT91PW4oZixcImhhcyBub24tbGlzdCBhcmNzIG91dFwiKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYuZmlyc3Q/dj91PW4oZixcImhhcyBtdWx0aXBsZSByZGY6Zmlyc3QgYXJjc1wiKTpvLnB1c2godj1oKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYucmVzdD9nP3U9bihmLFwiaGFzIG11bHRpcGxlIHJkZjpyZXN0IGFyY3NcIik6by5wdXNoKGc9aCk6cC5sZW5ndGg/dT1uKGYsXCJjYW4ndCBiZSBzdWJqZWN0IGFuZCBvYmplY3RcIik6KGk9aCxhPVwic3ViamVjdFwiKTp1PW4oZixcIm5vdCBjb25maW5lZCB0byBzaW5nbGUgZ3JhcGhcIik7Zm9yKGw9MDtsPHAubGVuZ3RoJiYhdTsrK2wpaD1wW2xdLGk/dT1uKGYsXCJjYW4ndCBoYXZlIGNvcmVmZXJlbmNlc1wiKTpoLnByZWRpY2F0ZS52YWx1ZT09PU0uYS5yZGYucmVzdD95P3U9bihmLFwiaGFzIGluY29taW5nIHJkZjpyZXN0IGFyY3NcIik6eT1oOihpPWgsYT1cIm9iamVjdFwiKTt2P3MudW5zaGlmdCh2Lm9iamVjdCk6dT1uKGYsXCJoYXMgbm8gbGlzdCBoZWFkXCIpLGY9eSYmeS5zdWJqZWN0fXU/dD0hMTppJiYocltpW2FdLnZhbHVlXT1zKX0pLHQmJnRoaXMucmVtb3ZlUXVhZHMobykscn19ZnVuY3Rpb24gc3QodCl7cmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBTdHJpbmd9dmFyIHV0PXIoMTQ0KSxjdD1yLm4odXQpKCkoKSxmdD1LLm5hbWVkTm9kZSxsdD1LLmxpdGVyYWwsaHQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiB0KGUpe3UoKSh0aGlzLHQpLHRoaXMuX2ZldGNoPWUsdGhpcy5wYXJzZXI9bmV3IHR0LHRoaXMuc3RvcmU9bmV3IGF0LHRoaXMuY2FjaGU9e30sdGhpcy5wcmVmaXg9e319dmFyIGUscixuLG87cmV0dXJuIGYoKSh0LFt7a2V5Olwic2V0UHJlZml4XCIsdmFsdWU6ZnVuY3Rpb24odCxlKXt0aGlzLnByZWZpeFt0XT1lfX0se2tleTpcImdldFByZWZpeFwiLHZhbHVlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnByZWZpeFt0XX19LHtrZXk6XCJxdWVyeVwiLHZhbHVlOihvPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEpe3ZhciBzLHUsYz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZighKGMubGVuZ3RoPjUmJnZvaWQgMCE9PWNbNV0/Y1s1XTp7dXNlQ2FjaGU6ITB9KS51c2VDYWNoZXx8IShlIGluIHRoaXMuY2FjaGUpKXt0Lm5leHQ9MzticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLl9xdWVyeUNhY2hlZChlLHIsbixvLGEpKTtjYXNlIDM6cmV0dXJuIHQubmV4dD01LHRoaXMuX2ZldGNoKGUse2hlYWRlcnM6e0FjY2VwdDpcInRleHQvdHVydGxlXCJ9fSk7Y2FzZSA1OnJldHVybiBzPXQuc2VudCx0Lm5leHQ9OCxzLnRleHQoKTtjYXNlIDg6cmV0dXJuIHU9dC5zZW50LHQuYWJydXB0KFwicmV0dXJuXCIsdGhpcy5xdWVyeVR1cnRsZShlLHUscixuLG8sYSkpO2Nhc2UgMTA6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIG8uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJxdWVyeVR1cnRsZVwiLHZhbHVlOihuPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEscyl7dmFyIHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5fcGFyc2UocixlKTtjYXNlIDI6cmV0dXJuIHU9dC5zZW50LHRoaXMuY2FjaGVbZV09dSx0LmFicnVwdChcInJldHVyblwiLHRoaXMuX3F1ZXJ5Q2FjaGVkKGUsbixvLGEscykpO2Nhc2UgNTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIsaSxvLGEpe3JldHVybiBuLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiX3F1ZXJ5Q2FjaGVkXCIsdmFsdWU6KHI9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscixuLG8sYSl7dmFyIHMsdT10aGlzO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIGF8fChhPWZ0KGUpW2FdPVtyLG4sbyxhXS5tYXAoKGZ1bmN0aW9uKHQpe2lmKFwib2JqZWN0XCI9PT1GKCkodCkmJnQpe2lmKHQuaWQpcmV0dXJuIHQ7dmFyIHI9T2JqZWN0LmtleXModCksbj10W3JdO3JldHVybiAxPT09ci5sZW5ndGgmJlwidGhpc0RvY1wiPT09clswXT9mdChuP2UrXCIjXCIrbjplKTpjdFtyXT9mdChjdFtyXShuKSk6dS5wcmVmaXhbcl0/ZnQodS5wcmVmaXhbcl0rbik6ZnQocituKX1yZXR1cm4gdCYmdm9pZCAwIT09dD9sdCh0KTp0fSkpKSxzPXRoaXMuY2FjaGVbZV0sdC5hYnJ1cHQoXCJyZXR1cm5cIixzLmdldFF1YWRzKGFbMF0sYVsxXSxhWzJdLGFbM10pKTtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxuLGksbyl7cmV0dXJuIHIuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJfcGFyc2VcIix2YWx1ZTooZT1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyKXt2YXIgbixvO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIG49W10sbz1uZXcgdHQoe2Jhc2VJUkk6cn0pLHQuYWJydXB0KFwicmV0dXJuXCIsbmV3IFByb21pc2UoKGZ1bmN0aW9uKHQscil7by5wYXJzZShlLChmdW5jdGlvbihlLGksbyl7aWYoaSYmbi5wdXNoKGkpLGUpcmV0dXJuIHIoZSk7aWYoIWkpe3ZhciBhPW5ldyBhdDthLmFkZFF1YWRzKG4pLHQoYSl9fSkpfSkpKTtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKSxmdW5jdGlvbih0LHIpe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfV0pLHR9KCkscHQ9SSxkdD1PO2Z1bmN0aW9uIHZ0KHQsZSl7dmFyIHI9e3VybDp0fTtmb3IodmFyIG4gaW4gZS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgZT10LnByZWRpY2F0ZS52YWx1ZS5yZXBsYWNlKC8uKlxcLy8sXCJcIikucmVwbGFjZSgvLiojLyxcIlwiKSxuPXQub2JqZWN0LnZhbHVlLm1hdGNoKFwiaHR0cDovL3d3dy53My5vcmcvbnMvaWFuYS9tZWRpYS10eXBlcy9cIik/dC5vYmplY3QudmFsdWUucmVwbGFjZShcImh0dHA6Ly93d3cudzMub3JnL25zL2lhbmEvbWVkaWEtdHlwZXMvXCIsXCJcIik6dC5vYmplY3QudmFsdWUucmVwbGFjZSgvLipcXC8vLFwiXCIpO2UubWF0Y2goXCJ0eXBlXCIpfHwobj1uLnJlcGxhY2UoLy4qIy8sXCJcIikpLFwibGRwI1Jlc291cmNlXCIhPT1uJiZcImxkcCNDb250YWluZXJcIiE9PW4mJihyW2VdPVtdLmNvbmNhdCh4KCkocltlXXx8W10pLFtuLnJlcGxhY2UoXCIjUmVzb3VyY2VcIixcIlwiKV0pKX0pKSxyKTE9PT1yW25dLmxlbmd0aCYmKHJbbl09cltuXVswXSk7cmV0dXJuIHZvaWQgMD09PXIudHlwZSYmKHIudHlwZT1cImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSxyLml0ZW1UeXBlPXIudHlwZS5pbmNsdWRlcyhcImxkcCNCYXNpY0NvbnRhaW5lclwiKT9cIkNvbnRhaW5lclwiOlwiUmVzb3VyY2VcIixyLm5hbWU9ZHQodCksci5wYXJlbnQ9cHQodCkscn1mdW5jdGlvbiBndCh0LGUscil7dmFyIG49e3R5cGU6XCJmb2xkZXJcIn07cmV0dXJuIG4ubW9kaWZpZWQ9dC5tb2RpZmllZCxuLm10aW1lPXQubXRpbWUsbi5zaXplPXQuc2l6ZSxuLml0ZW1UeXBlPXQuaXRlbVR5cGUsbi5uYW1lPXQubmFtZSxuLnBhcmVudD10LnBhcmVudCxuLnVybD10LnVybCxuLmZvbGRlcnM9ZSxuLmZpbGVzPXIsbn12YXIgeXQ9e3BhcnNlRm9sZGVyUmVzcG9uc2U6ZnVuY3Rpb24oKXt2YXIgdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHIsbixvLHMsdSxjLGYsbCxoPWFyZ3VtZW50cztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiByPWgubGVuZ3RoPjEmJnZvaWQgMCE9PWhbMV0/aFsxXTplLnVybCx0Lm5leHQ9MyxlLnRleHQoKTtjYXNlIDM6cmV0dXJuIG49dC5zZW50LG89bmV3IGh0LHQubmV4dD03LG8ucXVlcnlUdXJ0bGUocixuLHt0aGlzRG9jOlwiXCJ9KTtjYXNlIDc6cmV0dXJuIHM9dC5zZW50LHU9dnQocixzKSx0Lm5leHQ9MTEsby5xdWVyeVR1cnRsZShyLG4se3RoaXNEb2M6XCJcIn0se2xkcDpcImNvbnRhaW5zXCJ9KTtjYXNlIDExOnJldHVybiBjPXQuc2VudCxmPVtdLGw9W10sdC5uZXh0PTE2LFByb21pc2UuYWxsKGMubWFwKGZ1bmN0aW9uKCl7dmFyIHQ9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciBuLGEscztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiBuPWUub2JqZWN0LHQubmV4dD0zLG8ucXVlcnkocixuKTtjYXNlIDM6YT10LnNlbnQsKHM9dnQobi52YWx1ZSxhKSkuaXRlbVR5cGUuaW5jbHVkZXMoXCJDb250YWluZXJcIik/KHMudHlwZT1cImZvbGRlclwiLGYucHVzaChzKSk6bC5wdXNoKHMpO2Nhc2UgNjpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCl9KSkpO3JldHVybiBmdW5jdGlvbihlKXtyZXR1cm4gdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9fSgpKSk7Y2FzZSAxNjpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixndCh1LGYsbCkpO2Nhc2UgMTc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKX0sYnQ9KHIoMjAxKSxyKDk3KSksX3Q9ci5uKGJ0KSxtdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQpe3ZhciByLG47dSgpKHRoaXMsZSk7Zm9yKHZhciBpPWFyZ3VtZW50cy5sZW5ndGgsbz1uZXcgQXJyYXkoaT4xP2ktMTowKSxhPTE7YTxpO2ErKylvW2EtMV09YXJndW1lbnRzW2FdO3JldHVybihuPWgoKSh0aGlzLChyPWQoKShlKSkuY2FsbC5hcHBseShyLFt0aGlzXS5jb25jYXQobykpKSkubmFtZT1cIlNpbmdsZVJlc3BvbnNlRXJyb3JcIixvLmxlbmd0aHx8KG4ubWVzc2FnZT1cIlwiLmNvbmNhdCh0LnN0YXR1cyxcIiBcIikuY29uY2F0KHQudXJsKSksbi5yZXNwb25zZT10LG4ub2s9ITEsbi5zdGF0dXM9dC5zdGF0dXMsbi5zdGF0dXNUZXh0PXQuc3RhdHVzVGV4dCxuLnVybD10LnVybCxufXJldHVybiBiKCkoZSx0KSxlfShfdCgpKEVycm9yKSksd3Q9ZnVuY3Rpb24odCl7ZnVuY3Rpb24gZSh0KXt2YXIgcixuLGk9dC5zdWNjZXNzZnVsLG89dm9pZCAwPT09aT9bXTppLGE9dC5yZWplY3RlZEVycm9ycyxzPXZvaWQgMD09PWE/W106YSxjPXQuZXJyb3JzLGY9dm9pZCAwPT09Yz9bXTpjO3UoKSh0aGlzLGUpO2Zvcih2YXIgbD1hcmd1bWVudHMubGVuZ3RoLHA9bmV3IEFycmF5KGw+MT9sLTE6MCksdj0xO3Y8bDt2KyspcFt2LTFdPWFyZ3VtZW50c1t2XTtyZXR1cm4obj1oKCkodGhpcywocj1kKCkoZSkpLmNhbGwuYXBwbHkocixbdGhpc10uY29uY2F0KHApKSkpLm5hbWU9XCJTRkNGZXRjaEVycm9yXCIsbi5zdWNjZXNzZnVsPW8sbi5yZWplY3RlZD1zLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQucmVzcG9uc2V9KSksbi5yZWplY3RlZEVycm9ycz1zLG4uZXJyb3JzPWYsbi5vaz0hMSxzLmxlbmd0aD8xIT09cy5sZW5ndGh8fGYubGVuZ3RoPyhuLm1lc3NhZ2U9XCJcIi5jb25jYXQobi5uYW1lLFwiIFwiKS5jb25jYXQoW10uY29uY2F0KHgoKShzKSx4KCkoZikpLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pKS5qb2luKFwiXFxuXCIpKSxuLnN0YXR1cz0tMixuLnN0YXR1c1RleHQ9bi5tZXNzYWdlKToobi5tZXNzYWdlPVwiXCIuY29uY2F0KG4ubmFtZSxcIiBcIikuY29uY2F0KHNbMF0ubWVzc2FnZSksbi5zdGF0dXM9c1swXS5zdGF0dXMsbi5zdGF0dXNUZXh0PXNbMF0uc3RhdHVzVGV4dCk6KG4ubWVzc2FnZT1cIlwiLmNvbmNhdChuLm5hbWUsXCIgXCIpLmNvbmNhdChmLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQubWVzc2FnZX0pKS5qb2luKFwiXFxuXCIpKSxuLnN0YXR1cz0tMSxuLnN0YXR1c1RleHQ9bi5tZXNzYWdlKSxuLnN1Y2Nlc3NmdWw9byxuLnJlamVjdGVkPXMubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZXNwb25zZX0pKSxuLnJlamVjdGVkRXJyb3JzPXMsbi5lcnJvcnM9ZixufXJldHVybiBiKCkoZSx0KSxlfShfdCgpKEVycm9yKSkseHQ9ezQwMTpcIk1ha2Ugc3VyZSB0aGF0IHRoZSB1c2VyIGlzIHByb3Blcmx5IGxvZ2dlZCBpblwiLDQwMzpcIk1ha2Ugc3VyZSB0aGF0IHRoZSBvcmlnaW4gb2YgeW91ciBhcHAgaXMgYXV0aG9yaXplZCBmb3IgeW91ciBwb2RcIiw0MDQ6XCJUaGUgcmVxdWVzdGVkIHJlc291cmNlIGNvdWxkIG5vdCBiZSBmb3VuZFwiLDQwOTpcIkEgY29uZmxpY3QgYXBwZWFyZWQuIElmIHlvdSB0cmllZCB0byBkZWxldGUgYSBmb2xkZXIsIG1ha2Ugc3VyZSB0aGF0IGl0IGlzIGVtcHR5XCIsNTAwOlwiQW4gaW50ZXJuYWwgc2VydmVyIGVycm9yIG9jY3VyZWRcIn07ZnVuY3Rpb24ga3QodCl7cmV0dXJuIEV0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBFdCgpe3JldHVybihFdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gcj1lLm1hcCgoZnVuY3Rpb24odCl7cmV0dXJuIHQudGhlbigoZnVuY3Rpb24odCl7cmV0dXJue3N0YXR1czpcImZ1bGZpbGxlZFwiLHZhbHVlOnR9fSkpLmNhdGNoKChmdW5jdGlvbih0KXtyZXR1cm57c3RhdHVzOlwicmVqZWN0ZWRcIixyZWFzb246dH19KSl9KSksdC5hYnJ1cHQoXCJyZXR1cm5cIixQcm9taXNlLmFsbChyKSk7Y2FzZSAyOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSkpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX1mdW5jdGlvbiBTdCgpe3JldHVybihTdD1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHIsbixvLGEscyx1LGMsZjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9MixrdChlKTtjYXNlIDI6aWYobj10LnNlbnQsbz0ocj1bXSkuY29uY2F0LmFwcGx5KHIseCgpKG4uZmlsdGVyKChmdW5jdGlvbih0KXtyZXR1cm5cImZ1bGZpbGxlZFwiPT09dC5zdGF0dXN9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC52YWx1ZX0pKSkpLCEoYT1uLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuXCJyZWplY3RlZFwiPT09dC5zdGF0dXN9KSkubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5yZWFzb259KSkpLmxlbmd0aCl7dC5uZXh0PTk7YnJlYWt9dGhyb3cgYz0ocz1bXSkuY29uY2F0LmFwcGx5KHMseCgpKGEubWFwKChmdW5jdGlvbih0KXtyZXR1cm4gdC5lcnJvcnN9KSkpKSxmPSh1PVtdKS5jb25jYXQuYXBwbHkodSx4KCkoYS5tYXAoKGZ1bmN0aW9uKHQpe3JldHVybiB0LnJlamVjdGVkRXJyb3JzfSkpKSksbmV3IHd0KHtzdWNjZXNzZnVsOm8scmVqZWN0ZWRFcnJvcnM6ZixlcnJvcnM6Y30pO2Nhc2UgOTpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvKTtjYXNlIDEwOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSkpLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIganQ9e0ZldGNoRXJyb3I6d3QsU2luZ2xlUmVzcG9uc2VFcnJvcjptdCxhc3NlcnRSZXNwb25zZU9rOmZ1bmN0aW9uKHQpe2lmKCF0Lm9rKXt2YXIgZT10LnN0YXR1cyBpbiB4dD9uZXcgbXQodCxcIlwiLmNvbmNhdCh0LnN0YXR1cyxcIiBcIikuY29uY2F0KHQudXJsLFwiIC0gXCIpLmNvbmNhdCh4dFt0LnN0YXR1c10pKTpuZXcgbXQodCk7dGhyb3cgbmV3IHd0KHtzdWNjZXNzZnVsOltdLHJlamVjdGVkRXJyb3JzOltlXX0pfXJldHVybiB0fSxjb21wb3NlZEZldGNoOmZ1bmN0aW9uKHQpe3JldHVybiBTdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHByb21pc2VzU2V0dGxlZDprdCx0b0ZldGNoRXJyb3I6ZnVuY3Rpb24odCl7dGhyb3cgdCBpbnN0YW5jZW9mIHd0P3Q6dCBpbnN0YW5jZW9mIG10P25ldyB3dCh7cmVqZWN0ZWRFcnJvcnM6W3RdfSk6dCBpbnN0YW5jZW9mIEVycm9yP25ldyB3dCh7ZXJyb3JzOlt0XX0pOnR9fTtyKDIwNCk7ZnVuY3Rpb24gUnQodCxlKXt2YXIgcj17fTtyZXR1cm4gZnVuY3Rpb24odCl7aWYodCl7cmV0dXJuIHQubWF0Y2goLzxbXj5dKj5cXHMqKFxccyo7XFxzKlteKCk8PkAsOzpcIi9bXFxdPz17fSBcXHRdKz0oKFteXFwoXFwpPD5ALDs6XCJcXC9cXFtcXF1cXD89e30gXFx0XSspfChcIlteXCJdKlwiKSkpKigsfCQpL2cpfX0odCkubWFwKChmdW5jdGlvbih0KXt2YXIgZT10LnN1YnN0cmluZyh0LmluZGV4T2YoXCI8XCIpKzEsdC5pbmRleE9mKFwiPlwiKSkscj10LnN1YnN0cmluZyh0LmluZGV4T2YoJ3JlbD1cIicpKydyZWw9XCInLmxlbmd0aCx0Lmxhc3RJbmRleE9mKCdcIicpKTtyZXR1cm5bXCJkZXNjcmliZWRieVwiPT09ci50b0xvd2VyQ2FzZSgpP1wibWV0YVwiOnIsZV19KSkuZmlsdGVyKChmdW5jdGlvbih0KXt2YXIgZT1tKCkodCwxKVswXTtyZXR1cm5bXCJtZXRhXCIsXCJhY2xcIl0uaW5jbHVkZXMoZSl9KSkuZm9yRWFjaCgoZnVuY3Rpb24odCl7dmFyIG49bSgpKHQsMiksaT1uWzBdLG89blsxXTtyW2ldPWZ1bmN0aW9uKHQsZSl7dmFyIHIsbixpLG8sYSxzPWUuaW5kZXhPZihcIiNcIik7cz4wJiYoZT1lLnNsaWNlKDAscykpO2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gZTtpZigwPT09dC5pbmRleE9mKFwiI1wiKSlyZXR1cm4gZSt0O2lmKHQuaW5kZXhPZihcIjpcIik+PTApcmV0dXJuIHQ7aWYocj1lLmluZGV4T2YoXCI6XCIpLDA9PT1lLmxlbmd0aClyZXR1cm4gdDtpZihyPDApcmV0dXJuIHQ7aWYobj1lLnNsaWNlKDAsK3IrMXx8OWU5KSwwPT09dC5pbmRleE9mKFwiLy9cIikpcmV0dXJuIG4rdDtpZihlLmluZGV4T2YoXCIvL1wiLHIpPT09cisxKXtpZigoaT1lLmluZGV4T2YoXCIvXCIsciszKSk8MClyZXR1cm4gZS5sZW5ndGgtci0zPjA/ZStcIi9cIit0Om4rdH1lbHNlIGlmKChpPWUuaW5kZXhPZihcIi9cIixyKzEpKTwwKXJldHVybiBlLmxlbmd0aC1yLTE+MD9lK1wiL1wiK3Q6bit0O2lmKDA9PT10LmluZGV4T2YoXCIvXCIpKXJldHVybiBlLnNsaWNlKDAsaSkrdDtpZihhPWUuc2xpY2UoaSksKG89YS5sYXN0SW5kZXhPZihcIi9cIikpPDApcmV0dXJuIG4rdDtvPj0wJiZvPGEubGVuZ3RoLTEmJihhPWEuc2xpY2UoMCwrbysxfHw5ZTkpKTthKz10O2Zvcig7YS5tYXRjaCgvW15cXC9dKlxcL1xcLlxcLlxcLy8pOylhPWEucmVwbGFjZSgvW15cXC9dKlxcL1xcLlxcLlxcLy8sXCJcIik7cmV0dXJuIGE9KGE9YS5yZXBsYWNlKC9cXC5cXC8vZyxcIlwiKSkucmVwbGFjZSgvXFwvXFwuJC8sXCIvXCIpLGUuc2xpY2UoMCxpKSthfShvLGUpfSkpLHJ9dmFyIEN0PWZ1bmN0aW9uKHQpe3ZhciBlPWFyZ3VtZW50cy5sZW5ndGg+MSYmdm9pZCAwIT09YXJndW1lbnRzWzFdP2FyZ3VtZW50c1sxXTp0LnVybCxyPXQuaGVhZGVycy5nZXQoXCJsaW5rXCIpO3JldHVybiBudWxsPT09cj97fTpSdChyLGUpfTtmdW5jdGlvbiBJdCh0LGUpe3ZhciByPU9iamVjdC5rZXlzKHQpO2lmKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpe3ZhciBuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModCk7ZSYmKG49bi5maWx0ZXIoKGZ1bmN0aW9uKGUpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsZSkuZW51bWVyYWJsZX0pKSksci5wdXNoLmFwcGx5KHIsbil9cmV0dXJuIHJ9ZnVuY3Rpb24gT3QodCl7Zm9yKHZhciBlPTE7ZTxhcmd1bWVudHMubGVuZ3RoO2UrKyl7dmFyIHI9bnVsbCE9YXJndW1lbnRzW2VdP2FyZ3VtZW50c1tlXTp7fTtlJTI/SXQoT2JqZWN0KHIpLCEwKS5mb3JFYWNoKChmdW5jdGlvbihlKXtFKCkodCxlLHJbZV0pfSkpOk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzP09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHQsT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMocikpOkl0KE9iamVjdChyKSkuZm9yRWFjaCgoZnVuY3Rpb24oZSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHQsZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHIsZSkpfSkpfXJldHVybiB0fXZhciBUdD1qKCkoXCJzb2xpZC1maWxlLWNsaWVudDpmZXRjaFwiKSxQdD1DLEF0PUksTHQ9TyxGdD1ULE10PVAsTnQ9QSxCdD1qdC5GZXRjaEVycm9yLER0PWp0LmFzc2VydFJlc3BvbnNlT2ssVXQ9anQuY29tcG9zZWRGZXRjaCxxdD1qdC50b0ZldGNoRXJyb3IsR3Q9Q3QsV3Q9eXQucGFyc2VGb2xkZXJSZXNwb25zZSx6dD17UkVQTEFDRTpcInJlcGxhY2VcIixLRUVQX1NPVVJDRTpcImtlZXBfc291cmNlXCIsS0VFUF9UQVJHRVQ6XCJrZWVwX3RhcmdldFwifSxZdD17RVhDTFVERTpcImV4Y2x1ZGVcIixJTkNMVURFOlwiaW5jbHVkZVwiLElOQ0xVREVfUE9TU0lCTEU6XCJpbmNsdWRlX3Bvc3NpYmxlXCJ9LFF0PVwibm9fbW9kaWZ5XCIsJHQ9XCJ0b190YXJnZXRcIixIdD1cInRvX3NvdXJjZVwiLEt0PXt3aXRoQWNsOiEwLHdpdGhNZXRhOiEwLGFnZW50OlF0LG1lcmdlOnp0LlJFUExBQ0UsY3JlYXRlUGF0aDohMH0sVnQ9e2VuYWJsZUxvZ2dpbmc6ITF9O2Z1bmN0aW9uIFp0KHQpe3JldHVybiBKdCgoZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3RhdHVzPT09dH0pKX1mdW5jdGlvbiBKdCh0KXtyZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXQoZSkpdGhyb3cgcXQoZSk7cmV0dXJuIGV9fXZhciBYdD1mdW5jdGlvbih0KXtmdW5jdGlvbiBlKHQscil7dmFyIG47cmV0dXJuIHUoKSh0aGlzLGUpLChuPWgoKSh0aGlzLGQoKShlKS5jYWxsKHRoaXMsdC5mZXRjaC5iaW5kKHQpLHIpKSkuX2F1dGg9dCxufXZhciByLG4sbyxzO3JldHVybiBiKCkoZSx0KSxmKCkoZSxbe2tleTpcInJlYWRGaWxlXCIsdmFsdWU6KHM9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscil7dmFyIG4sbztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9Mix0aGlzLmdldChlLHIpO2Nhc2UgMjppZihuPXQuc2VudCwhKG89bi5oZWFkZXJzLmdldChcImNvbnRlbnQtdHlwZVwiKSl8fCFvLm1hdGNoKC8oaW1hZ2V8YXVkaW98dmlkZW8pLykpe3QubmV4dD02O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLG4uYmxvYigpKTtjYXNlIDY6aWYoIW4udGV4dCl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbi50ZXh0KCkpO2Nhc2UgODpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixuKTtjYXNlIDk6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJyZWFkSGVhZFwiLHZhbHVlOihvPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChyLG4pe3ZhciBvLGEscyx1LGMsZixsLGg7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsZygpKGQoKShlLnByb3RvdHlwZSksXCJoZWFkXCIsdGhpcykuY2FsbCh0aGlzLHIsbik7Y2FzZSAyOmZvcihvPXQuc2VudCxhPVwiXCIscz0hMCx1PSExLGM9dm9pZCAwLHQucHJldj03LGY9by5oZWFkZXJzLmVudHJpZXMoKVtTeW1ib2wuaXRlcmF0b3JdKCk7IShzPShsPWYubmV4dCgpKS5kb25lKTtzPSEwKWg9bC52YWx1ZSxhKz1oWzBdK1wiOiBcIitoWzFdK1wiXFxuXCI7dC5uZXh0PTE1O2JyZWFrO2Nhc2UgMTE6dC5wcmV2PTExLHQudDA9dC5jYXRjaCg3KSx1PSEwLGM9dC50MDtjYXNlIDE1OnQucHJldj0xNSx0LnByZXY9MTYsc3x8bnVsbD09Zi5yZXR1cm58fGYucmV0dXJuKCk7Y2FzZSAxODppZih0LnByZXY9MTgsIXUpe3QubmV4dD0yMTticmVha310aHJvdyBjO2Nhc2UgMjE6cmV0dXJuIHQuZmluaXNoKDE4KTtjYXNlIDIyOnJldHVybiB0LmZpbmlzaCgxNSk7Y2FzZSAyMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixhKTtjYXNlIDI0OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMsW1s3LDExLDE1LDIzXSxbMTYsLDE4LDIyXV0pfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiBvLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZGVsZXRlRmlsZVwiLHZhbHVlOihuPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChyKXtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0LmFicnVwdChcInJldHVyblwiLGcoKShkKCkoZS5wcm90b3R5cGUpLFwiX2RlbGV0ZUl0ZW1XaXRoTGlua3NcIix0aGlzKS5jYWxsKHRoaXMscikpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJkZWxldGVGb2xkZXJcIix2YWx1ZToocj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQocixuKXtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0LmFicnVwdChcInJldHVyblwiLGcoKShkKCkoZS5wcm90b3R5cGUpLFwiZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHlcIix0aGlzKS5jYWxsKHRoaXMscikpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlKXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX1dKSxlfShmdW5jdGlvbigpe2Z1bmN0aW9uIHQoZSxyKXt1KCkodGhpcyx0KSxyPU90KHt9LFZ0LHt9LHIpLHRoaXMuX2ZldGNoPWUsdGhpcy5yZGY9bmV3IGh0KHRoaXMuZmV0Y2guYmluZCh0aGlzKSksci5lbmFibGVMb2dnaW5nJiYoXCJzdHJpbmdcIj09dHlwZW9mIHIuZW5hYmxlTG9nZ2luZz9qLmEuZW5hYmxlKHIuZW5hYmxlTG9nZ2luZyk6ai5hLmVuYWJsZShcInNvbGlkLWZpbGUtY2xpZW50OipcIikpfXZhciBlLHIsbixvLHMsYyxsLGgscCxkLHYsZyx5LGIsXyx3LGs7cmV0dXJuIGYoKSh0LFt7a2V5OlwiZmV0Y2hcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLl9mZXRjaCh0LGUpLnRoZW4oKGZ1bmN0aW9uKHIpe3JldHVybiBUdChcIlwiLmNvbmNhdChyLnN0YXR1cyxcIiAtIFwiKS5jb25jYXQoZSYmZS5tZXRob2QsXCIgXCIpLmNvbmNhdCh0KSkscn0pKS50aGVuKER0KX19LHtrZXk6XCJnZXRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiR0VUXCJ9KSl9fSx7a2V5OlwiZGVsZXRlXCIsdmFsdWU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mZXRjaCh0LE90KHt9LGUse21ldGhvZDpcIkRFTEVURVwifSkpfX0se2tleTpcInBvc3RcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiUE9TVFwifSkpfX0se2tleTpcInB1dFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmV0Y2godCxPdCh7fSxlLHttZXRob2Q6XCJQVVRcIn0pKX19LHtrZXk6XCJwYXRjaFwiLHZhbHVlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmV0Y2godCxPdCh7fSxlLHttZXRob2Q6XCJQQVRDSFwifSkpfX0se2tleTpcImhlYWRcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiSEVBRFwifSkpfX0se2tleTpcIm9wdGlvbnNcIix2YWx1ZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZldGNoKHQsT3Qoe30sZSx7bWV0aG9kOlwiT1BUSU9OU1wifSkpfX0se2tleTpcIml0ZW1FeGlzdHNcIix2YWx1ZTooaz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLmhlYWQoZSkudGhlbigoZnVuY3Rpb24oKXtyZXR1cm4hMH0pKS5jYXRjaCgoZnVuY3Rpb24odCl7cmV0dXJuIFp0KDQwNCkodCksITF9KSkpO2Nhc2UgMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIGsuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJwb3N0SXRlbVwiLHZhbHVlOih3PWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbixvLGEpe3ZhciBzLHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihhPU90KHt9LHtjcmVhdGVQYXRoOiEwfSx7fSxhKSxzPUF0KGUpLCFhLmNyZWF0ZVBhdGgpe3QubmV4dD01O2JyZWFrfXJldHVybiB0Lm5leHQ9NSx0aGlzLmNyZWF0ZUZvbGRlcihzKTtjYXNlIDU6cmV0dXJuIHU9e2hlYWRlcnM6e2xpbms6byxzbHVnOkx0KGUpLFwiQ29udGVudC1UeXBlXCI6bn0sYm9keTpyfSx0LmFicnVwdChcInJldHVyblwiLHRoaXMucG9zdChzLHUpKTtjYXNlIDc6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4saSl7cmV0dXJuIHcuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjcmVhdGVGb2xkZXJcIix2YWx1ZTooXz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyKXt2YXIgbjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiByPU90KHt9LHtjcmVhdGVQYXRoOiEwLG1lcmdlOnp0LktFRVBfVEFSR0VUfSx7fSxyKSx0LnByZXY9MSx0Lm5leHQ9NCx0aGlzLmhlYWQoZSk7Y2FzZSA0OmlmKG49dC5zZW50LHIubWVyZ2U9PT16dC5SRVBMQUNFKXt0Lm5leHQ9NzticmVha31yZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixuKTtjYXNlIDc6cmV0dXJuIHQubmV4dD05LHRoaXMuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSk7Y2FzZSA5OnQubmV4dD0xNDticmVhaztjYXNlIDExOnQucHJldj0xMSx0LnQwPXQuY2F0Y2goMSksWnQoNDA0KSh0LnQwKTtjYXNlIDE0OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLHRoaXMucG9zdEl0ZW0oZSxcIlwiLFwidGV4dC90dXJ0bGVcIixOdC5DT05UQUlORVIscikpO2Nhc2UgMTU6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyxbWzEsMTFdXSl9KSkpLGZ1bmN0aW9uKHQsZSl7cmV0dXJuIF8uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJwb3N0RmlsZVwiLHZhbHVlOmZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiB0aGlzLnBvc3RJdGVtKHQsZSxyLE50LlJFU09VUkNFLG4pfX0se2tleTpcImNyZWF0ZUZpbGVcIix2YWx1ZTpmdW5jdGlvbih0LGUscixuKXtyZXR1cm4gdGhpcy5wdXRGaWxlKHQsZSxyLG4pfX0se2tleTpcInB1dEZpbGVcIix2YWx1ZTooYj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyLG4sbyl7dmFyIGE7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihvPU90KHt9LEt0LHt9LG8pLHQudDA9by5tZXJnZT09PXp0LktFRVBfVEFSR0VULCF0LnQwKXt0Lm5leHQ9NjticmVha31yZXR1cm4gdC5uZXh0PTUsdGhpcy5pdGVtRXhpc3RzKGUpO2Nhc2UgNTp0LnQwPXQuc2VudDtjYXNlIDY6aWYoIXQudDApe3QubmV4dD04O2JyZWFrfXF0KG5ldyBFcnJvcihcIkZpbGUgYWxyZWFkeSBleGlzdGVkOiBcIitlKSk7Y2FzZSA4OnJldHVybiBhPXtoZWFkZXJzOntsaW5rOk50LlJFU09VUkNFLFwiQ29udGVudC1UeXBlXCI6bn0sYm9keTpyfSx0LmFicnVwdChcInJldHVyblwiLHRoaXMucHV0KGUsYSkpO2Nhc2UgMTA6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQsdGhpcyl9KSkpLGZ1bmN0aW9uKHQsZSxyLG4pe3JldHVybiBiLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwicmVhZEZvbGRlclwiLHZhbHVlOih5PWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3ZhciBuLG8scyx1PXRoaXM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gZT1lLmVuZHNXaXRoKFwiL1wiKT9lOmUrXCIvXCIscj1PdCh7bGlua3M6WXQuRVhDTFVERX0sciksdC5uZXh0PTQsdGhpcy5nZXQoZSx7aGVhZGVyczp7QWNjZXB0OlwidGV4dC90dXJ0bGVcIn19KTtjYXNlIDQ6cmV0dXJuIG49dC5zZW50LHQubmV4dD03LFd0KG4sZSk7Y2FzZSA3OmlmKG89dC5zZW50LHIubGlua3MhPT1ZdC5JTkNMVURFX1BPU1NJQkxFJiZyLmxpbmtzIT09WXQuSU5DTFVERSl7dC5uZXh0PTEyO2JyZWFrfXJldHVybiBzPWZ1bmN0aW9uKCl7dmFyIHQ9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIHQubmV4dD0yLHUuZ2V0SXRlbUxpbmtzKGUudXJsLHIpO2Nhc2UgMjplLmxpbmtzPXQuc2VudDtjYXNlIDM6Y2FzZVwiZW5kXCI6cmV0dXJuIHQuc3RvcCgpfX0pLHQpfSkpKTtyZXR1cm4gZnVuY3Rpb24oZSl7cmV0dXJuIHQuYXBwbHkodGhpcyxhcmd1bWVudHMpfX0oKSx0Lm5leHQ9MTIsVXQoW3MobyldLmNvbmNhdCh4KCkoby5maWxlcy5tYXAocykpKSk7Y2FzZSAxMjpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvKTtjYXNlIDEzOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiB5LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiZ2V0SXRlbUxpbmtzXCIsdmFsdWU6KGc9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciByLG4sbz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4ocj1vLmxlbmd0aD4xJiZ2b2lkIDAhPT1vWzFdP29bMV06e2xpbmtzOll0LklOQ0xVREVfUE9TU0lCTEV9KS5saW5rcz09PVl0LkVYQ0xVREUmJnF0KG5ldyBFcnJvcihcIkludmFsaWQgb3B0aW9uIExJTktTLkVYQ0xVREUgZm9yIGdldEl0ZW1MaW5rc1wiKSksdC5uZXh0PTQsdGhpcy5oZWFkKGUpLnRoZW4oR3QpO2Nhc2UgNDppZihuPXQuc2VudCxyLmxpbmtzIT09WXQuSU5DTFVERSl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQubmV4dD04LHRoaXMuX3JlbW92ZUluZXhpc3RpbmdMaW5rcyhuKTtjYXNlIDg6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbik7Y2FzZSA5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gZy5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcIl9yZW1vdmVJbmV4aXN0aW5nTGlua3NcIix2YWx1ZToodj1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI9dGhpcztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9MixVdChPYmplY3QuZW50cmllcyhlKS5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBuPW0oKSh0LDIpLGk9blswXSxvPW5bMV07cmV0dXJuIHIuaXRlbUV4aXN0cyhvKS5jYXRjaChadCg0MDQpKS50aGVuKChmdW5jdGlvbih0KXt0fHxkZWxldGUgZVtpXX0pKX0pKSk7Y2FzZSAyOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0KX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIHYuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5RmlsZVwiLHZhbHVlOihkPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHU7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDppZihuPU90KHt9LEt0LHt9LG4pLCFlLmVuZHNXaXRoKFwiL1wiKSYmIXIuZW5kc1dpdGgoXCIvXCIpKXt0Lm5leHQ9MzticmVha310aHJvdyBxdChuZXcgRXJyb3IoXCJGb2xkZXJzIGFyZSBub3QgYWxsb3dlZCB3aXRoIGNvcHlGaWxlLiBGb3VuZDogXCIuY29uY2F0KGUsXCIgYW5kIFwiKS5jb25jYXQocikpKTtjYXNlIDM6aWYoIWUuZW5kc1dpdGgoXCIuYWNsXCIpJiYhci5lbmRzV2l0aChcIi5hY2xcIikpe3QubmV4dD01O2JyZWFrfXRocm93IHF0KG5ldyBFcnJvcihcIlVzZSBjb3B5QWNsRmlsZSBmb3IgY29weWluZyBBQ0wgZmlsZXMuIEZvdW5kOiBcIi5jb25jYXQoZSxcIiBhbmQgXCIpLmNvbmNhdChyKSkpO2Nhc2UgNTpyZXR1cm4gdC5uZXh0PTcsdGhpcy5nZXQoZSk7Y2FzZSA3OnJldHVybiBvPXQuc2VudCx0Lm5leHQ9MTAsby5ibG9iKCk7Y2FzZSAxMDpyZXR1cm4gYT10LnNlbnQscz1vLmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpLHQubmV4dD0xNCx0aGlzLnB1dEZpbGUocixhLHMsbik7Y2FzZSAxNDpyZXR1cm4gdT10LnNlbnQsdC5uZXh0PTE3LHRoaXMuY29weUxpbmtzRm9ySXRlbShlLHIsbixvLHUpO2Nhc2UgMTc6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsdSk7Y2FzZSAxODpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIpe3JldHVybiBkLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiX2xpbmtVcmxzRGVmaW5lZFwiLHZhbHVlOihwPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpe3QubmV4dD00O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLCExKTtjYXNlIDQ6aWYodC50MD1cInN0cmluZ1wiIT10eXBlb2YgciwhdC50MCl7dC5uZXh0PTk7YnJlYWt9cmV0dXJuIHQubmV4dD04LHRoaXMuaXRlbUV4aXN0cyhlKTtjYXNlIDg6dC50MD10LnNlbnQ7Y2FzZSA5OmlmKCF0LnQwKXt0Lm5leHQ9MTM7YnJlYWt9dGhyb3cgcXQobmV3IEVycm9yKFwiQ2Fubm90IGNvcHkgbGluayBmaWxlIGJlY2F1c2UgdGFyZ2V0IGxvY2F0aW9uIHdhcyBub3QgcHJvdmlkZWQgYnkgdGhlIHBvZFwiKSk7Y2FzZSAxMzppZihcInN0cmluZ1wiPT10eXBlb2Ygcil7dC5uZXh0PTE3O2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLCExKTtjYXNlIDE3OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLCEwKTtjYXNlIDE4OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUpe3JldHVybiBwLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiY29weU1ldGFGaWxlRm9ySXRlbVwiLHZhbHVlOihoPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIpe3ZhciBuLG8sYSxzLHUsYz1hcmd1bWVudHM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gbj1jLmxlbmd0aD4yJiZ2b2lkIDAhPT1jWzJdP2NbMl06e30sdC5uZXh0PTMsdGhpcy5nZXRJdGVtTGlua3MoZSk7Y2FzZSAzOnJldHVybiBvPXQuc2VudCxhPW8ubWV0YSx0Lm5leHQ9Nyx0aGlzLmdldEl0ZW1MaW5rcyhyKTtjYXNlIDc6cmV0dXJuIHM9dC5zZW50LHU9cy5tZXRhLHQubmV4dD0xMSx0aGlzLl9saW5rVXJsc0RlZmluZWQoYSx1KTtjYXNlIDExOmlmKHQuc2VudCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLHZvaWQgMCk7Y2FzZSAxMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIix0aGlzLmNvcHlGaWxlKGEsdSx7d2l0aEFjbDpuLndpdGhBY2wsd2l0aE1ldGE6ITF9KSk7Y2FzZSAxNDpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlKXtyZXR1cm4gaC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImNvcHlBY2xGaWxlRm9ySXRlbVwiLHZhbHVlOihsPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHUsYyxmLGwsaCxwO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIG49T3Qoe30sS3Qse30se2FnZW50OlF0fSx7fSxuKSx0Lm5leHQ9Myx0aGlzLmdldEl0ZW1MaW5rcyhlKTtjYXNlIDM6cmV0dXJuIG89dC5zZW50LGE9by5hY2wsdC5uZXh0PTcsdGhpcy5nZXRJdGVtTGlua3Mocik7Y2FzZSA3OnJldHVybiBzPXQuc2VudCx1PXMuYWNsLHQubmV4dD0xMSx0aGlzLl9saW5rVXJsc0RlZmluZWQoYSx1KTtjYXNlIDExOmlmKHQuc2VudCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LmFicnVwdChcInJldHVyblwiLHZvaWQgMCk7Y2FzZSAxMzpyZXR1cm4gdC5uZXh0PTE1LHRoaXMuZ2V0KGEpO2Nhc2UgMTU6cmV0dXJuIGM9dC5zZW50LGY9Yy5oZWFkZXJzLmdldChcIkNvbnRlbnQtVHlwZVwiKSx0Lm5leHQ9MTksYy50ZXh0KCk7Y2FzZSAxOTpyZXR1cm4gbD10LnNlbnQsaD1MdChlKSxwPUZ0KHIpP1wiXCI6THQociksbC5pbmNsdWRlcyhlKSYmKGw9bC5yZXBsYWNlKG5ldyBSZWdFeHAoXCI8XCIrZStcIj5cIixcImdcIiksXCI8Li9cIitwK1wiPlwiKSkscCE9PWgmJihsPWwucmVwbGFjZShuZXcgUmVnRXhwKGgrXCI+XCIsXCJnXCIpLHArXCI+XCIpKSxuLmFnZW50PT09JHQmJihsPShsPWwucmVwbGFjZShuZXcgUmVnRXhwKFwiPFwiK1B0KGUpK1wicHJvZmlsZS9jYXJkI1wiLFwiZ1wiKSxcIjwvcHJvZmlsZS9jYXJkI1wiKSkucmVwbGFjZShuZXcgUmVnRXhwKFwiPFwiK1B0KGUpK1wicHJvZmlsZS9jYXJkI21lPlwiLFwiZ1wiKSxcIjwvcHJvZmlsZS9jYXJkI21lPlwiKSksbi5hZ2VudD09PUh0JiYobD0obD1sLnJlcGxhY2UobmV3IFJlZ0V4cChcIjwvcHJvZmlsZS9jYXJkI1wiLFwiZ1wiKSxcIjxcIitQdChlKStcInByb2ZpbGUvY2FyZCNcIikpLnJlcGxhY2UobmV3IFJlZ0V4cChcIjwvcHJvZmlsZS9jYXJkI21lPlwiLFwiZ1wiKSxcIjxcIitQdChlKStcInByb2ZpbGUvY2FyZCNtZT5cIikpLHQuYWJydXB0KFwicmV0dXJuXCIsdGhpcy5wdXRGaWxlKHUsbCxmLG4pKTtjYXNlIDI3OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUscil7cmV0dXJuIGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5TGlua3NGb3JJdGVtXCIsdmFsdWU6KGM9YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUscixuKXt2YXIgbztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmlmKG89W10sIW4ud2l0aE1ldGEpe3QubmV4dD03O2JyZWFrfXJldHVybiB0LnQwPW8sdC5uZXh0PTUsdGhpcy5jb3B5TWV0YUZpbGVGb3JJdGVtKGUscixuKS5jYXRjaChadCg0MDQpKTtjYXNlIDU6dC50MT10LnNlbnQsdC50MC5wdXNoLmNhbGwodC50MCx0LnQxKTtjYXNlIDc6aWYoIW4ud2l0aEFjbCl7dC5uZXh0PTEzO2JyZWFrfXJldHVybiB0LnQyPW8sdC5uZXh0PTExLHRoaXMuY29weUFjbEZpbGVGb3JJdGVtKGUscixuKS5jYXRjaChadCg0MDQpKTtjYXNlIDExOnQudDM9dC5zZW50LHQudDIucHVzaC5jYWxsKHQudDIsdC50Myk7Y2FzZSAxMzpyZXR1cm4gdC5hYnJ1cHQoXCJyZXR1cm5cIixvLmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuIHQmJiEodCBpbnN0YW5jZW9mIEVycm9yKX0pKSk7Y2FzZSAxNDpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxlLHIpe3JldHVybiBjLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwiY29weUZvbGRlclwiLHZhbHVlOihzPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlLHIsbil7dmFyIG8sYSxzLHUsYyxmLGw9dGhpcztyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOmlmKG49T3Qoe30sS3Qse30sbiksXCJzdHJpbmdcIj09dHlwZW9mIGUmJlwic3RyaW5nXCI9PXR5cGVvZiByKXt0Lm5leHQ9MzticmVha310aHJvdyBxdChuZXcgRXJyb3IoXCJUaGUgZnJvbSBhbmQgdG8gcGFyYW1ldGVycyBvZiBjb3B5Rm9sZGVyIG11c3QgYmUgc3RyaW5ncy4gRm91bmQ6IFwiLmNvbmNhdChlLFwiIGFuZCBcIikuY29uY2F0KHIpKSk7Y2FzZSAzOmlmKGUuZW5kc1dpdGgoXCIvXCIpJiZyLmVuZHNXaXRoKFwiL1wiKSl7dC5uZXh0PTU7YnJlYWt9dGhyb3cgcXQobmV3IEVycm9yKFwiRmlsZXMgYXJlIG5vdCBhbGxvd2VkIHdpdGggY29weUZvbGRlci4gRm91bmQ6IFwiLmNvbmNhdChlLFwiIGFuZCBcIikuY29uY2F0KHIpKSk7Y2FzZSA1OnJldHVybiB0Lm5leHQ9Nyx0aGlzLnJlYWRGb2xkZXIoZSk7Y2FzZSA3OnJldHVybiBhPXQuc2VudCxzPWEuZm9sZGVycyx1PWEuZmlsZXMsdC5uZXh0PTEyLHRoaXMuY3JlYXRlRm9sZGVyKHIsbik7Y2FzZSAxMjpyZXR1cm4gYz10LnNlbnQsdC5uZXh0PTE1LHRoaXMuY29weUxpbmtzRm9ySXRlbShlLHIsbix2b2lkIDAsYyk7Y2FzZSAxNTpyZXR1cm4gdC5uZXh0PTE3LFV0KFtdLmNvbmNhdCh4KCkocy5tYXAoKGZ1bmN0aW9uKHQpe3ZhciBpPXQubmFtZTtyZXR1cm4gbC5jb3B5Rm9sZGVyKFwiXCIuY29uY2F0KGUpLmNvbmNhdChpLFwiL1wiKSxcIlwiLmNvbmNhdChyKS5jb25jYXQoaSxcIi9cIiksbil9KSkpLHgoKSh1Lm1hcCgoZnVuY3Rpb24odCl7dmFyIGk9dC5uYW1lO3JldHVybiBsLmNvcHlGaWxlKFwiXCIuY29uY2F0KGUpLmNvbmNhdChpKSxcIlwiLmNvbmNhdChyKS5jb25jYXQoaSksbikuY2F0Y2goSnQoKGZ1bmN0aW9uKHQpe3JldHVybiB0Lm1lc3NhZ2UuaW5jbHVkZXMoXCJhbHJlYWR5IGV4aXN0ZWRcIil9KSkpfSkpKSkpLnRoZW4oKGZ1bmN0aW9uKHQpe3JldHVybiB0LmZpbHRlcigoZnVuY3Rpb24odCl7cmV0dXJuISh0IGluc3RhbmNlb2YgQnQpfSkpfSkpO2Nhc2UgMTc6cmV0dXJuIGY9dC5zZW50LHQuYWJydXB0KFwicmV0dXJuXCIsKG89W2NdKS5jb25jYXQuYXBwbHkobyx4KCkoZikpKTtjYXNlIDE5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0LGUscil7cmV0dXJuIHMuYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJjb3B5XCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe3JldHVybiBGdCh0LGUpP3RoaXMuY29weUZvbGRlcih0LGUscik6TXQodCxlKT90aGlzLmNvcHlGaWxlKHQsZSxyKTp2b2lkIHF0KG5ldyBFcnJvcihcIkNhbm5vdCBjb3B5IGZyb20gYSBmb2xkZXIgdXJsIHRvIGEgZmlsZSB1cmwgb3IgdmljZSB2ZXJzYVwiKSl9fSx7a2V5OlwiX2RlbGV0ZUl0ZW1XaXRoTGlua3NcIix2YWx1ZToobz1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSl7dmFyIHI7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5nZXRJdGVtTGlua3MoZSx7bGlua3M6WXQuSU5DTFVERX0pO2Nhc2UgMjppZighKHI9dC5zZW50KS5tZXRhKXt0Lm5leHQ9NjticmVha31yZXR1cm4gdC5uZXh0PTYsdGhpcy5fZGVsZXRlSXRlbVdpdGhMaW5rcyhyLm1ldGEpO2Nhc2UgNjppZighci5hY2wpe3QubmV4dD05O2JyZWFrfXJldHVybiB0Lm5leHQ9OSx0aGlzLmRlbGV0ZShyLmFjbCk7Y2FzZSA5OnJldHVybiB0LmFicnVwdChcInJldHVyblwiLHRoaXMuZGVsZXRlKGUpKTtjYXNlIDEwOmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gby5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcImRlbGV0ZUZvbGRlckNvbnRlbnRzXCIsdmFsdWU6KG49YSgpKGkuYS5tYXJrKChmdW5jdGlvbiB0KGUpe3ZhciByLG4sbyxhPXRoaXM7cmV0dXJuIGkuYS53cmFwKChmdW5jdGlvbih0KXtmb3IoOzspc3dpdGNoKHQucHJldj10Lm5leHQpe2Nhc2UgMDpyZXR1cm4gdC5uZXh0PTIsdGhpcy5yZWFkRm9sZGVyKGUpO2Nhc2UgMjpyZXR1cm4gcj10LnNlbnQsbj1yLmZvbGRlcnMsbz1yLmZpbGVzLHQuYWJydXB0KFwicmV0dXJuXCIsVXQoW10uY29uY2F0KHgoKShuLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9dC51cmw7cmV0dXJuIGEuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSl9KSkpLHgoKShvLm1hcCgoZnVuY3Rpb24odCl7dmFyIGU9dC51cmw7cmV0dXJuIGEuX2RlbGV0ZUl0ZW1XaXRoTGlua3MoZSl9KSkpKSkpO2Nhc2UgNjpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCl7cmV0dXJuIG4uYXBwbHkodGhpcyxhcmd1bWVudHMpfSl9LHtrZXk6XCJkZWxldGVGb2xkZXJSZWN1cnNpdmVseVwiLHZhbHVlOihyPWEoKShpLmEubWFyaygoZnVuY3Rpb24gdChlKXt2YXIgcjtyZXR1cm4gaS5hLndyYXAoKGZ1bmN0aW9uKHQpe2Zvcig7Oylzd2l0Y2godC5wcmV2PXQubmV4dCl7Y2FzZSAwOnJldHVybiB0Lm5leHQ9Mix0aGlzLmRlbGV0ZUZvbGRlckNvbnRlbnRzKGUpO2Nhc2UgMjpyZXR1cm4gcj10LnNlbnQsdC50MD1yLHQubmV4dD02LHRoaXMuX2RlbGV0ZUl0ZW1XaXRoTGlua3MoZSk7Y2FzZSA2OnJldHVybiB0LnQxPXQuc2VudCx0LnQwLnVuc2hpZnQuY2FsbCh0LnQwLHQudDEpLHQuYWJydXB0KFwicmV0dXJuXCIscik7Y2FzZSA5OmNhc2VcImVuZFwiOnJldHVybiB0LnN0b3AoKX19KSx0LHRoaXMpfSkpKSxmdW5jdGlvbih0KXtyZXR1cm4gci5hcHBseSh0aGlzLGFyZ3VtZW50cyl9KX0se2tleTpcIm1vdmVcIix2YWx1ZTooZT1hKCkoaS5hLm1hcmsoKGZ1bmN0aW9uIHQoZSxyLG4pe3ZhciBvO3JldHVybiBpLmEud3JhcCgoZnVuY3Rpb24odCl7Zm9yKDs7KXN3aXRjaCh0LnByZXY9dC5uZXh0KXtjYXNlIDA6cmV0dXJuIHQubmV4dD0yLHRoaXMuY29weShlLHIsbik7Y2FzZSAyOmlmKG89dC5zZW50LCFGdChlKSl7dC5uZXh0PTg7YnJlYWt9cmV0dXJuIHQubmV4dD02LHRoaXMuZGVsZXRlRm9sZGVyUmVjdXJzaXZlbHkoZSk7Y2FzZSA2OnQubmV4dD0xMDticmVhaztjYXNlIDg6cmV0dXJuIHQubmV4dD0xMCx0aGlzLl9kZWxldGVJdGVtV2l0aExpbmtzKGUpO2Nhc2UgMTA6cmV0dXJuIHQuYWJydXB0KFwicmV0dXJuXCIsbyk7Y2FzZSAxMTpjYXNlXCJlbmRcIjpyZXR1cm4gdC5zdG9wKCl9fSksdCx0aGlzKX0pKSksZnVuY3Rpb24odCxyLG4pe3JldHVybiBlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0pfSx7a2V5OlwicmVuYW1lXCIsdmFsdWU6ZnVuY3Rpb24odCxlLHIpe3ZhciBuPUF0KHQpK2UrKEZ0KHQpP1wiL1wiOlwiXCIpO3JldHVybiB0aGlzLm1vdmUodCxuLHIpfX1dKSx0fSgpKSx0ZT1qdC5GZXRjaEVycm9yLGVlPWp0LlNpbmdsZVJlc3BvbnNlRXJyb3I7WHQuRmV0Y2hFcnJvcj10ZSxYdC5TaW5nbGVSZXNwb25zZUVycm9yPWVlLFh0LkxJTktTPVl0LFh0Lk1FUkdFPXp0O2UuZGVmYXVsdD1YdH1dKS5kZWZhdWx0fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtZmlsZS1jbGllbnQuYnVuZGxlLmpzLm1hcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///57\n')},function(module,exports,__webpack_require__){eval("var DataFactory = __webpack_require__(87)\n\nmodule.exports = DataFactory\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvaW5kZXguanM/OWI5MiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFvQjs7QUFFOUMiLCJmaWxlIjoiNTguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGF0YUZhY3RvcnkgPSByZXF1aXJlKCcuL2xpYi9kYXRhLWZhY3RvcnknKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFGYWN0b3J5XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///58\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* WEBPACK VAR INJECTION */(function(setImmediate, Buffer) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return N3Lexer; });\n/* harmony import */ var _IRIs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);\n// **N3Lexer** tokenizes N3 documents.\n\nconst { xsd } = _IRIs__WEBPACK_IMPORTED_MODULE_0__[/* default */ \"a\"];\n\nconst { fromCharCode } = String;\n\n// Regular expression and replacement string to escape N3 strings.\n// Note how we catch invalid unicode sequences separately (they will trigger an error).\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\[uU]|\\\\(.)/g;\nvar escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nvar illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nvar lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nvar invalidRegExp = /$0^/;\n\n// ## Constructor\nclass N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s()\\[\\]\\{\\}\"'<])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (var key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    var input = this._input, outputComments = this._comments;\n    while (true) {\n      // Count and skip whitespace lines\n      var whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (outputComments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (outputComments && (comment = this._comment.exec(input)))\n            callback(null, { line: this._line, type: 'comment', value: comment[1], prefix: '' });\n          callback(input = null, { line: this._line, type: 'eof', value: '', prefix: '' });\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      var line = this._line, type = '', value = '', prefix = '',\n          firstChar = input[0], match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=')\n          type = 'inverse', matchLength = 2, value = '>';\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(input + ' ')))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(input + ' '))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(input + ' ')))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      var token = { line: line, type: type, value: value, prefix: prefix };\n      callback(null, token);\n      this.previousToken = token;\n      this._previousMarker = type;\n      // Advance to next part to tokenize\n      input = input.substr(matchLength || match[0].length, input.length);\n    }\n\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    try {\n      return item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {\n        var charCode;\n        if (unicode4) {\n          charCode = parseInt(unicode4, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n          return fromCharCode(charCode);\n        }\n        else if (unicode8) {\n          charCode = parseInt(unicode8, 16);\n          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance\n          if (charCode <= 0xFFFF) return fromCharCode(charCode);\n          return fromCharCode(0xD800 + ((charCode -= 0x10000) / 0x400), 0xDC00 + (charCode & 0x3FF));\n        }\n        else {\n          var replacement = escapeReplacements[escapedChar];\n          if (!replacement)\n            throw new Error();\n          return replacement;\n        }\n      });\n    }\n    catch (error) { return null; }\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    var err = new Error('Unexpected \"' + issue + '\" on line ' + this._line + '.');\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    var self = this;\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = input;\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        setImmediate(function () { self._tokenizeToEnd(callback, true); });\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        var tokens = [], error;\n        this._tokenizeToEnd(function (e, t) { e ? (error = e) : tokens.push(t); }, true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._input = '';\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', function (data) {\n        if (self._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (self._pendingBuffer) {\n            data = Buffer.concat([self._pendingBuffer, data]);\n            self._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            self._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            self._input += data;\n            self._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', function () {\n        if (self._input !== null)\n          self._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(51).setImmediate, __webpack_require__(9).Buffer))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbjMvc3JjL04zTGV4ZXIuanM/ZjNiZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDZ0M7QUFDaEMsT0FBTyxNQUFNLEdBQUcscURBQVU7O0FBRTFCLE9BQU8sZUFBZTs7QUFFdEI7QUFDQTtBQUNBLHNDQUFzQyxFQUFFLGtCQUFrQixFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7QUFDQTtBQUNBLHdDQUF3QyxFQUFFOztBQUUxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0IsOEJBQThCO0FBQ2xGLCtDQUErQyxFQUFFLGtCQUFrQixpQ0FBaUM7QUFDcEcsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDBrQkFBMGtCLEVBQUUsVUFBVSxtTkFBbU4sRUFBRSxVQUFVLCtNQUErTSxFQUFFLFVBQVUsaUNBQWlDLGNBQWMsRUFBRTtBQUNqa0MsNllBQTZZLGNBQWMsRUFBRTtBQUM3WiwwWkFBMFosWUFBWSxFQUFFO0FBQ3hhLCtFQUErRSxZQUFZLEVBQUU7QUFDN0YsMkNBQTJDLFdBQVcsRUFBRTtBQUN4RDtBQUNBO0FBQ0EsNkNBQTZDLEVBQUU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtRUFBbUU7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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a0MsRUFBRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI1OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vICoqTjNMZXhlcioqIHRva2VuaXplcyBOMyBkb2N1bWVudHMuXG5pbXBvcnQgbmFtZXNwYWNlcyBmcm9tICcuL0lSSXMnO1xuY29uc3QgeyB4c2QgfSA9IG5hbWVzcGFjZXM7XG5cbmNvbnN0IHsgZnJvbUNoYXJDb2RlIH0gPSBTdHJpbmc7XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbiBhbmQgcmVwbGFjZW1lbnQgc3RyaW5nIHRvIGVzY2FwZSBOMyBzdHJpbmdzLlxuLy8gTm90ZSBob3cgd2UgY2F0Y2ggaW52YWxpZCB1bmljb2RlIHNlcXVlbmNlcyBzZXBhcmF0ZWx5ICh0aGV5IHdpbGwgdHJpZ2dlciBhbiBlcnJvcikuXG52YXIgZXNjYXBlU2VxdWVuY2UgPSAvXFxcXHUoW2EtZkEtRjAtOV17NH0pfFxcXFxVKFthLWZBLUYwLTldezh9KXxcXFxcW3VVXXxcXFxcKC4pL2c7XG52YXIgZXNjYXBlUmVwbGFjZW1lbnRzID0ge1xuICAnXFxcXCc6ICdcXFxcJywgXCInXCI6IFwiJ1wiLCAnXCInOiAnXCInLFxuICAnbic6ICdcXG4nLCAncic6ICdcXHInLCAndCc6ICdcXHQnLCAnZic6ICdcXGYnLCAnYic6ICdcXGInLFxuICAnXyc6ICdfJywgJ34nOiAnficsICcuJzogJy4nLCAnLSc6ICctJywgJyEnOiAnIScsICckJzogJyQnLCAnJic6ICcmJyxcbiAgJygnOiAnKCcsICcpJzogJyknLCAnKic6ICcqJywgJysnOiAnKycsICcsJzogJywnLCAnOyc6ICc7JywgJz0nOiAnPScsXG4gICcvJzogJy8nLCAnPyc6ICc/JywgJyMnOiAnIycsICdAJzogJ0AnLCAnJSc6ICclJyxcbn07XG52YXIgaWxsZWdhbElyaUNoYXJzID0gL1tcXHgwMC1cXHgyMDw+XFxcXFwiXFx7XFx9XFx8XFxeXFxgXS87XG5cbnZhciBsaW5lTW9kZVJlZ0V4cHMgPSB7XG4gIF9pcmk6IHRydWUsXG4gIF91bmVzY2FwZWRJcmk6IHRydWUsXG4gIF9zaW1wbGVRdW90ZWRTdHJpbmc6IHRydWUsXG4gIF9sYW5nY29kZTogdHJ1ZSxcbiAgX2JsYW5rOiB0cnVlLFxuICBfbmV3bGluZTogdHJ1ZSxcbiAgX2NvbW1lbnQ6IHRydWUsXG4gIF93aGl0ZXNwYWNlOiB0cnVlLFxuICBfZW5kT2ZGaWxlOiB0cnVlLFxufTtcbnZhciBpbnZhbGlkUmVnRXhwID0gLyQwXi87XG5cbi8vICMjIENvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOM0xleGVyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIC8vICMjIFJlZ3VsYXIgZXhwcmVzc2lvbnNcbiAgICAvLyBJdCdzIHNsaWdodGx5IGZhc3RlciB0byBoYXZlIHRoZXNlIGFzIHByb3BlcnRpZXMgdGhhbiBhcyBpbi1zY29wZSB2YXJpYWJsZXNcbiAgICB0aGlzLl9pcmkgPSAvXjwoKD86W14gPD57fVxcXFxdfFxcXFxbdVVdKSspPlsgXFx0XSovOyAvLyBJUkkgd2l0aCBlc2NhcGUgc2VxdWVuY2VzOyBuZWVkcyBzYW5pdHkgY2hlY2sgYWZ0ZXIgdW5lc2NhcGluZ1xuICAgIHRoaXMuX3VuZXNjYXBlZElyaSA9IC9ePChbXlxceDAwLVxceDIwPD5cXFxcXCJcXHtcXH1cXHxcXF5cXGBdKik+WyBcXHRdKi87IC8vIElSSSB3aXRob3V0IGVzY2FwZSBzZXF1ZW5jZXM7IG5vIHVuZXNjYXBpbmdcbiAgICB0aGlzLl9zaW1wbGVRdW90ZWRTdHJpbmcgPSAvXlwiKFteXCJcXFxcXFxyXFxuXSopXCIoPz1bXlwiXSkvOyAvLyBzdHJpbmcgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgdGhpcy5fc2ltcGxlQXBvc3Ryb3BoZVN0cmluZyA9IC9eJyhbXidcXFxcXFxyXFxuXSopJyg/PVteJ10pLztcbiAgICB0aGlzLl9sYW5nY29kZSA9IC9eQChbYS16XSsoPzotW2EtejAtOV0rKSopKD89W15hLXowLTlcXC1dKS9pO1xuICAgIHRoaXMuX3ByZWZpeCA9IC9eKCg/OltBLVphLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopPzooPz1bI1xcczxdKS87XG4gICAgdGhpcy5fcHJlZml4ZWQgPSAvXigoPzpbQS1aYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkoPzpcXC4/W1xcLTAtOUEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKT86KCg/Oig/OlswLTpBLVpfYS16XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyZmZcXHUwMzcwLVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXXwlWzAtOWEtZkEtRl17Mn18XFxcXFshIy1cXC87PT9cXC1AX35dKSg/Oig/OltcXC5cXC0wLTpBLVpfYS16XFx4YjdcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl18JVswLTlhLWZBLUZdezJ9fFxcXFxbISMtXFwvOz0/XFwtQF9+XSkqKD86W1xcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXXwlWzAtOWEtZkEtRl17Mn18XFxcXFshIy1cXC87PT9cXC1AX35dKSk/KT8pKD86WyBcXHRdK3woPz1cXC4/Wyw7IVxcXlxccyMoKVxcW1xcXVxce1xcfVwiJzxdKSkvO1xuICAgIHRoaXMuX3ZhcmlhYmxlID0gL15cXD8oPzooPzpbQS1aX2EtelxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmZmXFx1MDM3MC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDcwLVxcdTIxOGZcXHUyYzAwLVxcdTJmZWZcXHUzMDAxLVxcdWQ3ZmZcXHVmOTAwLVxcdWZkY2ZcXHVmZGYwLVxcdWZmZmRdfFtcXHVkODAwLVxcdWRiN2ZdW1xcdWRjMDAtXFx1ZGZmZl0pKD86W1xcLTAtOkEtWl9hLXpcXHhiN1xceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMzdkXFx1MDM3Zi1cXHUxZmZmXFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNzAtXFx1MjE4ZlxcdTJjMDAtXFx1MmZlZlxcdTMwMDEtXFx1ZDdmZlxcdWY5MDAtXFx1ZmRjZlxcdWZkZjAtXFx1ZmZmZF18W1xcdWQ4MDAtXFx1ZGI3Zl1bXFx1ZGMwMC1cXHVkZmZmXSkqKSg/PVsuLDshXFxeXFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLztcbiAgICB0aGlzLl9ibGFuayA9IC9eXzooKD86WzAtOUEtWl9hLXpcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJmZlxcdTAzNzAtXFx1MDM3ZFxcdTAzN2YtXFx1MWZmZlxcdTIwMGNcXHUyMDBkXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSg/OlxcLj9bXFwtMC05QS1aX2EtelxceGI3XFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAzN2RcXHUwMzdmLVxcdTFmZmZcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA3MC1cXHUyMThmXFx1MmMwMC1cXHUyZmVmXFx1MzAwMS1cXHVkN2ZmXFx1ZjkwMC1cXHVmZGNmXFx1ZmRmMC1cXHVmZmZkXXxbXFx1ZDgwMC1cXHVkYjdmXVtcXHVkYzAwLVxcdWRmZmZdKSopKD86WyBcXHRdK3woPz1cXC4/Wyw7OlxccyMoKVxcW1xcXVxce1xcfVwiJzxdKSkvO1xuICAgIHRoaXMuX251bWJlciA9IC9eW1xcLStdPyg/OihcXGQrXFwuXFxkKnxcXC4/XFxkKylbZUVdW1xcLStdP3xcXGQqKFxcLik/KVxcZCsoPz1cXC4/Wyw7OlxccyMoKVxcW1xcXVxce1xcfVwiJzxdKS87XG4gICAgdGhpcy5fYm9vbGVhbiA9IC9eKD86dHJ1ZXxmYWxzZSkoPz1bLiw7XFxzIygpXFxbXFxdXFx7XFx9XCInPF0pLztcbiAgICB0aGlzLl9rZXl3b3JkID0gL15AW2Etel0rKD89W1xccyM8Ol0pL2k7XG4gICAgdGhpcy5fc3BhcnFsS2V5d29yZCA9IC9eKD86UFJFRklYfEJBU0V8R1JBUEgpKD89W1xccyM8XSkvaTtcbiAgICB0aGlzLl9zaG9ydFByZWRpY2F0ZXMgPSAvXmEoPz1bXFxzKClcXFtcXF1cXHtcXH1cIic8XSkvO1xuICAgIHRoaXMuX25ld2xpbmUgPSAvXlsgXFx0XSooPzojW15cXG5cXHJdKik/KD86XFxyXFxufFxcbnxcXHIpWyBcXHRdKi87XG4gICAgdGhpcy5fY29tbWVudCA9IC8jKFteXFxuXFxyXSopLztcbiAgICB0aGlzLl93aGl0ZXNwYWNlID0gL15bIFxcdF0rLztcbiAgICB0aGlzLl9lbmRPZkZpbGUgPSAvXig/OiNbXlxcblxccl0qKT8kLztcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIC8vIEluIGxpbmUgbW9kZSAoTi1UcmlwbGVzIG9yIE4tUXVhZHMpLCBvbmx5IHNpbXBsZSBmZWF0dXJlcyBtYXkgYmUgcGFyc2VkXG4gICAgaWYgKHRoaXMuX2xpbmVNb2RlID0gISFvcHRpb25zLmxpbmVNb2RlKSB7XG4gICAgICB0aGlzLl9uM01vZGUgPSBmYWxzZTtcbiAgICAgIC8vIERvbid0IHRva2VuaXplIHNwZWNpYWwgbGl0ZXJhbHNcbiAgICAgIGZvciAodmFyIGtleSBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBsaW5lTW9kZVJlZ0V4cHMpICYmIHRoaXNba2V5XSBpbnN0YW5jZW9mIFJlZ0V4cClcbiAgICAgICAgICB0aGlzW2tleV0gPSBpbnZhbGlkUmVnRXhwO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBXaGVuIG5vdCBpbiBsaW5lIG1vZGUsIGVuYWJsZSBOMyBmdW5jdGlvbmFsaXR5IGJ5IGRlZmF1bHRcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX24zTW9kZSA9IG9wdGlvbnMubjMgIT09IGZhbHNlO1xuICAgIH1cbiAgICAvLyBEb24ndCBvdXRwdXQgY29tbWVudCB0b2tlbnMgYnkgZGVmYXVsdFxuICAgIHRoaXMuX2NvbW1lbnRzID0gISFvcHRpb25zLmNvbW1lbnRzO1xuICAgIC8vIENhY2hlIHRoZSBsYXN0IHRlc3RlZCBjbG9zaW5nIHBvc2l0aW9uIG9mIGxvbmcgbGl0ZXJhbHNcbiAgICB0aGlzLl9saXRlcmFsQ2xvc2luZ1BvcyA9IDA7XG4gIH1cblxuICAvLyAjIyBQcml2YXRlIG1ldGhvZHNcblxuICAvLyAjIyMgYF90b2tlbml6ZVRvRW5kYCB0b2tlbml6ZXMgYXMgZm9yIGFzIHBvc3NpYmxlLCBlbWl0dGluZyB0b2tlbnMgdGhyb3VnaCB0aGUgY2FsbGJhY2tcbiAgX3Rva2VuaXplVG9FbmQoY2FsbGJhY2ssIGlucHV0RmluaXNoZWQpIHtcbiAgICAvLyBDb250aW51ZSBwYXJzaW5nIGFzIGZhciBhcyBwb3NzaWJsZTsgdGhlIGxvb3Agd2lsbCByZXR1cm4gZXZlbnR1YWxseVxuICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0LCBvdXRwdXRDb21tZW50cyA9IHRoaXMuX2NvbW1lbnRzO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBDb3VudCBhbmQgc2tpcCB3aGl0ZXNwYWNlIGxpbmVzXG4gICAgICB2YXIgd2hpdGVTcGFjZU1hdGNoLCBjb21tZW50O1xuICAgICAgd2hpbGUgKHdoaXRlU3BhY2VNYXRjaCA9IHRoaXMuX25ld2xpbmUuZXhlYyhpbnB1dCkpIHtcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBjb21tZW50XG4gICAgICAgIGlmIChvdXRwdXRDb21tZW50cyAmJiAoY29tbWVudCA9IHRoaXMuX2NvbW1lbnQuZXhlYyh3aGl0ZVNwYWNlTWF0Y2hbMF0pKSlcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGxpbmU6IHRoaXMuX2xpbmUsIHR5cGU6ICdjb21tZW50JywgdmFsdWU6IGNvbW1lbnRbMV0sIHByZWZpeDogJycgfSk7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIGlucHV0XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKHdoaXRlU3BhY2VNYXRjaFswXS5sZW5ndGgsIGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2xpbmUrKztcbiAgICAgIH1cbiAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSBvbiBjdXJyZW50IGxpbmVcbiAgICAgIGlmICghd2hpdGVTcGFjZU1hdGNoICYmICh3aGl0ZVNwYWNlTWF0Y2ggPSB0aGlzLl93aGl0ZXNwYWNlLmV4ZWMoaW5wdXQpKSlcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zdWJzdHIod2hpdGVTcGFjZU1hdGNoWzBdLmxlbmd0aCwgaW5wdXQubGVuZ3RoKTtcblxuICAgICAgLy8gU3RvcCBmb3Igbm93IGlmIHdlJ3JlIGF0IHRoZSBlbmRcbiAgICAgIGlmICh0aGlzLl9lbmRPZkZpbGUudGVzdChpbnB1dCkpIHtcbiAgICAgICAgLy8gSWYgdGhlIGlucHV0IGlzIGZpbmlzaGVkLCBlbWl0IEVPRlxuICAgICAgICBpZiAoaW5wdXRGaW5pc2hlZCkge1xuICAgICAgICAgIC8vIFRyeSB0byBmaW5kIGEgZmluYWwgY29tbWVudFxuICAgICAgICAgIGlmIChvdXRwdXRDb21tZW50cyAmJiAoY29tbWVudCA9IHRoaXMuX2NvbW1lbnQuZXhlYyhpbnB1dCkpKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBsaW5lOiB0aGlzLl9saW5lLCB0eXBlOiAnY29tbWVudCcsIHZhbHVlOiBjb21tZW50WzFdLCBwcmVmaXg6ICcnIH0pO1xuICAgICAgICAgIGNhbGxiYWNrKGlucHV0ID0gbnVsbCwgeyBsaW5lOiB0aGlzLl9saW5lLCB0eXBlOiAnZW9mJywgdmFsdWU6ICcnLCBwcmVmaXg6ICcnIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgfVxuXG4gICAgICAvLyBMb29rIGZvciBzcGVjaWZpYyB0b2tlbiB0eXBlcyBiYXNlZCBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gICAgICB2YXIgbGluZSA9IHRoaXMuX2xpbmUsIHR5cGUgPSAnJywgdmFsdWUgPSAnJywgcHJlZml4ID0gJycsXG4gICAgICAgICAgZmlyc3RDaGFyID0gaW5wdXRbMF0sIG1hdGNoID0gbnVsbCwgbWF0Y2hMZW5ndGggPSAwLCBpbmNvbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAgIHN3aXRjaCAoZmlyc3RDaGFyKSB7XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgLy8gV2UgbmVlZCBhdCBsZWFzdCAzIHRva2VucyBsb29rYWhlYWQgdG8gZGlzdGluZ3Vpc2ggXl48SVJJPiBhbmQgXl5wcmU6Zml4ZWRcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA8IDMpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIHR5cGVcbiAgICAgICAgZWxzZSBpZiAoaW5wdXRbMV0gPT09ICdeJykge1xuICAgICAgICAgIHRoaXMuX3ByZXZpb3VzTWFya2VyID0gJ15eJztcbiAgICAgICAgICAvLyBNb3ZlIHRvIHR5cGUgSVJJIG9yIHByZWZpeGVkIG5hbWVcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnN1YnN0cigyKTtcbiAgICAgICAgICBpZiAoaW5wdXRbMF0gIT09ICc8Jykge1xuICAgICAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyB0eXBlLCBpdCBtdXN0IGJlIGEgcGF0aCBleHByZXNzaW9uXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLl9uM01vZGUpIHtcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMTtcbiAgICAgICAgICAgIHR5cGUgPSAnXic7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGwgdGhyb3VnaCBpbiBjYXNlIHRoZSB0eXBlIGlzIGFuIElSSVxuICAgICAgY2FzZSAnPCc6XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGEgZnVsbCBJUkkgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX3VuZXNjYXBlZElyaS5leGVjKGlucHV0KSlcbiAgICAgICAgICB0eXBlID0gJ0lSSScsIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGEgZnVsbCBJUkkgd2l0aCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgIGVsc2UgaWYgKG1hdGNoID0gdGhpcy5faXJpLmV4ZWMoaW5wdXQpKSB7XG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl91bmVzY2FwZShtYXRjaFsxXSk7XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IGlsbGVnYWxJcmlDaGFycy50ZXN0KHZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiByZXBvcnRTeW50YXhFcnJvcih0aGlzKTtcbiAgICAgICAgICB0eXBlID0gJ0lSSSc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBiYWNrd2FyZHMgaW1wbGljYXRpb24gYXJyb3dcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fbjNNb2RlICYmIGlucHV0Lmxlbmd0aCA+IDEgJiYgaW5wdXRbMV0gPT09ICc9JylcbiAgICAgICAgICB0eXBlID0gJ2ludmVyc2UnLCBtYXRjaExlbmd0aCA9IDIsIHZhbHVlID0gJz4nO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXyc6XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGEgYmxhbmsgbm9kZS4gU2luY2UgaXQgY2FuIGNvbnRhaW4gKGJ1dCBub3QgZW5kIHdpdGgpIGEgZG90LFxuICAgICAgICAvLyB3ZSBhbHdheXMgbmVlZCBhIG5vbi1kb3QgY2hhcmFjdGVyIGJlZm9yZSBkZWNpZGluZyBpdCBpcyBhIGJsYW5rIG5vZGUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICBpZiAoKG1hdGNoID0gdGhpcy5fYmxhbmsuZXhlYyhpbnB1dCkpIHx8XG4gICAgICAgICAgICBpbnB1dEZpbmlzaGVkICYmIChtYXRjaCA9IHRoaXMuX2JsYW5rLmV4ZWMoaW5wdXQgKyAnICcpKSlcbiAgICAgICAgICB0eXBlID0gJ2JsYW5rJywgcHJlZml4ID0gJ18nLCB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnXCInOlxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX3NpbXBsZVF1b3RlZFN0cmluZy5leGVjKGlucHV0KSlcbiAgICAgICAgICB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd3JhcHBlZCBpbiB0aHJlZSBwYWlycyBvZiBxdW90ZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgKHsgdmFsdWUsIG1hdGNoTGVuZ3RoIH0gPSB0aGlzLl9wYXJzZUxpdGVyYWwoaW5wdXQpKTtcbiAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcmVwb3J0U3ludGF4RXJyb3IodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoICE9PSBudWxsIHx8IG1hdGNoTGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgdHlwZSA9ICdsaXRlcmFsJztcbiAgICAgICAgICB0aGlzLl9saXRlcmFsQ2xvc2luZ1BvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgXCInXCI6XG4gICAgICAgIGlmICghdGhpcy5fbGluZU1vZGUpIHtcbiAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxpdGVyYWwgd2l0aG91dCBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fc2ltcGxlQXBvc3Ryb3BoZVN0cmluZy5leGVjKGlucHV0KSlcbiAgICAgICAgICAgIHZhbHVlID0gbWF0Y2hbMV07XG4gICAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBsaXRlcmFsIHdyYXBwZWQgaW4gdGhyZWUgcGFpcnMgb2YgcXVvdGVzXG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyB2YWx1ZSwgbWF0Y2hMZW5ndGggfSA9IHRoaXMuX3BhcnNlTGl0ZXJhbChpbnB1dCkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgICByZXR1cm4gcmVwb3J0U3ludGF4RXJyb3IodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCB8fCBtYXRjaExlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgdHlwZSA9ICdsaXRlcmFsJztcbiAgICAgICAgICAgIHRoaXMuX2xpdGVyYWxDbG9zaW5nUG9zID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz8nOlxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHZhcmlhYmxlXG4gICAgICAgIGlmICh0aGlzLl9uM01vZGUgJiYgKG1hdGNoID0gdGhpcy5fdmFyaWFibGUuZXhlYyhpbnB1dCkpKVxuICAgICAgICAgIHR5cGUgPSAndmFyJywgdmFsdWUgPSBtYXRjaFswXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0AnOlxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGxhbmd1YWdlIGNvZGVcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnbGl0ZXJhbCcgJiYgKG1hdGNoID0gdGhpcy5fbGFuZ2NvZGUuZXhlYyhpbnB1dCkpKVxuICAgICAgICAgIHR5cGUgPSAnbGFuZ2NvZGUnLCB2YWx1ZSA9IG1hdGNoWzFdO1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGtleXdvcmRcbiAgICAgICAgZWxzZSBpZiAobWF0Y2ggPSB0aGlzLl9rZXl3b3JkLmV4ZWMoaW5wdXQpKVxuICAgICAgICAgIHR5cGUgPSBtYXRjaFswXTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJy4nOlxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIGRvdCBhcyBwdW5jdHVhdGlvblxuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID09PSAxID8gaW5wdXRGaW5pc2hlZCA6IChpbnB1dFsxXSA8ICcwJyB8fCBpbnB1dFsxXSA+ICc5JykpIHtcbiAgICAgICAgICB0eXBlID0gJy4nO1xuICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsIHRocm91Z2ggdG8gbnVtZXJpY2FsIGNhc2UgKGNvdWxkIGJlIGEgZGVjaW1hbCBkb3QpXG5cbiAgICAgIGNhc2UgJzAnOlxuICAgICAgY2FzZSAnMSc6XG4gICAgICBjYXNlICcyJzpcbiAgICAgIGNhc2UgJzMnOlxuICAgICAgY2FzZSAnNCc6XG4gICAgICBjYXNlICc1JzpcbiAgICAgIGNhc2UgJzYnOlxuICAgICAgY2FzZSAnNyc6XG4gICAgICBjYXNlICc4JzpcbiAgICAgIGNhc2UgJzknOlxuICAgICAgY2FzZSAnKyc6XG4gICAgICBjYXNlICctJzpcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBudW1iZXIuIFNpbmNlIGl0IGNhbiBjb250YWluIChidXQgbm90IGVuZCB3aXRoKSBhIGRvdCxcbiAgICAgICAgLy8gd2UgYWx3YXlzIG5lZWQgYSBub24tZG90IGNoYXJhY3RlciBiZWZvcmUgZGVjaWRpbmcgaXQgaXMgYSBudW1iZXIuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl9udW1iZXIuZXhlYyhpbnB1dCkgfHxcbiAgICAgICAgICAgIGlucHV0RmluaXNoZWQgJiYgKG1hdGNoID0gdGhpcy5fbnVtYmVyLmV4ZWMoaW5wdXQgKyAnICcpKSkge1xuICAgICAgICAgIHR5cGUgPSAnbGl0ZXJhbCcsIHZhbHVlID0gbWF0Y2hbMF07XG4gICAgICAgICAgcHJlZml4ID0gKHR5cGVvZiBtYXRjaFsxXSA9PT0gJ3N0cmluZycgPyB4c2QuZG91YmxlIDpcbiAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBtYXRjaFsyXSA9PT0gJ3N0cmluZycgPyB4c2QuZGVjaW1hbCA6IHhzZC5pbnRlZ2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ0InOlxuICAgICAgY2FzZSAnYic6XG4gICAgICBjYXNlICdwJzpcbiAgICAgIGNhc2UgJ1AnOlxuICAgICAgY2FzZSAnRyc6XG4gICAgICBjYXNlICdnJzpcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYSBTUEFSUUwtc3R5bGUga2V5d29yZFxuICAgICAgICBpZiAobWF0Y2ggPSB0aGlzLl9zcGFycWxLZXl3b3JkLmV4ZWMoaW5wdXQpKVxuICAgICAgICAgIHR5cGUgPSBtYXRjaFswXS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2YnOlxuICAgICAgY2FzZSAndCc6XG4gICAgICAgIC8vIFRyeSB0byBtYXRjaCBhIGJvb2xlYW5cbiAgICAgICAgaWYgKG1hdGNoID0gdGhpcy5fYm9vbGVhbi5leGVjKGlucHV0KSlcbiAgICAgICAgICB0eXBlID0gJ2xpdGVyYWwnLCB2YWx1ZSA9IG1hdGNoWzBdLCBwcmVmaXggPSB4c2QuYm9vbGVhbjtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGluY29uY2x1c2l2ZSA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdhJzpcbiAgICAgICAgLy8gVHJ5IHRvIGZpbmQgYW4gYWJicmV2aWF0ZWQgcHJlZGljYXRlXG4gICAgICAgIGlmIChtYXRjaCA9IHRoaXMuX3Nob3J0UHJlZGljYXRlcy5leGVjKGlucHV0KSlcbiAgICAgICAgICB0eXBlID0gJ2FiYnJldmlhdGlvbicsIHZhbHVlID0gJ2EnO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJz0nOlxuICAgICAgICAvLyBUcnkgdG8gZmluZCBhbiBpbXBsaWNhdGlvbiBhcnJvdyBvciBlcXVhbHMgc2lnblxuICAgICAgICBpZiAodGhpcy5fbjNNb2RlICYmIGlucHV0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0eXBlID0gJ2FiYnJldmlhdGlvbic7XG4gICAgICAgICAgaWYgKGlucHV0WzFdICE9PSAnPicpXG4gICAgICAgICAgICBtYXRjaExlbmd0aCA9IDEsIHZhbHVlID0gJz0nO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIG1hdGNoTGVuZ3RoID0gMiwgdmFsdWUgPSAnPic7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJyEnOlxuICAgICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJywnOlxuICAgICAgY2FzZSAnOyc6XG4gICAgICBjYXNlICdbJzpcbiAgICAgIGNhc2UgJ10nOlxuICAgICAgY2FzZSAnKCc6XG4gICAgICBjYXNlICcpJzpcbiAgICAgIGNhc2UgJ3snOlxuICAgICAgY2FzZSAnfSc6XG4gICAgICAgIGlmICghdGhpcy5fbGluZU1vZGUpIHtcbiAgICAgICAgICBtYXRjaExlbmd0aCA9IDE7XG4gICAgICAgICAgdHlwZSA9IGZpcnN0Q2hhcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5jb25jbHVzaXZlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU29tZSBmaXJzdCBjaGFyYWN0ZXJzIGRvIG5vdCBhbGxvdyBhbiBpbW1lZGlhdGUgZGVjaXNpb24sIHNvIGluc3BlY3QgbW9yZVxuICAgICAgaWYgKGluY29uY2x1c2l2ZSkge1xuICAgICAgICAvLyBUcnkgdG8gZmluZCBhIHByZWZpeFxuICAgICAgICBpZiAoKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnQHByZWZpeCcgfHwgdGhpcy5fcHJldmlvdXNNYXJrZXIgPT09ICdQUkVGSVgnKSAmJlxuICAgICAgICAgICAgKG1hdGNoID0gdGhpcy5fcHJlZml4LmV4ZWMoaW5wdXQpKSlcbiAgICAgICAgICB0eXBlID0gJ3ByZWZpeCcsIHZhbHVlID0gbWF0Y2hbMV0gfHwgJyc7XG4gICAgICAgIC8vIFRyeSB0byBmaW5kIGEgcHJlZml4ZWQgbmFtZS4gU2luY2UgaXQgY2FuIGNvbnRhaW4gKGJ1dCBub3QgZW5kIHdpdGgpIGEgZG90LFxuICAgICAgICAvLyB3ZSBhbHdheXMgbmVlZCBhIG5vbi1kb3QgY2hhcmFjdGVyIGJlZm9yZSBkZWNpZGluZyBpdCBpcyBhIHByZWZpeGVkIG5hbWUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgdHJ5IGluc2VydGluZyBhIHNwYWNlIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0LlxuICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSB0aGlzLl9wcmVmaXhlZC5leGVjKGlucHV0KSkgfHxcbiAgICAgICAgICAgICAgICAgaW5wdXRGaW5pc2hlZCAmJiAobWF0Y2ggPSB0aGlzLl9wcmVmaXhlZC5leGVjKGlucHV0ICsgJyAnKSkpXG4gICAgICAgICAgdHlwZSA9ICdwcmVmaXhlZCcsIHByZWZpeCA9IG1hdGNoWzFdIHx8ICcnLCB2YWx1ZSA9IHRoaXMuX3VuZXNjYXBlKG1hdGNoWzJdKTtcbiAgICAgIH1cblxuICAgICAgLy8gQSB0eXBlIHRva2VuIGlzIHNwZWNpYWw6IGl0IGNhbiBvbmx5IGJlIGVtaXR0ZWQgYWZ0ZXIgYW4gSVJJIG9yIHByZWZpeGVkIG5hbWUgaXMgcmVhZFxuICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzTWFya2VyID09PSAnXl4nKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlICdwcmVmaXhlZCc6IHR5cGUgPSAndHlwZSc7ICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJUkknOiAgICAgIHR5cGUgPSAndHlwZUlSSSc7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAgICAgICAgIHR5cGUgPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBXaGF0IGlmIG5vdGhpbmcgb2YgdGhlIGFib3ZlIHdhcyBmb3VuZD9cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAvLyBXZSBjb3VsZCBiZSBpbiBzdHJlYW1pbmcgbW9kZSwgYW5kIHRoZW4gd2UganVzdCB3YWl0IGZvciBtb3JlIGlucHV0IHRvIGFycml2ZS5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBhIHN5bnRheCBlcnJvciBoYXMgb2NjdXJyZWQgaW4gdGhlIGlucHV0LlxuICAgICAgICAvLyBPbmUgZXhjZXB0aW9uOiBlcnJvciBvbiBhbiB1bmFjY291bnRlZCBsaW5lYnJlYWsgKD0gbm90IGluc2lkZSBhIHRyaXBsZS1xdW90ZWQgbGl0ZXJhbCkuXG4gICAgICAgIGlmIChpbnB1dEZpbmlzaGVkIHx8ICghL14nJyd8XlwiXCJcIi8udGVzdChpbnB1dCkgJiYgL1xcbnxcXHIvLnRlc3QoaW5wdXQpKSlcbiAgICAgICAgICByZXR1cm4gcmVwb3J0U3ludGF4RXJyb3IodGhpcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICByZXR1cm4gdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgIH1cblxuICAgICAgLy8gRW1pdCB0aGUgcGFyc2VkIHRva2VuXG4gICAgICB2YXIgdG9rZW4gPSB7IGxpbmU6IGxpbmUsIHR5cGU6IHR5cGUsIHZhbHVlOiB2YWx1ZSwgcHJlZml4OiBwcmVmaXggfTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbiAgICAgIHRoaXMucHJldmlvdXNUb2tlbiA9IHRva2VuO1xuICAgICAgdGhpcy5fcHJldmlvdXNNYXJrZXIgPSB0eXBlO1xuICAgICAgLy8gQWR2YW5jZSB0byBuZXh0IHBhcnQgdG8gdG9rZW5pemVcbiAgICAgIGlucHV0ID0gaW5wdXQuc3Vic3RyKG1hdGNoTGVuZ3RoIHx8IG1hdGNoWzBdLmxlbmd0aCwgaW5wdXQubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBTaWduYWxzIHRoZSBzeW50YXggZXJyb3IgdGhyb3VnaCB0aGUgY2FsbGJhY2tcbiAgICBmdW5jdGlvbiByZXBvcnRTeW50YXhFcnJvcihzZWxmKSB7IGNhbGxiYWNrKHNlbGYuX3N5bnRheEVycm9yKC9eXFxTKi8uZXhlYyhpbnB1dClbMF0pKTsgfVxuICB9XG5cbiAgLy8gIyMjIGBfdW5lc2NhcGVgIHJlcGxhY2VzIE4zIGVzY2FwZSBjb2RlcyBieSB0aGVpciBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnNcbiAgX3VuZXNjYXBlKGl0ZW0pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGl0ZW0ucmVwbGFjZShlc2NhcGVTZXF1ZW5jZSwgZnVuY3Rpb24gKHNlcXVlbmNlLCB1bmljb2RlNCwgdW5pY29kZTgsIGVzY2FwZWRDaGFyKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZTtcbiAgICAgICAgaWYgKHVuaWNvZGU0KSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBwYXJzZUludCh1bmljb2RlNCwgMTYpO1xuICAgICAgICAgIGlmIChpc05hTihjaGFyQ29kZSkpIHRocm93IG5ldyBFcnJvcigpOyAvLyBjYW4gbmV2ZXIgaGFwcGVuIChyZWdleCksIGJ1dCBoZWxwcyBwZXJmb3JtYW5jZVxuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaWNvZGU4KSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBwYXJzZUludCh1bmljb2RlOCwgMTYpO1xuICAgICAgICAgIGlmIChpc05hTihjaGFyQ29kZSkpIHRocm93IG5ldyBFcnJvcigpOyAvLyBjYW4gbmV2ZXIgaGFwcGVuIChyZWdleCksIGJ1dCBoZWxwcyBwZXJmb3JtYW5jZVxuICAgICAgICAgIGlmIChjaGFyQ29kZSA8PSAweEZGRkYpIHJldHVybiBmcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgICAgICAgIHJldHVybiBmcm9tQ2hhckNvZGUoMHhEODAwICsgKChjaGFyQ29kZSAtPSAweDEwMDAwKSAvIDB4NDAwKSwgMHhEQzAwICsgKGNoYXJDb2RlICYgMHgzRkYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBlc2NhcGVSZXBsYWNlbWVudHNbZXNjYXBlZENoYXJdO1xuICAgICAgICAgIGlmICghcmVwbGFjZW1lbnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgcmV0dXJuIG51bGw7IH1cbiAgfVxuXG4gIC8vICMjIyBgX3BhcnNlTGl0ZXJhbGAgcGFyc2VzIGEgbGl0ZXJhbCBpbnRvIGFuIHVuZXNjYXBlZCB2YWx1ZVxuICBfcGFyc2VMaXRlcmFsKGlucHV0KSB7XG4gICAgLy8gRW5zdXJlIHdlIGhhdmUgZW5vdWdoIGxvb2thaGVhZCB0byBpZGVudGlmeSB0cmlwbGUtcXVvdGVkIHN0cmluZ3NcbiAgICBpZiAoaW5wdXQubGVuZ3RoID49IDMpIHtcbiAgICAgIC8vIElkZW50aWZ5IHRoZSBvcGVuaW5nIHF1b3RlKHMpXG4gICAgICBjb25zdCBvcGVuaW5nID0gaW5wdXQubWF0Y2goL14oPzpcIlwiXCJ8XCJ8JycnfCd8KS8pWzBdO1xuICAgICAgY29uc3Qgb3BlbmluZ0xlbmd0aCA9IG9wZW5pbmcubGVuZ3RoO1xuXG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGNhbmRpZGF0ZSBjbG9zaW5nIHF1b3Rlc1xuICAgICAgbGV0IGNsb3NpbmdQb3MgPSBNYXRoLm1heCh0aGlzLl9saXRlcmFsQ2xvc2luZ1Bvcywgb3BlbmluZ0xlbmd0aCk7XG4gICAgICB3aGlsZSAoKGNsb3NpbmdQb3MgPSBpbnB1dC5pbmRleE9mKG9wZW5pbmcsIGNsb3NpbmdQb3MpKSA+IDApIHtcbiAgICAgICAgLy8gQ291bnQgYmFja3NsYXNoZXMgcmlnaHQgYmVmb3JlIHRoZSBjbG9zaW5nIHF1b3Rlc1xuICAgICAgICBsZXQgYmFja3NsYXNoQ291bnQgPSAwO1xuICAgICAgICB3aGlsZSAoaW5wdXRbY2xvc2luZ1BvcyAtIGJhY2tzbGFzaENvdW50IC0gMV0gPT09ICdcXFxcJylcbiAgICAgICAgICBiYWNrc2xhc2hDb3VudCsrO1xuXG4gICAgICAgIC8vIEFuIGV2ZW4gbnVtYmVyIG9mIGJhY2tzbGFzaGVzIChpbiBwYXJ0aWN1bGFyIDApXG4gICAgICAgIC8vIG1lYW5zIHRoZXNlIGFyZSBhY3R1YWwsIG5vbi1lc2NhcGVkIGNsb3NpbmcgcXVvdGVzXG4gICAgICAgIGlmIChiYWNrc2xhc2hDb3VudCAlIDIgPT09IDApIHtcbiAgICAgICAgICAvLyBFeHRyYWN0IGFuZCB1bmVzY2FwZSB0aGUgdmFsdWVcbiAgICAgICAgICBjb25zdCByYXcgPSBpbnB1dC5zdWJzdHJpbmcob3BlbmluZ0xlbmd0aCwgY2xvc2luZ1Bvcyk7XG4gICAgICAgICAgY29uc3QgbGluZXMgPSByYXcuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLykubGVuZ3RoIC0gMTtcbiAgICAgICAgICBjb25zdCBtYXRjaExlbmd0aCA9IGNsb3NpbmdQb3MgKyBvcGVuaW5nTGVuZ3RoO1xuICAgICAgICAgIC8vIE9ubHkgdHJpcGxlLXF1b3RlZCBzdHJpbmdzIGNhbiBiZSBtdWx0aS1saW5lXG4gICAgICAgICAgaWYgKG9wZW5pbmdMZW5ndGggPT09IDEgJiYgbGluZXMgIT09IDAgfHxcbiAgICAgICAgICAgICAgb3BlbmluZ0xlbmd0aCA9PT0gMyAmJiB0aGlzLl9saW5lTW9kZSlcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIHRoaXMuX2xpbmUgKz0gbGluZXM7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHRoaXMuX3VuZXNjYXBlKHJhdyksIG1hdGNoTGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgY2xvc2luZ1BvcysrO1xuICAgICAgfVxuICAgICAgdGhpcy5fbGl0ZXJhbENsb3NpbmdQb3MgPSBpbnB1dC5sZW5ndGggLSBvcGVuaW5nTGVuZ3RoICsgMTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWU6ICcnLCBtYXRjaExlbmd0aDogMCB9O1xuICB9XG5cbiAgLy8gIyMjIGBfc3ludGF4RXJyb3JgIGNyZWF0ZXMgYSBzeW50YXggZXJyb3IgZm9yIHRoZSBnaXZlbiBpc3N1ZVxuICBfc3ludGF4RXJyb3IoaXNzdWUpIHtcbiAgICB0aGlzLl9pbnB1dCA9IG51bGw7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5leHBlY3RlZCBcIicgKyBpc3N1ZSArICdcIiBvbiBsaW5lICcgKyB0aGlzLl9saW5lICsgJy4nKTtcbiAgICBlcnIuY29udGV4dCA9IHtcbiAgICAgIHRva2VuOiB1bmRlZmluZWQsXG4gICAgICBsaW5lOiB0aGlzLl9saW5lLFxuICAgICAgcHJldmlvdXNUb2tlbjogdGhpcy5wcmV2aW91c1Rva2VuLFxuICAgIH07XG4gICAgcmV0dXJuIGVycjtcbiAgfVxuXG4gIC8vICMjIFB1YmxpYyBtZXRob2RzXG5cbiAgLy8gIyMjIGB0b2tlbml6ZWAgc3RhcnRzIHRoZSB0cmFuc2Zvcm1hdGlvbiBvZiBhbiBOMyBkb2N1bWVudCBpbnRvIGFuIGFycmF5IG9mIHRva2Vucy5cbiAgLy8gVGhlIGlucHV0IGNhbiBiZSBhIHN0cmluZyBvciBhIHN0cmVhbS5cbiAgdG9rZW5pemUoaW5wdXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX2xpbmUgPSAxO1xuXG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGEgc3RyaW5nLCBjb250aW51b3VzbHkgZW1pdCB0b2tlbnMgdGhyb3VnaCB0aGUgY2FsbGJhY2sgdW50aWwgdGhlIGVuZFxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9pbnB1dCA9IGlucHV0O1xuICAgICAgLy8gSWYgYSBjYWxsYmFjayB3YXMgcGFzc2VkLCBhc3luY2hyb25vdXNseSBjYWxsIGl0XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKVxuICAgICAgICBzZXRJbW1lZGlhdGUoZnVuY3Rpb24gKCkgeyBzZWxmLl90b2tlbml6ZVRvRW5kKGNhbGxiYWNrLCB0cnVlKTsgfSk7XG4gICAgICAvLyBJZiBubyBjYWxsYmFjayB3YXMgcGFzc2VkLCB0b2tlbml6ZSBzeW5jaHJvbm91c2x5IGFuZCByZXR1cm5cbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdG9rZW5zID0gW10sIGVycm9yO1xuICAgICAgICB0aGlzLl90b2tlbml6ZVRvRW5kKGZ1bmN0aW9uIChlLCB0KSB7IGUgPyAoZXJyb3IgPSBlKSA6IHRva2Vucy5wdXNoKHQpOyB9LCB0cnVlKTtcbiAgICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gT3RoZXJ3aXNlLCB0aGUgaW5wdXQgbXVzdCBiZSBhIHN0cmVhbVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXQgPSAnJztcbiAgICAgIHRoaXMuX3BlbmRpbmdCdWZmZXIgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dC5zZXRFbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgaW5wdXQuc2V0RW5jb2RpbmcoJ3V0ZjgnKTtcbiAgICAgIC8vIEFkZHMgdGhlIGRhdGEgY2h1bmsgdG8gdGhlIGJ1ZmZlciBhbmQgcGFyc2VzIGFzIGZhciBhcyBwb3NzaWJsZVxuICAgICAgaW5wdXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoc2VsZi5faW5wdXQgIT09IG51bGwgJiYgZGF0YS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAvLyBQcmVwZW5kIGFueSBwcmV2aW91cyBwZW5kaW5nIHdyaXRlc1xuICAgICAgICAgIGlmIChzZWxmLl9wZW5kaW5nQnVmZmVyKSB7XG4gICAgICAgICAgICBkYXRhID0gQnVmZmVyLmNvbmNhdChbc2VsZi5fcGVuZGluZ0J1ZmZlciwgZGF0YV0pO1xuICAgICAgICAgICAgc2VsZi5fcGVuZGluZ0J1ZmZlciA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEhvbGQgaWYgdGhlIGJ1ZmZlciBlbmRzIGluIGFuIGluY29tcGxldGUgdW5pY29kZSBzZXF1ZW5jZVxuICAgICAgICAgIGlmIChkYXRhW2RhdGEubGVuZ3RoIC0gMV0gJiAweDgwKSB7XG4gICAgICAgICAgICBzZWxmLl9wZW5kaW5nQnVmZmVyID0gZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCB0b2tlbml6ZSBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuX2lucHV0ICs9IGRhdGE7XG4gICAgICAgICAgICBzZWxmLl90b2tlbml6ZVRvRW5kKGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIFBhcnNlcyB1bnRpbCB0aGUgZW5kXG4gICAgICBpbnB1dC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5faW5wdXQgIT09IG51bGwpXG4gICAgICAgICAgc2VsZi5fdG9rZW5pemVUb0VuZChjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIGlucHV0Lm9uKCdlcnJvcicsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///59\n")},function(module,exports,__webpack_require__){eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = __webpack_require__(31).EventEmitter;\nvar inherits = __webpack_require__(7);\n\ninherits(Stream, EE);\nStream.Readable = __webpack_require__(32);\nStream.Writable = __webpack_require__(103);\nStream.Duplex = __webpack_require__(104);\nStream.Transform = __webpack_require__(105);\nStream.PassThrough = __webpack_require__(106);\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanM/ZDQ4NSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFNBQVMsbUJBQU8sQ0FBQyxFQUFRO0FBQ3pCLGVBQWUsbUJBQU8sQ0FBQyxDQUFVOztBQUVqQztBQUNBLGtCQUFrQixtQkFBTyxDQUFDLEVBQTZCO0FBQ3ZELGtCQUFrQixtQkFBTyxDQUFDLEdBQTZCO0FBQ3ZELGdCQUFnQixtQkFBTyxDQUFDLEdBQTJCO0FBQ25ELG1CQUFtQixtQkFBTyxDQUFDLEdBQThCO0FBQ3pELHFCQUFxQixtQkFBTyxDQUFDLEdBQWdDOztBQUU3RDtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI2MC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///60\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzcz8xOGU2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjYxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///61\n")},function(module,exports,__webpack_require__){eval("// extracted by mini-css-extract-plugin//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvc3R5bGVzLmNzcz9kYjFlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjYyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///62\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar addToUnscopables = __webpack_require__(64);\nvar step = __webpack_require__(67);\nvar Iterators = __webpack_require__(25);\nvar toIObject = __webpack_require__(26);\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = __webpack_require__(69)(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5hcnJheS5pdGVyYXRvci5qcz9jYWRmIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdUJBQXVCLG1CQUFPLENBQUMsRUFBdUI7QUFDdEQsV0FBVyxtQkFBTyxDQUFDLEVBQWM7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlOztBQUV2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBTyxDQUFDLEVBQWdCO0FBQ3pDLGdDQUFnQztBQUNoQyxjQUFjO0FBQ2QsaUJBQWlCO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiI2My5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi9fYWRkLXRvLXVuc2NvcGFibGVzJyk7XG52YXIgc3RlcCA9IHJlcXVpcmUoJy4vX2l0ZXItc3RlcCcpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4vX2l0ZXJhdG9ycycpO1xudmFyIHRvSU9iamVjdCA9IHJlcXVpcmUoJy4vX3RvLWlvYmplY3QnKTtcblxuLy8gMjIuMS4zLjQgQXJyYXkucHJvdG90eXBlLmVudHJpZXMoKVxuLy8gMjIuMS4zLjEzIEFycmF5LnByb3RvdHlwZS5rZXlzKClcbi8vIDIyLjEuMy4yOSBBcnJheS5wcm90b3R5cGUudmFsdWVzKClcbi8vIDIyLjEuMy4zMCBBcnJheS5wcm90b3R5cGVbQEBpdGVyYXRvcl0oKVxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19pdGVyLWRlZmluZScpKEFycmF5LCAnQXJyYXknLCBmdW5jdGlvbiAoaXRlcmF0ZWQsIGtpbmQpIHtcbiAgdGhpcy5fdCA9IHRvSU9iamVjdChpdGVyYXRlZCk7IC8vIHRhcmdldFxuICB0aGlzLl9pID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbmV4dCBpbmRleFxuICB0aGlzLl9rID0ga2luZDsgICAgICAgICAgICAgICAgLy8ga2luZFxuLy8gMjIuMS41LjIuMSAlQXJyYXlJdGVyYXRvclByb3RvdHlwZSUubmV4dCgpXG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBPID0gdGhpcy5fdDtcbiAgdmFyIGtpbmQgPSB0aGlzLl9rO1xuICB2YXIgaW5kZXggPSB0aGlzLl9pKys7XG4gIGlmICghTyB8fCBpbmRleCA+PSBPLmxlbmd0aCkge1xuICAgIHRoaXMuX3QgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHN0ZXAoMSk7XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4gc3RlcCgwLCBpbmRleCk7XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4gc3RlcCgwLCBPW2luZGV4XSk7XG4gIHJldHVybiBzdGVwKDAsIFtpbmRleCwgT1tpbmRleF1dKTtcbn0sICd2YWx1ZXMnKTtcblxuLy8gYXJndW1lbnRzTGlzdFtAQGl0ZXJhdG9yXSBpcyAlQXJyYXlQcm90b192YWx1ZXMlICg5LjQuNC42LCA5LjQuNC43KVxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuYWRkVG9VbnNjb3BhYmxlcygna2V5cycpO1xuYWRkVG9VbnNjb3BhYmxlcygndmFsdWVzJyk7XG5hZGRUb1Vuc2NvcGFibGVzKCdlbnRyaWVzJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///63\n")},function(module,exports,__webpack_require__){eval("// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = __webpack_require__(1)('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(3)(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hZGQtdG8tdW5zY29wYWJsZXMuanM/OWM2YyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixtQkFBTyxDQUFDLENBQVE7QUFDbEM7QUFDQSwwQ0FBMEMsbUJBQU8sQ0FBQyxDQUFTLDZCQUE2QjtBQUN4RjtBQUNBO0FBQ0EiLCJmaWxlIjoiNjQuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAyMi4xLjMuMzEgQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG52YXIgVU5TQ09QQUJMRVMgPSByZXF1aXJlKCcuL193a3MnKSgndW5zY29wYWJsZXMnKTtcbnZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuaWYgKEFycmF5UHJvdG9bVU5TQ09QQUJMRVNdID09IHVuZGVmaW5lZCkgcmVxdWlyZSgnLi9faGlkZScpKEFycmF5UHJvdG8sIFVOU0NPUEFCTEVTLCB7fSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b1tVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///64\n")},function(module,exports,__webpack_require__){eval("module.exports = !__webpack_require__(13) && !__webpack_require__(14)(function () {\n  return Object.defineProperty(__webpack_require__(37)('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pZTgtZG9tLWRlZmluZS5qcz9jNjlhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGtCQUFrQixtQkFBTyxDQUFDLEVBQWdCLE1BQU0sbUJBQU8sQ0FBQyxFQUFVO0FBQ2xFLCtCQUErQixtQkFBTyxDQUFDLEVBQWUsZ0JBQWdCLG1CQUFtQixVQUFVLEVBQUUsRUFBRTtBQUN2RyxDQUFDIiwiZmlsZSI6IjY1LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAhcmVxdWlyZSgnLi9fZGVzY3JpcHRvcnMnKSAmJiAhcmVxdWlyZSgnLi9fZmFpbHMnKShmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVxdWlyZSgnLi9fZG9tLWNyZWF0ZScpKCdkaXYnKSwgJ2EnLCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfSB9KS5hICE9IDc7XG59KTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///65\n")},function(module,exports,__webpack_require__){eval("// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = __webpack_require__(12);\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1wcmltaXRpdmUuanM/NmE5OSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjY2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4xLjEgVG9QcmltaXRpdmUoaW5wdXQgWywgUHJlZmVycmVkVHlwZV0pXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbi8vIGluc3RlYWQgb2YgdGhlIEVTNiBzcGVjIHZlcnNpb24sIHdlIGRpZG4ndCBpbXBsZW1lbnQgQEB0b1ByaW1pdGl2ZSBjYXNlXG4vLyBhbmQgdGhlIHNlY29uZCBhcmd1bWVudCAtIGZsYWcgLSBwcmVmZXJyZWQgdHlwZSBpcyBhIHN0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFMpIHtcbiAgaWYgKCFpc09iamVjdChpdCkpIHJldHVybiBpdDtcbiAgdmFyIGZuLCB2YWw7XG4gIGlmIChTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICBpZiAodHlwZW9mIChmbiA9IGl0LnZhbHVlT2YpID09ICdmdW5jdGlvbicgJiYgIWlzT2JqZWN0KHZhbCA9IGZuLmNhbGwoaXQpKSkgcmV0dXJuIHZhbDtcbiAgaWYgKCFTICYmIHR5cGVvZiAoZm4gPSBpdC50b1N0cmluZykgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpdCkpKSByZXR1cm4gdmFsO1xuICB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///66\n")},function(module,exports){eval("module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLXN0ZXAuanM/ZDUzYiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFVBQVU7QUFDViIsImZpbGUiOiI2Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGRvbmUsIHZhbHVlKSB7XG4gIHJldHVybiB7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISFkb25lIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///67\n")},function(module,exports,__webpack_require__){eval("// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = __webpack_require__(27);\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pb2JqZWN0LmpzPzYyNmEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI2OC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApID8gT2JqZWN0IDogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjb2YoaXQpID09ICdTdHJpbmcnID8gaXQuc3BsaXQoJycpIDogT2JqZWN0KGl0KTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///68\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar LIBRARY = __webpack_require__(36);\nvar $export = __webpack_require__(39);\nvar redefine = __webpack_require__(16);\nvar hide = __webpack_require__(3);\nvar Iterators = __webpack_require__(25);\nvar $iterCreate = __webpack_require__(72);\nvar setToStringTag = __webpack_require__(43);\nvar getPrototypeOf = __webpack_require__(79);\nvar ITERATOR = __webpack_require__(1)('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWRlZmluZS5qcz8wMWY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsY0FBYyxtQkFBTyxDQUFDLEVBQVk7QUFDbEMsY0FBYyxtQkFBTyxDQUFDLEVBQVc7QUFDakMsZUFBZSxtQkFBTyxDQUFDLEVBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLENBQVM7QUFDNUIsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFnQjtBQUMxQyxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFzQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxFQUFlO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxDQUFRO0FBQy9CLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLGFBQWE7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsb0NBQW9DO0FBQzdFLDZDQUE2QyxvQ0FBb0M7QUFDakYsS0FBSyw0QkFBNEIsb0NBQW9DO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQW1CO0FBQ25DO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsImZpbGUiOiI2OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbnZhciBMSUJSQVJZID0gcmVxdWlyZSgnLi9fbGlicmFyeScpO1xudmFyICRleHBvcnQgPSByZXF1aXJlKCcuL19leHBvcnQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4vX3JlZGVmaW5lJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4vX2hpZGUnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuL19pdGVyYXRvcnMnKTtcbnZhciAkaXRlckNyZWF0ZSA9IHJlcXVpcmUoJy4vX2l0ZXItY3JlYXRlJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi9fb2JqZWN0LWdwbycpO1xudmFyIElURVJBVE9SID0gcmVxdWlyZSgnLi9fd2tzJykoJ2l0ZXJhdG9yJyk7XG52YXIgQlVHR1kgPSAhKFtdLmtleXMgJiYgJ25leHQnIGluIFtdLmtleXMoKSk7IC8vIFNhZmFyaSBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbnZhciBGRl9JVEVSQVRPUiA9ICdAQGl0ZXJhdG9yJztcbnZhciBLRVlTID0gJ2tleXMnO1xudmFyIFZBTFVFUyA9ICd2YWx1ZXMnO1xuXG52YXIgcmV0dXJuVGhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEJhc2UsIE5BTUUsIENvbnN0cnVjdG9yLCBuZXh0LCBERUZBVUxULCBJU19TRVQsIEZPUkNFRCkge1xuICAkaXRlckNyZWF0ZShDb25zdHJ1Y3RvciwgTkFNRSwgbmV4dCk7XG4gIHZhciBnZXRNZXRob2QgPSBmdW5jdGlvbiAoa2luZCkge1xuICAgIGlmICghQlVHR1kgJiYga2luZCBpbiBwcm90bykgcmV0dXJuIHByb3RvW2tpbmRdO1xuICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgY2FzZSBLRVlTOiByZXR1cm4gZnVuY3Rpb24ga2V5cygpIHsgcmV0dXJuIG5ldyBDb25zdHJ1Y3Rvcih0aGlzLCBraW5kKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHRoaXMsIGtpbmQpOyB9O1xuICAgIH0gcmV0dXJuIGZ1bmN0aW9uIGVudHJpZXMoKSB7IHJldHVybiBuZXcgQ29uc3RydWN0b3IodGhpcywga2luZCk7IH07XG4gIH07XG4gIHZhciBUQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBERUZfVkFMVUVTID0gREVGQVVMVCA9PSBWQUxVRVM7XG4gIHZhciBWQUxVRVNfQlVHID0gZmFsc2U7XG4gIHZhciBwcm90byA9IEJhc2UucHJvdG90eXBlO1xuICB2YXIgJG5hdGl2ZSA9IHByb3RvW0lURVJBVE9SXSB8fCBwcm90b1tGRl9JVEVSQVRPUl0gfHwgREVGQVVMVCAmJiBwcm90b1tERUZBVUxUXTtcbiAgdmFyICRkZWZhdWx0ID0gJG5hdGl2ZSB8fCBnZXRNZXRob2QoREVGQVVMVCk7XG4gIHZhciAkZW50cmllcyA9IERFRkFVTFQgPyAhREVGX1ZBTFVFUyA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKCdlbnRyaWVzJykgOiB1bmRlZmluZWQ7XG4gIHZhciAkYW55TmF0aXZlID0gTkFNRSA9PSAnQXJyYXknID8gcHJvdG8uZW50cmllcyB8fCAkbmF0aXZlIDogJG5hdGl2ZTtcbiAgdmFyIG1ldGhvZHMsIGtleSwgSXRlcmF0b3JQcm90b3R5cGU7XG4gIC8vIEZpeCBuYXRpdmVcbiAgaWYgKCRhbnlOYXRpdmUpIHtcbiAgICBJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvdHlwZU9mKCRhbnlOYXRpdmUuY2FsbChuZXcgQmFzZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEl0ZXJhdG9yUHJvdG90eXBlLm5leHQpIHtcbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yUHJvdG90eXBlLCBUQUcsIHRydWUpO1xuICAgICAgLy8gZml4IGZvciBzb21lIG9sZCBlbmdpbmVzXG4gICAgICBpZiAoIUxJQlJBUlkgJiYgdHlwZW9mIEl0ZXJhdG9yUHJvdG90eXBlW0lURVJBVE9SXSAhPSAnZnVuY3Rpb24nKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgfVxuICB9XG4gIC8vIGZpeCBBcnJheSN7dmFsdWVzLCBAQGl0ZXJhdG9yfS5uYW1lIGluIFY4IC8gRkZcbiAgaWYgKERFRl9WQUxVRVMgJiYgJG5hdGl2ZSAmJiAkbmF0aXZlLm5hbWUgIT09IFZBTFVFUykge1xuICAgIFZBTFVFU19CVUcgPSB0cnVlO1xuICAgICRkZWZhdWx0ID0gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gJG5hdGl2ZS5jYWxsKHRoaXMpOyB9O1xuICB9XG4gIC8vIERlZmluZSBpdGVyYXRvclxuICBpZiAoKCFMSUJSQVJZIHx8IEZPUkNFRCkgJiYgKEJVR0dZIHx8IFZBTFVFU19CVUcgfHwgIXByb3RvW0lURVJBVE9SXSkpIHtcbiAgICBoaWRlKHByb3RvLCBJVEVSQVRPUiwgJGRlZmF1bHQpO1xuICB9XG4gIC8vIFBsdWcgZm9yIGxpYnJhcnlcbiAgSXRlcmF0b3JzW05BTUVdID0gJGRlZmF1bHQ7XG4gIEl0ZXJhdG9yc1tUQUddID0gcmV0dXJuVGhpcztcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBERUZfVkFMVUVTID8gJGRlZmF1bHQgOiBnZXRNZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/ICRkZWZhdWx0IDogZ2V0TWV0aG9kKEtFWVMpLFxuICAgICAgZW50cmllczogJGVudHJpZXNcbiAgICB9O1xuICAgIGlmIChGT1JDRUQpIGZvciAoa2V5IGluIG1ldGhvZHMpIHtcbiAgICAgIGlmICghKGtleSBpbiBwcm90bykpIHJlZGVmaW5lKHByb3RvLCBrZXksIG1ldGhvZHNba2V5XSk7XG4gICAgfSBlbHNlICRleHBvcnQoJGV4cG9ydC5QICsgJGV4cG9ydC5GICogKEJVR0dZIHx8IFZBTFVFU19CVUcpLCBOQU1FLCBtZXRob2RzKTtcbiAgfVxuICByZXR1cm4gbWV0aG9kcztcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///69\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(21)('native-function-to-string', Function.toString);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mdW5jdGlvbi10by1zdHJpbmcuanM/ZmE1YiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFXIiwiZmlsZSI6IjcwLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19zaGFyZWQnKSgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///70\n")},function(module,exports,__webpack_require__){eval("// optional / simple context binding\nvar aFunction = __webpack_require__(40);\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jdHguanM/OWI0MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjcxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9fYS1mdW5jdGlvbicpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4sIHRoYXQsIGxlbmd0aCkge1xuICBhRnVuY3Rpb24oZm4pO1xuICBpZiAodGhhdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gZm47XG4gIHN3aXRjaCAobGVuZ3RoKSB7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEpO1xuICAgIH07XG4gICAgY2FzZSAyOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIpO1xuICAgIH07XG4gICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgIHJldHVybiBmbi5jYWxsKHRoYXQsIGEsIGIsIGMpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uICgvKiAuLi5hcmdzICovKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///71\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar create = __webpack_require__(73);\nvar descriptor = __webpack_require__(38);\nvar setToStringTag = __webpack_require__(43);\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n__webpack_require__(3)(IteratorPrototype, __webpack_require__(1)('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pdGVyLWNyZWF0ZS5qcz80MWEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsYUFBYSxtQkFBTyxDQUFDLEVBQWtCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLEVBQWtCO0FBQzNDLHFCQUFxQixtQkFBTyxDQUFDLEVBQXNCO0FBQ25EOztBQUVBO0FBQ0EsbUJBQU8sQ0FBQyxDQUFTLHFCQUFxQixtQkFBTyxDQUFDLENBQVEsNEJBQTRCLGFBQWEsRUFBRTs7QUFFakc7QUFDQSxxREFBcUQsNEJBQTRCO0FBQ2pGO0FBQ0EiLCJmaWxlIjoiNzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi9fb2JqZWN0LWNyZWF0ZScpO1xudmFyIGRlc2NyaXB0b3IgPSByZXF1aXJlKCcuL19wcm9wZXJ0eS1kZXNjJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuL19zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5yZXF1aXJlKCcuL19oaWRlJykoSXRlcmF0b3JQcm90b3R5cGUsIHJlcXVpcmUoJy4vX3drcycpKCdpdGVyYXRvcicpLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIE5BTUUsIG5leHQpIHtcbiAgQ29uc3RydWN0b3IucHJvdG90eXBlID0gY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlLCB7IG5leHQ6IGRlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKENvbnN0cnVjdG9yLCBOQU1FICsgJyBJdGVyYXRvcicpO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///72\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = __webpack_require__(4);\nvar dPs = __webpack_require__(74);\nvar enumBugKeys = __webpack_require__(42);\nvar IE_PROTO = __webpack_require__(29)('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = __webpack_require__(37)('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  __webpack_require__(78).appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtY3JlYXRlLmpzPzJhZWIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxVQUFVLG1CQUFPLENBQUMsRUFBZTtBQUNqQyxrQkFBa0IsbUJBQU8sQ0FBQyxFQUFrQjtBQUM1QyxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0Qyx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLEVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsbUJBQU8sQ0FBQyxFQUFTO0FBQ25CLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJmaWxlIjoiNzMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAxOS4xLjIuMiAvIDE1LjIuMy41IE9iamVjdC5jcmVhdGUoTyBbLCBQcm9wZXJ0aWVzXSlcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGRQcyA9IHJlcXVpcmUoJy4vX29iamVjdC1kcHMnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4vX2VudW0tYnVnLWtleXMnKTtcbnZhciBJRV9QUk9UTyA9IHJlcXVpcmUoJy4vX3NoYXJlZC1rZXknKSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eSA9IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfTtcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcblxuLy8gQ3JlYXRlIG9iamVjdCB3aXRoIGZha2UgYG51bGxgIHByb3RvdHlwZTogdXNlIGlmcmFtZSBPYmplY3Qgd2l0aCBjbGVhcmVkIHByb3RvdHlwZVxudmFyIGNyZWF0ZURpY3QgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFRocmFzaCwgd2FzdGUgYW5kIHNvZG9teTogSUUgR0MgYnVnXG4gIHZhciBpZnJhbWUgPSByZXF1aXJlKCcuL19kb20tY3JlYXRlJykoJ2lmcmFtZScpO1xuICB2YXIgaSA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgZ3QgPSAnPic7XG4gIHZhciBpZnJhbWVEb2N1bWVudDtcbiAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIHJlcXVpcmUoJy4vX2h0bWwnKS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICBpZnJhbWUuc3JjID0gJ2phdmFzY3JpcHQ6JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zY3JpcHQtdXJsXG4gIC8vIGNyZWF0ZURpY3QgPSBpZnJhbWUuY29udGVudFdpbmRvdy5PYmplY3Q7XG4gIC8vIGh0bWwucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgaWZyYW1lRG9jdW1lbnQgPSBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcbiAgaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuICBpZnJhbWVEb2N1bWVudC53cml0ZShsdCArICdzY3JpcHQnICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnL3NjcmlwdCcgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAoaS0tKSBkZWxldGUgY3JlYXRlRGljdFtQUk9UT1RZUEVdW2VudW1CdWdLZXlzW2ldXTtcbiAgcmV0dXJuIGNyZWF0ZURpY3QoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoTyAhPT0gbnVsbCkge1xuICAgIEVtcHR5W1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgICByZXN1bHQgPSBuZXcgRW1wdHkoKTtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gbnVsbDtcbiAgICAvLyBhZGQgXCJfX3Byb3RvX19cIiBmb3IgT2JqZWN0LmdldFByb3RvdHlwZU9mIHBvbHlmaWxsXG4gICAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gIH0gZWxzZSByZXN1bHQgPSBjcmVhdGVEaWN0KCk7XG4gIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkUHMocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///73\n")},function(module,exports,__webpack_require__){eval("var dP = __webpack_require__(24);\nvar anObject = __webpack_require__(4);\nvar getKeys = __webpack_require__(41);\n\nmodule.exports = __webpack_require__(13) ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZHBzLmpzPzE0OTUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsU0FBUyxtQkFBTyxDQUFDLEVBQWM7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLENBQWM7QUFDckMsY0FBYyxtQkFBTyxDQUFDLEVBQWdCOztBQUV0QyxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc0LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIGRQID0gcmVxdWlyZSgnLi9fb2JqZWN0LWRwJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbnZhciBnZXRLZXlzID0gcmVxdWlyZSgnLi9fb2JqZWN0LWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL19kZXNjcmlwdG9ycycpID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gZ2V0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaSA9IDA7XG4gIHZhciBQO1xuICB3aGlsZSAobGVuZ3RoID4gaSkgZFAuZihPLCBQID0ga2V5c1tpKytdLCBQcm9wZXJ0aWVzW1BdKTtcbiAgcmV0dXJuIE87XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///74\n")},function(module,exports,__webpack_require__){eval("var has = __webpack_require__(17);\nvar toIObject = __webpack_require__(26);\nvar arrayIndexOf = __webpack_require__(76)(false);\nvar IE_PROTO = __webpack_require__(29)('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3Qta2V5cy1pbnRlcm5hbC5qcz9jZTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMsbUJBQW1CLG1CQUFPLENBQUMsRUFBbUI7QUFDOUMsZUFBZSxtQkFBTyxDQUFDLEVBQWU7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3NS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b0lPYmplY3QgPSByZXF1aXJlKCcuL190by1pb2JqZWN0Jyk7XG52YXIgYXJyYXlJbmRleE9mID0gcmVxdWlyZSgnLi9fYXJyYXktaW5jbHVkZXMnKShmYWxzZSk7XG52YXIgSUVfUFJPVE8gPSByZXF1aXJlKCcuL19zaGFyZWQta2V5JykoJ0lFX1BST1RPJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwgbmFtZXMpIHtcbiAgdmFyIE8gPSB0b0lPYmplY3Qob2JqZWN0KTtcbiAgdmFyIGkgPSAwO1xuICB2YXIgcmVzdWx0ID0gW107XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIE8pIGlmIChrZXkgIT0gSUVfUFJPVE8pIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+YXJyYXlJbmRleE9mKHJlc3VsdCwga2V5KSB8fCByZXN1bHQucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///75\n")},function(module,exports,__webpack_require__){eval("// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = __webpack_require__(26);\nvar toLength = __webpack_require__(28);\nvar toAbsoluteIndex = __webpack_require__(77);\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19hcnJheS1pbmNsdWRlcy5qcz9jMzY2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLHNCQUFzQixtQkFBTyxDQUFDLEVBQXNCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxZQUFZLGVBQWU7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsImZpbGUiOiI3Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGZhbHNlIC0+IEFycmF5I2luZGV4T2Zcbi8vIHRydWUgIC0+IEFycmF5I2luY2x1ZGVzXG52YXIgdG9JT2JqZWN0ID0gcmVxdWlyZSgnLi9fdG8taW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi9fdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi9fdG8tYWJzb2x1dGUtaW5kZXgnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSU9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSB7XG4gICAgICBpZiAoT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///76\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(18);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL190by1hYnNvbHV0ZS1pbmRleC5qcz83N2YxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6Ijc3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiAgaW5kZXggPSB0b0ludGVnZXIoaW5kZXgpO1xuICByZXR1cm4gaW5kZXggPCAwID8gbWF4KGluZGV4ICsgbGVuZ3RoLCAwKSA6IG1pbihpbmRleCwgbGVuZ3RoKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///77\n")},function(module,exports,__webpack_require__){eval("var document = __webpack_require__(2).document;\nmodule.exports = document && document.documentElement;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19odG1sLmpzP2ZhYjIiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLENBQVc7QUFDbEMiLCJmaWxlIjoiNzguanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgZG9jdW1lbnQgPSByZXF1aXJlKCcuL19nbG9iYWwnKS5kb2N1bWVudDtcbm1vZHVsZS5leHBvcnRzID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///78\n")},function(module,exports,__webpack_require__){eval("// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = __webpack_require__(17);\nvar toObject = __webpack_require__(44);\nvar IE_PROTO = __webpack_require__(29)('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19vYmplY3QtZ3BvLmpzPzM4ZmQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixlQUFlLG1CQUFPLENBQUMsRUFBYztBQUNyQyxlQUFlLG1CQUFPLENBQUMsRUFBZTtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIIiwiZmlsZSI6Ijc5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gMTkuMS4yLjkgLyAxNS4yLjMuMiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoTylcbnZhciBoYXMgPSByZXF1aXJlKCcuL19oYXMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4vX3RvLW9iamVjdCcpO1xudmFyIElFX1BST1RPID0gcmVxdWlyZSgnLi9fc2hhcmVkLWtleScpKCdJRV9QUk9UTycpO1xudmFyIE9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgfHwgZnVuY3Rpb24gKE8pIHtcbiAgTyA9IHRvT2JqZWN0KE8pO1xuICBpZiAoaGFzKE8sIElFX1BST1RPKSkgcmV0dXJuIE9bSUVfUFJPVE9dO1xuICBpZiAodHlwZW9mIE8uY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBPIGluc3RhbmNlb2YgTy5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBPLmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgfSByZXR1cm4gTyBpbnN0YW5jZW9mIE9iamVjdCA/IE9iamVjdFByb3RvIDogbnVsbDtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///79\n")},function(module,exports,__webpack_require__){eval("// 7.2.8 IsRegExp(argument)\nvar isObject = __webpack_require__(12);\nvar cof = __webpack_require__(27);\nvar MATCH = __webpack_require__(1)('match');\nmodule.exports = function (it) {\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19pcy1yZWdleHAuanM/YWFlMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLFVBQVUsbUJBQU8sQ0FBQyxFQUFRO0FBQzFCLFlBQVksbUJBQU8sQ0FBQyxDQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjgwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gNy4yLjggSXNSZWdFeHAoYXJndW1lbnQpXG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuL19pcy1vYmplY3QnKTtcbnZhciBjb2YgPSByZXF1aXJlKCcuL19jb2YnKTtcbnZhciBNQVRDSCA9IHJlcXVpcmUoJy4vX3drcycpKCdtYXRjaCcpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIGlzUmVnRXhwO1xuICByZXR1cm4gaXNPYmplY3QoaXQpICYmICgoaXNSZWdFeHAgPSBpdFtNQVRDSF0pICE9PSB1bmRlZmluZWQgPyAhIWlzUmVnRXhwIDogY29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///80\n")},function(module,exports,__webpack_require__){eval("// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = __webpack_require__(4);\nvar aFunction = __webpack_require__(40);\nvar SPECIES = __webpack_require__(1)('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zcGVjaWVzLWNvbnN0cnVjdG9yLmpzP2ViZDYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQyxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxDQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiODEuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyA3LjMuMjAgU3BlY2llc0NvbnN0cnVjdG9yKE8sIGRlZmF1bHRDb25zdHJ1Y3RvcilcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4vX2FuLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4vX2EtZnVuY3Rpb24nKTtcbnZhciBTUEVDSUVTID0gcmVxdWlyZSgnLi9fd2tzJykoJ3NwZWNpZXMnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIEQpIHtcbiAgdmFyIEMgPSBhbk9iamVjdChPKS5jb25zdHJ1Y3RvcjtcbiAgdmFyIFM7XG4gIHJldHVybiBDID09PSB1bmRlZmluZWQgfHwgKFMgPSBhbk9iamVjdChDKVtTUEVDSUVTXSkgPT0gdW5kZWZpbmVkID8gRCA6IGFGdW5jdGlvbihTKTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///81\n")},function(module,exports,__webpack_require__){eval("var toInteger = __webpack_require__(18);\nvar defined = __webpack_require__(15);\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19zdHJpbmctYXQuanM/MDJmNCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFlO0FBQ3ZDLGNBQWMsbUJBQU8sQ0FBQyxFQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuL190by1pbnRlZ2VyJyk7XG52YXIgZGVmaW5lZCA9IHJlcXVpcmUoJy4vX2RlZmluZWQnKTtcbi8vIHRydWUgIC0+IFN0cmluZyNhdFxuLy8gZmFsc2UgLT4gU3RyaW5nI2NvZGVQb2ludEF0XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChUT19TVFJJTkcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0aGF0LCBwb3MpIHtcbiAgICB2YXIgcyA9IFN0cmluZyhkZWZpbmVkKHRoYXQpKTtcbiAgICB2YXIgaSA9IHRvSW50ZWdlcihwb3MpO1xuICAgIHZhciBsID0gcy5sZW5ndGg7XG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGkgPCAwIHx8IGkgPj0gbCkgcmV0dXJuIFRPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGEgPSBzLmNoYXJDb2RlQXQoaSk7XG4gICAgcmV0dXJuIGEgPCAweGQ4MDAgfHwgYSA+IDB4ZGJmZiB8fCBpICsgMSA9PT0gbCB8fCAoYiA9IHMuY2hhckNvZGVBdChpICsgMSkpIDwgMHhkYzAwIHx8IGIgPiAweGRmZmZcbiAgICAgID8gVE9fU1RSSU5HID8gcy5jaGFyQXQoaSkgOiBhXG4gICAgICA6IFRPX1NUUklORyA/IHMuc2xpY2UoaSwgaSArIDIpIDogKGEgLSAweGQ4MDAgPDwgMTApICsgKGIgLSAweGRjMDApICsgMHgxMDAwMDtcbiAgfTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///82\n")},function(module,exports,__webpack_require__){eval("// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = __webpack_require__(27);\nvar TAG = __webpack_require__(1)('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19jbGFzc29mLmpzPzIzYzYiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQSxVQUFVLG1CQUFPLENBQUMsRUFBUTtBQUMxQixVQUFVLG1CQUFPLENBQUMsQ0FBUTtBQUMxQjtBQUNBLDJCQUEyQixrQkFBa0IsRUFBRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLFlBQVk7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4My5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIGdldHRpbmcgdGFnIGZyb20gMTkuMS4zLjYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpXG52YXIgY29mID0gcmVxdWlyZSgnLi9fY29mJyk7XG52YXIgVEFHID0gcmVxdWlyZSgnLi9fd2tzJykoJ3RvU3RyaW5nVGFnJyk7XG4vLyBFUzMgd3JvbmcgaGVyZVxudmFyIEFSRyA9IGNvZihmdW5jdGlvbiAoKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPT0gJ0FyZ3VtZW50cyc7XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIFNjcmlwdCBBY2Nlc3MgRGVuaWVkIGVycm9yXG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gaXRba2V5XTtcbiAgfSBjYXRjaCAoZSkgeyAvKiBlbXB0eSAqLyB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgTywgVCwgQjtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKFQgPSB0cnlHZXQoTyA9IE9iamVjdChpdCksIFRBRykpID09ICdzdHJpbmcnID8gVFxuICAgIC8vIGJ1aWx0aW5UYWcgY2FzZVxuICAgIDogQVJHID8gY29mKE8pXG4gICAgLy8gRVMzIGFyZ3VtZW50cyBmYWxsYmFja1xuICAgIDogKEIgPSBjb2YoTykpID09ICdPYmplY3QnICYmIHR5cGVvZiBPLmNhbGxlZSA9PSAnZnVuY3Rpb24nID8gJ0FyZ3VtZW50cycgOiBCO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///83\n")},function(module,exports,__webpack_require__){"use strict";eval("\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = __webpack_require__(4);\nmodule.exports = function () {\n  var that = anObject(this);\n  var result = '';\n  if (that.global) result += 'g';\n  if (that.ignoreCase) result += 'i';\n  if (that.multiline) result += 'm';\n  if (that.unicode) result += 'u';\n  if (that.sticky) result += 'y';\n  return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL19mbGFncy5qcz8wYmZiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSxlQUFlLG1CQUFPLENBQUMsQ0FBYztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI4NC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0Jztcbi8vIDIxLjIuNS4zIGdldCBSZWdFeHAucHJvdG90eXBlLmZsYWdzXG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuL19hbi1vYmplY3QnKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC51bmljb2RlKSByZXN1bHQgKz0gJ3UnO1xuICBpZiAodGhhdC5zdGlja3kpIHJlc3VsdCArPSAneSc7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///84\n")},function(module,exports,__webpack_require__){"use strict";eval("\nvar regexpExec = __webpack_require__(30);\n__webpack_require__(39)({\n  target: 'RegExp',\n  proto: true,\n  forced: regexpExec !== /./.exec\n}, {\n  exec: regexpExec\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAuZXhlYy5qcz9iMGM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsaUJBQWlCLG1CQUFPLENBQUMsRUFBZ0I7QUFDekMsbUJBQU8sQ0FBQyxFQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMiLCJmaWxlIjoiODUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vX3JlZ2V4cC1leGVjJyk7XG5yZXF1aXJlKCcuL19leHBvcnQnKSh7XG4gIHRhcmdldDogJ1JlZ0V4cCcsXG4gIHByb3RvOiB0cnVlLFxuICBmb3JjZWQ6IHJlZ2V4cEV4ZWMgIT09IC8uLy5leGVjXG59LCB7XG4gIGV4ZWM6IHJlZ2V4cEV4ZWNcbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///85\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nvar anObject = __webpack_require__(4);\nvar toObject = __webpack_require__(44);\nvar toLength = __webpack_require__(28);\nvar toInteger = __webpack_require__(18);\nvar advanceStringIndex = __webpack_require__(46);\nvar regExpExec = __webpack_require__(47);\nvar max = Math.max;\nvar min = Math.min;\nvar floor = Math.floor;\nvar SUBSTITUTION_SYMBOLS = /\\$([$&`']|\\d\\d?|<[^>]*>)/g;\nvar SUBSTITUTION_SYMBOLS_NO_NAMED = /\\$([$&`']|\\d\\d?)/g;\n\nvar maybeToString = function (it) {\n  return it === undefined ? it : String(it);\n};\n\n// @@replace logic\n__webpack_require__(48)('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {\n  return [\n    // `String.prototype.replace` method\n    // https://tc39.github.io/ecma262/#sec-string.prototype.replace\n    function replace(searchValue, replaceValue) {\n      var O = defined(this);\n      var fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n      return fn !== undefined\n        ? fn.call(searchValue, O, replaceValue)\n        : $replace.call(String(O), searchValue, replaceValue);\n    },\n    // `RegExp.prototype[@@replace]` method\n    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace\n    function (regexp, replaceValue) {\n      var res = maybeCallNative($replace, regexp, this, replaceValue);\n      if (res.done) return res.value;\n\n      var rx = anObject(regexp);\n      var S = String(this);\n      var functionalReplace = typeof replaceValue === 'function';\n      if (!functionalReplace) replaceValue = String(replaceValue);\n      var global = rx.global;\n      if (global) {\n        var fullUnicode = rx.unicode;\n        rx.lastIndex = 0;\n      }\n      var results = [];\n      while (true) {\n        var result = regExpExec(rx, S);\n        if (result === null) break;\n        results.push(result);\n        if (!global) break;\n        var matchStr = String(result[0]);\n        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);\n      }\n      var accumulatedResult = '';\n      var nextSourcePosition = 0;\n      for (var i = 0; i < results.length; i++) {\n        result = results[i];\n        var matched = String(result[0]);\n        var position = max(min(toInteger(result.index), S.length), 0);\n        var captures = [];\n        // NOTE: This is equivalent to\n        //   captures = result.slice(1).map(maybeToString)\n        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in\n        // the slice polyfill when slicing native arrays) \"doesn't work\" in safari 9 and\n        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.\n        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));\n        var namedCaptures = result.groups;\n        if (functionalReplace) {\n          var replacerArgs = [matched].concat(captures, position, S);\n          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);\n          var replacement = String(replaceValue.apply(undefined, replacerArgs));\n        } else {\n          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);\n        }\n        if (position >= nextSourcePosition) {\n          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;\n          nextSourcePosition = position + matched.length;\n        }\n      }\n      return accumulatedResult + S.slice(nextSourcePosition);\n    }\n  ];\n\n    // https://tc39.github.io/ecma262/#sec-getsubstitution\n  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {\n    var tailPos = position + matched.length;\n    var m = captures.length;\n    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;\n    if (namedCaptures !== undefined) {\n      namedCaptures = toObject(namedCaptures);\n      symbols = SUBSTITUTION_SYMBOLS;\n    }\n    return $replace.call(replacement, symbols, function (match, ch) {\n      var capture;\n      switch (ch.charAt(0)) {\n        case '$': return '$';\n        case '&': return matched;\n        case '`': return str.slice(0, position);\n        case \"'\": return str.slice(tailPos);\n        case '<':\n          capture = namedCaptures[ch.slice(1, -1)];\n          break;\n        default: // \\d\\d?\n          var n = +ch;\n          if (n === 0) return match;\n          if (n > m) {\n            var f = floor(n / 10);\n            if (f === 0) return match;\n            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);\n            return match;\n          }\n          capture = captures[n - 1];\n      }\n      return capture === undefined ? '' : capture;\n    });\n  }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzNi5yZWdleHAucmVwbGFjZS5qcz9hNDgxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFhOztBQUViLGVBQWUsbUJBQU8sQ0FBQyxDQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGVBQWUsbUJBQU8sQ0FBQyxFQUFjO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLEVBQWU7QUFDdkMseUJBQXlCLG1CQUFPLENBQUMsRUFBeUI7QUFDMUQsaUJBQWlCLG1CQUFPLENBQUMsRUFBeUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBTyxDQUFDLEVBQWU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsQ0FBQyIsImZpbGUiOiI4Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi9fYW4tb2JqZWN0Jyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuL190by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4vX3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4vX3RvLWludGVnZXInKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuL19hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIHJlZ0V4cEV4ZWMgPSByZXF1aXJlKCcuL19yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MUyA9IC9cXCQoWyQmYCddfFxcZFxcZD98PFtePl0qPikvZztcbnZhciBTVUJTVElUVVRJT05fU1lNQk9MU19OT19OQU1FRCA9IC9cXCQoWyQmYCddfFxcZFxcZD8pL2c7XG5cbnZhciBtYXliZVRvU3RyaW5nID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCA9PT0gdW5kZWZpbmVkID8gaXQgOiBTdHJpbmcoaXQpO1xufTtcblxuLy8gQEByZXBsYWNlIGxvZ2ljXG5yZXF1aXJlKCcuL19maXgtcmUtd2tzJykoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoZGVmaW5lZCwgUkVQTEFDRSwgJHJlcGxhY2UsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2VgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwbGFjZVxuICAgIGZ1bmN0aW9uIHJlcGxhY2Uoc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIE8gPSBkZWZpbmVkKHRoaXMpO1xuICAgICAgdmFyIGZuID0gc2VhcmNoVmFsdWUgPT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogc2VhcmNoVmFsdWVbUkVQTEFDRV07XG4gICAgICByZXR1cm4gZm4gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZuLmNhbGwoc2VhcmNoVmFsdWUsIE8sIHJlcGxhY2VWYWx1ZSlcbiAgICAgICAgOiAkcmVwbGFjZS5jYWxsKFN0cmluZyhPKSwgc2VhcmNoVmFsdWUsIHJlcGxhY2VWYWx1ZSk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAucHJvdG90eXBlLUBAcmVwbGFjZVxuICAgIGZ1bmN0aW9uIChyZWdleHAsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgdmFyIHJlcyA9IG1heWJlQ2FsbE5hdGl2ZSgkcmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG4gICAgICB2YXIgZnVuY3Rpb25hbFJlcGxhY2UgPSB0eXBlb2YgcmVwbGFjZVZhbHVlID09PSAnZnVuY3Rpb24nO1xuICAgICAgaWYgKCFmdW5jdGlvbmFsUmVwbGFjZSkgcmVwbGFjZVZhbHVlID0gU3RyaW5nKHJlcGxhY2VWYWx1ZSk7XG4gICAgICB2YXIgZ2xvYmFsID0gcnguZ2xvYmFsO1xuICAgICAgaWYgKGdsb2JhbCkge1xuICAgICAgICB2YXIgZnVsbFVuaWNvZGUgPSByeC51bmljb2RlO1xuICAgICAgICByeC5sYXN0SW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCkgYnJlYWs7XG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBpZiAobWF0Y2hTdHIgPT09ICcnKSByeC5sYXN0SW5kZXggPSBhZHZhbmNlU3RyaW5nSW5kZXgoUywgdG9MZW5ndGgocngubGFzdEluZGV4KSwgZnVsbFVuaWNvZGUpO1xuICAgICAgfVxuICAgICAgdmFyIGFjY3VtdWxhdGVkUmVzdWx0ID0gJyc7XG4gICAgICB2YXIgbmV4dFNvdXJjZVBvc2l0aW9uID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldHN1YnN0aXR1dGlvblxuICBmdW5jdGlvbiBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgc3RyLCBwb3NpdGlvbiwgY2FwdHVyZXMsIG5hbWVkQ2FwdHVyZXMsIHJlcGxhY2VtZW50KSB7XG4gICAgdmFyIHRhaWxQb3MgPSBwb3NpdGlvbiArIG1hdGNoZWQubGVuZ3RoO1xuICAgIHZhciBtID0gY2FwdHVyZXMubGVuZ3RoO1xuICAgIHZhciBzeW1ib2xzID0gU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQ7XG4gICAgaWYgKG5hbWVkQ2FwdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgbmFtZWRDYXB0dXJlcyA9IHRvT2JqZWN0KG5hbWVkQ2FwdHVyZXMpO1xuICAgICAgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTO1xuICAgIH1cbiAgICByZXR1cm4gJHJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///86\n")},function(module,exports,__webpack_require__){eval("var BlankNode = __webpack_require__(88)\nvar DefaultGraph = __webpack_require__(49)\nvar Literal = __webpack_require__(89)\nvar NamedNode = __webpack_require__(50)\nvar Quad = __webpack_require__(90)\nvar Variable = __webpack_require__(91)\n\nfunction DataFactory () {}\n\nDataFactory.namedNode = function (value) {\n  return new NamedNode(value)\n}\n\nDataFactory.blankNode = function (value) {\n  return new BlankNode(value)\n}\n\nDataFactory.literal = function (value, languageOrDatatype) {\n  if (typeof languageOrDatatype === 'string') {\n    if (languageOrDatatype.indexOf(':') === -1) {\n      return new Literal(value, languageOrDatatype)\n    }\n\n    return new Literal(value, null, DataFactory.namedNode(languageOrDatatype))\n  }\n\n  return new Literal(value, null, languageOrDatatype)\n}\n\nDataFactory.defaultGraph = function () {\n  return DataFactory.defaultGraphInstance\n}\n\nDataFactory.variable = function (value) {\n  return new Variable(value)\n}\n\nDataFactory.triple = function (subject, predicate, object) {\n  return DataFactory.quad(subject, predicate, object)\n}\n\nDataFactory.quad = function (subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph || DataFactory.defaultGraphInstance)\n}\n\nDataFactory.defaultGraphInstance = new DefaultGraph()\n\nmodule.exports = DataFactory\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2RhdGEtZmFjdG9yeS5qcz8zY2YxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLEVBQWM7QUFDdEMsbUJBQW1CLG1CQUFPLENBQUMsRUFBaUI7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLEVBQVc7QUFDakMsZ0JBQWdCLG1CQUFPLENBQUMsRUFBYztBQUN0QyxXQUFXLG1CQUFPLENBQUMsRUFBUTtBQUMzQixlQUFlLG1CQUFPLENBQUMsRUFBWTs7QUFFbkM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJmaWxlIjoiODcuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQmxhbmtOb2RlID0gcmVxdWlyZSgnLi9ibGFuay1ub2RlJylcbnZhciBEZWZhdWx0R3JhcGggPSByZXF1aXJlKCcuL2RlZmF1bHQtZ3JhcGgnKVxudmFyIExpdGVyYWwgPSByZXF1aXJlKCcuL2xpdGVyYWwnKVxudmFyIE5hbWVkTm9kZSA9IHJlcXVpcmUoJy4vbmFtZWQtbm9kZScpXG52YXIgUXVhZCA9IHJlcXVpcmUoJy4vcXVhZCcpXG52YXIgVmFyaWFibGUgPSByZXF1aXJlKCcuL3ZhcmlhYmxlJylcblxuZnVuY3Rpb24gRGF0YUZhY3RvcnkgKCkge31cblxuRGF0YUZhY3RvcnkubmFtZWROb2RlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiBuZXcgTmFtZWROb2RlKHZhbHVlKVxufVxuXG5EYXRhRmFjdG9yeS5ibGFua05vZGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBCbGFua05vZGUodmFsdWUpXG59XG5cbkRhdGFGYWN0b3J5LmxpdGVyYWwgPSBmdW5jdGlvbiAodmFsdWUsIGxhbmd1YWdlT3JEYXRhdHlwZSkge1xuICBpZiAodHlwZW9mIGxhbmd1YWdlT3JEYXRhdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAobGFuZ3VhZ2VPckRhdGF0eXBlLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbCh2YWx1ZSwgbGFuZ3VhZ2VPckRhdGF0eXBlKVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgTGl0ZXJhbCh2YWx1ZSwgbnVsbCwgRGF0YUZhY3RvcnkubmFtZWROb2RlKGxhbmd1YWdlT3JEYXRhdHlwZSkpXG4gIH1cblxuICByZXR1cm4gbmV3IExpdGVyYWwodmFsdWUsIG51bGwsIGxhbmd1YWdlT3JEYXRhdHlwZSlcbn1cblxuRGF0YUZhY3RvcnkuZGVmYXVsdEdyYXBoID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gRGF0YUZhY3RvcnkuZGVmYXVsdEdyYXBoSW5zdGFuY2Vcbn1cblxuRGF0YUZhY3RvcnkudmFyaWFibGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBWYXJpYWJsZSh2YWx1ZSlcbn1cblxuRGF0YUZhY3RvcnkudHJpcGxlID0gZnVuY3Rpb24gKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSB7XG4gIHJldHVybiBEYXRhRmFjdG9yeS5xdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KVxufVxuXG5EYXRhRmFjdG9yeS5xdWFkID0gZnVuY3Rpb24gKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICByZXR1cm4gbmV3IFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoIHx8IERhdGFGYWN0b3J5LmRlZmF1bHRHcmFwaEluc3RhbmNlKVxufVxuXG5EYXRhRmFjdG9yeS5kZWZhdWx0R3JhcGhJbnN0YW5jZSA9IG5ldyBEZWZhdWx0R3JhcGgoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFGYWN0b3J5XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///87\n")},function(module,exports){eval("function BlankNode (id) {\n  this.value = id || ('b' + (++BlankNode.nextId))\n}\n\nBlankNode.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nBlankNode.prototype.termType = 'BlankNode'\n\nBlankNode.nextId = 0\n\nmodule.exports = BlankNode\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2JsYW5rLW5vZGUuanM/NDdiNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBIiwiZmlsZSI6Ijg4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gQmxhbmtOb2RlIChpZCkge1xuICB0aGlzLnZhbHVlID0gaWQgfHwgKCdiJyArICgrK0JsYW5rTm9kZS5uZXh0SWQpKVxufVxuXG5CbGFua05vZGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZVxufVxuXG5CbGFua05vZGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ0JsYW5rTm9kZSdcblxuQmxhbmtOb2RlLm5leHRJZCA9IDBcblxubW9kdWxlLmV4cG9ydHMgPSBCbGFua05vZGVcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///88\n")},function(module,exports,__webpack_require__){eval("var NamedNode = __webpack_require__(50)\n\nfunction Literal (value, language, datatype) {\n  this.value = value\n  this.datatype = Literal.stringDatatype\n  this.language = ''\n\n  if (language) {\n    this.language = language\n    this.datatype = Literal.langStringDatatype\n  } else if (datatype) {\n    this.datatype = datatype\n  }\n}\n\nLiteral.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value &&\n    other.language === this.language && other.datatype.equals(this.datatype)\n}\n\nLiteral.prototype.termType = 'Literal'\nLiteral.langStringDatatype = new NamedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#langString')\nLiteral.stringDatatype = new NamedNode('http://www.w3.org/2001/XMLSchema#string')\n\nmodule.exports = Literal\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL2xpdGVyYWwuanM/NWFmYSJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxnQkFBZ0IsbUJBQU8sQ0FBQyxFQUFjOztBQUV0QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsImZpbGUiOiI4OS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBOYW1lZE5vZGUgPSByZXF1aXJlKCcuL25hbWVkLW5vZGUnKVxuXG5mdW5jdGlvbiBMaXRlcmFsICh2YWx1ZSwgbGFuZ3VhZ2UsIGRhdGF0eXBlKSB7XG4gIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB0aGlzLmRhdGF0eXBlID0gTGl0ZXJhbC5zdHJpbmdEYXRhdHlwZVxuICB0aGlzLmxhbmd1YWdlID0gJydcblxuICBpZiAobGFuZ3VhZ2UpIHtcbiAgICB0aGlzLmxhbmd1YWdlID0gbGFuZ3VhZ2VcbiAgICB0aGlzLmRhdGF0eXBlID0gTGl0ZXJhbC5sYW5nU3RyaW5nRGF0YXR5cGVcbiAgfSBlbHNlIGlmIChkYXRhdHlwZSkge1xuICAgIHRoaXMuZGF0YXR5cGUgPSBkYXRhdHlwZVxuICB9XG59XG5cbkxpdGVyYWwucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICByZXR1cm4gISFvdGhlciAmJiBvdGhlci50ZXJtVHlwZSA9PT0gdGhpcy50ZXJtVHlwZSAmJiBvdGhlci52YWx1ZSA9PT0gdGhpcy52YWx1ZSAmJlxuICAgIG90aGVyLmxhbmd1YWdlID09PSB0aGlzLmxhbmd1YWdlICYmIG90aGVyLmRhdGF0eXBlLmVxdWFscyh0aGlzLmRhdGF0eXBlKVxufVxuXG5MaXRlcmFsLnByb3RvdHlwZS50ZXJtVHlwZSA9ICdMaXRlcmFsJ1xuTGl0ZXJhbC5sYW5nU3RyaW5nRGF0YXR5cGUgPSBuZXcgTmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjbGFuZ1N0cmluZycpXG5MaXRlcmFsLnN0cmluZ0RhdGF0eXBlID0gbmV3IE5hbWVkTm9kZSgnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjc3RyaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSBMaXRlcmFsXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///89\n")},function(module,exports,__webpack_require__){eval("var DefaultGraph = __webpack_require__(49)\n\nfunction Quad (subject, predicate, object, graph) {\n  this.subject = subject\n  this.predicate = predicate\n  this.object = object\n\n  if (graph) {\n    this.graph = graph\n  } else {\n    this.graph = new DefaultGraph()\n  }\n}\n\nQuad.prototype.equals = function (other) {\n  return !!other && other.subject.equals(this.subject) && other.predicate.equals(this.predicate) &&\n    other.object.equals(this.object) && other.graph.equals(this.graph)\n}\n\nmodule.exports = Quad\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL3F1YWQuanM/ZTFjYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsbUJBQU8sQ0FBQyxFQUFpQjs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJmaWxlIjoiOTAuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgRGVmYXVsdEdyYXBoID0gcmVxdWlyZSgnLi9kZWZhdWx0LWdyYXBoJylcblxuZnVuY3Rpb24gUXVhZCAoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gIHRoaXMuc3ViamVjdCA9IHN1YmplY3RcbiAgdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGVcbiAgdGhpcy5vYmplY3QgPSBvYmplY3RcblxuICBpZiAoZ3JhcGgpIHtcbiAgICB0aGlzLmdyYXBoID0gZ3JhcGhcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmdyYXBoID0gbmV3IERlZmF1bHRHcmFwaCgpXG4gIH1cbn1cblxuUXVhZC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKG90aGVyKSB7XG4gIHJldHVybiAhIW90aGVyICYmIG90aGVyLnN1YmplY3QuZXF1YWxzKHRoaXMuc3ViamVjdCkgJiYgb3RoZXIucHJlZGljYXRlLmVxdWFscyh0aGlzLnByZWRpY2F0ZSkgJiZcbiAgICBvdGhlci5vYmplY3QuZXF1YWxzKHRoaXMub2JqZWN0KSAmJiBvdGhlci5ncmFwaC5lcXVhbHModGhpcy5ncmFwaClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBRdWFkXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///90\n")},function(module,exports){eval("function Variable (name) {\n  this.value = name\n}\n\nVariable.prototype.equals = function (other) {\n  return !!other && other.termType === this.termType && other.value === this.value\n}\n\nVariable.prototype.termType = 'Variable'\n\nmodule.exports = Variable\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHJkZmpzL2RhdGEtbW9kZWwvbGliL3ZhcmlhYmxlLmpzP2E1NWMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsImZpbGUiOiI5MS5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIFZhcmlhYmxlIChuYW1lKSB7XG4gIHRoaXMudmFsdWUgPSBuYW1lXG59XG5cblZhcmlhYmxlLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAob3RoZXIpIHtcbiAgcmV0dXJuICEhb3RoZXIgJiYgb3RoZXIudGVybVR5cGUgPT09IHRoaXMudGVybVR5cGUgJiYgb3RoZXIudmFsdWUgPT09IHRoaXMudmFsdWVcbn1cblxuVmFyaWFibGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ1ZhcmlhYmxlJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZhcmlhYmxlXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///91\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzFmYjUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsImZpbGUiOiI5Mi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///92\n")},function(module,exports){eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz85MTUyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFdBQVc7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVzs7QUFFbkI7QUFDQTtBQUNBLFFBQVEsVUFBVTs7QUFFbEI7QUFDQSIsImZpbGUiOiI5My5qcyIsInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///93\n")},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pc2FycmF5L2luZGV4LmpzPzIzMzUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EiLCJmaWxlIjoiOTQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgdG9TdHJpbmcgPSB7fS50b1N0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwoYXJyKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///94\n")},function(module,exports,__webpack_require__){eval('/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    "use strict";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== "function") {\n        callback = new Function("" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."\n        // So if we\'re currently running a task, we\'ll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // "too much recursion" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can\'t be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage("", "*");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = "setImmediate$" + Math.random() + "$";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === "string" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener("message", onGlobalMessage, false);\n        } else {\n            global.attachEvent("onmessage", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, "*");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it\'s been called.\n            var script = doc.createElement("script");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don\'t get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === "[object process]") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && "onreadystatechange" in doc.createElement("script")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6), __webpack_require__(19)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcz82MDE3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsRUFBRTtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQyIsImZpbGUiOiI5NS5qcyIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCB1bmRlZmluZWQpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIGlmIChnbG9iYWwuc2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbmV4dEhhbmRsZSA9IDE7IC8vIFNwZWMgc2F5cyBncmVhdGVyIHRoYW4gemVyb1xuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XG4gICAgdmFyIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgIHZhciBkb2MgPSBnbG9iYWwuZG9jdW1lbnQ7XG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xuXG4gICAgZnVuY3Rpb24gc2V0SW1tZWRpYXRlKGNhbGxiYWNrKSB7XG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBjYWxsYmFjayA9IG5ldyBGdW5jdGlvbihcIlwiICsgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgLy8gQ29weSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaSArIDFdO1xuICAgICAgfVxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXG4gICAgICB2YXIgdGFzayA9IHsgY2FsbGJhY2s6IGNhbGxiYWNrLCBhcmdzOiBhcmdzIH07XG4gICAgICB0YXNrc0J5SGFuZGxlW25leHRIYW5kbGVdID0gdGFzaztcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xuICAgICAgcmV0dXJuIG5leHRIYW5kbGUrKztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjbGVhckltbWVkaWF0ZShoYW5kbGUpIHtcbiAgICAgICAgZGVsZXRlIHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW4odGFzaykge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICB2YXIgYXJncyA9IHRhc2suYXJncztcbiAgICAgICAgc3dpdGNoIChhcmdzLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhbGxiYWNrKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseSh1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XG4gICAgICAgIC8vIEZyb20gdGhlIHNwZWM6IFwiV2FpdCB1bnRpbCBhbnkgaW52b2NhdGlvbnMgb2YgdGhpcyBhbGdvcml0aG0gc3RhcnRlZCBiZWZvcmUgdGhpcyBvbmUgaGF2ZSBjb21wbGV0ZWQuXCJcbiAgICAgICAgLy8gU28gaWYgd2UncmUgY3VycmVudGx5IHJ1bm5pbmcgYSB0YXNrLCB3ZSdsbCBuZWVkIHRvIGRlbGF5IHRoaXMgaW52b2NhdGlvbi5cbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xuICAgICAgICAgICAgLy8gRGVsYXkgYnkgZG9pbmcgYSBzZXRUaW1lb3V0LiBzZXRJbW1lZGlhdGUgd2FzIHRyaWVkIGluc3RlYWQsIGJ1dCBpbiBGaXJlZm94IDcgaXQgZ2VuZXJhdGVkIGFcbiAgICAgICAgICAgIC8vIFwidG9vIG11Y2ggcmVjdXJzaW9uXCIgZXJyb3IuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0YXNrID0gdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgICAgICAgICAgaWYgKHRhc2spIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcbiAgICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhckltbWVkaWF0ZShoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkgeyBydW5JZlByZXNlbnQoaGFuZGxlKTsgfSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XG4gICAgICAgIC8vIFRoZSB0ZXN0IGFnYWluc3QgYGltcG9ydFNjcmlwdHNgIHByZXZlbnRzIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSBiZWluZyBpbnN0YWxsZWQgaW5zaWRlIGEgd2ViIHdvcmtlcixcbiAgICAgICAgLy8gd2hlcmUgYGdsb2JhbC5wb3N0TWVzc2FnZWAgbWVhbnMgc29tZXRoaW5nIGNvbXBsZXRlbHkgZGlmZmVyZW50IGFuZCBjYW4ndCBiZSB1c2VkIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XG4gICAgICAgICAgICB2YXIgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb2xkT25NZXNzYWdlID0gZ2xvYmFsLm9ubWVzc2FnZTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBvbGRPbk1lc3NhZ2U7XG4gICAgICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICAvLyBJbnN0YWxscyBhbiBldmVudCBoYW5kbGVyIG9uIGBnbG9iYWxgIGZvciB0aGUgYG1lc3NhZ2VgIGV2ZW50OiBzZWVcbiAgICAgICAgLy8gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9ET00vd2luZG93LnBvc3RNZXNzYWdlXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcblxuICAgICAgICB2YXIgbWVzc2FnZVByZWZpeCA9IFwic2V0SW1tZWRpYXRlJFwiICsgTWF0aC5yYW5kb20oKSArIFwiJFwiO1xuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2UgPT09IGdsb2JhbCAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBldmVudC5kYXRhID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KCtldmVudC5kYXRhLnNsaWNlKG1lc3NhZ2VQcmVmaXgubGVuZ3RoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoXCJvbm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaGFuZGxlID0gZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgPHNjcmlwdD4gZWxlbWVudDsgaXRzIHJlYWR5c3RhdGVjaGFuZ2UgZXZlbnQgd2lsbCBiZSBmaXJlZCBhc3luY2hyb25vdXNseSBvbmNlIGl0IGlzIGluc2VydGVkXG4gICAgICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudC4gRG8gc28sIHRodXMgcXVldWluZyB1cCB0aGUgdGFzay4gUmVtZW1iZXIgdG8gY2xlYW4gdXAgb25jZSBpdCdzIGJlZW4gY2FsbGVkLlxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIElmIHN1cHBvcnRlZCwgd2Ugc2hvdWxkIGF0dGFjaCB0byB0aGUgcHJvdG90eXBlIG9mIGdsb2JhbCwgc2luY2UgdGhhdCBpcyB3aGVyZSBzZXRUaW1lb3V0IGV0IGFsLiBsaXZlLlxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcbiAgICBhdHRhY2hUbyA9IGF0dGFjaFRvICYmIGF0dGFjaFRvLnNldFRpbWVvdXQgPyBhdHRhY2hUbyA6IGdsb2JhbDtcblxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChnbG9iYWwucHJvY2VzcykgPT09IFwiW29iamVjdCBwcm9jZXNzXVwiKSB7XG4gICAgICAgIC8vIEZvciBOb2RlLmpzIGJlZm9yZSAwLjlcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoY2FuVXNlUG9zdE1lc3NhZ2UoKSkge1xuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xuICAgICAgICAvLyBGb3Igd2ViIHdvcmtlcnMsIHdoZXJlIHN1cHBvcnRlZFxuICAgICAgICBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChkb2MgJiYgXCJvbnJlYWR5c3RhdGVjaGFuZ2VcIiBpbiBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKSkge1xuICAgICAgICAvLyBGb3IgSUUgNuKAkzhcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXG4gICAgICAgIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKTtcbiAgICB9XG5cbiAgICBhdHRhY2hUby5zZXRJbW1lZGlhdGUgPSBzZXRJbW1lZGlhdGU7XG4gICAgYXR0YWNoVG8uY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///95\n')},function(module,exports){eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanM/OWJjOCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSIsImZpbGUiOiI5Ni5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///96\n")},function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/Zjc4MyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI5Ny5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///97\n")},function(module,exports,__webpack_require__){"use strict";eval("\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = __webpack_require__(33).Buffer;\nvar util = __webpack_require__(99);\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0LmpzPzliNTQiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsaURBQWlELDBDQUEwQywwREFBMEQsRUFBRTs7QUFFdkosYUFBYSxtQkFBTyxDQUFDLEVBQWE7QUFDbEMsV0FBVyxtQkFBTyxDQUFDLEVBQU07O0FBRXpCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7QUFDakIsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLDRCQUE0QixzQkFBc0I7QUFDbEQ7QUFDQTtBQUNBIiwiZmlsZSI6Ijk4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///98\n")},function(module,exports){eval("/* (ignored) *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vdXRpbCAoaWdub3JlZCk/MGRhMCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSIsImZpbGUiOiI5OS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qIChpZ25vcmVkKSAqLyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///99\n")},function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(global) {\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(6)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcz9iN2QxIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixhQUFhLFNBQVM7QUFDdEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///100\n")},function(module,exports,__webpack_require__){eval("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(9)\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanM/ODcwNyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLENBQVE7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMTAxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///101\n")},function(module,exports,__webpack_require__){"use strict";eval('// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// "Software"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n\n\nmodule.exports = PassThrough;\n\nvar Transform = __webpack_require__(56);\n\n/*<replacement>*/\nvar util = Object.create(__webpack_require__(10));\nutil.inherits = __webpack_require__(7);\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcz9hYTY5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVhOztBQUViOztBQUVBLGdCQUFnQixtQkFBTyxDQUFDLEVBQXFCOztBQUU3QztBQUNBLHlCQUF5QixtQkFBTyxDQUFDLEVBQWM7QUFDL0MsZ0JBQWdCLG1CQUFPLENBQUMsQ0FBVTtBQUNsQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwiZmlsZSI6IjEwMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///102\n')},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(34);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzP2FmN2UiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUJBQWlCLG1CQUFPLENBQUMsRUFBMkIiLCJmaWxlIjoiMTAzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///103\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(5);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcz83YzE2Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLENBQXlCIiwiZmlsZSI6IjEwNC5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///104\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(32).Transform\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanM/ODlmZCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsbUJBQU8sQ0FBQyxFQUFZIiwiZmlsZSI6IjEwNS5qcyIsInNvdXJjZXNDb250ZW50IjpbIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///105\n")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(32).PassThrough\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcz81MWEyIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLEVBQVkiLCJmaWxlIjoiMTA2LmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///106\n")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/css/bootstrap/bootstrap.min.css\nvar bootstrap_min = __webpack_require__(61);\n\n// EXTERNAL MODULE: ./src/styles.css\nvar src_styles = __webpack_require__(62);\n\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/dom.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * True if the custom elements polyfill is in use.\n */\nconst isCEPolyfill = typeof window !== 'undefined' &&\n    window.customElements != null &&\n    window.customElements.polyfillWrapFlushCallback !==\n        undefined;\n/**\n * Reparents nodes, starting from `start` (inclusive) to `end` (exclusive),\n * into another container (could be the same container), before `before`. If\n * `before` is null, it appends the nodes to the container.\n */\nconst reparentNodes = (container, start, end = null, before = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.insertBefore(start, before);\n        start = n;\n    }\n};\n/**\n * Removes nodes, starting from `start` (inclusive) to `end` (exclusive), from\n * `container`.\n */\nconst removeNodes = (container, start, end = null) => {\n    while (start !== end) {\n        const n = start.nextSibling;\n        container.removeChild(start);\n        start = n;\n    }\n};\n//# sourceMappingURL=dom.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * An expression marker with embedded unique key to avoid collision with\n * possible text in templates.\n */\nconst marker = `{{lit-${String(Math.random()).slice(2)}}}`;\n/**\n * An expression marker used text-positions, multi-binding attributes, and\n * attributes with markup-like text values.\n */\nconst nodeMarker = `\x3c!--${marker}--\x3e`;\nconst markerRegex = new RegExp(`${marker}|${nodeMarker}`);\n/**\n * Suffix appended to all bound attribute names.\n */\nconst boundAttributeSuffix = '$lit$';\n/**\n * An updatable Template that tracks the location of dynamic parts.\n */\nclass Template {\n    constructor(result, element) {\n        this.parts = [];\n        this.element = element;\n        const nodesToRemove = [];\n        const stack = [];\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(element.content, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        // Keeps track of the last index associated with a part. We try to delete\n        // unnecessary nodes, but we never want to associate two different parts\n        // to the same index. They must have a constant node between.\n        let lastPartIndex = 0;\n        let index = -1;\n        let partIndex = 0;\n        const { strings, values: { length } } = result;\n        while (partIndex < length) {\n            const node = walker.nextNode();\n            if (node === null) {\n                // We've exhausted the content inside a nested template element.\n                // Because we still have parts (the outer for-loop), we know:\n                // - There is a template in the stack\n                // - The walker will find a nextNode outside the template\n                walker.currentNode = stack.pop();\n                continue;\n            }\n            index++;\n            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {\n                if (node.hasAttributes()) {\n                    const attributes = node.attributes;\n                    const { length } = attributes;\n                    // Per\n                    // https://developer.mozilla.org/en-US/docs/Web/API/NamedNodeMap,\n                    // attributes are not guaranteed to be returned in document order.\n                    // In particular, Edge/IE can return them out of order, so we cannot\n                    // assume a correspondence between part index and attribute index.\n                    let count = 0;\n                    for (let i = 0; i < length; i++) {\n                        if (endsWith(attributes[i].name, boundAttributeSuffix)) {\n                            count++;\n                        }\n                    }\n                    while (count-- > 0) {\n                        // Get the template literal section leading up to the first\n                        // expression in this attribute\n                        const stringForPart = strings[partIndex];\n                        // Find the attribute name\n                        const name = lastAttributeNameRegex.exec(stringForPart)[2];\n                        // Find the corresponding attribute\n                        // All bound attributes have had a suffix added in\n                        // TemplateResult#getHTML to opt out of special attribute\n                        // handling. To look up the attribute value we also need to add\n                        // the suffix.\n                        const attributeLookupName = name.toLowerCase() + boundAttributeSuffix;\n                        const attributeValue = node.getAttribute(attributeLookupName);\n                        node.removeAttribute(attributeLookupName);\n                        const statics = attributeValue.split(markerRegex);\n                        this.parts.push({ type: 'attribute', index, name, strings: statics });\n                        partIndex += statics.length - 1;\n                    }\n                }\n                if (node.tagName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n            }\n            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {\n                const data = node.data;\n                if (data.indexOf(marker) >= 0) {\n                    const parent = node.parentNode;\n                    const strings = data.split(markerRegex);\n                    const lastIndex = strings.length - 1;\n                    // Generate a new text node for each literal section\n                    // These nodes are also used as the markers for node parts\n                    for (let i = 0; i < lastIndex; i++) {\n                        let insert;\n                        let s = strings[i];\n                        if (s === '') {\n                            insert = createMarker();\n                        }\n                        else {\n                            const match = lastAttributeNameRegex.exec(s);\n                            if (match !== null && endsWith(match[2], boundAttributeSuffix)) {\n                                s = s.slice(0, match.index) + match[1] +\n                                    match[2].slice(0, -boundAttributeSuffix.length) + match[3];\n                            }\n                            insert = document.createTextNode(s);\n                        }\n                        parent.insertBefore(insert, node);\n                        this.parts.push({ type: 'node', index: ++index });\n                    }\n                    // If there's no text, we must insert a comment to mark our place.\n                    // Else, we can trust it will stick around after cloning.\n                    if (strings[lastIndex] === '') {\n                        parent.insertBefore(createMarker(), node);\n                        nodesToRemove.push(node);\n                    }\n                    else {\n                        node.data = strings[lastIndex];\n                    }\n                    // We have a part for each match found\n                    partIndex += lastIndex;\n                }\n            }\n            else if (node.nodeType === 8 /* Node.COMMENT_NODE */) {\n                if (node.data === marker) {\n                    const parent = node.parentNode;\n                    // Add a new marker node to be the startNode of the Part if any of\n                    // the following are true:\n                    //  * We don't have a previousSibling\n                    //  * The previousSibling is already the start of a previous part\n                    if (node.previousSibling === null || index === lastPartIndex) {\n                        index++;\n                        parent.insertBefore(createMarker(), node);\n                    }\n                    lastPartIndex = index;\n                    this.parts.push({ type: 'node', index });\n                    // If we don't have a nextSibling, keep this node so we have an end.\n                    // Else, we can remove it to save future costs.\n                    if (node.nextSibling === null) {\n                        node.data = '';\n                    }\n                    else {\n                        nodesToRemove.push(node);\n                        index--;\n                    }\n                    partIndex++;\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        // TODO (justinfagnani): consider whether it's even worth it to\n                        // make bindings in comments work\n                        this.parts.push({ type: 'node', index: -1 });\n                        partIndex++;\n                    }\n                }\n            }\n        }\n        // Remove text binding nodes after the walk to not disturb the TreeWalker\n        for (const n of nodesToRemove) {\n            n.parentNode.removeChild(n);\n        }\n    }\n}\nconst endsWith = (str, suffix) => {\n    const index = str.length - suffix.length;\n    return index >= 0 && str.slice(index) === suffix;\n};\nconst isTemplatePartActive = (part) => part.index !== -1;\n// Allows `document.createComment('')` to be renamed for a\n// small manual size-savings.\nconst createMarker = () => document.createComment('');\n/**\n * This regex extracts the attribute name preceding an attribute-position\n * expression. It does this by matching the syntax allowed for attributes\n * against the string literal directly preceding the expression, assuming that\n * the expression is in an attribute-value position.\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\x09\\x0a\\x0c\\x0d\" are HTML space characters:\n * https://www.w3.org/TR/html5/infrastructure.html#space-characters\n *\n * \"\\0-\\x1F\\x7F-\\x9F\" are Unicode control characters, which includes every\n * space character except \" \".\n *\n * So an attribute is:\n *  * The name: any character except a control character, space character, ('),\n *    (\"), \">\", \"=\", or \"/\"\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst lastAttributeNameRegex = \n// eslint-disable-next-line no-control-regex\n/([ \\x09\\x0a\\x0c\\x0d])([^\\0-\\x1F\\x7F-\\x9F \"'>=/]+)([ \\x09\\x0a\\x0c\\x0d]*=[ \\x09\\x0a\\x0c\\x0d]*(?:[^ \\x09\\x0a\\x0c\\x0d\"'`<>=]*|\"[^\"]*|'[^']*))$/;\n//# sourceMappingURL=template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/modify-template.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module shady-render\n */\n\nconst walkerNodeFilter = 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */;\n/**\n * Removes the list of nodes from a Template safely. In addition to removing\n * nodes from the Template, the Template part indices are updated to match\n * the mutated Template DOM.\n *\n * As the template is walked the removal state is tracked and\n * part indices are adjusted as needed.\n *\n * div\n *   div#1 (remove) <-- start removing (removing node is div#1)\n *     div\n *       div#2 (remove)  <-- continue removing (removing node is still div#1)\n *         div\n * div <-- stop removing since previous sibling is the removing node (div#1,\n * removed 4 nodes)\n */\nfunction removeNodesFromTemplate(template, nodesToRemove) {\n    const { element: { content }, parts } = template;\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let part = parts[partIndex];\n    let nodeIndex = -1;\n    let removeCount = 0;\n    const nodesToRemoveInTemplate = [];\n    let currentRemovingNode = null;\n    while (walker.nextNode()) {\n        nodeIndex++;\n        const node = walker.currentNode;\n        // End removal if stepped past the removing node\n        if (node.previousSibling === currentRemovingNode) {\n            currentRemovingNode = null;\n        }\n        // A node to remove was found in the template\n        if (nodesToRemove.has(node)) {\n            nodesToRemoveInTemplate.push(node);\n            // Track node we're removing\n            if (currentRemovingNode === null) {\n                currentRemovingNode = node;\n            }\n        }\n        // When removing, increment count by which to adjust subsequent part indices\n        if (currentRemovingNode !== null) {\n            removeCount++;\n        }\n        while (part !== undefined && part.index === nodeIndex) {\n            // If part is in a removed node deactivate it by setting index to -1 or\n            // adjust the index as needed.\n            part.index = currentRemovingNode !== null ? -1 : part.index - removeCount;\n            // go to the next active part.\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n            part = parts[partIndex];\n        }\n    }\n    nodesToRemoveInTemplate.forEach((n) => n.parentNode.removeChild(n));\n}\nconst countNodes = (node) => {\n    let count = (node.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */) ? 0 : 1;\n    const walker = document.createTreeWalker(node, walkerNodeFilter, null, false);\n    while (walker.nextNode()) {\n        count++;\n    }\n    return count;\n};\nconst nextActiveIndexInTemplateParts = (parts, startIndex = -1) => {\n    for (let i = startIndex + 1; i < parts.length; i++) {\n        const part = parts[i];\n        if (isTemplatePartActive(part)) {\n            return i;\n        }\n    }\n    return -1;\n};\n/**\n * Inserts the given node into the Template, optionally before the given\n * refNode. In addition to inserting the node into the Template, the Template\n * part indices are updated to match the mutated Template DOM.\n */\nfunction insertNodeIntoTemplate(template, node, refNode = null) {\n    const { element: { content }, parts } = template;\n    // If there's no refNode, then put node at end of template.\n    // No part indices need to be shifted in this case.\n    if (refNode === null || refNode === undefined) {\n        content.appendChild(node);\n        return;\n    }\n    const walker = document.createTreeWalker(content, walkerNodeFilter, null, false);\n    let partIndex = nextActiveIndexInTemplateParts(parts);\n    let insertCount = 0;\n    let walkerIndex = -1;\n    while (walker.nextNode()) {\n        walkerIndex++;\n        const walkerNode = walker.currentNode;\n        if (walkerNode === refNode) {\n            insertCount = countNodes(node);\n            refNode.parentNode.insertBefore(node, refNode);\n        }\n        while (partIndex !== -1 && parts[partIndex].index === walkerIndex) {\n            // If we've inserted the node, simply adjust all subsequent parts\n            if (insertCount > 0) {\n                while (partIndex !== -1) {\n                    parts[partIndex].index += insertCount;\n                    partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n                }\n                return;\n            }\n            partIndex = nextActiveIndexInTemplateParts(parts, partIndex);\n        }\n    }\n}\n//# sourceMappingURL=modify-template.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/directive.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst directives = new WeakMap();\n/**\n * Brands a function as a directive factory function so that lit-html will call\n * the function during template rendering, rather than passing as a value.\n *\n * A _directive_ is a function that takes a Part as an argument. It has the\n * signature: `(part: Part) => void`.\n *\n * A directive _factory_ is a function that takes arguments for data and\n * configuration and returns a directive. Users of directive usually refer to\n * the directive factory as the directive. For example, \"The repeat directive\".\n *\n * Usually a template author will invoke a directive factory in their template\n * with relevant arguments, which will then return a directive function.\n *\n * Here's an example of using the `repeat()` directive factory that takes an\n * array and a function to render an item:\n *\n * ```js\n * html`<ul><${repeat(items, (item) => html`<li>${item}</li>`)}</ul>`\n * ```\n *\n * When `repeat` is invoked, it returns a directive function that closes over\n * `items` and the template function. When the outer template is rendered, the\n * return directive function is called with the Part for the expression.\n * `repeat` then performs it's custom logic to render multiple items.\n *\n * @param f The directive factory function. Must be a function that returns a\n * function of the signature `(part: Part) => void`. The returned function will\n * be called with the part object.\n *\n * @example\n *\n * import {directive, html} from 'lit-html';\n *\n * const immutable = directive((v) => (part) => {\n *   if (part.value !== v) {\n *     part.setValue(v)\n *   }\n * });\n */\nconst directive_directive = (f) => ((...args) => {\n    const d = f(...args);\n    directives.set(d, true);\n    return d;\n});\nconst isDirective = (o) => {\n    return typeof o === 'function' && directives.has(o);\n};\n//# sourceMappingURL=directive.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/part.js\n/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nconst noChange = {};\n/**\n * A sentinel value that signals a NodePart to fully clear its content.\n */\nconst nothing = {};\n//# sourceMappingURL=part.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-instance.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n/**\n * An instance of a `Template` that can be attached to the DOM and updated\n * with new values.\n */\nclass template_instance_TemplateInstance {\n    constructor(template, processor, options) {\n        this.__parts = [];\n        this.template = template;\n        this.processor = processor;\n        this.options = options;\n    }\n    update(values) {\n        let i = 0;\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.setValue(values[i]);\n            }\n            i++;\n        }\n        for (const part of this.__parts) {\n            if (part !== undefined) {\n                part.commit();\n            }\n        }\n    }\n    _clone() {\n        // There are a number of steps in the lifecycle of a template instance's\n        // DOM fragment:\n        //  1. Clone - create the instance fragment\n        //  2. Adopt - adopt into the main document\n        //  3. Process - find part markers and create parts\n        //  4. Upgrade - upgrade custom elements\n        //  5. Update - set node, attribute, property, etc., values\n        //  6. Connect - connect to the document. Optional and outside of this\n        //     method.\n        //\n        // We have a few constraints on the ordering of these steps:\n        //  * We need to upgrade before updating, so that property values will pass\n        //    through any property setters.\n        //  * We would like to process before upgrading so that we're sure that the\n        //    cloned fragment is inert and not disturbed by self-modifying DOM.\n        //  * We want custom elements to upgrade even in disconnected fragments.\n        //\n        // Given these constraints, with full custom elements support we would\n        // prefer the order: Clone, Process, Adopt, Upgrade, Update, Connect\n        //\n        // But Safari does not implement CustomElementRegistry#upgrade, so we\n        // can not implement that order and still have upgrade-before-update and\n        // upgrade disconnected fragments. So we instead sacrifice the\n        // process-before-upgrade constraint, since in Custom Elements v1 elements\n        // must not modify their light DOM in the constructor. We still have issues\n        // when co-existing with CEv0 elements like Polymer 1, and with polyfills\n        // that don't strictly adhere to the no-modification rule because shadow\n        // DOM, which may be created in the constructor, is emulated by being placed\n        // in the light DOM.\n        //\n        // The resulting order is on native is: Clone, Adopt, Upgrade, Process,\n        // Update, Connect. document.importNode() performs Clone, Adopt, and Upgrade\n        // in one step.\n        //\n        // The Custom Elements v1 polyfill supports upgrade(), so the order when\n        // polyfilled is the more ideal: Clone, Process, Adopt, Upgrade, Update,\n        // Connect.\n        const fragment = isCEPolyfill ?\n            this.template.element.content.cloneNode(true) :\n            document.importNode(this.template.element.content, true);\n        const stack = [];\n        const parts = this.template.parts;\n        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null\n        const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_{ELEMENT|COMMENT|TEXT} */, null, false);\n        let partIndex = 0;\n        let nodeIndex = 0;\n        let part;\n        let node = walker.nextNode();\n        // Loop through all the nodes and parts of a template\n        while (partIndex < parts.length) {\n            part = parts[partIndex];\n            if (!isTemplatePartActive(part)) {\n                this.__parts.push(undefined);\n                partIndex++;\n                continue;\n            }\n            // Progress the tree walker until we find our next part's node.\n            // Note that multiple parts may share the same node (attribute parts\n            // on a single element), so this loop may not run at all.\n            while (nodeIndex < part.index) {\n                nodeIndex++;\n                if (node.nodeName === 'TEMPLATE') {\n                    stack.push(node);\n                    walker.currentNode = node.content;\n                }\n                if ((node = walker.nextNode()) === null) {\n                    // We've exhausted the content inside a nested template element.\n                    // Because we still have parts (the outer for-loop), we know:\n                    // - There is a template in the stack\n                    // - The walker will find a nextNode outside the template\n                    walker.currentNode = stack.pop();\n                    node = walker.nextNode();\n                }\n            }\n            // We've arrived at our part's node.\n            if (part.type === 'node') {\n                const part = this.processor.handleTextExpression(this.options);\n                part.insertAfterNode(node.previousSibling);\n                this.__parts.push(part);\n            }\n            else {\n                this.__parts.push(...this.processor.handleAttributeExpressions(node, part.name, part.strings, this.options));\n            }\n            partIndex++;\n        }\n        if (isCEPolyfill) {\n            document.adoptNode(fragment);\n            customElements.upgrade(fragment);\n        }\n        return fragment;\n    }\n}\n//# sourceMappingURL=template-instance.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-result.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\nconst commentMarker = ` ${marker} `;\n/**\n * The return type of `html`, which holds a Template and the values from\n * interpolated expressions.\n */\nclass template_result_TemplateResult {\n    constructor(strings, values, type, processor) {\n        this.strings = strings;\n        this.values = values;\n        this.type = type;\n        this.processor = processor;\n    }\n    /**\n     * Returns a string of HTML used to create a `<template>` element.\n     */\n    getHTML() {\n        const l = this.strings.length - 1;\n        let html = '';\n        let isCommentBinding = false;\n        for (let i = 0; i < l; i++) {\n            const s = this.strings[i];\n            // For each binding we want to determine the kind of marker to insert\n            // into the template source before it's parsed by the browser's HTML\n            // parser. The marker type is based on whether the expression is in an\n            // attribute, text, or comment position.\n            //   * For node-position bindings we insert a comment with the marker\n            //     sentinel as its text content, like \x3c!--{{lit-guid}}--\x3e.\n            //   * For attribute bindings we insert just the marker sentinel for the\n            //     first binding, so that we support unquoted attribute bindings.\n            //     Subsequent bindings can use a comment marker because multi-binding\n            //     attributes must be quoted.\n            //   * For comment bindings we insert just the marker sentinel so we don't\n            //     close the comment.\n            //\n            // The following code scans the template source, but is *not* an HTML\n            // parser. We don't need to track the tree structure of the HTML, only\n            // whether a binding is inside a comment, and if not, if it appears to be\n            // the first binding in an attribute.\n            const commentOpen = s.lastIndexOf('\x3c!--');\n            // We're in comment position if we have a comment open with no following\n            // comment close. Because <-- can appear in an attribute value there can\n            // be false positives.\n            isCommentBinding = (commentOpen > -1 || isCommentBinding) &&\n                s.indexOf('--\x3e', commentOpen + 1) === -1;\n            // Check to see if we have an attribute-like sequence preceding the\n            // expression. This can match \"name=value\" like structures in text,\n            // comments, and attribute values, so there can be false-positives.\n            const attributeMatch = lastAttributeNameRegex.exec(s);\n            if (attributeMatch === null) {\n                // We're only in this branch if we don't have a attribute-like\n                // preceding sequence. For comments, this guards against unusual\n                // attribute values like <div foo=\"\x3c!--${'bar'}\">. Cases like\n                // \x3c!-- foo=${'bar'}--\x3e are handled correctly in the attribute branch\n                // below.\n                html += s + (isCommentBinding ? commentMarker : nodeMarker);\n            }\n            else {\n                // For attributes we use just a marker sentinel, and also append a\n                // $lit$ suffix to the name to opt-out of attribute-specific parsing\n                // that IE and Edge do for style and certain SVG attributes.\n                html += s.substr(0, attributeMatch.index) + attributeMatch[1] +\n                    attributeMatch[2] + boundAttributeSuffix + attributeMatch[3] +\n                    marker;\n            }\n        }\n        html += this.strings[l];\n        return html;\n    }\n    getTemplateElement() {\n        const template = document.createElement('template');\n        template.innerHTML = this.getHTML();\n        return template;\n    }\n}\n/**\n * A TemplateResult for SVG fragments.\n *\n * This class wraps HTML in an `<svg>` tag in order to parse its contents in the\n * SVG namespace, then modifies the template to remove the `<svg>` tag so that\n * clones only container the original fragment.\n */\nclass template_result_SVGTemplateResult extends template_result_TemplateResult {\n    getHTML() {\n        return `<svg>${super.getHTML()}</svg>`;\n    }\n    getTemplateElement() {\n        const template = super.getTemplateElement();\n        const content = template.content;\n        const svgElement = content.firstChild;\n        content.removeChild(svgElement);\n        reparentNodes(content, svgElement.firstChild);\n        return template;\n    }\n}\n//# sourceMappingURL=template-result.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/parts.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\n\n\n\nconst isPrimitive = (value) => {\n    return (value === null ||\n        !(typeof value === 'object' || typeof value === 'function'));\n};\nconst isIterable = (value) => {\n    return Array.isArray(value) ||\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        !!(value && value[Symbol.iterator]);\n};\n/**\n * Writes attribute values to the DOM for a group of AttributeParts bound to a\n * single attribute. The value is only set once even if there are multiple parts\n * for an attribute.\n */\nclass AttributeCommitter {\n    constructor(element, name, strings) {\n        this.dirty = true;\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n        this.parts = [];\n        for (let i = 0; i < strings.length - 1; i++) {\n            this.parts[i] = this._createPart();\n        }\n    }\n    /**\n     * Creates a single part. Override this to create a differnt type of part.\n     */\n    _createPart() {\n        return new parts_AttributePart(this);\n    }\n    _getValue() {\n        const strings = this.strings;\n        const l = strings.length - 1;\n        let text = '';\n        for (let i = 0; i < l; i++) {\n            text += strings[i];\n            const part = this.parts[i];\n            if (part !== undefined) {\n                const v = part.value;\n                if (isPrimitive(v) || !isIterable(v)) {\n                    text += typeof v === 'string' ? v : String(v);\n                }\n                else {\n                    for (const t of v) {\n                        text += typeof t === 'string' ? t : String(t);\n                    }\n                }\n            }\n        }\n        text += strings[l];\n        return text;\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            this.element.setAttribute(this.name, this._getValue());\n        }\n    }\n}\n/**\n * A Part that controls all or part of an attribute value.\n */\nclass parts_AttributePart {\n    constructor(committer) {\n        this.value = undefined;\n        this.committer = committer;\n    }\n    setValue(value) {\n        if (value !== noChange && (!isPrimitive(value) || value !== this.value)) {\n            this.value = value;\n            // If the value is a not a directive, dirty the committer so that it'll\n            // call setAttribute. If the value is a directive, it'll dirty the\n            // committer if it calls setValue().\n            if (!isDirective(value)) {\n                this.committer.dirty = true;\n            }\n        }\n    }\n    commit() {\n        while (isDirective(this.value)) {\n            const directive = this.value;\n            this.value = noChange;\n            directive(this);\n        }\n        if (this.value === noChange) {\n            return;\n        }\n        this.committer.commit();\n    }\n}\n/**\n * A Part that controls a location within a Node tree. Like a Range, NodePart\n * has start and end locations and can set and update the Nodes between those\n * locations.\n *\n * NodeParts support several value types: primitives, Nodes, TemplateResults,\n * as well as arrays and iterables of those types.\n */\nclass parts_NodePart {\n    constructor(options) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.options = options;\n    }\n    /**\n     * Appends this part into a container.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendInto(container) {\n        this.startNode = container.appendChild(createMarker());\n        this.endNode = container.appendChild(createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` node (between `ref` and `ref`'s next\n     * sibling). Both `ref` and its next sibling must be static, unchanging nodes\n     * such as those that appear in a literal section of a template.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterNode(ref) {\n        this.startNode = ref;\n        this.endNode = ref.nextSibling;\n    }\n    /**\n     * Appends this part into a parent part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    appendIntoPart(part) {\n        part.__insert(this.startNode = createMarker());\n        part.__insert(this.endNode = createMarker());\n    }\n    /**\n     * Inserts this part after the `ref` part.\n     *\n     * This part must be empty, as its contents are not automatically moved.\n     */\n    insertAfterPart(ref) {\n        ref.__insert(this.startNode = createMarker());\n        this.endNode = ref.endNode;\n        ref.endNode = this.startNode;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        if (this.startNode.parentNode === null) {\n            return;\n        }\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        const value = this.__pendingValue;\n        if (value === noChange) {\n            return;\n        }\n        if (isPrimitive(value)) {\n            if (value !== this.value) {\n                this.__commitText(value);\n            }\n        }\n        else if (value instanceof template_result_TemplateResult) {\n            this.__commitTemplateResult(value);\n        }\n        else if (value instanceof Node) {\n            this.__commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this.__commitIterable(value);\n        }\n        else if (value === nothing) {\n            this.value = nothing;\n            this.clear();\n        }\n        else {\n            // Fallback, will render the string representation\n            this.__commitText(value);\n        }\n    }\n    __insert(node) {\n        this.endNode.parentNode.insertBefore(node, this.endNode);\n    }\n    __commitNode(value) {\n        if (this.value === value) {\n            return;\n        }\n        this.clear();\n        this.__insert(value);\n        this.value = value;\n    }\n    __commitText(value) {\n        const node = this.startNode.nextSibling;\n        value = value == null ? '' : value;\n        // If `value` isn't already a string, we explicitly convert it here in case\n        // it can't be implicitly converted - i.e. it's a symbol.\n        const valueAsString = typeof value === 'string' ? value : String(value);\n        if (node === this.endNode.previousSibling &&\n            node.nodeType === 3 /* Node.TEXT_NODE */) {\n            // If we only have a single text node between the markers, we can just\n            // set its value, rather than replacing it.\n            // TODO(justinfagnani): Can we just check if this.value is primitive?\n            node.data = valueAsString;\n        }\n        else {\n            this.__commitNode(document.createTextNode(valueAsString));\n        }\n        this.value = value;\n    }\n    __commitTemplateResult(value) {\n        const template = this.options.templateFactory(value);\n        if (this.value instanceof template_instance_TemplateInstance &&\n            this.value.template === template) {\n            this.value.update(value.values);\n        }\n        else {\n            // Make sure we propagate the template processor from the TemplateResult\n            // so that we use its syntax extension, etc. The template factory comes\n            // from the render function options so that it can control template\n            // caching and preprocessing.\n            const instance = new template_instance_TemplateInstance(template, value.processor, this.options);\n            const fragment = instance._clone();\n            instance.update(value.values);\n            this.__commitNode(fragment);\n            this.value = instance;\n        }\n    }\n    __commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If _value is an array, then the previous render was of an\n        // iterable and _value will contain the NodeParts from the previous\n        // render. If _value is not an array, clear this part and make a new\n        // array for NodeParts.\n        if (!Array.isArray(this.value)) {\n            this.value = [];\n            this.clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this.value;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            // Try to reuse an existing part\n            itemPart = itemParts[partIndex];\n            // If no existing part, create a new one\n            if (itemPart === undefined) {\n                itemPart = new parts_NodePart(this.options);\n                itemParts.push(itemPart);\n                if (partIndex === 0) {\n                    itemPart.appendIntoPart(this);\n                }\n                else {\n                    itemPart.insertAfterPart(itemParts[partIndex - 1]);\n                }\n            }\n            itemPart.setValue(item);\n            itemPart.commit();\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n            this.clear(itemPart && itemPart.endNode);\n        }\n    }\n    clear(startNode = this.startNode) {\n        removeNodes(this.startNode.parentNode, startNode.nextSibling, this.endNode);\n    }\n}\n/**\n * Implements a boolean attribute, roughly as defined in the HTML\n * specification.\n *\n * If the value is truthy, then the attribute is present with a value of\n * ''. If the value is falsey, the attribute is removed.\n */\nclass parts_BooleanAttributePart {\n    constructor(element, name, strings) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        if (strings.length !== 2 || strings[0] !== '' || strings[1] !== '') {\n            throw new Error('Boolean attributes can only contain a single expression');\n        }\n        this.element = element;\n        this.name = name;\n        this.strings = strings;\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const value = !!this.__pendingValue;\n        if (this.value !== value) {\n            if (value) {\n                this.element.setAttribute(this.name, '');\n            }\n            else {\n                this.element.removeAttribute(this.name);\n            }\n            this.value = value;\n        }\n        this.__pendingValue = noChange;\n    }\n}\n/**\n * Sets attribute values for PropertyParts, so that the value is only set once\n * even if there are multiple parts for a property.\n *\n * If an expression controls the whole property value, then the value is simply\n * assigned to the property under control. If there are string literals or\n * multiple expressions, then the strings are expressions are interpolated into\n * a string first.\n */\nclass PropertyCommitter extends AttributeCommitter {\n    constructor(element, name, strings) {\n        super(element, name, strings);\n        this.single =\n            (strings.length === 2 && strings[0] === '' && strings[1] === '');\n    }\n    _createPart() {\n        return new PropertyPart(this);\n    }\n    _getValue() {\n        if (this.single) {\n            return this.parts[0].value;\n        }\n        return super._getValue();\n    }\n    commit() {\n        if (this.dirty) {\n            this.dirty = false;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            this.element[this.name] = this._getValue();\n        }\n    }\n}\nclass PropertyPart extends parts_AttributePart {\n}\n// Detect event listener options support. If the `capture` property is read\n// from the options object, then options are supported. If not, then the third\n// argument to add/removeEventListener is interpreted as the boolean capture\n// value so we should only pass the `capture` property.\nlet eventOptionsSupported = false;\n// Wrap into an IIFE because MS Edge <= v41 does not support having try/catch\n// blocks right into the body of a module\n(() => {\n    try {\n        const options = {\n            get capture() {\n                eventOptionsSupported = true;\n                return false;\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.addEventListener('test', options, options);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        window.removeEventListener('test', options, options);\n    }\n    catch (_e) {\n        // event options not supported\n    }\n})();\nclass parts_EventPart {\n    constructor(element, eventName, eventContext) {\n        this.value = undefined;\n        this.__pendingValue = undefined;\n        this.element = element;\n        this.eventName = eventName;\n        this.eventContext = eventContext;\n        this.__boundHandleEvent = (e) => this.handleEvent(e);\n    }\n    setValue(value) {\n        this.__pendingValue = value;\n    }\n    commit() {\n        while (isDirective(this.__pendingValue)) {\n            const directive = this.__pendingValue;\n            this.__pendingValue = noChange;\n            directive(this);\n        }\n        if (this.__pendingValue === noChange) {\n            return;\n        }\n        const newListener = this.__pendingValue;\n        const oldListener = this.value;\n        const shouldRemoveListener = newListener == null ||\n            oldListener != null &&\n                (newListener.capture !== oldListener.capture ||\n                    newListener.once !== oldListener.once ||\n                    newListener.passive !== oldListener.passive);\n        const shouldAddListener = newListener != null && (oldListener == null || shouldRemoveListener);\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        if (shouldAddListener) {\n            this.__options = getOptions(newListener);\n            this.element.addEventListener(this.eventName, this.__boundHandleEvent, this.__options);\n        }\n        this.value = newListener;\n        this.__pendingValue = noChange;\n    }\n    handleEvent(event) {\n        if (typeof this.value === 'function') {\n            this.value.call(this.eventContext || this.element, event);\n        }\n        else {\n            this.value.handleEvent(event);\n        }\n    }\n}\n// We copy options because of the inconsistent behavior of browsers when reading\n// the third argument of add/removeEventListener. IE11 doesn't support options\n// at all. Chrome 41 only reads `capture` if the argument is an object.\nconst getOptions = (o) => o &&\n    (eventOptionsSupported ?\n        { capture: o.capture, passive: o.passive, once: o.once } :\n        o.capture);\n//# sourceMappingURL=parts.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/template-factory.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * The default TemplateFactory which caches Templates keyed on\n * result.type and result.strings.\n */\nfunction templateFactory(result) {\n    let templateCache = templateCaches.get(result.type);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(result.type, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    // If the TemplateStringsArray is new, generate a key from the strings\n    // This key is shared between all templates with identical content\n    const key = result.strings.join(marker);\n    // Check if we already have a Template for this key\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        // If we have not seen this key before, create a new Template\n        template = new Template(result, result.getTemplateElement());\n        // Cache the Template for this key\n        templateCache.keyString.set(key, template);\n    }\n    // Cache all future queries for this TemplateStringsArray\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n}\nconst templateCaches = new Map();\n//# sourceMappingURL=template-factory.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * @module lit-html\n */\n\n\n\nconst render_parts = new WeakMap();\n/**\n * Renders a template result or other value to a container.\n *\n * To update a container with new values, reevaluate the template literal and\n * call `render` with the new result.\n *\n * @param result Any value renderable by NodePart - typically a TemplateResult\n *     created by evaluating a template tag like `html` or `svg`.\n * @param container A DOM parent to render to. The entire contents are either\n *     replaced, or efficiently updated if the same result type was previous\n *     rendered there.\n * @param options RenderOptions for the entire render tree rendered to this\n *     container. Render options must *not* change between renders to the same\n *     container, as those changes will not effect previously rendered DOM.\n */\nconst render = (result, container, options) => {\n    let part = render_parts.get(container);\n    if (part === undefined) {\n        removeNodes(container, container.firstChild);\n        render_parts.set(container, part = new parts_NodePart(Object.assign({ templateFactory: templateFactory }, options)));\n        part.appendInto(container);\n    }\n    part.setValue(result);\n    part.commit();\n};\n//# sourceMappingURL=render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/default-template-processor.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n/**\n * Creates Parts when a template is instantiated.\n */\nclass default_template_processor_DefaultTemplateProcessor {\n    /**\n     * Create parts for an attribute-position binding, given the event, attribute\n     * name, and string literals.\n     *\n     * @param element The element containing the binding\n     * @param name  The attribute name\n     * @param strings The string literals. There are always at least two strings,\n     *   event for fully-controlled bindings with a single expression.\n     */\n    handleAttributeExpressions(element, name, strings, options) {\n        const prefix = name[0];\n        if (prefix === '.') {\n            const committer = new PropertyCommitter(element, name.slice(1), strings);\n            return committer.parts;\n        }\n        if (prefix === '@') {\n            return [new parts_EventPart(element, name.slice(1), options.eventContext)];\n        }\n        if (prefix === '?') {\n            return [new parts_BooleanAttributePart(element, name.slice(1), strings)];\n        }\n        const committer = new AttributeCommitter(element, name, strings);\n        return committer.parts;\n    }\n    /**\n     * Create parts for a text-position binding.\n     * @param templateFactory\n     */\n    handleTextExpression(options) {\n        return new parts_NodePart(options);\n    }\n}\nconst defaultTemplateProcessor = new default_template_processor_DefaultTemplateProcessor();\n//# sourceMappingURL=default-template-processor.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lit-html.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n *\n * Main lit-html module.\n *\n * Main exports:\n *\n * -  [[html]]\n * -  [[svg]]\n * -  [[render]]\n *\n * @module lit-html\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n// TODO(justinfagnani): remove line when we get NodePart moving methods\n\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n// TODO(justinfagnani): inject version number at build time\nif (typeof window !== 'undefined') {\n    (window['litHtmlVersions'] || (window['litHtmlVersions'] = [])).push('1.2.1');\n}\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n */\nconst lit_html_html = (strings, ...values) => new template_result_TemplateResult(strings, values, 'html', defaultTemplateProcessor);\n/**\n * Interprets a template literal as an SVG template that can efficiently\n * render to and update a container.\n */\nconst svg = (strings, ...values) => new template_result_SVGTemplateResult(strings, values, 'svg', defaultTemplateProcessor);\n//# sourceMappingURL=lit-html.js.map\n// CONCATENATED MODULE: ./node_modules/lit-html/lib/shady-render.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n/**\n * Module to add shady DOM/shady CSS polyfill support to lit-html template\n * rendering. See the [[render]] method for details.\n *\n * @module shady-render\n * @preferred\n */\n/**\n * Do not remove this comment; it keeps typedoc from misplacing the module\n * docs.\n */\n\n\n\n\n\n\n\n// Get a key to lookup in `templateCaches`.\nconst getTemplateCacheKey = (type, scopeName) => `${type}--${scopeName}`;\nlet compatibleShadyCSSVersion = true;\nif (typeof window.ShadyCSS === 'undefined') {\n    compatibleShadyCSSVersion = false;\n}\nelse if (typeof window.ShadyCSS.prepareTemplateDom === 'undefined') {\n    console.warn(`Incompatible ShadyCSS version detected. ` +\n        `Please update to at least @webcomponents/webcomponentsjs@2.0.2 and ` +\n        `@webcomponents/shadycss@1.3.1.`);\n    compatibleShadyCSSVersion = false;\n}\n/**\n * Template factory which scopes template DOM using ShadyCSS.\n * @param scopeName {string}\n */\nconst shadyTemplateFactory = (scopeName) => (result) => {\n    const cacheKey = getTemplateCacheKey(result.type, scopeName);\n    let templateCache = templateCaches.get(cacheKey);\n    if (templateCache === undefined) {\n        templateCache = {\n            stringsArray: new WeakMap(),\n            keyString: new Map()\n        };\n        templateCaches.set(cacheKey, templateCache);\n    }\n    let template = templateCache.stringsArray.get(result.strings);\n    if (template !== undefined) {\n        return template;\n    }\n    const key = result.strings.join(marker);\n    template = templateCache.keyString.get(key);\n    if (template === undefined) {\n        const element = result.getTemplateElement();\n        if (compatibleShadyCSSVersion) {\n            window.ShadyCSS.prepareTemplateDom(element, scopeName);\n        }\n        template = new Template(result, element);\n        templateCache.keyString.set(key, template);\n    }\n    templateCache.stringsArray.set(result.strings, template);\n    return template;\n};\nconst TEMPLATE_TYPES = ['html', 'svg'];\n/**\n * Removes all style elements from Templates for the given scopeName.\n */\nconst removeStylesFromLitTemplates = (scopeName) => {\n    TEMPLATE_TYPES.forEach((type) => {\n        const templates = templateCaches.get(getTemplateCacheKey(type, scopeName));\n        if (templates !== undefined) {\n            templates.keyString.forEach((template) => {\n                const { element: { content } } = template;\n                // IE 11 doesn't support the iterable param Set constructor\n                const styles = new Set();\n                Array.from(content.querySelectorAll('style')).forEach((s) => {\n                    styles.add(s);\n                });\n                removeNodesFromTemplate(template, styles);\n            });\n        }\n    });\n};\nconst shadyRenderSet = new Set();\n/**\n * For the given scope name, ensures that ShadyCSS style scoping is performed.\n * This is done just once per scope name so the fragment and template cannot\n * be modified.\n * (1) extracts styles from the rendered fragment and hands them to ShadyCSS\n * to be scoped and appended to the document\n * (2) removes style elements from all lit-html Templates for this scope name.\n *\n * Note, <style> elements can only be placed into templates for the\n * initial rendering of the scope. If <style> elements are included in templates\n * dynamically rendered to the scope (after the first scope render), they will\n * not be scoped and the <style> will be left in the template and rendered\n * output.\n */\nconst prepareTemplateStyles = (scopeName, renderedDOM, template) => {\n    shadyRenderSet.add(scopeName);\n    // If `renderedDOM` is stamped from a Template, then we need to edit that\n    // Template's underlying template element. Otherwise, we create one here\n    // to give to ShadyCSS, which still requires one while scoping.\n    const templateElement = !!template ? template.element : document.createElement('template');\n    // Move styles out of rendered DOM and store.\n    const styles = renderedDOM.querySelectorAll('style');\n    const { length } = styles;\n    // If there are no styles, skip unnecessary work\n    if (length === 0) {\n        // Ensure prepareTemplateStyles is called to support adding\n        // styles via `prepareAdoptedCssText` since that requires that\n        // `prepareTemplateStyles` is called.\n        //\n        // ShadyCSS will only update styles containing @apply in the template\n        // given to `prepareTemplateStyles`. If no lit Template was given,\n        // ShadyCSS will not be able to update uses of @apply in any relevant\n        // template. However, this is not a problem because we only create the\n        // template for the purpose of supporting `prepareAdoptedCssText`,\n        // which doesn't support @apply at all.\n        window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n        return;\n    }\n    const condensedStyle = document.createElement('style');\n    // Collect styles into a single style. This helps us make sure ShadyCSS\n    // manipulations will not prevent us from being able to fix up template\n    // part indices.\n    // NOTE: collecting styles is inefficient for browsers but ShadyCSS\n    // currently does this anyway. When it does not, this should be changed.\n    for (let i = 0; i < length; i++) {\n        const style = styles[i];\n        style.parentNode.removeChild(style);\n        condensedStyle.textContent += style.textContent;\n    }\n    // Remove styles from nested templates in this scope.\n    removeStylesFromLitTemplates(scopeName);\n    // And then put the condensed style into the \"root\" template passed in as\n    // `template`.\n    const content = templateElement.content;\n    if (!!template) {\n        insertNodeIntoTemplate(template, condensedStyle, content.firstChild);\n    }\n    else {\n        content.insertBefore(condensedStyle, content.firstChild);\n    }\n    // Note, it's important that ShadyCSS gets the template that `lit-html`\n    // will actually render so that it can update the style inside when\n    // needed (e.g. @apply native Shadow DOM case).\n    window.ShadyCSS.prepareTemplateStyles(templateElement, scopeName);\n    const style = content.querySelector('style');\n    if (window.ShadyCSS.nativeShadow && style !== null) {\n        // When in native Shadow DOM, ensure the style created by ShadyCSS is\n        // included in initially rendered output (`renderedDOM`).\n        renderedDOM.insertBefore(style.cloneNode(true), renderedDOM.firstChild);\n    }\n    else if (!!template) {\n        // When no style is left in the template, parts will be broken as a\n        // result. To fix this, we put back the style node ShadyCSS removed\n        // and then tell lit to remove that node from the template.\n        // There can be no style in the template in 2 cases (1) when Shady DOM\n        // is in use, ShadyCSS removes all styles, (2) when native Shadow DOM\n        // is in use ShadyCSS removes the style if it contains no content.\n        // NOTE, ShadyCSS creates its own style so we can safely add/remove\n        // `condensedStyle` here.\n        content.insertBefore(condensedStyle, content.firstChild);\n        const removes = new Set();\n        removes.add(condensedStyle);\n        removeNodesFromTemplate(template, removes);\n    }\n};\n/**\n * Extension to the standard `render` method which supports rendering\n * to ShadowRoots when the ShadyDOM (https://github.com/webcomponents/shadydom)\n * and ShadyCSS (https://github.com/webcomponents/shadycss) polyfills are used\n * or when the webcomponentsjs\n * (https://github.com/webcomponents/webcomponentsjs) polyfill is used.\n *\n * Adds a `scopeName` option which is used to scope element DOM and stylesheets\n * when native ShadowDOM is unavailable. The `scopeName` will be added to\n * the class attribute of all rendered DOM. In addition, any style elements will\n * be automatically re-written with this `scopeName` selector and moved out\n * of the rendered DOM and into the document `<head>`.\n *\n * It is common to use this render method in conjunction with a custom element\n * which renders a shadowRoot. When this is done, typically the element's\n * `localName` should be used as the `scopeName`.\n *\n * In addition to DOM scoping, ShadyCSS also supports a basic shim for css\n * custom properties (needed only on older browsers like IE11) and a shim for\n * a deprecated feature called `@apply` that supports applying a set of css\n * custom properties to a given location.\n *\n * Usage considerations:\n *\n * * Part values in `<style>` elements are only applied the first time a given\n * `scopeName` renders. Subsequent changes to parts in style elements will have\n * no effect. Because of this, parts in style elements should only be used for\n * values that will never change, for example parts that set scope-wide theme\n * values or parts which render shared style elements.\n *\n * * Note, due to a limitation of the ShadyDOM polyfill, rendering in a\n * custom element's `constructor` is not supported. Instead rendering should\n * either done asynchronously, for example at microtask timing (for example\n * `Promise.resolve()`), or be deferred until the first time the element's\n * `connectedCallback` runs.\n *\n * Usage considerations when using shimmed custom properties or `@apply`:\n *\n * * Whenever any dynamic changes are made which affect\n * css custom properties, `ShadyCSS.styleElement(element)` must be called\n * to update the element. There are two cases when this is needed:\n * (1) the element is connected to a new parent, (2) a class is added to the\n * element that causes it to match different custom properties.\n * To address the first case when rendering a custom element, `styleElement`\n * should be called in the element's `connectedCallback`.\n *\n * * Shimmed custom properties may only be defined either for an entire\n * shadowRoot (for example, in a `:host` rule) or via a rule that directly\n * matches an element with a shadowRoot. In other words, instead of flowing from\n * parent to child as do native css custom properties, shimmed custom properties\n * flow only from shadowRoots to nested shadowRoots.\n *\n * * When using `@apply` mixing css shorthand property names with\n * non-shorthand names (for example `border` and `border-width`) is not\n * supported.\n */\nconst shady_render_render = (result, container, options) => {\n    if (!options || typeof options !== 'object' || !options.scopeName) {\n        throw new Error('The `scopeName` option is required.');\n    }\n    const scopeName = options.scopeName;\n    const hasRendered = render_parts.has(container);\n    const needsScoping = compatibleShadyCSSVersion &&\n        container.nodeType === 11 /* Node.DOCUMENT_FRAGMENT_NODE */ &&\n        !!container.host;\n    // Handle first render to a scope specially...\n    const firstScopeRender = needsScoping && !shadyRenderSet.has(scopeName);\n    // On first scope render, render into a fragment; this cannot be a single\n    // fragment that is reused since nested renders can occur synchronously.\n    const renderContainer = firstScopeRender ? document.createDocumentFragment() : container;\n    render(result, renderContainer, Object.assign({ templateFactory: shadyTemplateFactory(scopeName) }, options));\n    // When performing first scope render,\n    // (1) We've rendered into a fragment so that there's a chance to\n    // `prepareTemplateStyles` before sub-elements hit the DOM\n    // (which might cause them to render based on a common pattern of\n    // rendering in a custom element's `connectedCallback`);\n    // (2) Scope the template with ShadyCSS one time only for this scope.\n    // (3) Render the fragment into the container and make sure the\n    // container knows its `part` is the one we just rendered. This ensures\n    // DOM will be re-used on subsequent renders.\n    if (firstScopeRender) {\n        const part = render_parts.get(renderContainer);\n        render_parts.delete(renderContainer);\n        // ShadyCSS might have style sheets (e.g. from `prepareAdoptedCssText`)\n        // that should apply to `renderContainer` even if the rendered value is\n        // not a TemplateInstance. However, it will only insert scoped styles\n        // into the document if `prepareTemplateStyles` has already been called\n        // for the given scope name.\n        const template = part.value instanceof template_instance_TemplateInstance ?\n            part.value.template :\n            undefined;\n        prepareTemplateStyles(scopeName, renderContainer, template);\n        removeNodes(container, container.firstChild);\n        container.appendChild(renderContainer);\n        render_parts.set(container, part);\n    }\n    // After elements have hit the DOM, update styling if this is the\n    // initial render to this container.\n    // This is needed whenever dynamic changes are made so it would be\n    // safest to do every render; however, this would regress performance\n    // so we leave it up to the user to call `ShadyCSS.styleElement`\n    // for dynamic changes.\n    if (!hasRendered && needsScoping) {\n        window.ShadyCSS.styleElement(container.host);\n    }\n};\n//# sourceMappingURL=shady-render.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/updating-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nvar updating_element_a;\n/**\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\nwindow.JSCompiler_renameProperty =\n    (prop, _obj) => prop;\nconst defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value ? '' : null;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                return value == null ? value : JSON.stringify(value);\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                return value !== null;\n            case Number:\n                return value === null ? null : Number(value);\n            case Object:\n            case Array:\n                return JSON.parse(value);\n        }\n        return value;\n    }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nconst notEqual = (value, old) => {\n    // This ensures (old==NaN, value==NaN) always returns false\n    return old !== value && (old === old || value === value);\n};\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual\n};\nconst STATE_HAS_UPDATED = 1;\nconst STATE_UPDATE_REQUESTED = 1 << 2;\nconst STATE_IS_REFLECTING_TO_ATTRIBUTE = 1 << 3;\nconst STATE_IS_REFLECTING_TO_PROPERTY = 1 << 4;\n/**\n * The Closure JS Compiler doesn't currently have good support for static\n * property semantics where \"this\" is dynamic (e.g.\n * https://github.com/google/closure-compiler/issues/3177 and others) so we use\n * this hack to bypass any rewriting by the compiler.\n */\nconst finalized = 'finalized';\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclassers to render updates as desired.\n */\nclass UpdatingElement extends HTMLElement {\n    constructor() {\n        super();\n        this._updateState = 0;\n        this._instanceProperties = undefined;\n        // Initialize to an unresolved Promise so we can make sure the element has\n        // connected before first update.\n        this._updatePromise = new Promise((res) => this._enableUpdatingResolver = res);\n        /**\n         * Map with keys for any properties that have changed since the last\n         * update cycle with previous values.\n         */\n        this._changedProperties = new Map();\n        /**\n         * Map with keys of properties that should be reflected when updated.\n         */\n        this._reflectingProperties = undefined;\n        this.initialize();\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     */\n    static get observedAttributes() {\n        // note: piggy backing on this to ensure we're finalized.\n        this.finalize();\n        const attributes = [];\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this._classProperties.forEach((v, p) => {\n            const attr = this._attributeNameForProperty(p, v);\n            if (attr !== undefined) {\n                this._attributeToPropertyMap.set(attr, p);\n                attributes.push(attr);\n            }\n        });\n        return attributes;\n    }\n    /**\n     * Ensures the private `_classProperties` property metadata is created.\n     * In addition to `finalize` this is also called in `createProperty` to\n     * ensure the `@property` decorator can add property metadata.\n     */\n    /** @nocollapse */\n    static _ensureClassProperties() {\n        // ensure private storage for property declarations.\n        if (!this.hasOwnProperty(JSCompiler_renameProperty('_classProperties', this))) {\n            this._classProperties = new Map();\n            // NOTE: Workaround IE11 not supporting Map constructor argument.\n            const superProperties = Object.getPrototypeOf(this)._classProperties;\n            if (superProperties !== undefined) {\n                superProperties.forEach((v, k) => this._classProperties.set(k, v));\n            }\n        }\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a PropertyDeclaration for the property with the given options.\n     * The property setter calls the property's `hasChanged` property option\n     * or uses a strict identity check to determine whether or not to request\n     * an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     *\n     * @nocollapse\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // Note, since this can be called by the `@property` decorator which\n        // is called before `finalize`, we ensure storage exists for property\n        // metadata.\n        this._ensureClassProperties();\n        this._classProperties.set(name, options);\n        // Do not generate an accessor if the prototype already has one, since\n        // it would be lost otherwise and that would never be the user's intention;\n        // Instead, we expect users to call `requestUpdate` themselves from\n        // user-defined accessors. Note that if the super has an accessor we will\n        // still overwrite it\n        if (options.noAccessor || this.prototype.hasOwnProperty(name)) {\n            return;\n        }\n        const key = typeof name === 'symbol' ? Symbol() : `__${name}`;\n        const descriptor = this.getPropertyDescriptor(name, key, options);\n        if (descriptor !== undefined) {\n            Object.defineProperty(this.prototype, name, descriptor);\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     *   class MyElement extends LitElement {\n     *     static getPropertyDescriptor(name, key, options) {\n     *       const defaultDescriptor =\n     *           super.getPropertyDescriptor(name, key, options);\n     *       const setter = defaultDescriptor.set;\n     *       return {\n     *         get: defaultDescriptor.get,\n     *         set(value) {\n     *           setter.call(this, value);\n     *           // custom action.\n     *         },\n     *         configurable: true,\n     *         enumerable: true\n     *       }\n     *     }\n     *   }\n     *\n     * @nocollapse\n     */\n    static getPropertyDescriptor(name, key, _options) {\n        return {\n            // tslint:disable-next-line:no-any no symbol in index\n            get() {\n                return this[key];\n            },\n            set(value) {\n                const oldValue = this[name];\n                this[key] = value;\n                this._requestUpdate(name, oldValue);\n            },\n            configurable: true,\n            enumerable: true\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a PropertyDeclaration via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override `createProperty`.\n     *\n     * @nocollapse\n     * @final\n     */\n    static getPropertyOptions(name) {\n        return this._classProperties && this._classProperties.get(name) ||\n            defaultPropertyDeclaration;\n    }\n    /**\n     * Creates property accessors for registered properties and ensures\n     * any superclasses are also finalized.\n     * @nocollapse\n     */\n    static finalize() {\n        // finalize any superclasses\n        const superCtor = Object.getPrototypeOf(this);\n        if (!superCtor.hasOwnProperty(finalized)) {\n            superCtor.finalize();\n        }\n        this[finalized] = true;\n        this._ensureClassProperties();\n        // initialize Map populated in observedAttributes\n        this._attributeToPropertyMap = new Map();\n        // make any properties\n        // Note, only process \"own\" properties since this element will inherit\n        // any properties defined on the superClass, and finalization ensures\n        // the entire prototype chain is finalized.\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n            const props = this.properties;\n            // support symbols in properties (IE11 does not support this)\n            const propKeys = [\n                ...Object.getOwnPropertyNames(props),\n                ...(typeof Object.getOwnPropertySymbols === 'function') ?\n                    Object.getOwnPropertySymbols(props) :\n                    []\n            ];\n            // This for/of is ok because propKeys is an array\n            for (const p of propKeys) {\n                // note, use of `any` is due to TypeSript lack of support for symbol in\n                // index types\n                // tslint:disable-next-line:no-any no symbol in index\n                this.createProperty(p, props[p]);\n            }\n        }\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static _attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false ?\n            undefined :\n            (typeof attribute === 'string' ?\n                attribute :\n                (typeof name === 'string' ? name.toLowerCase() : undefined));\n    }\n    /**\n     * Returns true if a property should request an update.\n     * Called when a property value is set and uses the `hasChanged`\n     * option for the property if present or a strict identity check.\n     * @nocollapse\n     */\n    static _valueHasChanged(value, old, hasChanged = notEqual) {\n        return hasChanged(value, old);\n    }\n    /**\n     * Returns the property value for the given attribute value.\n     * Called via the `attributeChangedCallback` and uses the property's\n     * `converter` or `converter.fromAttribute` property option.\n     * @nocollapse\n     */\n    static _propertyValueFromAttribute(value, options) {\n        const type = options.type;\n        const converter = options.converter || defaultConverter;\n        const fromAttribute = (typeof converter === 'function' ? converter : converter.fromAttribute);\n        return fromAttribute ? fromAttribute(value, type) : value;\n    }\n    /**\n     * Returns the attribute value for the given property value. If this\n     * returns undefined, the property will *not* be reflected to an attribute.\n     * If this returns null, the attribute will be removed, otherwise the\n     * attribute will be set to the value.\n     * This uses the property's `reflect` and `type.toAttribute` property options.\n     * @nocollapse\n     */\n    static _propertyValueToAttribute(value, options) {\n        if (options.reflect === undefined) {\n            return;\n        }\n        const type = options.type;\n        const converter = options.converter;\n        const toAttribute = converter && converter.toAttribute ||\n            defaultConverter.toAttribute;\n        return toAttribute(value, type);\n    }\n    /**\n     * Performs element initialization. By default captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        this._saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this._requestUpdate();\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */\n    _saveInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        this.constructor\n            ._classProperties.forEach((_v, p) => {\n            if (this.hasOwnProperty(p)) {\n                const value = this[p];\n                delete this[p];\n                if (!this._instanceProperties) {\n                    this._instanceProperties = new Map();\n                }\n                this._instanceProperties.set(p, value);\n            }\n        });\n    }\n    /**\n     * Applies previously saved instance properties.\n     */\n    _applyInstanceProperties() {\n        // Use forEach so this works even if for/of loops are compiled to for loops\n        // expecting arrays\n        // tslint:disable-next-line:no-any\n        this._instanceProperties.forEach((v, p) => this[p] = v);\n        this._instanceProperties = undefined;\n    }\n    connectedCallback() {\n        // Ensure first connection completes an update. Updates cannot complete\n        // before connection.\n        this.enableUpdating();\n    }\n    enableUpdating() {\n        if (this._enableUpdatingResolver !== undefined) {\n            this._enableUpdatingResolver();\n            this._enableUpdatingResolver = undefined;\n        }\n    }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     */\n    disconnectedCallback() {\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     */\n    attributeChangedCallback(name, old, value) {\n        if (old !== value) {\n            this._attributeToProperty(name, value);\n        }\n    }\n    _propertyToAttribute(name, value, options = defaultPropertyDeclaration) {\n        const ctor = this.constructor;\n        const attr = ctor._attributeNameForProperty(name, options);\n        if (attr !== undefined) {\n            const attrValue = ctor._propertyValueToAttribute(value, options);\n            // an undefined value does not change the attribute.\n            if (attrValue === undefined) {\n                return;\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_ATTRIBUTE;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_ATTRIBUTE;\n        }\n    }\n    _attributeToProperty(name, value) {\n        // Use tracking info to avoid deserializing attribute value if it was\n        // just set from a property setter.\n        if (this._updateState & STATE_IS_REFLECTING_TO_ATTRIBUTE) {\n            return;\n        }\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        // tslint:disable-next-line:no-unnecessary-type-assertion\n        const propName = ctor._attributeToPropertyMap.get(name);\n        if (propName !== undefined) {\n            const options = ctor.getPropertyOptions(propName);\n            // mark state reflecting\n            this._updateState = this._updateState | STATE_IS_REFLECTING_TO_PROPERTY;\n            this[propName] =\n                // tslint:disable-next-line:no-any\n                ctor._propertyValueFromAttribute(value, options);\n            // mark state not reflecting\n            this._updateState = this._updateState & ~STATE_IS_REFLECTING_TO_PROPERTY;\n        }\n    }\n    /**\n     * This private version of `requestUpdate` does not access or return the\n     * `updateComplete` promise. This promise can be overridden and is therefore\n     * not free to access.\n     */\n    _requestUpdate(name, oldValue) {\n        let shouldRequestUpdate = true;\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            const ctor = this.constructor;\n            const options = ctor.getPropertyOptions(name);\n            if (ctor._valueHasChanged(this[name], oldValue, options.hasChanged)) {\n                if (!this._changedProperties.has(name)) {\n                    this._changedProperties.set(name, oldValue);\n                }\n                // Add to reflecting properties set.\n                // Note, it's important that every change has a chance to add the\n                // property to `_reflectingProperties`. This ensures setting\n                // attribute + property reflects correctly.\n                if (options.reflect === true &&\n                    !(this._updateState & STATE_IS_REFLECTING_TO_PROPERTY)) {\n                    if (this._reflectingProperties === undefined) {\n                        this._reflectingProperties = new Map();\n                    }\n                    this._reflectingProperties.set(name, options);\n                }\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                shouldRequestUpdate = false;\n            }\n        }\n        if (!this._hasRequestedUpdate && shouldRequestUpdate) {\n            this._updatePromise = this._enqueueUpdate();\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should\n     * be called when an element should update based on some state not triggered\n     * by setting a property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored. Returns the `updateComplete` Promise which is resolved\n     * when the update completes.\n     *\n     * @param name {PropertyKey} (optional) name of requesting property\n     * @param oldValue {any} (optional) old value of requesting property\n     * @returns {Promise} A Promise that is resolved when the update completes.\n     */\n    requestUpdate(name, oldValue) {\n        this._requestUpdate(name, oldValue);\n        return this.updateComplete;\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async _enqueueUpdate() {\n        this._updateState = this._updateState | STATE_UPDATE_REQUESTED;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this._updatePromise;\n        }\n        catch (e) {\n            // Ignore any previous errors. We only care that the previous cycle is\n            // done. Any error should have been handled in the previous update.\n        }\n        const result = this.performUpdate();\n        // If `performUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this._hasRequestedUpdate;\n    }\n    get _hasRequestedUpdate() {\n        return (this._updateState & STATE_UPDATE_REQUESTED);\n    }\n    get hasUpdated() {\n        return (this._updateState & STATE_HAS_UPDATED);\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * You can override this method to change the timing of updates. If this\n     * method is overridden, `super.performUpdate()` must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```\n     * protected async performUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.performUpdate();\n     * }\n     * ```\n     */\n    performUpdate() {\n        // Mixin instance properties once, if they exist.\n        if (this._instanceProperties) {\n            this._applyInstanceProperties();\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.update(changedProperties);\n            }\n            else {\n                this._markUpdated();\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this._markUpdated();\n            throw e;\n        }\n        if (shouldUpdate) {\n            if (!(this._updateState & STATE_HAS_UPDATED)) {\n                this._updateState = this._updateState | STATE_HAS_UPDATED;\n                this.firstUpdated(changedProperties);\n            }\n            this.updated(changedProperties);\n        }\n    }\n    _markUpdated() {\n        this._changedProperties = new Map();\n        this._updateState = this._updateState & ~STATE_UPDATE_REQUESTED;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `_getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super._getUpdateComplete()`, then any subsequent state.\n     *\n     * @returns {Promise} The Promise returns a boolean that indicates if the\n     * update resolved without triggering another update.\n     */\n    get updateComplete() {\n        return this._getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     *   class MyElement extends LitElement {\n     *     async _getUpdateComplete() {\n     *       await super._getUpdateComplete();\n     *       await this._myChild.updateComplete;\n     *     }\n     *   }\n     */\n    _getUpdateComplete() {\n        return this._updatePromise;\n    }\n    /**\n     * Controls whether or not `update` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    update(_changedProperties) {\n        if (this._reflectingProperties !== undefined &&\n            this._reflectingProperties.size > 0) {\n            // Use forEach so this works even if for/of loops are compiled to for\n            // loops expecting arrays\n            this._reflectingProperties.forEach((v, k) => this._propertyToAttribute(k, this[k], v));\n            this._reflectingProperties = undefined;\n        }\n        this._markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    updated(_changedProperties) {\n    }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     */\n    firstUpdated(_changedProperties) {\n    }\n}\nupdating_element_a = finalized;\n/**\n * Marks class as having finished creating properties.\n */\nUpdatingElement[updating_element_a] = true;\n//# sourceMappingURL=updating-element.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/decorators.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    window.customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // tslint:disable-next-line:no-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            window.customElements.define(tagName, clazz);\n        }\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```\n * @customElement('my-element')\n * class MyElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n *\n * @param tagName The name of the custom element to define.\n */\nconst customElement = (tagName) => (classOrDescriptor) => (typeof classOrDescriptor === 'function') ?\n    legacyCustomElement(tagName, classOrDescriptor) :\n    standardCustomElement(tagName, classOrDescriptor);\nconst standardProperty = (options, element) => {\n    // When decorating an accessor, pass it through and add property metadata.\n    // Note, the `hasOwnProperty` check in `createProperty` ensures we don't\n    // stomp over the user's accessor.\n    if (element.kind === 'method' && element.descriptor &&\n        !('value' in element.descriptor)) {\n        return Object.assign(Object.assign({}, element), { finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            } });\n    }\n    else {\n        // createProperty() takes care of defining the property, but we still\n        // must return some kind of descriptor, so return a descriptor for an\n        // unused prototype field. The finisher calls createProperty().\n        return {\n            kind: 'field',\n            key: Symbol(),\n            placement: 'own',\n            descriptor: {},\n            // When @babel/plugin-proposal-decorators implements initializers,\n            // do this instead of the initializer below. See:\n            // https://github.com/babel/babel/issues/9260 extras: [\n            //   {\n            //     kind: 'initializer',\n            //     placement: 'own',\n            //     initializer: descriptor.initializer,\n            //   }\n            // ],\n            initializer() {\n                if (typeof element.initializer === 'function') {\n                    this[element.key] = element.initializer.call(this);\n                }\n            },\n            finisher(clazz) {\n                clazz.createProperty(element.key, options);\n            }\n        };\n    }\n};\nconst legacyProperty = (options, proto, name) => {\n    proto.constructor\n        .createProperty(name, options);\n};\n/**\n * A property decorator which creates a LitElement property which reflects a\n * corresponding attribute value. A `PropertyDeclaration` may optionally be\n * supplied to configure property features.\n *\n * This decorator should only be used for public fields. Private or protected\n * fields should use the internalProperty decorator.\n *\n * @example\n *\n *     class MyElement {\n *       @property({ type: Boolean })\n *       clicked = false;\n *     }\n *\n * @ExportDecoratedItems\n */\nfunction property(options) {\n    // tslint:disable-next-line:no-any decorator\n    return (protoOrDescriptor, name) => (name !== undefined) ?\n        legacyProperty(options, protoOrDescriptor, name) :\n        standardProperty(options, protoOrDescriptor);\n}\n/**\n * Declares a private or protected property that still triggers updates to the\n * element when it changes.\n *\n * Properties declared this way must not be used from HTML or HTML templating\n * systems, they're solely for properties internal to the element. These\n * properties may be renamed by optimization tools like closure compiler.\n */\nfunction internalProperty(options) {\n    return property({ attribute: false, hasChanged: options === null || options === void 0 ? void 0 : options.hasChanged });\n}\n/**\n * A property decorator that converts a class property into a getter that\n * executes a querySelector on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n *     class MyElement {\n *       @query('#first')\n *       first;\n *\n *       render() {\n *         return html`\n *           <div id=\"first\"></div>\n *           <div id=\"second\"></div>\n *         `;\n *       }\n *     }\n *\n */\nfunction query(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n// Note, in the future, we may extend this decorator to support the use case\n// where the queried element may need to do work to become ready to interact\n// with (e.g. load some implementation code). If so, we might elect to\n// add a second argument defining a function that can be run to make the\n// queried element loaded/updated/ready.\n/**\n * A property decorator that converts a class property into a getter that\n * returns a promise that resolves to the result of a querySelector on the\n * element's renderRoot done after the element's `updateComplete` promise\n * resolves. When the queried property may change with element state, this\n * decorator can be used instead of requiring users to await the\n * `updateComplete` before accessing the property.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\n *\n * @example\n *\n *     class MyElement {\n *       @queryAsync('#first')\n *       first;\n *\n *       render() {\n *         return html`\n *           <div id=\"first\"></div>\n *           <div id=\"second\"></div>\n *         `;\n *       }\n *     }\n *\n *     // external usage\n *     async doSomethingWithFirst() {\n *      (await aMyElement.first).doSomething();\n *     }\n */\nfunction queryAsync(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            async get() {\n                await this.updateComplete;\n                return this.renderRoot.querySelector(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n/**\n * A property decorator that converts a class property into a getter\n * that executes a querySelectorAll on the element's renderRoot.\n *\n * @param selector A DOMString containing one or more selectors to match.\n *\n * See:\n * https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelectorAll\n *\n * @example\n *\n *     class MyElement {\n *       @queryAll('div')\n *       divs;\n *\n *       render() {\n *         return html`\n *           <div id=\"first\"></div>\n *           <div id=\"second\"></div>\n *         `;\n *       }\n *     }\n */\nfunction queryAll(selector) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                return this.renderRoot.querySelectorAll(selector);\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\nconst legacyQuery = (descriptor, proto, name) => {\n    Object.defineProperty(proto, name, descriptor);\n};\nconst standardQuery = (descriptor, element) => ({\n    kind: 'method',\n    placement: 'prototype',\n    key: element.key,\n    descriptor,\n});\nconst standardEventOptions = (options, element) => {\n    return Object.assign(Object.assign({}, element), { finisher(clazz) {\n            Object.assign(clazz.prototype[element.key], options);\n        } });\n};\nconst legacyEventOptions = \n// tslint:disable-next-line:no-any legacy decorator\n(options, proto, name) => {\n    Object.assign(proto[name], options);\n};\n/**\n * Adds event listener options to a method used as an event listener in a\n * lit-html template.\n *\n * @param options An object that specifies event listener options as accepted by\n * `EventTarget#addEventListener` and `EventTarget#removeEventListener`.\n *\n * Current browsers support the `capture`, `passive`, and `once` options. See:\n * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Parameters\n *\n * @example\n *\n *     class MyElement {\n *       clicked = false;\n *\n *       render() {\n *         return html`\n *           <div @click=${this._onClick}`>\n *             <button></button>\n *           </div>\n *         `;\n *       }\n *\n *       @eventOptions({capture: true})\n *       _onClick(e) {\n *         this.clicked = true;\n *       }\n *     }\n */\nfunction eventOptions(options) {\n    // Return value typed as any to prevent TypeScript from complaining that\n    // standard decorator function signature does not match TypeScript decorator\n    // signature\n    // TODO(kschaaf): unclear why it was only failing on this decorator and not\n    // the others\n    return ((protoOrDescriptor, name) => (name !== undefined) ?\n        legacyEventOptions(options, protoOrDescriptor, name) :\n        standardEventOptions(options, protoOrDescriptor));\n}\n/**\n * A property decorator that converts a class property into a getter that\n * returns the `assignedNodes` of the given named `slot`. Note, the type of\n * this property should be annotated as `NodeListOf<HTMLElement>`.\n *\n */\nfunction queryAssignedNodes(slotName = '', flatten = false) {\n    return (protoOrDescriptor, \n    // tslint:disable-next-line:no-any decorator\n    name) => {\n        const descriptor = {\n            get() {\n                const selector = `slot${slotName ? `[name=${slotName}]` : ''}`;\n                const slot = this.renderRoot.querySelector(selector);\n                return slot && slot.assignedNodes({ flatten });\n            },\n            enumerable: true,\n            configurable: true,\n        };\n        return (name !== undefined) ?\n            legacyQuery(descriptor, protoOrDescriptor, name) :\n            standardQuery(descriptor, protoOrDescriptor);\n    };\n}\n//# sourceMappingURL=decorators.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lib/css-tag.js\n/**\n@license\nCopyright (c) 2019 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at\nhttp://polymer.github.io/LICENSE.txt The complete set of authors may be found at\nhttp://polymer.github.io/AUTHORS.txt The complete set of contributors may be\nfound at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by Google as\npart of the polymer project is also subject to an additional IP rights grant\nfound at http://polymer.github.io/PATENTS.txt\n*/\nconst supportsAdoptingStyleSheets = ('adoptedStyleSheets' in Document.prototype) &&\n    ('replace' in CSSStyleSheet.prototype);\nconst constructionToken = Symbol();\nclass CSSResult {\n    constructor(cssText, safeToken) {\n        if (safeToken !== constructionToken) {\n            throw new Error('CSSResult is not constructable. Use `unsafeCSS` or `css` instead.');\n        }\n        this.cssText = cssText;\n    }\n    // Note, this is a getter so that it's lazy. In practice, this means\n    // stylesheets are not created until the first element instance is made.\n    get styleSheet() {\n        if (this._styleSheet === undefined) {\n            // Note, if `adoptedStyleSheets` is supported then we assume CSSStyleSheet\n            // is constructable.\n            if (supportsAdoptingStyleSheets) {\n                this._styleSheet = new CSSStyleSheet();\n                this._styleSheet.replaceSync(this.cssText);\n            }\n            else {\n                this._styleSheet = null;\n            }\n        }\n        return this._styleSheet;\n    }\n    toString() {\n        return this.cssText;\n    }\n}\n/**\n * Wrap a value for interpolation in a css tagged template literal.\n *\n * This is unsafe because untrusted CSS text can be used to phone home\n * or exfiltrate data to an attacker controlled site. Take care to only use\n * this with trusted input.\n */\nconst unsafeCSS = (value) => {\n    return new CSSResult(String(value), constructionToken);\n};\nconst textFromCSSResult = (value) => {\n    if (value instanceof CSSResult) {\n        return value.cssText;\n    }\n    else if (typeof value === 'number') {\n        return value;\n    }\n    else {\n        throw new Error(`Value passed to 'css' function must be a 'css' function result: ${value}. Use 'unsafeCSS' to pass non-literal values, but\n            take care to ensure page security.`);\n    }\n};\n/**\n * Template tag which which can be used with LitElement's `style` property to\n * set element styles. For security reasons, only literal string values may be\n * used. To incorporate non-literal values `unsafeCSS` may be used inside a\n * template string part.\n */\nconst css = (strings, ...values) => {\n    const cssText = values.reduce((acc, v, idx) => acc + textFromCSSResult(v) + strings[idx + 1], strings[0]);\n    return new CSSResult(cssText, constructionToken);\n};\n//# sourceMappingURL=css-tag.js.map\n// CONCATENATED MODULE: ./node_modules/lit-element/lit-element.js\n/**\n * @license\n * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\n\n\n\n\n\n\n\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for LitElement usage.\n// TODO(justinfagnani): inject version number at build time\n(window['litElementVersions'] || (window['litElementVersions'] = []))\n    .push('2.3.1');\n/**\n * Sentinal value used to avoid calling lit-html's render function when\n * subclasses do not implement `render`\n */\nconst renderNotImplemented = {};\nclass lit_element_LitElement extends UpdatingElement {\n    /**\n     * Return the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * @nocollapse\n     */\n    static getStyles() {\n        return this.styles;\n    }\n    /** @nocollapse */\n    static _getUniqueStyles() {\n        // Only gather styles once per class\n        if (this.hasOwnProperty(JSCompiler_renameProperty('_styles', this))) {\n            return;\n        }\n        // Take care not to call `this.getStyles()` multiple times since this\n        // generates new CSSResults each time.\n        // TODO(sorvell): Since we do not cache CSSResults by input, any\n        // shared styles will generate new stylesheet objects, which is wasteful.\n        // This should be addressed when a browser ships constructable\n        // stylesheets.\n        const userStyles = this.getStyles();\n        if (userStyles === undefined) {\n            this._styles = [];\n        }\n        else if (Array.isArray(userStyles)) {\n            // De-duplicate styles preserving the _last_ instance in the set.\n            // This is a performance optimization to avoid duplicated styles that can\n            // occur especially when composing via subclassing.\n            // The last item is kept to try to preserve the cascade order with the\n            // assumption that it's most important that last added styles override\n            // previous styles.\n            const addStyles = (styles, set) => styles.reduceRight((set, s) => \n            // Note: On IE set.add() does not return the set\n            Array.isArray(s) ? addStyles(s, set) : (set.add(s), set), set);\n            // Array.from does not work on Set in IE, otherwise return\n            // Array.from(addStyles(userStyles, new Set<CSSResult>())).reverse()\n            const set = addStyles(userStyles, new Set());\n            const styles = [];\n            set.forEach((v) => styles.unshift(v));\n            this._styles = styles;\n        }\n        else {\n            this._styles = [userStyles];\n        }\n    }\n    /**\n     * Performs element initialization. By default this calls `createRenderRoot`\n     * to create the element `renderRoot` node and captures any pre-set values for\n     * registered properties.\n     */\n    initialize() {\n        super.initialize();\n        this.constructor._getUniqueStyles();\n        this.renderRoot =\n            this.createRenderRoot();\n        // Note, if renderRoot is not a shadowRoot, styles would/could apply to the\n        // element's getRootNode(). While this could be done, we're choosing not to\n        // support this now since it would require different logic around de-duping.\n        if (window.ShadowRoot && this.renderRoot instanceof window.ShadowRoot) {\n            this.adoptStyles();\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     * @returns {Element|DocumentFragment} Returns a node into which to render.\n     */\n    createRenderRoot() {\n        return this.attachShadow({ mode: 'open' });\n    }\n    /**\n     * Applies styling to the element shadowRoot using the `static get styles`\n     * property. Styling will apply using `shadowRoot.adoptedStyleSheets` where\n     * available and will fallback otherwise. When Shadow DOM is polyfilled,\n     * ShadyCSS scopes styles and adds them to the document. When Shadow DOM\n     * is available but `adoptedStyleSheets` is not, styles are appended to the\n     * end of the `shadowRoot` to [mimic spec\n     * behavior](https://wicg.github.io/construct-stylesheets/#using-constructed-stylesheets).\n     */\n    adoptStyles() {\n        const styles = this.constructor._styles;\n        if (styles.length === 0) {\n            return;\n        }\n        // There are three separate cases here based on Shadow DOM support.\n        // (1) shadowRoot polyfilled: use ShadyCSS\n        // (2) shadowRoot.adoptedStyleSheets available: use it.\n        // (3) shadowRoot.adoptedStyleSheets polyfilled: append styles after\n        // rendering\n        if (window.ShadyCSS !== undefined && !window.ShadyCSS.nativeShadow) {\n            window.ShadyCSS.ScopingShim.prepareAdoptedCssText(styles.map((s) => s.cssText), this.localName);\n        }\n        else if (supportsAdoptingStyleSheets) {\n            this.renderRoot.adoptedStyleSheets =\n                styles.map((s) => s.styleSheet);\n        }\n        else {\n            // This must be done after rendering so the actual style insertion is done\n            // in `update`.\n            this._needsShimAdoptedStyleSheets = true;\n        }\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        // Note, first update/render handles styleElement so we only call this if\n        // connected after first update.\n        if (this.hasUpdated && window.ShadyCSS !== undefined) {\n            window.ShadyCSS.styleElement(this);\n        }\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes\n     * and calls `render` to render DOM via lit-html. Setting properties inside\n     * this method will *not* trigger another update.\n     * @param _changedProperties Map of changed properties with old values\n     */\n    update(changedProperties) {\n        // Setting properties in `render` should not trigger an update. Since\n        // updates are allowed after super.update, it's important to call `render`\n        // before that.\n        const templateResult = this.render();\n        super.update(changedProperties);\n        // If render is not implemented by the component, don't call lit-html render\n        if (templateResult !== renderNotImplemented) {\n            this.constructor\n                .render(templateResult, this.renderRoot, { scopeName: this.localName, eventContext: this });\n        }\n        // When native Shadow DOM is used but adoptedStyles are not supported,\n        // insert styling after rendering to ensure adoptedStyles have highest\n        // priority.\n        if (this._needsShimAdoptedStyleSheets) {\n            this._needsShimAdoptedStyleSheets = false;\n            this.constructor._styles.forEach((s) => {\n                const style = document.createElement('style');\n                style.textContent = s.cssText;\n                this.renderRoot.appendChild(style);\n            });\n        }\n    }\n    /**\n     * Invoked on each update to perform rendering tasks. This method may return\n     * any value renderable by lit-html's NodePart - typically a TemplateResult.\n     * Setting properties inside this method will *not* trigger the element to\n     * update.\n     */\n    render() {\n        return renderNotImplemented;\n    }\n}\n/**\n * Ensure this class is marked as `finalized` as an optimization ensuring\n * it will not needlessly try to `finalize`.\n *\n * Note this property name is a string to prevent breaking Closure JS Compiler\n * optimizations. See updating-element.ts for more information.\n */\nlit_element_LitElement['finalized'] = true;\n/**\n * Render method used to render the value to the element's DOM.\n * @param result The value to render.\n * @param container Node into which to render.\n * @param options Element name.\n * @nocollapse\n */\nlit_element_LitElement.render = shady_render_render;\n//# sourceMappingURL=lit-element.js.map\n// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom.iterable.js\nvar web_dom_iterable = __webpack_require__(11);\n\n// CONCATENATED MODULE: ./src/agents/hello-agent.js\n\n\n//import  eve from 'evejs/dist/eve.custom.js';\nfunction HelloAgent(id) {\n  // execute super constructor\n  eve.Agent.call(this, id); // connect to all transports configured by the system\n\n  this.connect(eve.system.transports.getAll());\n} // extend the eve.Agent prototype\n\n\nHelloAgent.prototype = Object.create(eve.Agent.prototype);\nHelloAgent.prototype.constructor = HelloAgent;\n\nHelloAgent.prototype.sayHello = function (to) {\n  this.send(to, 'Hello ' + to + '!');\n};\n\nHelloAgent.prototype.receive = function (from, message) {\n  //slog(this.id+\" received from :\"+from + ' this message: ' + JSON.stringify(message));\n  console.log(this.id + \" received from :\" + from + ' this message: ' + JSON.stringify(message));\n\n  if (JSON.stringify(message).indexOf('Hello') === 0) {\n    // reply to the greeting\n    this.send(from, 'Hi ' + from + ', nice to meet you!');\n  }\n};\n\nHelloAgent.prototype.broadcast = function (message) {\n  var me = this;\n  var allAgents = Object.keys(this.connections[0].transport.agents);\n  console.log(allAgents);\n  allAgents.forEach(function (agent) {\n    me.send(agent, message);\n  });\n};\n\nHelloAgent.prototype.sendMulti = function (recipients, message) {\n  var me = this;\n  recipients.forEach(function (agent) {\n    //  console.log(agent, message)\n    me.send(agent, message);\n  });\n};\n\n\n// CONCATENATED MODULE: ./src/views/app-view.js\nfunction _templateObject2() {\n  const data = _taggedTemplateLiteral([\"\\n      <button class=\\\"btn btn-outline-primary \", \"\\\" level=\\\"\", \"\\\" @click=\\\"\", \"\\\">\", \"</button>\\n      \"]);\n\n  _templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _templateObject() {\n  const data = _taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n\\n    <div class=\\\"container-fluid\\\">\\n    <div class=\\\"row\\\">\\n    <div class=\\\"col\\\">\\n    <vis-view name=\\\"Vis\\\">Loading VIS</vis-view>\\n    </div>\\n    <div class=\\\"col\\\">\\n    <div class=\\\"row\\\">\\n    \", \"\\n      <login-element name=\\\"Login\\\"></login-element>\\n      </div>\\n\\n\\n      </div>\\n      \x3c!--    <vis-tool-view name=\\\"VisTool\\\">Vis Tool</vis-tool-view> --\x3e\\n      </div>\\n      <div class=\\\"row\\\">\\n      \", \"\\n\\n      <browser-view name=\\\"Browser\\\" ?hidden=\\\"\", \"\\\"></browser-view>\\n\\n      <input-view name=\\\"Input\\\" ?hidden=\\\"\", \"\\\"></input-view>\\n      <selected-view name=\\\"Selected\\\" ?hidden=\\\"\", \"\\\"></selected-view>\\n\\n      </div>\\n      </div>\\n      \"]);\n\n  _templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass app_view_AppView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      levels: {\n        type: Array\n      },\n      level: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"App\";\n    this.levels = [\"Browser\", \"Triple\", \"Node\"]; // \"Pod\",, \"Groups\" [\"World\", \"Organization\", \"Pod\", \"Folder\", \"File\", \"Triple\", \"Node\" ]\n\n    this.level = this.levels[0];\n  }\n\n  render() {\n    return lit_html_html(_templateObject(), this.levels.map(l => lit_html_html(_templateObject2(), this.level == l ? \"active\" : \"\", l, this.levelChanged, l)), this.level, this.level != \"Browser\", this.level != \"Triple\", this.level != \"Node\");\n  }\n\n  levelChanged(e) {\n    this.level = e.target.getAttribute(\"level\");\n  }\n  /*function recupParams(){\r\n  //console.log(window.location)\r\n  var url = window.location.search+window.location.hash;  // pour catcher les /card#me\r\n  var params = (function(a) {\r\n  if (a == \"\") return {};\r\n  var b = {};\r\n  for (var i = 0; i < a.length; ++i)\r\n  {        var p=a[i].split('=', 2);\r\n  if (p.length == 1)\r\n  b[p[0]] = \"\";\r\n  else\r\n  b[p[0]] = decodeURIComponent(p[1].replace(/\\+/g, \" \"));\r\n  }\r\n  return b;\r\n  })(url.substr(1).split('&'));\r\n  return params;\r\n  }*/\n\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"levelChanged\":\n            app.level = message.level;\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n  configChanged(config) {\n    this.config = config;\n    console.log(this.config);\n  }\n\n}\n\ncustomElements.define('app-view', app_view_AppView);\n// CONCATENATED MODULE: ./src/views/login-element.js\nfunction _templateObject3() {\n  const data = login_element_taggedTemplateLiteral([\"\\n      <button type=\\\"button\\\" class=\\\"btn btn-sm btn-outline-danger\\\" @click=\", \">Logout</button>\\n      \"]);\n\n  _templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_templateObject2() {\n  const data = login_element_taggedTemplateLiteral([\"\\n      <button type=\\\"button\\\" class=\\\"btn btn-success\\\" @click=\", \">Login</button>\\n      \"]);\n\n  login_element_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_templateObject() {\n  const data = login_element_taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n\\n    \", \"\\n    \"]);\n\n  login_element_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction login_element_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n //import { BaseView } from './base-view.js';\n//import * as auth from 'solid-auth-client';\n////let data = solid.data\n//console.log(\"LDFK+LEX\",data)\n\nclass login_element_LoginElement extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      webId: {\n        type: String\n      },\n      destinataires: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.webId = null; //  this.destinataires = ['App','Config', 'ConfigGet', 'Fab', 'Post', 'PostTabs', 'Profile', 'ProfileCartouche', 'Friends']\n\n    this.destinataires = ['Browser', 'Input'];\n  }\n\n  render() {\n    return lit_html_html(login_element_templateObject(), this.webId == null ? lit_html_html(login_element_templateObject2(), this.login) : lit_html_html(_templateObject3(), this.logout));\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      console.log(\"messah\", message);\n\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"webIdChanged\":\n            app.webIdChanged(message.webId);\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n\n    solid.auth.trackSession(async function (session) {\n      if (!session) {\n        app.webId = null;\n        console.log(\"WEBID\", app.webId);\n        app.agent.sendMulti(app.destinataires, {\n          action: \"webIdChanged\",\n          webId: app.webId\n        });\n      } else {\n        app.webId = session.webId;\n        console.log(\"WEBID\", app.webId);\n        app.agent.sendMulti(app.destinataires, {\n          action: \"webIdChanged\",\n          webId: app.webId\n        });\n      }\n    });\n\n    this.agent.receive = function (from, message) {\n      if (message.hasOwnProperty(\"action\")) {\n        switch (message.action) {\n          case \"logout\":\n            app.logout(null);\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n  login() {\n    this.popupLogin();\n  }\n\n  logout() {\n    let wi = this.webId;\n    solid.auth.logout().then(() => alert('Goodbye ' + wi + ' !'));\n  }\n\n  async popupLogin() {\n    let session = await solid.auth.currentSession();\n    let popupUri = './dist-popup/popup.html'; //  let popupUri = 'https://solid.community/common/popup.html';\n\n    if (!session) session = await solid.auth.popupLogin({\n      popupUri\n    });\n  }\n\n}\n\ncustomElements.define('login-element', login_element_LoginElement);\n// CONCATENATED MODULE: ./src/views/vis-view.js\n\n\nfunction _templateObject4() {\n  const data = vis_view_taggedTemplateLiteral([\"<button class=\\\"btn btn-primary\\\" @click=\\\"\", \"\\\">Hide</button>\\n        \"]);\n\n  _templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction vis_view_templateObject3() {\n  const data = vis_view_taggedTemplateLiteral([\"<button class=\\\"btn btn-primary\\\" @click=\\\"\", \"\\\">Show</button>\\n        \"]);\n\n  vis_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction vis_view_templateObject2() {\n  const data = vis_view_taggedTemplateLiteral([\"\\n      -  key \", \"<br>\\n      \"]);\n\n  vis_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction vis_view_templateObject() {\n  const data = vis_view_taggedTemplateLiteral([\"\\n    <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/vis-network.min.css\\\" rel=\\\"stylesheet\\\">\\n    <style>\\n    #mynetwork {\\n      max-width: 500px; /* 800px */\\n      min-width: 320px;\\n      height: 600px;\\n      border: 1px solid lightgray;\\n      background: linear-gradient(to bottom, rgba(215, 215, 255), rgba(250, 250, 170))\\n    }\\n\\n    #node-popUp {\\n      display:none;\\n    }\\n\\n    #edge-popUp {\\n      display:none;\\n    }\\n\\n    </style>\\n\\n\\n    <div  id=\\\"node-popUp\\\" class=\\\"modal\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\">\\n    <div class=\\\"modal-dialog\\\" role=\\\"document\\\">\\n    <div class=\\\"modal-content\\\">\\n    <div class=\\\"modal-header\\\">\\n    <h5 class=\\\"modal-title\\\" id=\\\"node-operation\\\">Modal title</h5>\\n    <button type=\\\"button\\\" id=\\\"node-close\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\" aria-label=\\\"Close\\\">\\n    <span aria-hidden=\\\"true\\\">&times;</span>\\n    </button>\\n    </div>\\n    <div class=\\\"modal-body\\\">\\n    \x3c!--  <tr>\\n    <td>id</td><td><input id=\\\"node-id\\\" value=\\\"new value\\\" /></td>\\n    </tr>--\x3e\\n    <div class=\\\"input-group mb-3\\\">\\n    <div class=\\\"input-group-prepend\\\">\\n    <span class=\\\"input-group-text\\\" id=\\\"nodeL\\\">Label</span>\\n    </div>\\n    <input type=\\\"text\\\" id=\\\"node-label\\\" class=\\\"form-control\\\" placeholder=\\\"Label\\\" aria-label=\\\"Label\\\" aria-describedby=\\\"nodeL\\\">\\n    </div>\\n\\n    \x3c!--\\n    \", \"\\n      --\x3e\\n\\n\\n      </div>\\n      <div class=\\\"modal-footer\\\">\\n      <button type=\\\"button\\\" id=\\\"node-saveButton\\\" class=\\\"btn btn-primary\\\">Save changes</button>\\n      <button type=\\\"button\\\" id=\\\"node-cancelButton\\\"  class=\\\"btn btn-secondary\\\" data-dismiss=\\\"modal\\\">Close</button>\\n\\n\\n      </div>\\n      </div>\\n      </div>\\n      </div>\\n\\n\\n      <div  id=\\\"edge-popUp\\\" class=\\\"modal\\\" tabindex=\\\"-1\\\" role=\\\"dialog\\\">\\n      <div class=\\\"modal-dialog\\\" role=\\\"document\\\">\\n      <div class=\\\"modal-content\\\">\\n      <div class=\\\"modal-header\\\">\\n      <h5 class=\\\"modal-title\\\" id=\\\"edge-operation\\\">Modal title</h5>\\n      <button type=\\\"button\\\" id=\\\"edge-close\\\" class=\\\"close\\\" data-dismiss=\\\"modal\\\" aria-label=\\\"Close\\\">\\n      <span aria-hidden=\\\"true\\\">&times;</span>\\n      </button>\\n      </div>\\n      <div class=\\\"modal-body\\\">\\n      \x3c!--  <tr>\\n      <td>id</td><td><input id=\\\"node-id\\\" value=\\\"new value\\\" /></td>\\n      </tr>--\x3e\\n      <div class=\\\"input-group mb-3\\\">\\n      <div class=\\\"input-group-prepend\\\">\\n      <span class=\\\"input-group-text\\\" id=\\\"edgeL\\\">Label</span>\\n      </div>\\n      <input type=\\\"text\\\" id=\\\"edge-label\\\" class=\\\"form-control\\\" placeholder=\\\"Edge label\\\" aria-label=\\\"Edge label\\\" aria-describedby=\\\"edgeL\\\">\\n      </div>\\n\\n      </div>\\n      <div class=\\\"modal-footer\\\">\\n      <button type=\\\"button\\\" id=\\\"edge-saveButton\\\" class=\\\"btn btn-primary\\\">Save changes</button>\\n      <button type=\\\"button\\\" id=\\\"edge-cancelButton\\\"  class=\\\"btn btn-secondary\\\" data-dismiss=\\\"modal\\\">Close</button>\\n\\n\\n      </div>\\n      </div>\\n      </div>\\n      </div>\\n      \x3c!-- fin modal --\x3e\\n\\n\\n\\n\\n      <div  class=\\\"row\\\" ?hidden=\\\"\", \"\\\">\\n      <div id=\\\"mynetwork\\\">Network</div>\\n      </div>\\n      <div class=\\\"row\\\">\\n      <button class=\\\"btn btn-primary\\\" @click=\\\"\", \"\\\">clear</button>\\n\\n\\n      \", \"\\n        </div>\\n        \"]);\n\n  vis_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction vis_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n // import / export, voir https://github.com/scenaristeur/spoggy-simple/blob/a9c73eec43e37c736fef656a72c948dd1c453886/js/import-export.js\n\nclass vis_view_VisView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      groups: {\n        type: Object\n      },\n      visHide: {\n        type: Boolean\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    let face = \"'Font Awesome 5 Free'\";\n    this.name = \"Vis\";\n    this.visHide = false;\n    this.groups = {\n      organizations: {\n        label: 'Orga',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf1ad',\n          size: 50,\n          color: '#f00a57'\n        }\n      },\n      usergroups: {\n        label: 'User Group',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf0c0',\n          size: 50,\n          color: '#57169a'\n        }\n      },\n      users: {\n        label: 'User',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf007',\n          size: 50,\n          color: '#aa00ff'\n        }\n      },\n      roles: {\n        label: 'Role',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf8c1',\n          size: 50,\n          color: '#0af0a3'\n        }\n      },\n      tensions: {\n        label: 'Tension (a problem or idea, a gap between \"What is\" and \"What should be\")',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf0e7',\n          size: 50,\n          color: '#f0a30a'\n        }\n      },\n      whatis: {\n        label: 'What is ? (the Tension matter)',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf059',\n          size: 50,\n          color: '#f0a30a'\n        }\n      },\n      whatsb: {\n        label: 'What should be ! (the Tension proposition)',\n        shape: 'icon',\n        icon: {\n          face: face,\n          weight: \"bold\",\n          // Font Awesome 5 doesn't work properly unless bold.\n          code: '\\uf0eb',\n          size: 50,\n          color: '#f0a30a'\n        }\n      }\n    };\n    var nodes = new vis.DataSet([{\n      id: 1,\n      label: 'John',\n      group: 'users'\n    }, {\n      id: 2,\n      label: 'Mike',\n      group: 'users'\n    }, {\n      id: 3,\n      label: 'Usergroup 1',\n      group: 'usergroups'\n    }, {\n      id: 4,\n      label: 'Usergroup 2',\n      group: 'usergroups'\n    }, {\n      id: 5,\n      label: 'My Oranization',\n      group: 'organizations'\n    }, {\n      id: 6,\n      label: 'Developer',\n      group: 'roles'\n    }, {\n      id: 7,\n      label: 'We must develop a cool GUI for Spoggy !',\n      group: 'tensions'\n    }, {\n      id: 8,\n      label: 'It is not easy to deal with LinkedData',\n      group: 'whatis' // what is\n\n    }, {\n      id: 9,\n      label: 'We can use Visjs to provide a simple way to interact with LinkedData.',\n      group: 'whatsb' // what should be\n\n    }]); // create an array with edges\n\n    var edges = new vis.DataSet([{\n      from: 1,\n      to: 3,\n      label: \"memberOf\",\n      title: \"org:memberOf\"\n    }, {\n      from: 1,\n      to: 2,\n      label: \"friend\",\n      title: \"foaf:friend\"\n    }, {\n      from: 2,\n      to: 4,\n      label: \"memberOf\",\n      title: \"org:memberOf\"\n    }, {\n      from: 2,\n      to: 5,\n      label: \"memberOf\",\n      title: \"org:memberOf\"\n    }, {\n      from: 5,\n      to: 4,\n      label: \"hasUnit\",\n      title: \"org:hasUnit\"\n    }, {\n      from: 1,\n      to: 7,\n      label: \"submit\",\n      title: \"as:submit\"\n    }, {\n      from: 2,\n      to: 6,\n      label: \"takeRole\",\n      title: \"takeRole\"\n    }, {\n      from: 7,\n      to: 8,\n      label: \"whatIs\",\n      title: \"whatIs\"\n    }, {\n      from: 7,\n      to: 9,\n      label: \"whatShouldBe\",\n      title: \"whatShouldBe\"\n    }]);\n    this.data = {\n      nodes: nodes,\n      edges: edges\n    };\n  }\n\n  render() {\n    return lit_html_html(vis_view_templateObject(), Object.entries(this.groups).map(([key, value]) => lit_html_html(vis_view_templateObject2(), value.label)), this.visHide, this.clear, this.visHide == true ? lit_html_html(vis_view_templateObject3(), this.toggleHide) : lit_html_html(_templateObject4(), this.toggleHide));\n  }\n\n  toggleHide() {\n    this.visHide = !this.visHide;\n  }\n\n  clear() {\n    this.data.nodes.clear();\n    this.data.edges.clear();\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"nodeUpdate\":\n            app.nodeUpdate(message.node);\n            break;\n\n          case \"edgeUpdate\":\n            app.edgeUpdate(message.edge);\n            break;\n\n          case \"triplesChanged\":\n            app.triplesChanged(message.triples);\n            break;\n\n          case \"addTriple\":\n            app.addTriple(message.triple);\n            break;\n\n          case \"clear\":\n            app.clear();\n            break;\n\n          case \"currentFileChanged\":\n            app.currentFile = message.currentFile;\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n\n    this.init();\n  }\n\n  addTriple(t) {\n    // from input-view\n    console.log(t);\n    let n_sub = {\n      id: t.subject,\n      label: this.localName(t.subject),\n      title: t.subject\n    };\n    this.addNodeIfNotExist(n_sub);\n    let n_obj = {\n      id: t.object,\n      label: this.localName(t.object),\n      title: t.object\n    };\n    this.addNodeIfNotExist(n_obj);\n    let edge = {\n      from: n_sub.id,\n      to: n_obj.id,\n      label: this.localName(t.predicate),\n      title: t.predicate\n    }; //  this.network.body.data.edges.update(edge)\n\n    this.addEdgeIfNotExist(edge);\n  }\n\n  triplesChanged(triples) {\n    //from tripledoc in browser-view\n    let app = this;\n    var clear = confirm(\"Do you want to clear the network ?\");\n    clear == true ? this.clear() : \"\";\n\n    if (triples.length != 0) {\n      triples.forEach((t, i) => {\n        let n_sub = {\n          id: t.subject.id,\n          label: app.localName(t.subject.id),\n          title: t.subject.id\n        };\n        app.addNodeIfNotExist(n_sub);\n        let n_obj = {\n          id: t.object.id,\n          label: app.localName(t.object.id),\n          title: t.object.id\n        };\n        app.addNodeIfNotExist(n_obj);\n        let edge = {\n          from: n_sub.id,\n          to: n_obj.id,\n          label: app.localName(t.predicate.id),\n          title: t.predicate.id\n        };\n        /*  app.network.body.data.edges.update(edge)*/\n\n        this.addEdgeIfNotExist(edge);\n      });\n    } else {\n      alert(\"this file does not contain any triple.\");\n    }\n  }\n\n  localName(strPromise) {\n    let str = \"\".concat(strPromise);\n    var ln = str.substring(str.lastIndexOf('#') + 1);\n    ln == str ? ln = str.substring(str.lastIndexOf('/') + 1) : \"\";\n    return ln;\n  }\n\n  nodeUpdate(node) {\n    console.log(node);\n    this.network.body.data.nodes.update(node);\n  }\n\n  edgeUpdate(edge) {\n    console.log(edge);\n    this.network.body.data.edges.update(edge);\n  }\n\n  addEdgeIfNotExist(edge) {\n    let id = \"\"; //  console.log(\"recherche \"+id_sujet+\" \"+id_objet+\" \"+propriete)\n\n    var items = this.network.body.data.edges.get({\n      filter: function filter(item) {\n        return item.from == edge.from && item.to == edge.to && item.label == edge.label;\n      }\n    });\n\n    if (items.length > 0) {\n      id = items[0].id; // must update the edge ?\n\n      console.log(\"trouvé \" + id);\n    } //else create node and get id\n    else {\n        id = this.network.body.data.edges.add(edge);\n        console.log(\"creation \" + id);\n      }\n  }\n\n  addNodeIfNotExist(data) {\n    let network = this.network;\n    var existNode = false; //console.log(data);\n\n    var nodeId;\n\n    try {\n      existNode = network.body.data.nodes.get({\n        filter: function filter(n) {\n          return n.id == data.id || n.label == data.label; //  || n.title == data.label\n        }\n      }); //console.log(existNode);\n\n      if (existNode.length == 0) {\n        //  console.log(\"n'existe pas\")\n        nodeId = network.body.data.nodes.add(data)[0];\n      } else {\n        //  console.log(\"existe\")\n        delete data.x;\n        delete data.y;\n        nodeId = network.body.data.nodes.update(data)[0];\n      }\n    } catch (err) {\n      console.log(err);\n    }\n  }\n\n  init() {\n    let app = this;\n    let face = \"'Font Awesome 5 Free'\";\n    var container = this.shadowRoot.getElementById('mynetwork');\n    let centralGravityValueDefault = 0.001; //, //0.001 ? A quoi sert cette valeur ?\n\n    let springLengthValueDefault = 220; // //220 (//200 //300)\n\n    let springConstantValueDefault = 0.01; //, //0.01\n\n    let nodeDistanceValueDefault = 150; //, //100 //350\n\n    let dampingValueDefault = 0.08;\n    let options = {\n      locale: navigator.language.slice(0, 2) || \"en\",\n      interaction: {\n        navigationButtons: true,\n        //  keyboard: true, // incompatible avec le déplacement par flèches dans le champ input\n        multiselect: true\n      },\n      edges: {\n        arrows: {\n          to: {\n            enabled: true,\n            scaleFactor: 1,\n            type: 'arrow'\n          }\n        },\n        font: {\n          size: 24\n        },\n        width: 2,\n        shadow: true,\n        color: {\n          inherit: 'both' //  highlight: '#000000',\n          //  color: '#2B7CE9'\n\n        }\n      },\n      nodes: {\n        shape: 'dot',\n        size: 30,\n        font: {\n          size: 24\n        },\n        borderWidth: 2,\n        shadow: true,\n        color: {\n          highlight: {\n            border: '#000000',\n            background: '#FFFFFF'\n          }\n        }\n      },\n      groups: this.groups,\n      physics: {\n        enabled: true,\n        barnesHut: {\n          gravitationalConstant: -1,\n          centralGravity: 0.3,\n          springLength: 95,\n          springConstant: 0.04,\n          damping: 0.09,\n          avoidOverlap: 1\n        },\n        forceAtlas2Based: {\n          gravitationalConstant: -50,\n          centralGravity: 0.01,\n          springConstant: 0.08,\n          springLength: 100,\n          damping: 0.4,\n          avoidOverlap: 0\n        },\n        repulsion: {\n          centralGravity: centralGravityValueDefault,\n          //0.001, //0.001 ? A quoi sert cette valeur ?\n          springLength: springLengthValueDefault,\n          // 220, //220 (//200 //300)\n          springConstant: springConstantValueDefault,\n          //0.01, //0.01\n          nodeDistance: nodeDistanceValueDefault,\n          //150, //100 //350\n          damping: dampingValueDefault ///0.08\n\n        },\n        hierarchicalRepulsion: {\n          centralGravity: 0.0,\n          springLength: 100,\n          springConstant: 0.01,\n          nodeDistance: 120,\n          damping: 0.09\n        },\n        //maxVelocity: 500, //50\n        //minVelocity: 1, //0.1\n        solver: 'repulsion'\n        /*stabilization: {\r\n        enabled: true,\r\n        iterations: 1000,\r\n        updateInterval: 100,\r\n        onlyDynamicEdges: false//,\r\n        //  fit: true\r\n        },*/\n        //timestep: 0.5,\n        //adaptiveTimestep: true\n\n      },\n      manipulation: {\n        // https://github.com/almende/vis/blob/master/examples/network/other/manipulationEditEdgeNoDrag.html\n        addNode: function addNode(data, callback) {\n          app.shadowRoot.getElementById('node-operation').innerHTML = \"Add Node\";\n          data.label = \"\"; //  app.shadowRoot.getElementById('node-label').value = data.label;\n\n          app.editNode(data, app.clearNodePopUp, callback);\n        },\n        editNode: function editNode(data, callback) {\n          app.shadowRoot.getElementById('node-operation').innerHTML = \"Edit Node\";\n          app.editNode(data, app.cancelNodeEdit, callback);\n        },\n        addEdge: function addEdge(data, callback) {\n          if (data.from == data.to) {\n            var r = confirm(\"Do you want to connect the node to itself?\");\n\n            if (r != true) {\n              callback(null);\n              return;\n            }\n          }\n\n          app.shadowRoot.getElementById('edge-operation').innerHTML = \"Add Edge\";\n          data.label = \"\"; //  app.shadowRoot.getElementById('edge-label').value = data.label\n\n          console.log(data);\n          app.editEdgeWithoutDrag(data, callback);\n        },\n        editEdge: function editEdge(data, callback) {\n          app.shadowRoot.getElementById('edge-operation').innerHTML = \"Edit Edge\";\n          app.editEdgeWithoutDrag(data, callback);\n        }\n      }\n    };\n    this.network = new vis.Network(container, this.data, options);\n    this.network.on(\"selectNode\", function (params) {\n      params.show = true;\n      app.sendSelected(params);\n    });\n    this.network.on(\"selectEdge\", function (params) {\n      params.show = true;\n      app.sendSelected(params);\n    });\n    this.network.on(\"deselectNode\", function (params) {\n      params.show = true;\n      app.sendSelected(params);\n    });\n    this.network.on(\"deselectEdge\", function (params) {\n      params.show = false;\n      app.sendSelected(params);\n    });\n  } ///////////////////////////\n\n\n  sendSelected(params) {\n    this.agent.send(\"Selected\", {\n      action: \"selectedChanged\",\n      nodes: this.network.body.data.nodes.get(params.nodes),\n      edges: this.network.body.data.edges.get(params.edges)\n    });\n    params.show == true ? this.agent.send(\"App\", {\n      action: \"levelChanged\",\n      level: \"Node\"\n    }) : \"\";\n  }\n\n  editNode(data, cancelAction, callback) {\n    console.log(data);\n    this.shadowRoot.getElementById('node-label').value = data.label;\n    this.shadowRoot.getElementById('node-saveButton').onclick = this.saveNodeData.bind(this, data, callback);\n    this.shadowRoot.getElementById('node-cancelButton').onclick = cancelAction.bind(this, callback);\n    this.shadowRoot.getElementById('node-close').onclick = cancelAction.bind(this, callback);\n    this.shadowRoot.getElementById('node-label').onkeydown = this.keydownNode.bind(this, data, callback); //\n\n    this.shadowRoot.getElementById('node-popUp').style.display = 'block'; //  app.shadowRoot.getElementById('node-label').focus({preventScroll:false});\n    //  this.agent.send(\"VisTool\", {action: \"changeTool\", params: {data: data, tool: \"editNode\", callback: cb}})\n  } // Callback passed as parameter is ignored\n\n\n  clearNodePopUp() {\n    this.shadowRoot.getElementById('node-saveButton').onclick = null;\n    this.shadowRoot.getElementById('node-cancelButton').onclick = null;\n    this.shadowRoot.getElementById('node-popUp').style.display = 'none';\n  }\n\n  cancelNodeEdit(callback) {\n    this.clearNodePopUp();\n    callback(null);\n  }\n\n  saveNodeData(data, callback) {\n    data.label = this.shadowRoot.getElementById('node-label').value;\n    data.id = this.currentFile + \"#\" + data.label;\n    this.clearNodePopUp();\n    callback(data);\n  }\n\n  editEdgeWithoutDrag(data, callback) {\n    console.log(data);\n    this.shadowRoot.getElementById('edge-label').value = data.label;\n    this.shadowRoot.getElementById('edge-saveButton').onclick = this.saveEdgeData.bind(this, data, callback);\n    this.shadowRoot.getElementById('edge-cancelButton').onclick = this.cancelEdgeEdit.bind(this, callback);\n    this.shadowRoot.getElementById('edge-close').onclick = this.cancelEdgeEdit.bind(this, callback);\n    this.shadowRoot.getElementById('edge-label').onkeydown = this.keydownEdge.bind(this, data, callback);\n    this.shadowRoot.getElementById('edge-popUp').style.display = 'block';\n  }\n\n  clearEdgePopUp() {\n    this.shadowRoot.getElementById('edge-saveButton').onclick = null;\n    this.shadowRoot.getElementById('edge-cancelButton').onclick = null;\n    this.shadowRoot.getElementById('edge-popUp').style.display = 'none';\n  }\n\n  cancelEdgeEdit(callback) {\n    this.clearEdgePopUp();\n    callback(null);\n  }\n\n  saveEdgeData(data, callback) {\n    console.log(data);\n    if (typeof data.to === 'object') data.to = data.to.id;\n    if (typeof data.from === 'object') data.from = data.from.id;\n    data.label = this.shadowRoot.getElementById('edge-label').value;\n    let subject = this.network.body.data.nodes.get(data.from).label;\n    let object = this.network.body.data.nodes.get(data.to).label;\n    let triple = {\n      subject: subject,\n      predicate: data.label,\n      object: object\n    };\n    console.log(triple);\n    this.agent.send(\"Browser\", {\n      action: \"addTriple\",\n      triple: triple\n    });\n    this.clearEdgePopUp(); // non necessaire car generé par browser  callback(data);\n  }\n\n  keydownNode(data, callback, e) {\n    console.log(e, data, callback);\n\n    if (e.which === 13) {\n      //  this.add_triple()\n      this.saveNodeData(data, callback);\n      e.preventDefault();\n      return false;\n    }\n  }\n\n  keydownEdge(data, callback, e) {\n    if (e.which === 13) {\n      //this.add_triple()\n      this.saveEdgeData(data, callback);\n      e.preventDefault();\n      return false;\n    }\n  }\n\n  configChanged(config) {\n    this.config = config;\n    console.log(this.config);\n  }\n\n}\n\ncustomElements.define('vis-view', vis_view_VisView);\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.split.js\nvar es6_regexp_split = __webpack_require__(45);\n\n// EXTERNAL MODULE: ./node_modules/core-js/modules/es6.regexp.replace.js\nvar es6_regexp_replace = __webpack_require__(86);\n\n// EXTERNAL MODULE: ./node_modules/solid-file-client/dist/window/solid-file-client.bundle.js\nvar solid_file_client_bundle = __webpack_require__(57);\n\n// EXTERNAL MODULE: ./node_modules/http-link-header/lib/link.js\nvar lib_link = __webpack_require__(35);\nvar link_default = /*#__PURE__*/__webpack_require__.n(lib_link);\n\n// EXTERNAL MODULE: ./node_modules/solid-auth-client/browser/index.js\nvar browser = __webpack_require__(8);\nvar browser_default = /*#__PURE__*/__webpack_require__.n(browser);\n\n// EXTERNAL MODULE: ./node_modules/n3/src/IRIs.js\nvar IRIs = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./node_modules/n3/src/N3DataFactory.js\n// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n\n\nconst { rdf, xsd } = IRIs[\"a\" /* default */];\n\nvar DataFactory, DEFAULTGRAPH;\n\nvar _blankNodeCounter = 0;\n\n// ## Term constructor\nclass Term {\n  constructor(id) {\n    this.id = id;\n  }\n\n  // ### The value of this term\n  get value() {\n    return this.id;\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term)\n      return this.id === other.id;\n    // Otherwise, compare term type and value\n    return !!other && this.termType === other.termType &&\n                      this.value    === other.value;\n  }\n\n  // ### Returns a plain object representation of this term\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n    };\n  }\n}\n\n\n// ## NamedNode constructor\nclass NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n}\n\n// ## Literal constructor\nclass Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  }\n\n  // ### The text value of this literal\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  }\n\n  // ### The language of this literal\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    var id = this.id, atPos = id.lastIndexOf('\"') + 1;\n    // If \"@\" it follows, return the remaining substring; empty otherwise\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  }\n\n  // ### The datatype IRI of this literal\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  }\n\n  // ### The datatype string of this literal\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    var id = this.id, dtPos = id.lastIndexOf('\"') + 1, ch;\n    // If \"^\" it follows, return the remaining substring\n    return dtPos < id.length && (ch = id[dtPos]) === '^' ? id.substr(dtPos + 2) :\n           // If \"@\" follows, return rdf:langString; xsd:string otherwise\n           (ch !== '@' ? xsd.string : rdf.langString);\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal)\n      return this.id === other.id;\n    // Otherwise, compare term type, value, language, and datatype\n    return !!other && !!other.datatype &&\n                      this.termType === other.termType &&\n                      this.value    === other.value    &&\n                      this.language === other.language &&\n                      this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n      language: this.language,\n      datatype: { termType: 'NamedNode', value: this.datatypeString },\n    };\n  }\n}\n\n// ## BlankNode constructor\nclass BlankNode extends Term {\n  constructor(name) {\n    super('_:' + name);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'BlankNode';\n  }\n\n  // ### The name of this blank node\n  get value() {\n    return this.id.substr(2);\n  }\n}\n\nclass Variable extends Term {\n  constructor(name) {\n    super('?' + name);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Variable';\n  }\n\n  // ### The name of this variable\n  get value() {\n    return this.id.substr(1);\n  }\n}\n\n// ## DefaultGraph constructor\nclass DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'DefaultGraph';\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return (this === other) || (!!other && (this.termType === other.termType));\n  }\n}\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n\n// ### Constructs a term from the given internal string ID\nfunction fromId(id, factory) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id)\n    return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n  case '_': return factory.blankNode(id.substr(2));\n  case '?': return factory.variable(id.substr(1));\n  case '\"':\n    // Shortcut for internal literals\n    if (factory === DataFactory)\n      return new Literal(id);\n    // Literal without datatype or language\n    if (id[id.length - 1] === '\"')\n      return factory.literal(id.substr(1, id.length - 2));\n    // Literal with datatype or language\n    var endPos = id.lastIndexOf('\"', id.length - 1);\n    return factory.literal(id.substr(1, endPos - 1),\n            id[endPos + 1] === '@' ? id.substr(endPos + 2)\n                                   : factory.namedNode(id.substr(endPos + 3)));\n  default:  return factory.namedNode(id);\n  }\n}\n\n// ### Constructs an internal string ID from the given term or ID string\nfunction toId(term) {\n  if (typeof term === 'string')\n    return term;\n  if (term instanceof Term)\n    return term.id;\n  if (!term)\n    return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return term.value;\n  case 'BlankNode':    return '_:' + term.value;\n  case 'Variable':     return '?' + term.value;\n  case 'DefaultGraph': return '';\n  case 'Literal':      return '\"' + term.value + '\"' +\n    (term.language ? '@' + term.language :\n      (term.datatype && term.datatype.value !== xsd.string ? '^^' + term.datatype.value : ''));\n  default: throw new Error('Unexpected termType: ' + term.termType);\n  }\n}\n\n\n// ## Quad constructor\nclass Quad {\n  constructor(subject, predicate, object, graph) {\n    this.subject   = subject;\n    this.predicate = predicate;\n    this.object    = object;\n    this.graph     = graph || DEFAULTGRAPH;\n  }\n\n  // ### Returns a plain object representation of this quad\n  toJSON() {\n    return {\n      subject:   this.subject.toJSON(),\n      predicate: this.predicate.toJSON(),\n      object:    this.object.toJSON(),\n      graph:     this.graph.toJSON(),\n    };\n  }\n\n  // ### Returns whether this object represents the same quad as the other\n  equals(other) {\n    return !!other && this.subject.equals(other.subject)     &&\n                      this.predicate.equals(other.predicate) &&\n                      this.object.equals(other.object)       &&\n                      this.graph.equals(other.graph);\n  }\n}\n\n\n// ## DataFactory singleton\nDataFactory = {\n  // ### Public factory functions\n  namedNode: N3DataFactory_namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad: N3DataFactory_quad,\n  triple: N3DataFactory_quad,\n\n  // ### Internal datatype constructors\n  internal: {\n    Term,\n    NamedNode,\n    BlankNode,\n    Variable,\n    Literal,\n    DefaultGraph,\n    Quad,\n    Triple: Quad,\n    fromId,\n    toId,\n  },\n};\n/* harmony default export */ var N3DataFactory = (DataFactory);\n\n// ### Creates an IRI\nfunction N3DataFactory_namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string')\n    return new Literal('\"' + value + '\"@' + languageOrDataType.toLowerCase());\n\n  // Automatically determine datatype for booleans and numbers\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean')\n      datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value))\n        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;\n      else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value))\n          value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return (datatype === '' || datatype === xsd.string) ?\n    new Literal('\"' + value + '\"') :\n    new Literal('\"' + value + '\"^^' + datatype);\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction N3DataFactory_quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}\n\n// CONCATENATED MODULE: ./node_modules/n3/src/N3Writer.js\n// **N3Writer** writes N3 documents.\n\n\n\nconst N3Writer_DEFAULTGRAPH = N3DataFactory.defaultGraph();\n\nconst { rdf: N3Writer_rdf, xsd: N3Writer_xsd } = IRIs[\"a\" /* default */];\n\n// Characters in literals that require escaping\nvar N3Writer_escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n// ## Placeholder class to represent already pretty-printed terms\nclass N3Writer_SerializedTerm extends N3DataFactory.internal.Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n}\n\n// ## Constructor\nclass N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function')\n      options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      var output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) { output += chunk; done && done(); },\n        end:   function (done) { done && done(null, output); },\n      };\n      this._endStream = true;\n    }\n    else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!(/triple|quad/i).test(options.format)) {\n      this._graph = N3Writer_DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n    }\n    else {\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  get _inDefaultGraph() {\n    return N3Writer_DEFAULTGRAPH.equals(this._graph);\n  }\n\n  // ### `_write` writes the argument to the output stream\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  }\n\n  // ### `_writeQuad` writes the quad to the output stream\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\\n' : '\\n}\\n')) +\n                    (N3Writer_DEFAULTGRAPH.equals(graph) ? '' : this._encodeIriOrBlank(graph) + ' {\\n'));\n        this._graph = graph;\n        this._subject = null;\n      }\n      // Don't repeat the subject if it's the same\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate))\n          this._write(', ' + this._encodeObject(object), done);\n        // Same subject, different predicate\n        else\n          this._write(';\\n    ' +\n                      this._encodePredicate(this._predicate = predicate) + ' ' +\n                      this._encodeObject(object), done);\n      }\n      // Different subject; write the whole quad\n      else\n        this._write((this._subject === null ? '' : '.\\n') +\n                    this._encodeIriOrBlank(this._subject = subject) + ' ' +\n                    this._encodePredicate(this._predicate = predicate) + ' ' +\n                    this._encodeObject(object), done);\n    }\n    catch (error) { done && done(error); }\n  }\n\n  // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  }\n\n  // ### `quadToString` serializes a quad as a string\n  quadToString(subject, predicate, object, graph) {\n    return  this._encodeIriOrBlank(subject)   + ' ' +\n            this._encodeIriOrBlank(predicate) + ' ' +\n            this._encodeObject(object) +\n            (graph && graph.value ? ' ' + this._encodeIriOrBlank(graph) + ' .\\n' : ' .\\n');\n  }\n\n  // ### `quadsToString` serializes an array of quads as a string\n  quadsToString(quads) {\n    return quads.map(function (t) {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }, this).join('');\n  }\n\n  // ### `_encodeIriOrBlank` represents an IRI or blank node\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && (entity.value in this._lists))\n        entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : '_:' + entity.value;\n    }\n    // Escape special characters\n    var iri = entity.value;\n    if (N3Writer_escape.test(iri))\n      iri = iri.replace(escapeAll, characterReplacer);\n    // Try to represent the IRI as prefixed name\n    var prefixMatch = this._prefixRegex.exec(iri);\n    return !prefixMatch ? '<' + iri + '>' :\n           (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);\n  }\n\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral(literal) {\n    // Escape special characters\n    var value = literal.value;\n    if (N3Writer_escape.test(value))\n      value = value.replace(escapeAll, characterReplacer);\n    // Write the literal, possibly with type or language\n    if (literal.language)\n      return '\"' + value + '\"@' + literal.language;\n    else if (literal.datatype.value !== N3Writer_xsd.string)\n      return '\"' + value + '\"^^' + this._encodeIriOrBlank(literal.datatype);\n    else\n      return '\"' + value + '\"';\n  }\n\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate(predicate) {\n    return predicate.value === N3Writer_rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  }\n\n  // ### `_encodeObject` represents an object\n  _encodeObject(object) {\n    return object.termType === 'Literal' ? this._encodeLiteral(object) : this._encodeIriOrBlank(object);\n  }\n\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  }\n\n  // ### `addQuad` adds the quad to the output stream\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined)\n      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n    // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function')\n      this._writeQuad(subject, predicate, object, N3Writer_DEFAULTGRAPH, graph);\n    // The `graph` parameter was provided\n    else\n      this._writeQuad(subject, predicate, object, graph || N3Writer_DEFAULTGRAPH, done);\n  }\n\n  // ### `addQuads` adds the quads to the output stream\n  addQuads(quads) {\n    for (var i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix(prefix, iri, done) {\n    var prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  }\n\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes(prefixes, done) {\n    var prefixIRIs = this._prefixIRIs, hasPrefixes = false;\n    for (var prefix in prefixes) {\n      var iri = prefixes[prefix];\n      if (typeof iri !== 'string')\n        iri = iri.value;\n      hasPrefixes = true;\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null, this._graph = '';\n      }\n      // Store and write the prefix\n      prefixIRIs[iri] = (prefix += ':');\n      this._write('@prefix ' + prefix + ' <' + iri + '>.\\n');\n    }\n    // Recreate the prefix matcher\n    if (hasPrefixes) {\n      var IRIlist = '', prefixList = '';\n      for (var prefixIRI in prefixIRIs) {\n        IRIlist += IRIlist ? '|' + prefixIRI : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + prefixIRIs[prefixIRI];\n      }\n      IRIlist = IRIlist.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp('^(?:' + prefixList + ')[^\\/]*$|' +\n                                     '^(' + IRIlist + ')([a-zA-Z][\\\\-_a-zA-Z0-9]*)$');\n    }\n    // End a prefix block with a newline\n    this._write(hasPrefixes ? '\\n' : '', done);\n  }\n\n  // ### `blank` creates a blank node with the given content\n  blank(predicate, object) {\n    var children = predicate, child, length;\n    // Empty blank node\n    if (predicate === undefined)\n      children = [];\n    // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType)\n      children = [{ predicate: predicate, object: object }];\n    // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate))\n      children = [predicate];\n\n    switch (length = children.length) {\n    // Generate an empty blank node\n    case 0:\n      return new N3Writer_SerializedTerm('[]');\n    // Generate a non-nested one-triple blank node\n    case 1:\n      child = children[0];\n      if (!(child.object instanceof N3Writer_SerializedTerm))\n        return new N3Writer_SerializedTerm('[ ' + this._encodePredicate(child.predicate) + ' ' +\n                                  this._encodeObject(child.object) + ' ]');\n    // Generate a multi-triple or nested blank node\n    default:\n      var contents = '[';\n      // Write all triples in order\n      for (var i = 0; i < length; i++) {\n        child = children[i];\n        // Write only the object is the predicate is the same as the previous\n        if (child.predicate.equals(predicate))\n          contents += ', ' + this._encodeObject(child.object);\n        // Otherwise, write the predicate and the object\n        else {\n          contents += (i ? ';\\n  ' : '\\n  ') +\n                      this._encodePredicate(child.predicate) + ' ' +\n                      this._encodeObject(child.object);\n          predicate = child.predicate;\n        }\n      }\n      return new N3Writer_SerializedTerm(contents + '\\n]');\n    }\n  }\n\n  // ### `list` creates a list node with the given content\n  list(elements) {\n    var length = elements && elements.length || 0, contents = new Array(length);\n    for (var i = 0; i < length; i++)\n      contents[i] = this._encodeObject(elements[i]);\n    return new N3Writer_SerializedTerm('(' + contents.join(' ') + ')');\n  }\n\n  // ### `end` signals the end of the output stream\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n      this._subject = null;\n    }\n    // Disallow further writing\n    this._write = this._blockedWrite;\n\n    // Try to end the underlying stream, ensuring done is called exactly one time\n    var singleDone = done && function (error, result) { singleDone = null, done(error, result); };\n    if (this._endStream) {\n      try { return this._outputStream.end(singleDone); }\n      catch (error) { /* error closing stream */ }\n    }\n    singleDone && singleDone();\n  }\n}\n\n// Replaces a character by its escaped version\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  var result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                 character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\n\n// EXTERNAL MODULE: ./node_modules/n3/src/N3Lexer.js\nvar N3Lexer = __webpack_require__(59);\n\n// CONCATENATED MODULE: ./node_modules/n3/src/N3Parser.js\n// **N3Parser** parses N3 documents.\n\n\n\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nclass N3Parser_N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    var format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = format === 'turtle', isTriG = format === 'trig',\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = function (iri) { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer[\"a\" /* default */]({ lineMode: isLineMode, n3: isN3 });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      var fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    var n3Mode = this._n3Mode;\n    this._contextStack.push({\n      subject: subject, predicate: predicate, object: object,\n      graph: graph, type: type,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? this._graph.id.substr(2) + '.' : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext() {\n    var context = this._contextStack.pop(), n3Mode = this._n3Mode;\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    var value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      var iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      var prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error('Undefined prefix \"' + token.prefix + ':\"', token);\n      value = this._namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error('Expected entity but got ' + token.type, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = this._blankNode;\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = this._variable;\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n      break;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    var type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error('Unexpected ' + type, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._literal(token.value, this._namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error('Expected graph but got ' + token.type, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    var empty = this._predicate === null;\n    this._restoreContext();\n    // If the blank node was the subject, continue reading the predicate\n    if (this._object === null)\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n    // If the blank node was the object, restore previous context and read punctuation\n    else\n      return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    var item = null,                      // The item of the list\n        list = null,                      // The list itself\n        previousList = this._subject,     // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1], // The parent containing the current list\n        next = this._readListItem;        // The next function to execute\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext();\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._literal(token.value, this._namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      var datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext();\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    var next, subject = this._subject, graph = this._graph,\n        inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      var predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    var next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error('Expected punctuation to follow \"' + this._object.id + '\"', token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error('Expected IRI to follow prefix \"' + this._prefix + ':\"', token);\n    var prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    var iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    var entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error('Unexpected ' + token.type, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      var stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        var item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext();\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    var subject, predicate, object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    var subject = this._blankNode(), predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    var contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    var err = new Error(message + ' on line ' + token.line + '.');\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    var result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return result + '/' + iri.substr(i + 1);\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    var self = this;\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : 'b' + blankNodePrefix++ + '_';\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      var quads = [], error;\n      this._callback = function (e, t) { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(function (token) {\n        return self._readCallback = self._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, function (error, token) {\n      if (error !== null)\n        self._callback(error), self._callback = noop;\n      else if (self._readCallback)\n        self._readCallback = self._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  var namedNode = factory.namedNode;\n  parser._namedNode   = namedNode;\n  parser._blankNode   = factory.blankNode;\n  parser._literal     = factory.literal;\n  parser._variable    = factory.variable;\n  parser._quad        = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = namedNode(IRIs[\"a\" /* default */].rdf.first);\n  parser.RDF_REST   = namedNode(IRIs[\"a\" /* default */].rdf.rest);\n  parser.RDF_NIL    = namedNode(IRIs[\"a\" /* default */].rdf.nil);\n  parser.N3_FORALL  = namedNode(IRIs[\"a\" /* default */].r.forAll);\n  parser.N3_FORSOME = namedNode(IRIs[\"a\" /* default */].r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(IRIs[\"a\" /* default */].rdf.type),\n    '=': namedNode(IRIs[\"a\" /* default */].owl.sameAs),\n    '>': namedNode(IRIs[\"a\" /* default */].log.implies),\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser_N3Parser.prototype, N3DataFactory);\n\n// EXTERNAL MODULE: ./node_modules/stream-browserify/index.js\nvar stream_browserify = __webpack_require__(60);\n\n// CONCATENATED MODULE: ./node_modules/n3/src/N3Store.js\n// **N3Store** objects store N3 quads by graph in memory.\n\n\n\n\nconst { toId: N3Store_toId, fromId: N3Store_fromId } = N3DataFactory.internal;\n\n// ## Constructor\nclass N3Store_N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0])\n      options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads)\n      this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    var size = this._size;\n    if (size !== null)\n      return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    var graphs = this._graphs, subjects, subject;\n    for (var graphKey in graphs)\n      for (var subjectKey in (subjects = graphs[graphKey].subjects))\n        for (var predicateKey in (subject = subjects[subjectKey]))\n          size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    var index1 = index0[key0] || (index0[key0] = {});\n    var index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    var existed = key2 in index2;\n    if (!existed)\n      index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    var index1 = index0[key0], index2 = index1[key1], key;\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (key in index2) return;\n    delete index1[key1];\n    for (key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    var tmp, index1, index2, varCount = !key0 + !key1 + !key2,\n        // depending on the number of variables, keys or reverse index are faster\n        entityKeys = varCount > 1 ? Object.keys(this._ids) : this._entities;\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (var value0 in index0) {\n      var entity0 = entityKeys[value0];\n\n      if (index1 = index0[value0]) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (var value1 in index1) {\n          var entity1 = entityKeys[value1];\n\n          if (index2 = index1[value1]) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            var values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (var l = 0; l < values.length; l++) {\n              var parts = { subject: null, predicate: null, object: null };\n              parts[name0] = N3Store_fromId(entity0, this._factory);\n              parts[name1] = N3Store_fromId(entity1, this._factory);\n              parts[name2] = N3Store_fromId(entityKeys[values[l]], this._factory);\n              var quad = this._factory.quad(\n                parts.subject, parts.predicate, parts.object, N3Store_fromId(graph, this._factory));\n              if (array)\n                array.push(quad);\n              else if (callback(quad))\n                return true;\n            }\n          }\n        }\n      }\n    }\n    return array;\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (var key0 in index0)\n      callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    var index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1)\n        callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    var key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1])\n        callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    var index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2)\n        callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    var count = 0, tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (var value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (var value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) (key2 in index2) && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph))\n      return this._graphs;\n    var graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    var uniqueIds = Object.create(null), entities = this._entities;\n    return function (id) {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(N3Store_fromId(entities[id]));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = N3Store_toId(subject);\n    predicate = N3Store_toId(predicate);\n    object = N3Store_toId(object);\n    graph = N3Store_toId(graph);\n\n    // Find the graph that will contain the triple\n    var graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    var ids = this._ids;\n    var entities = this._entities;\n    subject   = ids[subject]   || (ids[entities[++this._id] = subject]   = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object    = ids[object]    || (ids[entities[++this._id] = object]    = this._id);\n\n    var changed = this._addToIndex(graphItem.subjects,   subject,   predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._addToIndex(graphItem.objects,    object,    subject,   predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return changed;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (var i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    var self = this;\n    stream.on('data', function (quad) { self.addQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = N3Store_toId(subject);\n    predicate = N3Store_toId(predicate);\n    object = N3Store_toId(object);\n    graph = N3Store_toId(graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    var graphItem, ids = this._ids, graphs = this._graphs, subjects, predicates;\n    if (!(subject    = ids[subject]) || !(predicate = ids[predicate]) ||\n        !(object     = ids[object])  || !(graphItem = graphs[graph])  ||\n        !(subjects   = graphItem.subjects[subject]) ||\n        !(predicates = subjects[predicate]) ||\n        !(object in predicates))\n      return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);\n    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (var i = 0; i < quads.length; i++)\n      this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    var self = this;\n    stream.on('data', function (quad) { self.removeQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    return this.remove(this.match(subject, predicate, object, graph));\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && N3Store_toId(subject);\n    predicate = predicate && N3Store_toId(predicate);\n    object = object && N3Store_toId(object);\n    graph = graph && N3Store_toId(graph);\n\n    var quads = [], graphs = this._getGraphs(graph), content,\n        ids = this._ids, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return quads;\n\n    for (var graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                              'object', 'subject', 'predicate', graphId, null, quads);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null,\n                              'subject', 'predicate', 'object', graphId, null, quads);\n        }\n        else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null,\n                            'predicate', 'object', 'subject', graphId, null, quads);\n        else if (objectId)\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null,\n                            'object', 'subject', 'predicate', graphId, null, quads);\n        else\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null,\n                            'subject', 'predicate', 'object', graphId, null, quads);\n      }\n    }\n    return quads;\n  }\n\n  // ### `match` returns a stream of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  match(subject, predicate, object, graph) {\n    var stream = new stream_browserify[\"Readable\"]({ objectMode: true });\n\n    // Initialize stream once it is being read\n    stream._read = () => {\n      for (var quad of this.getQuads(subject, predicate, object, graph))\n        stream.push(quad);\n      stream.push(null);\n    };\n\n    return stream;\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && N3Store_toId(subject);\n    predicate = predicate && N3Store_toId(predicate);\n    object = object && N3Store_toId(object);\n    graph = graph && N3Store_toId(graph);\n\n    var count = 0, graphs = this._getGraphs(graph), content,\n        ids = this._ids, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return 0;\n\n    for (var graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        }\n        else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        }\n        else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(function (quad) {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    var some = false;\n    var every = !this.some(function (quad) {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && N3Store_toId(subject);\n    predicate = predicate && N3Store_toId(predicate);\n    object = object && N3Store_toId(object);\n    graph = graph && N3Store_toId(graph);\n\n    var graphs = this._getGraphs(graph), content,\n        ids = this._ids, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return false;\n\n    for (var graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n          // If subject and object are given, the object index will be the fastest\n            if (this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                                  'object', 'subject', 'predicate', graphId, callback, null))\n              return true;\n          }\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            if (this._findInIndex(content.subjects, subjectId, predicateId, null,\n                                  'subject', 'predicate', 'object', graphId, callback, null))\n              return true;\n        }\n        else if (predicateId) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          if (this._findInIndex(content.predicates, predicateId, objectId, null,\n                                'predicate', 'object', 'subject', graphId, callback, null)) {\n            return true;\n          }\n        }\n        else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          if (this._findInIndex(content.objects, objectId, null, null,\n                                'object', 'subject', 'predicate', graphId, callback, null)) {\n            return true;\n          }\n        }\n        else\n        // If nothing is given, iterate subjects and predicates first\n        if (this._findInIndex(content.subjects, null, null, null,\n                              'subject', 'predicate', 'object', graphId, callback, null)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    var results = [];\n    this.forSubjects(function (s) { results.push(s); }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && N3Store_toId(predicate);\n    object = object && N3Store_toId(object);\n    graph = graph && N3Store_toId(graph);\n\n    var ids = this._ids, graphs = this._getGraphs(graph), content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n          else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);\n        else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    var results = [];\n    this.forPredicates(function (p) { results.push(p); }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && N3Store_toId(subject);\n    object = object && N3Store_toId(object);\n    graph = graph && N3Store_toId(graph);\n\n    var ids = this._ids, graphs = this._getGraphs(graph), content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) ||\n        isString(object)  && !(objectId  = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n          else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);\n        else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    var results = [];\n    this.forObjects(function (o) { results.push(o); }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && N3Store_toId(subject);\n    predicate = predicate && N3Store_toId(predicate);\n    graph = graph && N3Store_toId(graph);\n\n    var ids = this._ids, graphs = this._getGraphs(graph), content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject]) ||\n        isString(predicate) && !(predicateId = ids[predicate]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n          else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        }\n        else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);\n        else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    var results = [];\n    this.forGraphs(function (g) { results.push(g); }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (var graph in this._graphs) {\n      this.some(function (quad) {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    var name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = '_:' + suggestedName, index = 1;\n      while (this._ids[name])\n        name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do { name = '_:b' + this._blankNodeIndex++; }\n      while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists({ remove = false, ignoreErrors = false } = {}) {\n    var lists = {}; // has scalar keys so could be a simple Object\n    var onError = ignoreErrors ? (() => true) :\n                  ((node, message) => { throw new Error(`${node.value} ${message}`); });\n\n    // Traverse each list from its tail\n    var tails = this.getQuads(null, IRIs[\"a\" /* default */].rdf.rest, IRIs[\"a\" /* default */].rdf.nil, null);\n    var toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      var items = [];             // the members found as objects of rdf:first quads\n      var malformed = false;      // signals whether the current list is malformed\n      var head;                   // the head of the list (_:b1 in above example)\n      var headPos;                // set to subject or object when head is set\n      var graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      var current = tailQuad.subject;\n      while (current && !malformed) {\n        var objectQuads = this.getQuads(null, null, current, null);\n        var subjectQuads = this.getQuads(current, null, null, null);\n        var i, quad, first = null, rest = null, parent = null;\n\n        // Find the first and rest of this list node\n        for (i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph))\n            malformed = onError(current, 'not confined to single graph');\n          else if (head)\n            malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === IRIs[\"a\" /* default */].rdf.first) {\n            if (first)\n              malformed = onError(current, 'has multiple rdf:first arcs');\n            else\n              toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === IRIs[\"a\" /* default */].rdf.rest) {\n            if (rest)\n              malformed = onError(current, 'has multiple rdf:rest arcs');\n            else\n              toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length)\n            malformed = onError(current, 'can\\'t be subject and object');\n          else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head)\n            malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === IRIs[\"a\" /* default */].rdf.rest) {\n            if (parent)\n              malformed = onError(current, 'has incoming rdf:rest arcs');\n            else\n              parent = quad;\n          }\n          else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first)\n          malformed = onError(current, 'has no list head');\n        else\n          items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed)\n        remove = false;\n      // Store the list under the value of its head\n      else if (head)\n        lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove)\n      this.removeQuads(toRemove);\n    return lists;\n  }\n}\n\n// Determines whether the argument is a string\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n// CONCATENATED MODULE: ./node_modules/tripledoc/dist/index.es.js\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\n/**\r\n * @param quads Triples that should be serialised to Turtle\r\n * @internal Utility method for internal use by Tripledoc; not part of the public API.\r\n */\r\nfunction triplesToTurtle(quads) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var format, writer, triples, writePromise, rawTurtle;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    format = 'text/turtle';\r\n                    writer = new N3Writer({ format: format });\r\n                    triples = quads.map(function (quad) { return N3DataFactory.triple(quad.subject, quad.predicate, quad.object); });\r\n                    writer.addQuads(triples);\r\n                    writePromise = new Promise(function (resolve, reject) {\r\n                        writer.end(function (error, result) {\r\n                            /* istanbul ignore if [n3.js doesn't actually pass an error nor a result, apparently: https://github.com/rdfjs/N3.js/blob/62682e48c02d8965b4d728cb5f2cbec6b5d1b1b8/src/N3Writer.js#L290] */\r\n                            if (error) {\r\n                                return reject(error);\r\n                            }\r\n                            resolve(result);\r\n                        });\r\n                    });\r\n                    return [4 /*yield*/, writePromise];\r\n                case 1:\r\n                    rawTurtle = _a.sent();\r\n                    return [2 /*return*/, rawTurtle];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * @param raw Turtle that should be parsed into Triples\r\n * @internal Utility method for internal use by Tripledoc; not part of the public API.\r\n */\r\nfunction turtleToTriples(raw, documentRef) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var format, parser, parsingPromise;\r\n        return __generator(this, function (_a) {\r\n            format = 'text/turtle';\r\n            parser = new N3Parser_N3Parser({ format: format, baseIRI: documentRef });\r\n            parsingPromise = new Promise(function (resolve, reject) {\r\n                var parsedTriples = [];\r\n                parser.parse(raw, function (error, triple, _prefixes) {\r\n                    if (error) {\r\n                        return reject(error);\r\n                    }\r\n                    if (triple) {\r\n                        parsedTriples.push(triple);\r\n                    }\r\n                    else {\r\n                        resolve(parsedTriples);\r\n                    }\r\n                });\r\n            });\r\n            return [2 /*return*/, parsingPromise];\r\n        });\r\n    });\r\n}\n\n/**\r\n * Utility function that gets Triples located at a URL\r\n *\r\n * @param url Location of the Document contains the Triples.\r\n * @returns Promise that resolves with the Triples\r\n * @internal Should not be used by library consumers directly.\r\n */\r\n/* istanbul ignore next Just a thin wrapper around solid-auth-client, yet cumbersome to test due to side effects */\r\nfunction get(url) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var response;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, browser_default.a.fetch(url, {\r\n                        headers: {\r\n                            Accept: 'text/turtle',\r\n                        },\r\n                    })];\r\n                case 1:\r\n                    response = _a.sent();\r\n                    return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Utility function that gets a URL's metadata\r\n *\r\n * @param url Location of the Document to get the metadata of\r\n * @returns Promise that resolves with the Response\r\n * @internal Should not be used by library consumers directly.\r\n */\r\n/* istanbul ignore next Just a thin wrapper around solid-auth-client, yet cumbersome to test due to side effects */\r\nfunction index_es_head(url) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var response;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, browser_default.a.fetch(url, {\r\n                        method: 'HEAD',\r\n                    })];\r\n                case 1:\r\n                    response = _a.sent();\r\n                    return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Utility function that sends a PATCH request to the Pod to update a Document\r\n *\r\n * @param url Location of the Document that contains the Triples to delete, and should have the Triples to add.\r\n * @param triplesToDelete Triples currently present on the Pod that should be deleted.\r\n * @param triplesToAdd Triples not currently present on the Pod that should be added.\r\n * @returns Promise that resolves when the update was executed successfully, and rejects if not.\r\n * @internal Should not be used by library consumers directly.\r\n */\r\n/* istanbul ignore next Just a thin wrapper around solid-auth-client, yet cumbersome to test due to side effects */\r\nfunction update(url, triplesToDelete, triplesToAdd) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var rawTriplesToDelete, rawTriplesToAdd, deleteStatement, insertStatement, response;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, triplesToTurtle(triplesToDelete)];\r\n                case 1:\r\n                    rawTriplesToDelete = _a.sent();\r\n                    return [4 /*yield*/, triplesToTurtle(triplesToAdd)];\r\n                case 2:\r\n                    rawTriplesToAdd = _a.sent();\r\n                    deleteStatement = (triplesToDelete.length > 0)\r\n                        ? \"DELETE DATA {\" + rawTriplesToDelete + \"};\"\r\n                        : '';\r\n                    insertStatement = (triplesToAdd.length > 0)\r\n                        ? \"INSERT DATA {\" + rawTriplesToAdd + \"};\"\r\n                        : '';\r\n                    return [4 /*yield*/, browser_default.a.fetch(url, {\r\n                            method: 'PATCH',\r\n                            body: deleteStatement + \" \" + insertStatement,\r\n                            headers: {\r\n                                'Content-Type': 'application/sparql-update',\r\n                            },\r\n                        })];\r\n                case 3:\r\n                    response = _a.sent();\r\n                    return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Utility function that sends a PUT request to the Pod to create a new Document\r\n *\r\n * @param url URL of the Document that should be created.\r\n * @param triplesToAdd Triples that should be added to the Document.\r\n * @returns Promise that resolves with the response when the Document was created successfully, and rejects if not.\r\n * @internal Should not be used by library consumers directly.\r\n */\r\n/* istanbul ignore next Just a thin wrapper around solid-auth-client, yet cumbersome to test due to side effects */\r\nfunction create(url, triplesToAdd) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var rawTurtle, response;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, triplesToTurtle(triplesToAdd)];\r\n                case 1:\r\n                    rawTurtle = _a.sent();\r\n                    return [4 /*yield*/, browser_default.a.fetch(url, {\r\n                            method: 'PUT',\r\n                            body: rawTurtle,\r\n                            headers: {\r\n                                'Content-Type': 'text/turtle',\r\n                                'If-None-Match': '*',\r\n                            },\r\n                        })];\r\n                case 2:\r\n                    response = _a.sent();\r\n                    return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * Utility function that sends a POST request to a Container in the Pod to create a new Document\r\n *\r\n * @param containerUrl URL of the Container in which the Document should be created.\r\n * @param triplesToAdd Triples that should be added to the Document.\r\n * @returns Promise that resolves with the response when the Document was created successfully, and rejects if not.\r\n * @internal Should not be used by library consumers directly.\r\n */\r\n/* istanbul ignore next Just a thin wrapper around solid-auth-client, yet cumbersome to test due to side effects */\r\nfunction createInContainer(containerUrl, triplesToAdd, options) {\r\n    if (options === void 0) { options = {}; }\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var rawTurtle, headers, response;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, triplesToTurtle(triplesToAdd)];\r\n                case 1:\r\n                    rawTurtle = _a.sent();\r\n                    headers = {\r\n                        'Content-Type': 'text/turtle',\r\n                    };\r\n                    if (options.slugSuggestion) {\r\n                        headers.slug = options.slugSuggestion;\r\n                    }\r\n                    return [4 /*yield*/, browser_default.a.fetch(containerUrl, {\r\n                            method: 'POST',\r\n                            body: rawTurtle,\r\n                            headers: headers,\r\n                        })];\r\n                case 2:\r\n                    response = _a.sent();\r\n                    return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\n\n/* istanbul ignore next: A simple wrapper to make N3 conform with a subset of the RDF/JS Dataset\r\n                         interface; should contain no business logic. */\r\nfunction toRdfjsDataset(store) {\r\n    var addAll = function (quads) {\r\n        var quadsAsArray = Array.isArray(quads) ? quads : quads.toArray();\r\n        store.addQuads(quadsAsArray);\r\n        return dataset;\r\n    };\r\n    var match = function (subject, predicate, object, graph) {\r\n        var notUndefinedSubject = (typeof subject === 'undefined') ? null : subject;\r\n        var notUndefinedPredicate = (typeof predicate === 'undefined') ? null : predicate;\r\n        var notUndefinedObject = (typeof object === 'undefined') ? null : object;\r\n        var notUndefinedGraph = (typeof graph === 'undefined') ? null : graph;\r\n        return {\r\n            toArray: function () { return store.getQuads(notUndefinedSubject, notUndefinedPredicate, notUndefinedObject, notUndefinedGraph); },\r\n        };\r\n    };\r\n    var toArray = function () { return store.getQuads(null, null, null, null); };\r\n    var dataset = {\r\n        addAll: addAll,\r\n        match: match,\r\n        toArray: toArray,\r\n    };\r\n    return dataset;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction initialiseDataset() {\r\n    return toRdfjsDataset(new N3Store_N3Store());\r\n}\r\n/**\r\n * @internal\r\n */\r\nvar index_es_DataFactory = N3DataFactory;\n\n/**\r\n * @internal This is a utility method for other parts of the code, and not part of the public API.\r\n */\r\nvar findSubjectInDataset = function (dataset, predicateRef, objectRef) {\r\n    return findEntityInDataset(dataset, 'subject', null, predicateRef, objectRef);\r\n};\r\n/**\r\n * @internal This is a utility method for other parts of the code, and not part of the public API.\r\n */\r\nvar findSubjectsInDataset = function (dataset, predicateRef, objectRef) {\r\n    return findEntitiesInDataset(dataset, 'subject', null, predicateRef, objectRef);\r\n};\r\n/**\r\n * @internal This is a utility method for other parts of the code, and not part of the public API.\r\n */\r\nvar findObjectsInDataset = function (dataset, subjectRef, predicateRef) {\r\n    return findEntitiesInDataset(dataset, 'object', subjectRef, predicateRef, null);\r\n};\r\n/**\r\n * @internal This is a utility method for other parts of the code, and not part of the public API.\r\n */\r\nfunction findEntityInDataset(dataset, type, subjectRef, predicateRef, objectRef) {\r\n    var targetSubject = subjectRef ? toNode(subjectRef) : null;\r\n    var targetPredicate = predicateRef ? toNode(predicateRef) : null;\r\n    var targetObject = objectRef ? toNode(objectRef) : null;\r\n    var matchingTriples = dataset.match(targetSubject, targetPredicate, targetObject, null).toArray();\r\n    var foundTriple = matchingTriples.find(function (triple) { return (typeof triple[type] !== 'undefined'); });\r\n    return (typeof foundTriple !== 'undefined') ? normaliseEntity(foundTriple[type]) : null;\r\n}\r\n/**\r\n * @internal This is a utility method for other parts of the code, and not part of the public API.\r\n */\r\nfunction findEntitiesInDataset(dataset, type, subjectRef, predicateRef, objectRef) {\r\n    var targetSubject = subjectRef ? toNode(subjectRef) : null;\r\n    var targetPredicate = predicateRef ? toNode(predicateRef) : null;\r\n    var targetObject = objectRef ? toNode(objectRef) : null;\r\n    var matchingTriples = dataset.match(targetSubject, targetPredicate, targetObject, null).toArray();\r\n    var foundTriples = matchingTriples.filter(function (triple) { return (typeof triple[type] !== 'undefined'); });\r\n    return foundTriples.map(function (triple) { return normaliseEntity(triple[type]); }).filter(isEntity);\r\n}\r\nfunction toNode(referenceOrBlankNode) {\r\n    return (typeof referenceOrBlankNode === 'string') ? index_es_DataFactory.namedNode(referenceOrBlankNode) : referenceOrBlankNode;\r\n}\r\nfunction normaliseEntity(entity) {\r\n    if (isBlankNode(entity)) {\r\n        return entity;\r\n    }\r\n    if (isNamedNode(entity)) {\r\n        return entity.value;\r\n    }\r\n    /* istanbul ignore else: All code paths to here result in either a Node or a Literal, so we can't test it */\r\n    if (isLiteral(entity)) {\r\n        return entity;\r\n    }\r\n    /* istanbul ignore next: All code paths to here result in either a Node or a Literal, so we can't test it */\r\n    return null;\r\n}\r\nfunction isEntity(node) {\r\n    return (node !== null);\r\n}\r\n/**\r\n * @internal Utility function for working with N3, which the library consumer should not need to\r\n *           be exposed to.\r\n */\r\nfunction isNamedNode(node) {\r\n    return node.termType === 'NamedNode';\r\n}\r\n/**\r\n * @internal Utility function for working with rdflib, which the library consumer should not need to\r\n *           be exposed to.\r\n */\r\nfunction isBlankNode(node) {\r\n    return node.termType === 'BlankNode';\r\n}\n\n/**\r\n * @internal Only to be called by the Document containing this subject; not a public API.\r\n * @param document The Document this Subject is defined in.\r\n * @param subjectRef The URL that identifies this subject.\r\n */\r\nfunction initialiseSubject(document, subjectRef) {\r\n    var subjectNode = isBlankNode$1(subjectRef) ? subjectRef : index_es_DataFactory.namedNode(subjectRef);\r\n    var triples = (isSavedToPod(document))\r\n        ? document.getStore().match(subjectNode, null, null, null).toArray()\r\n        : [];\r\n    var dataset = initialiseDataset();\r\n    dataset.addAll(triples);\r\n    var pendingAdditions = [];\r\n    var pendingDeletions = [];\r\n    var get = function (predicateNode) { return findObjectsInDataset(dataset, subjectRef, predicateNode); };\r\n    var getString = function (predicateNode) {\r\n        var objects = get(predicateNode);\r\n        var firstStringLiteral = objects.find(isStringLiteral);\r\n        if (typeof firstStringLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return firstStringLiteral.value;\r\n    };\r\n    var getLocaleString = function (predicateNode, locale) {\r\n        var objects = get(predicateNode);\r\n        var firstStringLiteral = objects.find(generateLocaleTypeGuard(locale));\r\n        if (typeof firstStringLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return firstStringLiteral.value;\r\n    };\r\n    var getInteger = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstIntegerLiteral = objects.find(isIntegerLiteral);\r\n        if (typeof firstIntegerLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return fromIntegerLiteral(firstIntegerLiteral);\r\n    };\r\n    var getDecimal = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstDecimalLiteral = objects.find(isDecimalLiteral);\r\n        if (typeof firstDecimalLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return fromDecimalLiteral(firstDecimalLiteral);\r\n    };\r\n    var getDateTime = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstDateTimeLiteral = objects.find(isDateTimeLiteral);\r\n        if (typeof firstDateTimeLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return fromDateTimeLiteral(firstDateTimeLiteral);\r\n    };\r\n    var getLiteral = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstLiteral = objects.find(isLiteral);\r\n        if (typeof firstLiteral === 'undefined') {\r\n            return null;\r\n        }\r\n        return fromLiteral(firstLiteral);\r\n    };\r\n    var getAllStrings = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(isStringLiteral);\r\n        return literals.map(fromStringLiteral);\r\n    };\r\n    var getAllLocaleStrings = function (predicateRef, locale) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(generateLocaleTypeGuard(locale));\r\n        return literals.map(fromStringLiteral);\r\n    };\r\n    var getAllIntegers = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(isIntegerLiteral);\r\n        return literals.map(fromIntegerLiteral);\r\n    };\r\n    var getAllDecimals = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(isDecimalLiteral);\r\n        return literals.map(fromDecimalLiteral);\r\n    };\r\n    var getAllDateTimes = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(isDateTimeLiteral);\r\n        return literals.map(fromDateTimeLiteral);\r\n    };\r\n    var getAllLiterals = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var literals = objects.filter(isLiteral);\r\n        return literals.map(fromLiteral);\r\n    };\r\n    var getLocalSubject = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstRef = objects.find(isBlankNode$1);\r\n        if (typeof firstRef === 'undefined') {\r\n            return null;\r\n        }\r\n        return initialiseSubject(document, firstRef);\r\n    };\r\n    var getAllLocalSubjects = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var nodeRefs = objects.filter(isBlankNode$1);\r\n        return nodeRefs.map(function (localSubject) { return initialiseSubject(document, localSubject); });\r\n    };\r\n    var getRef = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var firstRef = objects.find(isReference);\r\n        if (typeof firstRef === 'undefined') {\r\n            return null;\r\n        }\r\n        return firstRef;\r\n    };\r\n    var getAllRefs = function (predicateRef) {\r\n        var objects = get(predicateRef);\r\n        var nodeRefs = objects.filter(isReference);\r\n        return nodeRefs;\r\n    };\r\n    var getType = function () {\r\n        return getRef('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');\r\n    };\r\n    var addLiteral = function (predicateRef, literal) {\r\n        pendingAdditions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), asLiteral(literal)));\r\n    };\r\n    var addString = function (predicateRef, literal) {\r\n        if (typeof literal !== 'string') {\r\n            throw new Error('The given value is not a string.');\r\n        }\r\n        return addLiteral(predicateRef, literal);\r\n    };\r\n    var addLocaleString = function (predicateRef, literal, locale) {\r\n        if (typeof literal !== 'string') {\r\n            throw new Error('The given value is not a string.');\r\n        }\r\n        pendingAdditions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.literal(literal, locale)));\r\n    };\r\n    var addInteger = function (predicateRef, literal) {\r\n        if (typeof literal !== 'number' || !Number.isInteger(literal)) {\r\n            throw new Error('The given value is not an integer.');\r\n        }\r\n        return addLiteral(predicateRef, literal);\r\n    };\r\n    var addDecimal = function (predicateRef, literal) {\r\n        if (typeof literal !== 'number') {\r\n            throw new Error('The given value is not a decimal.');\r\n        }\r\n        pendingAdditions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.literal(literal.toString(), index_es_DataFactory.namedNode('http://www.w3.org/2001/XMLSchema#decimal'))));\r\n    };\r\n    var addDateTime = function (predicateRef, literal) {\r\n        if (literal instanceof Date === false) {\r\n            throw new Error('The given value is not a DateTime.');\r\n        }\r\n        return addLiteral(predicateRef, literal);\r\n    };\r\n    var addRef = function (predicateRef, nodeRef) {\r\n        pendingAdditions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.namedNode(nodeRef)));\r\n    };\r\n    var removeRef = function (predicateRef, nodeRef) {\r\n        pendingDeletions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.namedNode(nodeRef)));\r\n    };\r\n    var removeLiteral = function (predicateRef, literal) {\r\n        pendingDeletions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), asLiteral(literal)));\r\n    };\r\n    var removeString = function (predicateRef, literal) {\r\n        if (typeof literal !== 'string') {\r\n            throw new Error('The given value is not a string.');\r\n        }\r\n        return removeLiteral(predicateRef, literal);\r\n    };\r\n    var removeLocaleString = function (predicateRef, literal, locale) {\r\n        if (typeof literal !== 'string') {\r\n            throw new Error('The given value is not a string.');\r\n        }\r\n        pendingDeletions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.literal(literal, locale)));\r\n    };\r\n    var removeInteger = function (predicateRef, literal) {\r\n        if (typeof literal !== 'number' || !Number.isInteger(literal)) {\r\n            throw new Error('The given value is not an integer.');\r\n        }\r\n        return removeLiteral(predicateRef, literal);\r\n    };\r\n    var removeDecimal = function (predicateRef, literal) {\r\n        if (typeof literal !== 'number') {\r\n            throw new Error('The given value is not a decimal.');\r\n        }\r\n        // We cannot re-use `removeLiteral` here because it will parse `42.0` as an integer:\r\n        pendingDeletions.push(index_es_DataFactory.triple(subjectNode, index_es_DataFactory.namedNode(predicateRef), index_es_DataFactory.literal(literal.toString(), index_es_DataFactory.namedNode('http://www.w3.org/2001/XMLSchema#decimal'))));\r\n    };\r\n    var removeDateTime = function (predicateRef, literal) {\r\n        if (literal instanceof Date === false) {\r\n            throw new Error('The given value is not a DateTime.');\r\n        }\r\n        return removeLiteral(predicateRef, literal);\r\n    };\r\n    var removeAll = function (predicateRef) {\r\n        pendingDeletions.push.apply(pendingDeletions, dataset.match(subjectNode, index_es_DataFactory.namedNode(predicateRef), null, null).toArray());\r\n    };\r\n    var clear = function () {\r\n        pendingDeletions.push.apply(pendingDeletions, getTriples());\r\n    };\r\n    var setRef = function (predicateRef, nodeRef) {\r\n        removeAll(predicateRef);\r\n        addRef(predicateRef, nodeRef);\r\n    };\r\n    var setLiteral = function (predicateRef, literal) {\r\n        removeAll(predicateRef);\r\n        addLiteral(predicateRef, literal);\r\n    };\r\n    var setString = function (predicateRef, literal) {\r\n        removeAll(predicateRef);\r\n        addString(predicateRef, literal);\r\n    };\r\n    var setLocaleString = function (predicateRef, literal, locale) {\r\n        removeAll(predicateRef);\r\n        addLocaleString(predicateRef, literal, locale);\r\n    };\r\n    var setInteger = function (predicateRef, literal) {\r\n        removeAll(predicateRef);\r\n        addInteger(predicateRef, literal);\r\n    };\r\n    var setDecimal = function (predicateRef, literal) {\r\n        removeAll(predicateRef);\r\n        addDecimal(predicateRef, literal);\r\n    };\r\n    var setDateTime = function (predicateRef, literal) {\r\n        removeAll(predicateRef);\r\n        addDateTime(predicateRef, literal);\r\n    };\r\n    var getTriples = function () { return dataset.match(subjectNode, null, null, null).toArray(); };\r\n    var asRef = function () { return isBlankNode$1(subjectRef) ? subjectRef.value : subjectRef; };\r\n    var subject = {\r\n        getDocument: function () { return document; },\r\n        getTriples: getTriples,\r\n        getString: getString,\r\n        getLocaleString: getLocaleString,\r\n        getInteger: getInteger,\r\n        getDecimal: getDecimal,\r\n        getDateTime: getDateTime,\r\n        getLiteral: getLiteral,\r\n        getAllStrings: getAllStrings,\r\n        getAllLocaleStrings: getAllLocaleStrings,\r\n        getAllIntegers: getAllIntegers,\r\n        getAllDecimals: getAllDecimals,\r\n        getAllDateTimes: getAllDateTimes,\r\n        getAllLiterals: getAllLiterals,\r\n        getLocalSubject: getLocalSubject,\r\n        getAllLocalSubjects: getAllLocalSubjects,\r\n        getRef: getRef,\r\n        getAllRefs: getAllRefs,\r\n        getType: getType,\r\n        addString: addString,\r\n        addLocaleString: addLocaleString,\r\n        addInteger: addInteger,\r\n        addDecimal: addDecimal,\r\n        addDateTime: addDateTime,\r\n        addRef: addRef,\r\n        removeAll: removeAll,\r\n        removeString: removeString,\r\n        removeLocaleString: removeLocaleString,\r\n        removeInteger: removeInteger,\r\n        removeDecimal: removeDecimal,\r\n        removeDateTime: removeDateTime,\r\n        removeRef: removeRef,\r\n        setRef: setRef,\r\n        setString: setString,\r\n        setLocaleString: setLocaleString,\r\n        setInteger: setInteger,\r\n        setDecimal: setDecimal,\r\n        setDateTime: setDateTime,\r\n        clear: clear,\r\n        getPendingTriples: function () { return [pendingDeletions, pendingAdditions]; },\r\n        asRef: asRef,\r\n        // Deprecated aliases, included for backwards compatibility:\r\n        getNodeRef: getRef,\r\n        getAllNodeRefs: getAllRefs,\r\n        addNodeRef: addRef,\r\n        addLiteral: addLiteral,\r\n        removeNodeRef: removeRef,\r\n        removeLiteral: removeLiteral,\r\n        setNodeRef: setRef,\r\n        setLiteral: setLiteral,\r\n        asNodeRef: asRef,\r\n    };\r\n    return subject;\r\n}\r\nfunction fromDateTimeLiteral(literal) {\r\n    // See https://github.com/linkeddata/rdflib.js/blob/d84af88f367b8b5f617c753d8241c5a2035458e8/src/literal.js#L87\r\n    var utcFullYear = parseInt(literal.value.substring(0, 4), 10);\r\n    var utcMonth = parseInt(literal.value.substring(5, 7), 10) - 1;\r\n    var utcDate = parseInt(literal.value.substring(8, 10), 10);\r\n    var utcHours = parseInt(literal.value.substring(11, 13), 10);\r\n    var utcMinutes = parseInt(literal.value.substring(14, 16), 10);\r\n    var utcSeconds = parseInt(literal.value.substring(17, literal.value.indexOf('Z')), 10);\r\n    var date = new Date(0);\r\n    date.setUTCFullYear(utcFullYear);\r\n    date.setUTCMonth(utcMonth);\r\n    date.setUTCDate(utcDate);\r\n    date.setUTCHours(utcHours);\r\n    date.setUTCMinutes(utcMinutes);\r\n    date.setUTCSeconds(utcSeconds);\r\n    return date;\r\n}\r\nfunction fromIntegerLiteral(literal) {\r\n    return parseInt(literal.value, 10);\r\n}\r\nfunction fromDecimalLiteral(literal) {\r\n    return parseFloat(literal.value);\r\n}\r\nfunction fromStringLiteral(literal) {\r\n    return literal.value;\r\n}\r\nfunction fromLiteral(literal) {\r\n    if (isDateTimeLiteral(literal)) {\r\n        return fromDateTimeLiteral(literal);\r\n    }\r\n    if (isIntegerLiteral(literal)) {\r\n        return fromIntegerLiteral(literal);\r\n    }\r\n    if (isDecimalLiteral(literal)) {\r\n        return fromDecimalLiteral(literal);\r\n    }\r\n    return literal.value;\r\n}\r\nfunction asLiteral(literal) {\r\n    if (literal instanceof Date) {\r\n        // To align with rdflib, we ignore miliseconds:\r\n        // https://github.com/linkeddata/rdflib.js/blob/d84af88f367b8b5f617c753d8241c5a2035458e8/src/literal.js#L74\r\n        var roundedDate = new Date(Date.UTC(literal.getUTCFullYear(), literal.getUTCMonth(), literal.getUTCDate(), literal.getUTCHours(), literal.getUTCMinutes(), literal.getUTCSeconds(), 0));\r\n        // Truncate the `.000Z` at the end (i.e. the miliseconds), to plain `Z`:\r\n        var rdflibStyleString = roundedDate.toISOString().replace(/\\.000Z$/, 'Z');\r\n        return index_es_DataFactory.literal(rdflibStyleString, index_es_DataFactory.namedNode('http://www.w3.org/2001/XMLSchema#dateTime'));\r\n    }\r\n    if (typeof literal === 'number' && Number.isInteger(literal)) {\r\n        return index_es_DataFactory.literal(literal.toString(), index_es_DataFactory.namedNode('http://www.w3.org/2001/XMLSchema#integer'));\r\n    }\r\n    if (typeof literal === 'number' && !Number.isInteger(literal)) {\r\n        return index_es_DataFactory.literal(literal.toString(), index_es_DataFactory.namedNode('http://www.w3.org/2001/XMLSchema#decimal'));\r\n    }\r\n    return index_es_DataFactory.literal(literal.toString());\r\n}\n\n/**\r\n * @internal\r\n */\r\nfunction instantiateLocalTripleDocument(dataset, subjectCache, metadata) {\r\n    var _this = this;\r\n    var bareTripleDocument = instantiateBareTripleDocument(subjectCache, metadata);\r\n    var asRef = function () { return metadata.documentRef; };\r\n    var save = function (subjects) {\r\n        if (subjects === void 0) { subjects = Object.values(subjectCache.getAccessedSubjects()); }\r\n        return __awaiter(_this, void 0, void 0, function () {\r\n            var pendingChanges, updatedMetadata, response, message, aclRef, webSocketRef;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        pendingChanges = getPendingChanges(subjects, tripleDocumentWithRef, dataset);\r\n                        return [4 /*yield*/, create(metadata.documentRef, pendingChanges.allAdditions)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (!!response.ok) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, response.text()];\r\n                    case 2:\r\n                        message = _a.sent();\r\n                        throw new Error(message);\r\n                    case 3:\r\n                        updatedMetadata = __assign(__assign({}, metadata), { existsOnPod: true });\r\n                        aclRef = extractAclRef(response, metadata.documentRef);\r\n                        if (aclRef) {\r\n                            updatedMetadata.aclRef = aclRef;\r\n                        }\r\n                        webSocketRef = response.headers.get('Updates-Via');\r\n                        if (webSocketRef) {\r\n                            updatedMetadata.webSocketRef = webSocketRef;\r\n                        }\r\n                        // Instantiate a new TripleDocument that includes the updated Triples:\r\n                        return [2 /*return*/, instantiateDocument(pendingChanges.newTriples, updatedMetadata)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    var tripleDocumentWithRef = __assign(__assign({}, bareTripleDocument), { save: save, asRef: asRef, \r\n        // Deprecated alias:\r\n        asNodeRef: asRef });\r\n    // Make sure that when TripleSubjects get initialised for this Document,\r\n    // they're attached to the Document instance that includes its Reference:\r\n    subjectCache.setDocument(tripleDocumentWithRef);\r\n    return tripleDocumentWithRef;\r\n}\n\n/**\r\n * @internal\r\n */\r\nfunction instantiateFullTripleDocument(dataset, subjectCache, metadata) {\r\n    var _this = this;\r\n    var tripleDocumentWithRef = instantiateLocalTripleDocument(dataset, subjectCache, metadata);\r\n    var getAclRef = function () {\r\n        return metadata.aclRef || null;\r\n    };\r\n    var getWebSocketRef = function () {\r\n        return metadata.webSocketRef || null;\r\n    };\r\n    var removeSubject = function (subjectRef) {\r\n        var subject = subjectCache.getSubject(subjectRef);\r\n        return subject.clear();\r\n    };\r\n    var findSubject = function (predicateRef, objectRef) {\r\n        var findSubjectRef = withDocumentSingular(findSubjectInDataset, dataset);\r\n        var subjectRef = findSubjectRef(predicateRef, objectRef);\r\n        if (!subjectRef || !isReference(subjectRef)) {\r\n            return null;\r\n        }\r\n        return subjectCache.getSubject(subjectRef);\r\n    };\r\n    var findSubjects = function (predicateRef, objectRef) {\r\n        var findSubjectRefs = withDocumentPlural(findSubjectsInDataset, dataset);\r\n        var subjectRefs = findSubjectRefs(predicateRef, objectRef);\r\n        return subjectRefs.filter(isReference).map(subjectCache.getSubject);\r\n    };\r\n    var getAllSubjects = function () {\r\n        var allSubjectRefsInTriples = findEntitiesInDataset(dataset, 'subject', null, null, null)\r\n            .filter(isReference);\r\n        var uniqueSubjectRefs = Array.from(new Set(allSubjectRefsInTriples));\r\n        return uniqueSubjectRefs.map(function (subjectRef) { return subjectCache.getSubject(subjectRef); });\r\n    };\r\n    var getAllSubjectsOfType = function (typeRef) {\r\n        return findSubjects('http://www.w3.org/1999/02/22-rdf-syntax-ns#type', typeRef);\r\n    };\r\n    var save = function (subjects) {\r\n        if (subjects === void 0) { subjects = Object.values(subjectCache.getAccessedSubjects()); }\r\n        return __awaiter(_this, void 0, void 0, function () {\r\n            var pendingChanges, updatedMetadata, response, message;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        pendingChanges = getPendingChanges(subjects, tripleDocument, dataset);\r\n                        return [4 /*yield*/, update(metadata.documentRef, pendingChanges.allDeletions, pendingChanges.allAdditions)];\r\n                    case 1:\r\n                        response = _a.sent();\r\n                        if (!!response.ok) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, response.text()];\r\n                    case 2:\r\n                        message = _a.sent();\r\n                        throw new Error(message);\r\n                    case 3:\r\n                        updatedMetadata = __assign(__assign({}, metadata), { existsOnPod: true });\r\n                        // Instantiate a new TripleDocument that includes the updated Triples:\r\n                        return [2 /*return*/, instantiateDocument(pendingChanges.newTriples, updatedMetadata)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    var getStore = function () { return dataset; };\r\n    var getTriples = function () { return dataset.toArray(); };\r\n    var tripleDocument = __assign(__assign({}, tripleDocumentWithRef), { save: save, removeSubject: removeSubject, getSubject: subjectCache.getSubject, getAllSubjectsOfType: getAllSubjectsOfType, findSubject: findSubject, findSubjects: findSubjects, getAclRef: getAclRef, getWebSocketRef: getWebSocketRef, \r\n        // Experimental methods:\r\n        experimental_getAllSubjects: getAllSubjects, \r\n        // Escape hatches, should not be necessary:\r\n        getStore: getStore, getTriples: getTriples, \r\n        // Deprecated aliases, included for backwards compatibility:\r\n        getAcl: getAclRef, getStatements: getTriples, getSubjectsOfType: getAllSubjectsOfType });\r\n    // Make sure that when TripleSubjects get initialised for this Document,\r\n    // they're attached to the fully initialised Document instance:\r\n    subjectCache.setDocument(tripleDocument);\r\n    return tripleDocument;\r\n}\r\nvar withDocumentSingular = function (getEntityFromTriples, dataset) {\r\n    return function (knownEntity1, knownEntity2) {\r\n        return getEntityFromTriples(dataset, knownEntity1, knownEntity2);\r\n    };\r\n};\r\nvar withDocumentPlural = function (getEntitiesFromTriples, dataset) {\r\n    return function (knownEntity1, knownEntity2) {\r\n        return getEntitiesFromTriples(dataset, knownEntity1, knownEntity2);\r\n    };\r\n};\n\n/**\r\n * @internal\r\n */\r\nfunction instantiateLocalTripleDocumentForContainer(dataset, subjectCache, metadata) {\r\n    var _this = this;\r\n    var bareTripleDocument = instantiateBareTripleDocument(subjectCache, metadata);\r\n    var save = function (subjects) {\r\n        if (subjects === void 0) { subjects = Object.values(subjectCache.getAccessedSubjects()); }\r\n        return __awaiter(_this, void 0, void 0, function () {\r\n            var pendingChanges, updatedMetadata, containerResponse, locationHeader, message, documentRef, documentResponse, aclRef, webSocketRef;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        pendingChanges = getPendingChanges(subjects, localTripleDocumentForContainer, dataset);\r\n                        return [4 /*yield*/, createInContainer(metadata.containerRef, pendingChanges.allAdditions)];\r\n                    case 1:\r\n                        containerResponse = _a.sent();\r\n                        locationHeader = containerResponse.headers.get('Location');\r\n                        if (!(!containerResponse.ok || locationHeader === null)) return [3 /*break*/, 3];\r\n                        return [4 /*yield*/, containerResponse.text()];\r\n                    case 2:\r\n                        message = _a.sent();\r\n                        throw new Error(message);\r\n                    case 3:\r\n                        documentRef = new URL(locationHeader, new URL(metadata.containerRef).origin).href;\r\n                        updatedMetadata = __assign(__assign({}, metadata), { containerRef: undefined, documentRef: documentRef, existsOnPod: true });\r\n                        return [4 /*yield*/, index_es_head(documentRef)];\r\n                    case 4:\r\n                        documentResponse = _a.sent();\r\n                        aclRef = extractAclRef(documentResponse, documentRef);\r\n                        if (aclRef) {\r\n                            updatedMetadata.aclRef = aclRef;\r\n                        }\r\n                        webSocketRef = documentResponse.headers.get('Updates-Via');\r\n                        if (webSocketRef) {\r\n                            updatedMetadata.webSocketRef = webSocketRef;\r\n                        }\r\n                        // Instantiate a new TripleDocument that includes the updated Triples:\r\n                        return [2 /*return*/, instantiateDocument(pendingChanges.newTriples, updatedMetadata)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    var localTripleDocumentForContainer = __assign(__assign({}, bareTripleDocument), { save: save });\r\n    // Make sure that when TripleSubjects get initialised for this Document,\r\n    // they're attached to this Document instance:\r\n    subjectCache.setDocument(localTripleDocumentForContainer);\r\n    return localTripleDocumentForContainer;\r\n}\n\n/**\r\n * @ignore Not yet a supported API.\r\n */\r\nfunction hasRef(document) {\r\n    return typeof document.asRef === 'function';\r\n}\r\n/**\r\n * @ignore Not yet a supported API.\r\n */\r\nfunction isSavedToPod(document) {\r\n    return typeof document.getTriples === 'function';\r\n}\r\n/**\r\n * Initialise a new Turtle document\r\n *\r\n * Note that this Document will not be created on the Pod until you call [[save]] on it.\r\n *\r\n * @param ref URL where this document should live\r\n */\r\nfunction createDocument(ref) {\r\n    return instantiateDocument([], { documentRef: ref, existsOnPod: false });\r\n}\r\n/**\r\n * Initialise a new Turtle Document in a Container\r\n *\r\n * Note that this Document will not be created on the Pod until you call [[save]] on it.\r\n *\r\n * @param containerRef URL of the Container in which this document should live\r\n */\r\nfunction createDocumentInContainer(containerRef) {\r\n    return instantiateDocument([], { containerRef: containerRef, existsOnPod: false });\r\n}\r\n/**\r\n * Retrieve a document containing RDF triples\r\n *\r\n * @param documentRef Where the document lives.\r\n * @returns Representation of triples in the document at `uri`.\r\n */\r\nfunction fetchDocument(uri) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var docUrl, documentRef, response, rawDocument, triples, aclRef, webSocketRef;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    docUrl = new URL(uri);\r\n                    documentRef = docUrl.origin + docUrl.pathname + docUrl.search;\r\n                    return [4 /*yield*/, get(documentRef)];\r\n                case 1:\r\n                    response = _a.sent();\r\n                    if (response.ok === false) {\r\n                        throw new Error(\"Fetching the Document failed: \" + response.status + \" \" + response.statusText + \".\");\r\n                    }\r\n                    return [4 /*yield*/, response.text()];\r\n                case 2:\r\n                    rawDocument = _a.sent();\r\n                    return [4 /*yield*/, turtleToTriples(rawDocument, documentRef)];\r\n                case 3:\r\n                    triples = _a.sent();\r\n                    aclRef = extractAclRef(response, documentRef);\r\n                    webSocketRef = response.headers.get('Updates-Via');\r\n                    return [2 /*return*/, instantiateDocument(triples, {\r\n                            aclRef: aclRef,\r\n                            documentRef: documentRef,\r\n                            webSocketRef: webSocketRef || undefined,\r\n                            existsOnPod: true,\r\n                        })];\r\n            }\r\n        });\r\n    });\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction extractAclRef(response, documentRef) {\r\n    var aclRef;\r\n    var linkHeader = response.headers.get('Link');\r\n    // `LinkHeader` might not be present when using the UMD build in the browser,\r\n    // in which case we just don't parse the ACL header. It is recommended to use a non-UMD build\r\n    // that supports code splitting anyway.\r\n    if (linkHeader && link_default.a) {\r\n        var parsedLinks = link_default.a.parse(linkHeader);\r\n        var aclLinks = parsedLinks.get('rel', 'acl');\r\n        if (aclLinks.length === 1) {\r\n            aclRef = new URL(aclLinks[0].uri, documentRef).href;\r\n        }\r\n    }\r\n    return aclRef;\r\n}\r\nfunction hasKnownRef(metadata) {\r\n    return typeof metadata.documentRef === 'string';\r\n}\r\nfunction existsOnPod(metadata) {\r\n    return metadata.existsOnPod === true;\r\n}\r\nfunction instantiateDocument(triples, metadata) {\r\n    var dataset = initialiseDataset();\r\n    dataset.addAll(triples);\r\n    var subjectCache = initialiseSubjectCache();\r\n    if (!hasKnownRef(metadata)) {\r\n        return instantiateLocalTripleDocumentForContainer(dataset, subjectCache, metadata);\r\n    }\r\n    if (!existsOnPod(metadata)) {\r\n        return instantiateLocalTripleDocument(dataset, subjectCache, metadata);\r\n    }\r\n    return instantiateFullTripleDocument(dataset, subjectCache, metadata);\r\n}\r\nfunction initialiseSubjectCache() {\r\n    var sourceDocument;\r\n    var accessedSubjects = {};\r\n    var setDocument = function (newDocument) {\r\n        sourceDocument = newDocument;\r\n    };\r\n    var getSubject = function (subjectRef) {\r\n        // Allow relative URLs to access Subjects if we know where the Document is:\r\n        subjectRef = hasRef(sourceDocument)\r\n            ? new URL(subjectRef, sourceDocument.asRef()).href\r\n            : subjectRef;\r\n        if (!accessedSubjects[subjectRef]) {\r\n            accessedSubjects[subjectRef] = initialiseSubject(sourceDocument, subjectRef);\r\n        }\r\n        return accessedSubjects[subjectRef];\r\n    };\r\n    var getAccessedSubjects = function () { return accessedSubjects; };\r\n    return {\r\n        getSubject: getSubject,\r\n        setDocument: setDocument,\r\n        getAccessedSubjects: getAccessedSubjects,\r\n    };\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction instantiateBareTripleDocument(subjectCache, metadata) {\r\n    var addSubject = function (_a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.identifier, identifier = _c === void 0 ? generateIdentifier() : _c, _d = _b.identifierPrefix, identifierPrefix = _d === void 0 ? '' : _d;\r\n        var subjectRef = (hasKnownRef(metadata) ? metadata.documentRef : '') + '#' + identifierPrefix + identifier;\r\n        return subjectCache.getSubject(subjectRef);\r\n    };\r\n    var bareTripleDocument = {\r\n        addSubject: addSubject,\r\n    };\r\n    return bareTripleDocument;\r\n}\r\n/**\r\n * @internal\r\n */\r\nfunction getPendingChanges(subjects, document, dataset) {\r\n    var relevantSubjects = subjects.filter(function (subject) { return subject.getDocument() === document; });\r\n    var _a = relevantSubjects.reduce(function (_a, subject) {\r\n        var deletionsSoFar = _a[0], additionsSoFar = _a[1];\r\n        var _b = subject.getPendingTriples(), deletions = _b[0], additions = _b[1];\r\n        return [deletionsSoFar.concat(deletions), additionsSoFar.concat(additions)];\r\n    }, [[], []]), allDeletions = _a[0], allAdditions = _a[1];\r\n    var newTriples = dataset.toArray()\r\n        .concat(allAdditions)\r\n        .filter(function (tripleToDelete) { return allDeletions.findIndex(function (triple) { return triple.equals(tripleToDelete); }) === -1; });\r\n    return {\r\n        allAdditions: allAdditions,\r\n        allDeletions: allDeletions,\r\n        newTriples: newTriples,\r\n    };\r\n}\r\n/**\r\n * Generate a string that can be used as the unique identifier for a Subject\r\n *\r\n * This function works by starting with a date string (so that Subjects can be\r\n * sorted chronologically), followed by a random number generated by taking a\r\n * random number between 0 and 1, and cutting off the `0.`.\r\n *\r\n * @internal\r\n * @returns An string that's likely to be unique\r\n */\r\nvar generateIdentifier = function () {\r\n    return Date.now().toString() + Math.random().toString().substring('0.'.length);\r\n};\n\n/**\r\n * @ignore Tripledoc's methods should be explicit about whether they return or accept a Literal, so\r\n *         this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 Literal.\r\n * @returns Whether `param` is an N3 Literal.\r\n */\r\nfunction isLiteral(param) {\r\n    return (typeof param === 'object') &&\r\n        (param !== null) &&\r\n        (typeof param.termType === 'string') &&\r\n        param.termType === 'Literal';\r\n}\r\n/**\r\n * @internal Tripledoc's methods should be explicit about whether they return or accept a specific\r\n *           type, so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 string Literal.\r\n * @returns Whether `param` is an N3 string Literal.\r\n */\r\nfunction isStringLiteral(param) {\r\n    return isLiteral(param) && param.datatype.value === 'http://www.w3.org/2001/XMLSchema#string';\r\n}\r\n/**\r\n * @internal Tripledoc's methods should be explicit about whether they return or accept a specific\r\n *           type, so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 locale string Literal.\r\n * @returns Whether `param` is an N3 locale string Literal with the given locale.\r\n */\r\nfunction isLocaleStringLiteral(param, locale) {\r\n    return isLiteral(param) &&\r\n        param.datatype.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#langString' &&\r\n        param.language.toLowerCase() === locale.toLowerCase();\r\n}\r\n/**\r\n * Primarily useful to create type guarsd for use in e.g. `Array.prototype.filter`.\r\n * @internal This is an internal TripleDoc data type that should not be exposed to library consumers.\r\n */\r\nfunction generateLocaleTypeGuard(locale) {\r\n    return function typeGuard(param) {\r\n        return isLocaleStringLiteral(param, locale);\r\n    };\r\n}\r\n/**\r\n * @internal Tripledoc's methods should be explicit about whether they return or accept a specific\r\n *           type, so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 integer Literal.\r\n * @returns Whether `param` is an N3 integer Literal.\r\n */\r\nfunction isIntegerLiteral(param) {\r\n    return isLiteral(param) && param.datatype.value === 'http://www.w3.org/2001/XMLSchema#integer';\r\n}\r\n/**\r\n * @internal Tripledoc's methods should be explicit about whether they return or accept a specific\r\n *           type, so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 decimal Literal.\r\n * @returns Whether `param` is an N3 decimal Literal.\r\n */\r\nfunction isDecimalLiteral(param) {\r\n    return isLiteral(param) && param.datatype.value === 'http://www.w3.org/2001/XMLSchema#decimal';\r\n}\r\n/**\r\n * @internal Tripledoc's methods should be explicit about whether they return or accept a specific\r\n *           type, so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be an N3 DateTime Literal.\r\n * @returns Whether `param` is an N3 DateTime Literal.\r\n */\r\nfunction isDateTimeLiteral(param) {\r\n    return isLiteral(param) && param.datatype.value === 'http://www.w3.org/2001/XMLSchema#dateTime';\r\n}\r\n/**\r\n * @ignore Deprecated function.\r\n * @deprecated Replaced by [[isReference]].\r\n */\r\nvar isNodeRef = isReference;\r\n/**\r\n * @ignore Tripledoc's methods should be explicit about whether they return or accept a [[Reference]],\r\n *         so this is merely an internal utility function, rather than a public API.\r\n * @param param A value that might or might not be a reference to a node in the Linked Data graph.\r\n * @returns Whether `param` is a reference to a node in the Linked Data graph.\r\n */\r\nfunction isReference(value) {\r\n    return typeof value === 'string' && !isLiteral(value);\r\n}\r\n/**\r\n * @internal Blank Nodes themselves should not be exposed to library consumers, so this is merely an\r\n *           internal utility function, rather than a public API.\r\n * @param param A value that might or might not be a blank node in the Linked Data graph.\r\n * @returns Whether `param` is a blank node in the Linked Data graph.\r\n */\r\nfunction isBlankNode$1(param) {\r\n    return (typeof param === 'object') &&\r\n        (param !== null) &&\r\n        (typeof param.termType === 'string') &&\r\n        param.termType === 'BlankNode';\r\n}\n\n\n\n// EXTERNAL MODULE: ./node_modules/@rdfjs/data-model/index.js\nvar data_model = __webpack_require__(58);\n\n// CONCATENATED MODULE: ./src/views/browser-view.js\n\n\n\nfunction browser_view_templateObject3() {\n  const data = browser_view_taggedTemplateLiteral([\"\\n      <li class=\\\"list-group-item\\\">\\n      <div class=\\\"btn-toolbar justify-content-between\\\" role=\\\"toolbar\\\" aria-label=\\\"Toolbar with button groups\\\">\\n      <div class=\\\"btn-group\\\" role=\\\"group\\\" aria-label=\\\"First group\\\">\\n      <div class=\\\"text-outline-secondary\\\" url=\\\"\", \"\\\" type=\\\"\", \"\\\" @click=\\\"\", \"\\\">\\n      <i class=\\\"fas fa-file\\\" url=\\\"\", \"\\\" type=\\\"\", \"\\\" @click=\\\"\", \"\\\"></i>\\n      \", \"\\n      </div>\\n      </div>\\n\\n      <div class=\\\"btn-group\\\" role=\\\"group\\\">\\n      <a href=\\\"\", \"\\\" class=\\\"btn btn-secondary btn-sm\\\" target=\\\"_blank\\\"><i class=\\\"fas fa-external-link-alt\\\"></i></a>\\n      \x3c!--    <button type=\\\"button\\\" class=\\\"btn btn-secondary btn-sm\\\" disabled><i class=\\\"fas fa-file-download\\\"></i></button>\\n      <button type=\\\"button\\\" class=\\\"btn btn-secondary btn-sm\\\"disabled><i class=\\\"fas fa-file-export\\\"></i></button>\\n      --\x3e  <button type=\\\"button\\\" class=\\\"btn btn-secondary btn-sm\\\" url='\", \"' @click=\\\"\", \"\\\"><i class=\\\"fas fa-trash\\\" url='\", \"' @click=\\\"\", \"\\\"></i></button>\\n      </div>\\n      </div>\\n      </li>\\n      \"]);\n\n  browser_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction browser_view_templateObject2() {\n  const data = browser_view_taggedTemplateLiteral([\"\\n      <li class=\\\"list-group-item\\\" url=\\\"\", \"\\\" type=\\\"\", \"\\\" @click=\\\"\", \"\\\">\\n      <i class=\\\"fas fa-folder\\\"></i>\\n      \", \"</li>\\n      \"]);\n\n  browser_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction browser_view_templateObject() {\n  const data = browser_view_taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n\\n\\n    currentFile : \", \"\\n    <div class=\\\"container-fluid\\\" ?hidden=\\\"\", \"\\\">\\n    <div class=\\\"btn-group  container-fluid\\\" role=\\\"group\\\" aria-label=\\\"Basic example\\\">\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" @click=\\\"\", \"\\\"><i class=\\\"fas fa-arrow-up\\\" @click=\\\"\", \"\\\"></i> </button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" @click=\\\"\", \"\\\"><i class=\\\"fas fa-arrow-left\\\" @click=\\\"\", \"\\\"></i></button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" input_type=\\\"foldername\\\" @click=\\\"\", \"\\\"><i class=\\\"fas fa-folder-plus\\\" input_type=\\\"foldername\\\"  @click=\\\"\", \"\\\"></i></button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" input_type=\\\"filename\\\" @click=\\\"\", \"\\\"><i class=\\\"fas fa-file\\\" input_type=\\\"filename\\\" @click=\\\"\", \"\\\"></i></button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" input_type=\\\"file\\\" @click=\\\"\", \"\\\"><i class=\\\"fas fa-file-upload\\\" input_type=\\\"file\\\" @click=\\\"\", \"\\\"></i></button>\\n    <button type=\\\"button\\\" class=\\\"btn btn-secondary\\\" disabled @click=\\\"\", \"\\\"><i class=\\\"fas fa-user-friends\\\" @click=\\\"\", \"\\\"></i> solid</button>\\n    </div>\\n    <br>\\n    <div class=\\\"btn-group container-fluid\\\" role=\\\"group\\\" aria-label=\\\"Basic example\\\">\\n    <button type=\\\"button\\\" class=\\\"btn btn-outline-secondary\\\" disabled>\", \"</button>\\n    </div>\\n\\n\\n    <div  ?hidden=\\\"\", \"\\\"\\n    class=\\\"btn-group container-fluid\\\" role=\\\"group\\\" aria-label=\\\"new\\\">\\n    <div class=\\\"input-group mb-3\\\">\\n    <input type=\\\"text\\\"\\n    id=\\\"create_input\\\" class=\\\"form-control\\\"\\n    placeholder=\\\"Folder or File name\\\"\\n    aria-label=\\\"Folder or File name\\\"\\n    aria-describedby=\\\"basic-addon2\\\">\\n    <div class=\\\"input-group-append\\\">\\n    <button class=\\\"btn btn-outline-secondary\\\" type=\\\"button\\\" @click=\\\"\", \"\\\">Create</button>\\n    <i class=\\\"fas fa-times btn btn-outline-secondary\\\" @click=\\\"\", \"\\\"></i>\\n    </div>\\n    </div>\\n    </div>\\n\\n\\n\\n    <div style=\\\"height: 30vh; width:100%; overflow: auto\\\">\\n    <ul class=\\\"list-group\\\">\\n    \", \"\\n    </ul>\\n    <hr>\\n    <ul class=\\\"list-group\\\">\\n    \", \"\\n    </ul>\\n    </div>\\n    </div>\\n    \"]);\n\n  browser_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction browser_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\n\n\n\nclass browser_view_BrowserView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      webId: {\n        type: String\n      },\n      storage: {\n        type: String\n      },\n      path: {\n        type: String\n      },\n      last: {\n        type: String\n      },\n      folder: {\n        type: Object\n      },\n      folderName: {\n        type: String\n      },\n      fileName: {\n        type: String\n      },\n      createHidden: {\n        type: Boolean\n      },\n      currentFile: {\n        type: String\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"Browser\";\n    this.webId = {};\n    this.storage = \"\";\n    this.path = \"\";\n    this.last = \"\";\n    this.folder = {\n      folders: [],\n      files: []\n    };\n    this.folderName = \"\";\n    this.fileName = \"\";\n    this.fc = new solid_file_client_bundle(solid.auth);\n    this.createHidden = true;\n    this.currentFile = null;\n  }\n\n  render() {\n    return lit_html_html(browser_view_templateObject(), this.currentFile, this.path.length == 0, this.up, this.up, this.prec, this.prec, this.new, this.new, this.new, this.new, this.new, this.new, this.solid, this.solid, this.path, this.createHidden, this.create, this.closeCreateInput, this.folder.folders.map((f, i) => lit_html_html(browser_view_templateObject2(), f.url, f.type, this.changePath, f.name)), this.folder.files.map((f, i) => lit_html_html(browser_view_templateObject3(), f.url, f.type, this.changePath, f.url, f.type, this.changePath, f.name, f.url, f.url, this.deleteFile, f.url, this.delete)));\n  }\n\n  new(e) {\n    this.createHidden = false;\n    let input_type = e.target.getAttribute(\"input_type\");\n    this.shadowRoot.getElementById(\"create_input\").setAttribute(\"input_type\", input_type);\n    this.shadowRoot.getElementById(\"create_input\").setAttribute(\"type\", input_type == \"file\" ? \"file\" : \"text\");\n\n    if (input_type == \"filename\") {\n      this.shadowRoot.getElementById(\"create_input\").value = new Date().toISOString().replace(/:/gi, '-').replace(/t/gi, '_').replace(/z/gi, '').trim() + \".ttl\";\n      this.agent.send(\"Vis\", {\n        action: \"clear\"\n      });\n    } //  this.shadowRoot.getElementById(\"create_input\").placeholder( type)\n\n  }\n\n  async create() {\n    let name = this.shadowRoot.getElementById(\"create_input\").value.trim();\n\n    if (name.length > 0) {\n      let input_type = this.shadowRoot.getElementById(\"create_input\").getAttribute(\"input_type\");\n      console.log(name, input_type);\n      let create_path = this.path + name;\n\n      switch (input_type) {\n        case \"filename\":\n          create_path = !create_path.endsWith(\".ttl\") ? create_path + \".ttl\" : create_path;\n          console.log(create_path);\n          this.currentFile = create_path;\n          this.agent.send(\"Vis\", {\n            action: \"currentFileChanged\",\n            currentFile: this.currentFile\n          });\n          let defaultContent = \"# created by Spoggy App\";\n          await this.fc.createFile(create_path, defaultContent, \"text/turtle\").catch(err => console.error(\"Error: \".concat(err)));\n          break;\n\n        case \"foldername\":\n          console.log(create_path);\n          await this.fc.createFolder(create_path).catch(err => console.error(\"Error: \".concat(err)));\n          break;\n\n        case \"filename\":\n          console.log(\"TODO : upload\");\n          break;\n\n        default:\n      }\n\n      this.createHidden = true;\n      this.updateFolder();\n      this.shadowRoot.getElementById(\"create_input\").value = \"\";\n    } else {\n      alert(\"I can't create a folder or a file with a blank name !\");\n    }\n  }\n\n  closeCreateInput() {\n    this.createHidden = true;\n  }\n\n  async deleteFile(e) {\n    let url = e.target.getAttribute(\"url\");\n    var del = confirm(\"Do you want really want to delete \" + url + \" ?\");\n\n    if (del == true) {\n      await this.fc.deleteFile(url);\n      this.updateFolder();\n    }\n    /*\r\n    TODO AFTER CONFIRM\r\n    https://github.com/jeff-zucker/solid-file-client#deletefile-fileurl-options-\r\n    deleteFile( fileURL, options )\r\n    deleteFolder( folderURL )\r\n    */\n\n  }\n\n  changePath(e) {\n    //    console.log(e)\n    let url = e.target.getAttribute(\"url\");\n    let type = e.target.getAttribute(\"type\");\n\n    if (type == \"folder\") {\n      this.last = this.path;\n      this.path = url;\n      this.updateFolder();\n    } else {\n      console.log(\"A file, todo\", url);\n      this.getFile(url);\n    }\n  }\n\n  async getFile(url) {\n    this.createHidden = true;\n\n    try {\n      const doc = await fetchDocument(url);\n      this.currentFile = url;\n      this.agent.send(\"Vis\", {\n        action: \"currentFileChanged\",\n        currentFile: this.currentFile\n      }); //  console.log(\"doc\",doc)\n\n      let triples = doc.getTriples();\n      console.log(\"triples\", triples); //  let vis_network = this.statements2vis(triples)\n\n      this.agent.send(\"Vis\", {\n        action: \"triplesChanged\",\n        triples: triples\n      });\n    } catch (e) {\n      console.log(e);\n      alert(\"Oh i've got a problem to read this file :-(\");\n    }\n\n    console.log(\"currentFile\", this.currentFile);\n  }\n\n  statements2vis(statements) {\n    console.log(\"statements2vis\");\n    var app = this;\n    var data = {\n      nodes: [],\n      edges: []\n    }; //  var i = 0;\n\n    statements.forEach(function (statement) {\n      //console.log(statement)\n      //  i++;\n      //  app.agentImport.send('agentApp', {type: 'message', data: statements.length-i});\n      //  console.log(\"STATEMENT2VIS\", statement)\n      var edges = [];\n      var s = statement.subject;\n      var p = statement.predicate;\n      var o = statement.object;\n      var w = statement.why;\n\n      switch (p.value) {\n        case \"http://www.w3.org/2000/01/rdf-schema#label\":\n        case \"http://xmlns.com/foaf/0.1/label\":\n          var nodeAndLabel = {\n            id: s.value,\n            title: o.value,\n            label: o.value,\n            why: w.value,\n            y: 2 * Math.random(),\n            type: \"node\"\n          };\n          console.log(\"push\", s.value, \"label\", o.value); //app.addNodeIfNotExist(app.network, nodeAndLabel)\n\n          data.nodes.push(nodeAndLabel);\n          break;\n\n        default:\n          //console.log(\"NON LABEL \",p.value);\n          console.log(\"###\\n\", s.value, \"\\n\", p.value, \"\\n\", o.value);\n          var edges = [];\n          var nodeSujetTemp = app.detailNoeud(s, w);\n          var nodeObjetTemp = app.detailNoeud(o, w);\n          data.nodes.push(nodeSujetTemp);\n          data.nodes.push(nodeObjetTemp);\n          data.edges.push({\n            from: s.value,\n            to: o.value,\n            arrows: 'to',\n            label: app.localname(p),\n            uri: p.value\n          });\n        //  app.addEdgeIfNotExist(app.network,{from:s.subject.value, to: s.object.value, arrows: 'to', label:s.predicate.value});\n        //app.network.body.data.edges.update(edges)\n      }\n    });\n    console.log(data);\n    return data;\n  }\n\n  detailNoeud(n, w) {\n    var node = {};\n    console.log(n);\n\n    switch (n.termType) {\n      case 'BlankNode':\n        var l = this.localname(n);\n        node = {\n          id: n.value,\n          why: w.value,\n          //  y:2*Math.random(),\n          type: \"node\"\n        };\n\n        if (n.value != l) {\n          node.title = l;\n          node.label = l;\n        }\n\n        break;\n\n      case 'Collection':\n        n.elements.forEach(function (elem) {\n          console.log(\"elem\", elem);\n          this.detailNoeud(elem, w);\n        });\n        break;\n\n      case 'Literal':\n        var l = this.localname(n).length > 37 ? this.localname(n).substring(0, 40) + \"...\" : this.localname(n);\n        node = {\n          id: n.value,\n          title: n.value,\n          label: l,\n          why: w.value,\n          //  y:2*Math.random(),\n          type: \"node\",\n          shape: \"box\",\n          color: \"rgb(240,220,110)\"\n        };\n        break;\n\n      case 'NamedNode':\n        var l = this.localname(n);\n        node = {\n          id: n.value,\n          title: n.value,\n          label: l,\n          why: w.value,\n          //  y:2*Math.random(),\n          type: \"node\"\n        };\n\n        if (l == \"me\") {\n          node.label = node.title;\n          node.shape = \"image\";\n          node.image = \"./assets/profile.svg\";\n          node.type = \"webId\";\n        }\n\n        break;\n\n      default:\n        console.log('Sorry, je ne traite pas encore ' + n.termType + '.');\n        node = {\n          id: n.value,\n          title: n.value,\n          label: n.value,\n          why: w.value,\n          //  y:2*Math.random(),\n          type: \"node\"\n        };\n    }\n\n    console.log(node); //\n\n    return node;\n  }\n\n  localname(node) {\n    //  console.log(\"LOCALNAME OF \",node)\n    if (node.value != undefined) {\n      var value = node.value; //  console.log(value)\n\n      if (value.endsWith('/') || value.endsWith('#')) {\n        value = value.substring(0, value.length - 1);\n      }\n\n      var labelU = value;\n\n      if (node.termType == \"NamedNode\") {\n        //  console.log(\"namenode\")\n        var uLabel = value.split(\"#\");\n        var labelU = uLabel[uLabel.length - 1];\n\n        if (labelU == uLabel) {\n          uLabel = value.split(\"/\");\n          labelU = uLabel[uLabel.length - 1];\n        }\n      } else {\n        console.log(\"TODO : literal or blanknode ???\", node);\n      } //  console.log(labelU)\n\n\n      return labelU;\n    } else {\n      console.log(\"TODO node.value = undefined, il faut maintenant traiter le tableau\", node.elements);\n    }\n  }\n\n  async webIdChanged(webId) {\n    this.webId = webId;\n\n    if (webId != null) {\n      console.log(this.webId);\n      let storage = await solid.data[webId].storage;\n      this.storage = \"\".concat(storage); //    console.log(this.storage)\n\n      this.path = this.storage + \"public/spoggy/\";\n\n      if (!(await this.fc.itemExists(this.path))) {\n        await this.fc.createFolder(this.path); // only create if it doesn't already exist\n      }\n\n      let newfilename = new Date().toISOString().replace(/:/gi, '-').replace(/t/gi, '_').replace(/z/gi, '').trim() + \".ttl\";\n      this.shadowRoot.getElementById(\"create_input\").value = newfilename;\n      this.shadowRoot.getElementById(\"create_input\").setAttribute(\"input_type\", \"filename\");\n      this.createHidden = false;\n      this.currentFile = this.path + newfilename;\n      this.agent.send(\"Vis\", {\n        action: \"clear\"\n      });\n      this.agent.send(\"Vis\", {\n        action: \"currentFileChanged\",\n        currentFile: this.currentFile\n      });\n      this.updateFolder();\n    } else {\n      this.storage = \"\";\n      this.path = \"\";\n      this.folder = {\n        folders: [],\n        files: []\n      };\n      this.currentFile = null;\n      this.agent.send(\"Vis\", {\n        action: \"currentFileChanged\",\n        currentFile: this.currentFile\n      });\n    }\n  }\n\n  async updateFolder() {\n    //  console.log(this.path)\n    this.folder = await this.fc.readFolder(this.path);\n    console.log(\"folder\", this.folder);\n  }\n\n  async addTriple(t) {\n    let subject = t.subject;\n    let predicate = t.predicate;\n    let object = t.object;\n\n    if (this.currentFile == null) {\n      alert(\"Hey ! You must login to your POD to use me ! No need to give me 'Full Control', just the basic settings, a '/public/spoggy' folder will be created.\");\n    } else {\n      console.log(this.currentFile);\n      subject = this.currentFile + \"#\" + t.subject;\n      predicate = this.currentFile + \"#\" + t.predicate;\n      object = this.currentFile + \"#\" + t.object;\n      await solid.data[subject][predicate].add(Object(data_model[\"namedNode\"])(object));\n      this.updateFolder();\n      this.createHidden = true;\n    }\n\n    this.agent.send(\"Vis\", {\n      action: \"addTriple\",\n      triple: {\n        subject: subject,\n        predicate: predicate,\n        object: object\n      }\n    });\n  }\n\n  up() {\n    this.path = this.folder.parent;\n    this.updateFolder();\n  }\n\n  prec() {\n    // TODO manage an history\n    this.path = this.last;\n    this.updateFolder();\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"webIdChanged\":\n            app.webIdChanged(message.webId);\n            break;\n\n          case \"addTriple\":\n            app.addTriple(message.triple);\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define('browser-view', browser_view_BrowserView);\n// CONCATENATED MODULE: ./src/views/input-view.js\n\n\nfunction _templateObject5() {\n  const data = input_view_taggedTemplateLiteral([\"\\n        <small>\\n        You can add triples to your Spog.<br>\\n        To do so, just type 3 words in the above input and ends with a :\\n        <ul>\\n        <li>comma (,) if you want to keep subject & predicate, </li>\\n        <li>semicolon (;) if you want to keep just the subject,</li>\\n        <li>dot (.) if you don't want to keep anything,</li>\\n        <li>dash (-) if you want that the object become the subject of the next triple.</li>\\n        </ul>\\n        ex: Dav a Man,\\n        </small>\\n        \"]);\n\n  _templateObject5 = function _templateObject5() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction input_view_templateObject4() {\n  const data = input_view_taggedTemplateLiteral([\"  \", \"\"]);\n\n  input_view_templateObject4 = function _templateObject4() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction input_view_templateObject3() {\n  const data = input_view_taggedTemplateLiteral([\"\\n      <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n      <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n\\n      \x3c!--  <div ?hidden=\\\"\", \"\\\"> --\x3e\\n      <div  class=\\\"row\\\">\\n      <div class=\\\"container-fluid\\\">\\n      <div class=\\\"input-group mb-3\\\">\\n      \x3c!--<div class=\\\"input-group-prepend\\\">\\n      <span class=\\\"input-group-text\\\" id=\\\"input-label\\\">?</span>\\n      </div>--\x3e\\n      <input type=\\\"text\\\" class=\\\"form-control\\\"\\n      id=\\\"tripleInput\\\"\\n      placeholder=\\\"'Subject predicate Object,' ending with , ; . or - or command starting by '/'\\\"\\n      aria-label=\\\"'Subject predicate Object,' ending with , ; . or - or command starting by '/'\\\"\\n      title=\\\"'Subject predicate Object,' ending with , ; . or - or command starting by '/'\\\"\\n      aria-describedby=\\\"input-label\\\"\\n      @keydown=\", \">\\n      <div class=\\\"input-group-append\\\">\\n      <button class=\\\"btn btn-outline-primary\\\" @click=\\\"\", \"\\\" type=\\\"button\\\">Add</button>\\n      </div>\\n      </div>\\n      </div>\\n      </div>\\n\\n\\n\\n      <div class=\\\"row\\\">\\n      \", \"\\n      </div>\\n      \x3c!--      </div> --\x3e\\n      \"]);\n\n  input_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction input_view_templateObject2() {\n  const data = input_view_taggedTemplateLiteral([\"\\n      <li class=\\\"list-group-item\\\">\\n      <div class=\\\"row\\\">\\n      <button class=\\\"btn btn-outline-secondary btn-sm\\\" type=\\\"button\\\">\", \"</button>\\n      <button class=\\\"btn btn-outline-secondary btn-sm\\\" type=\\\"button\\\">\", \"</button>\\n      <button class=\\\"btn btn-outline-secondary btn-sm\\\" type=\\\"button\\\">\", \"</button>\\n      \x3c!--[edit] [delete]--\x3e\\n      </div>\\n      </li>\\n      \"]);\n\n  input_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction input_view_templateObject() {\n  const data = input_view_taggedTemplateLiteral([\"\\n    <ul class=\\\"list-group list-group-flush\\\" style=\\\"height: 30vh; width:100%; overflow: auto\\\">\\n    \", \"\\n      </ul>\\n      \"]);\n\n  input_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction input_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass input_view_InputView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      debug: {\n        type: Boolean\n      },\n      webId: {\n        type: String\n      },\n      triples: {\n        type: Array\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"Input\";\n    this.debug = false;\n    this.webId = null;\n    this.triples = [];\n  }\n\n  render() {\n    const triplesList = triples => lit_html_html(input_view_templateObject(), triples.map(t => lit_html_html(input_view_templateObject2(), t.subject, t.predicate, t.object)));\n\n    return lit_html_html(input_view_templateObject3(), this.webId == null, this.keydown, this.add_triple, this.triples.length > 0 ? lit_html_html(input_view_templateObject4(), triplesList(this.triples)) : lit_html_html(_templateObject5()));\n  }\n\n  add_triple() {\n    var new_triple = this.shadowRoot.getElementById('tripleInput').value.trim();\n\n    if (new_triple.length == 0) {\n      alert(\"you can't add an empty Triple\");\n      return;\n    }\n\n    console.log(new_triple);\n    var res = this.catchCommand(new_triple);\n  }\n\n  catchCommand(message) {\n    if (message.startsWith('/')) {\n      let command = message.slice(1);\n      console.log(\"command\", command);\n    } else {\n      this.updateInput(message);\n    }\n  }\n\n  updateInput(message) {\n    var result = {};\n    var inputNew = \"\";\n    let lastChar = message.slice(-1);\n    let messageCut = message.slice(0, -1).split(\" \");\n    let isTriplet = true;\n    console.log(messageCut);\n    let detectLiteral = \"\";\n    let messageCutTemp = [];\n    messageCut.forEach(function (part) {\n      part = part.trim(); //  console.log(part);\n\n      if (part.startsWith('\"')) {\n        detectLiteral = \"debut\"; //  console.log(detectLiteral);\n\n        messageCutTemp.push(part.substr(1));\n      } else if (part.endsWith('\"')) {\n        detectLiteral = \"fin\"; //console.log(detectLiteral);\n\n        messageCutTemp.push(messageCutTemp.pop() + \" \" + part.slice(0, -1));\n      } else if (detectLiteral == \"debut\") {\n        //  console.log(\"recupere le dernier et lui ajoute part\" )\n        messageCutTemp.push(messageCutTemp.pop() + \" \" + part);\n      } else {\n        messageCutTemp.push(part);\n      }\n    });\n\n    if (messageCutTemp.length > 0) {\n      messageCut = messageCutTemp;\n    }\n\n    switch (lastChar) {\n      case '.':\n        inputNew = \"\";\n        break;\n\n      case ';':\n        if (messageCut[0].indexOf(\" \") > -1) {\n          inputNew = '\"' + messageCut[0] + '\"' + ' ';\n        } else {\n          inputNew = messageCut[0] + ' ';\n        }\n\n        break;\n\n      case ',':\n        if (messageCut[0].indexOf(\" \") > -1) {\n          inputNew = '\"' + messageCut[0] + '\" ';\n        } else {\n          inputNew = messageCut[0] + ' ';\n        }\n\n        if (messageCut[1].indexOf(\" \") > -1) {\n          inputNew += '\"' + messageCut[1] + '\" ';\n        } else {\n          inputNew += messageCut[1] + ' ';\n        }\n\n        break;\n\n      case '-':\n        if (messageCut[2].indexOf(\" \") > -1) {\n          inputNew = '\"' + messageCut[2] + '\"' + ' ';\n        } else {\n          inputNew = messageCut[2] + ' ';\n        }\n\n        break;\n\n      default:\n        console.log(\"message to chat \" + message); //this.sendMessage(message);\n        //  this.agentInput.send('agentSocket', {type: \"sendMessage\", message:message});\n        //  this.catchTriplet(message.slice(0,-1), this.network); // A REMPLACER PAR CATCHTRIPLETS V2\n\n        inputNew = \"\";\n        isTriplet = false;\n    }\n\n    if (isTriplet) {\n      //  console.log(\"est Triplet\",messageCut)\n      result.type = \"triplet\";\n      var tripletvalue = {};\n      tripletvalue.subject = messageCut[0];\n      tripletvalue.predicate = messageCut[1];\n      tripletvalue.object = messageCut[2];\n      result.value = tripletvalue;\n      result.inputNew = inputNew;\n    } else {\n      //  console.log(\"n'est pas triplet\")\n      result.type = \"message\";\n      result.value = message;\n      result.inputNew = inputNew;\n    } //  console.log(res)\n\n\n    this.shadowRoot.getElementById('tripleInput').value = result.inputNew;\n\n    if (result.type == \"triplet\") {\n      //  var triple = result.value\n      //  this.triples.reverse()\n      this.triples = [result.value, ...this.triples]; //  this.triples.reverse()\n\n      console.log(this.triples);\n      console.log(result);\n      this.agent.send(\"Browser\", {\n        action: \"addTriple\",\n        triple: result.value\n      });\n    } else {\n      alert(\"Triple is an association of three words (subject, predicate, object) & must end with ',' or ';' or '.' or '-' \");\n    }\n  }\n\n  keydown(e) {\n    if (e.which === 13) {\n      this.add_triple();\n      e.preventDefault();\n      return false;\n    }\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"webIdChanged\":\n            app.webId = message.webId;\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define('input-view', input_view_InputView);\n// CONCATENATED MODULE: ./src/views/node-view.js\n\n\nfunction node_view_templateObject2() {\n  const data = node_view_taggedTemplateLiteral([\"\\n      <div class=\\\"input-group mb-3\\\">\\n      <div class=\\\"input-group-prepend\\\">\\n      <span class=\\\"input-group-text text-primary\\\" id=\\\"\", \"\\\">\", \"</span>\\n      </div>\\n      <input type=\\\"text\\\"   class=\\\"form-control\\\" placeholder=\\\"\", \"\\\" aria-label=\\\"\", \"\\\"\\n      aria-describedby=\\\"\", \"\\\"\\n      key=\\\"\", \"\\\"\\n      .value=\\\"\", \"\\\"\\n      @change=\\\"\", \"\\\">\\n      </div>\\n      \"]);\n\n  node_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction node_view_templateObject() {\n  const data = node_view_taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n\\n    <div class=\\\"container-fluid\\\">\\n    \", \"\\n\\n    <hr>\\n    </div>\\n\\n\\n    <div ?hidden = \\\"\", \"\\\">\\n    <hr>\\n    Hello from<b>\", \"</b><br>\\n    debug : \", \"<br>\\n    node :\\n    <pre> \", \"</pre><br>\\n    </div>\\n\\n\\n    \"]);\n\n  node_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction node_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass node_view_NodeView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      debug: {\n        type: Boolean\n      },\n      node: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"Modele\";\n    this.debug = false;\n    this.node = {};\n  }\n\n  render() {\n    return lit_html_html(node_view_templateObject(), Object.entries(this.node).map(([key, value], i) => lit_html_html(node_view_templateObject2(), key, key, key, key, key, key, value, this.change)), !this.debug, this.name, this.debug, JSON.stringify(this.node, undefined, 2));\n  }\n\n  change(e) {\n    let key = e.target.getAttribute(\"key\");\n    let value = e.target.value.trim(); //  console.log(\"change\",key, value)\n\n    this.node[key] = value;\n    console.log(this.node);\n    this.agent.send(\"Vis\", {\n      action: \"nodeUpdate\",\n      node: this.node\n    });\n  }\n  /*  input(e){\r\n  \x3c!--  @input=\"${this.input}\"--\x3e\r\n  let key = e.target.getAttribute(\"key\")\r\n  let value = e.target.value.trim()\r\n  console.log(\"input\",key, value)\r\n  console.log(this.node)\r\n  }*/\n\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name); //  console.log(this.agent)\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"configChanged\":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n  configChanged(config) {\n    this.config = config;\n    console.log(this.config);\n  }\n\n}\n\ncustomElements.define('node-view', node_view_NodeView);\n// CONCATENATED MODULE: ./src/views/edge-view.js\n\n\nfunction edge_view_templateObject2() {\n  const data = edge_view_taggedTemplateLiteral([\"\\n      <div class=\\\"input-group mb-3\\\">\\n      <div class=\\\"input-group-prepend\\\">\\n      <span class=\\\"input-group-text\\\" id=\\\"\", \"\\\">\", \"</span>\\n      </div>\\n      <input type=\\\"text\\\"   class=\\\"form-control\\\" placeholder=\\\"\", \"\\\" aria-label=\\\"\", \"\\\"\\n      aria-describedby=\\\"\", \"\\\"\\n      key=\\\"\", \"\\\"\\n      .value=\\\"\", \"\\\"\\n      @change=\\\"\", \"\\\">\\n      </div>\\n      \"]);\n\n  edge_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction edge_view_templateObject() {\n  const data = edge_view_taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n    <link href=\\\"css/fontawesome/css/all.css\\\" rel=\\\"stylesheet\\\">\\n\\n    <div class=\\\"container-fluid\\\">\\n    \", \"\\n    <hr>\\n    </div>\\n\\n\\n    <div ?hidden = \\\"\", \"\\\">\\n    <hr>\\n    Hello from<b>\", \"</b><br>\\n    debug : \", \"<br>\\n    edge :\\n    <pre> \", \"</pre><br>\\n    </div>\\n\\n\\n    \"]);\n\n  edge_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction edge_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass edge_view_EdgeView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      debug: {\n        type: Boolean\n      },\n      edge: {\n        type: Object\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"Edge\";\n    this.debug = false;\n    this.edge = {};\n  }\n\n  render() {\n    return lit_html_html(edge_view_templateObject(), Object.entries(this.edge).map(([key, value], i) => lit_html_html(edge_view_templateObject2(), key, key, key, key, key, key, value, this.change)), !this.debug, this.name, this.debug, JSON.stringify(this.edge, undefined, 2));\n  }\n\n  change(e) {\n    let key = e.target.getAttribute(\"key\");\n    let value = e.target.value.trim(); //  console.log(\"change\",key, value)\n\n    this.edge[key] = value;\n    console.log(this.edge);\n    this.agent.send(\"Vis\", {\n      action: \"edgeUpdate\",\n      edge: this.edge\n    });\n  }\n  /*  input(e){\r\n  \x3c!--  @input=\"${this.input}\"--\x3e\r\n  let key = e.target.getAttribute(\"key\")\r\n  let value = e.target.value.trim()\r\n  console.log(\"input\",key, value)\r\n  console.log(this.node)\r\n  }*/\n\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"configChanged\":\n            app.configChanged(message.config);\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n  configChanged(config) {\n    this.config = config;\n    console.log(this.config);\n  }\n\n}\n\ncustomElements.define('edge-view', edge_view_EdgeView);\n// CONCATENATED MODULE: ./src/views/selected-view.js\nfunction selected_view_templateObject3() {\n  const data = selected_view_taggedTemplateLiteral([\"\\n      <edge-view name=\\\"\", \"\\\" .edge=\\\"\", \"\\\"></edge-view>\\n      \"]);\n\n  selected_view_templateObject3 = function _templateObject3() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction selected_view_templateObject2() {\n  const data = selected_view_taggedTemplateLiteral([\"\\n      <node-view name=\\\"\", \"\\\" .node=\\\"\", \"\\\"></node-view>\\n      \"]);\n\n  selected_view_templateObject2 = function _templateObject2() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction selected_view_templateObject() {\n  const data = selected_view_taggedTemplateLiteral([\"\\n    <link href=\\\"css/bootstrap/bootstrap.min.css\\\" rel=\\\"stylesheet\\\">\\n\\n    <div ?hidden=\\\"\", \"\\\">\\n    <hr>\\n    <b>\", \" nodes.</b>\\n    <hr>\\n    \", \"\\n    </div>\\n\\n    <div ?hidden=\\\"\", \"\\\">\\n    <hr>\\n    <b>\", \" edges.</b>\\n    <hr>\\n    \", \"\\n    </div>\\n\\n    \"]);\n\n  selected_view_templateObject = function _templateObject() {\n    return data;\n  };\n\n  return data;\n}\n\nfunction selected_view_taggedTemplateLiteral(strings, raw) { if (!raw) { raw = strings.slice(0); } return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }\n\n\n\n\nclass selected_view_SelectedView extends lit_element_LitElement {\n  static get properties() {\n    return {\n      name: {\n        type: String\n      },\n      selected_nodes: {\n        type: Array\n      },\n      selected_edges: {\n        type: Array\n      }\n    };\n  }\n\n  constructor() {\n    super();\n    this.name = \"Selected\";\n    this.selected_nodes = [];\n    this.selected_edges = [];\n  }\n\n  render() {\n    return lit_html_html(selected_view_templateObject(), this.selected_nodes.length == 0, this.selected_nodes.length, this.selected_nodes.map((n, i) => lit_html_html(selected_view_templateObject2(), 'Node_' + i, n)), this.selected_edges.length == 0, this.selected_edges.length, this.selected_edges.map((e, i) => lit_html_html(selected_view_templateObject3(), 'Edge_' + i, e)));\n  }\n\n  firstUpdated() {\n    var app = this;\n    this.agent = new HelloAgent(this.name);\n    console.log(this.agent);\n\n    this.agent.receive = function (from, message) {\n      //  console.log(\"messah\",message)\n      if (message.hasOwnProperty(\"action\")) {\n        //  console.log(message)\n        switch (message.action) {\n          case \"selectedChanged\":\n            app.selected_nodes = message.nodes;\n            app.selected_edges = message.edges;\n            break;\n\n          default:\n            console.log(\"Unknown action \", message);\n        }\n      }\n    };\n  }\n\n}\n\ncustomElements.define('selected-view', selected_view_SelectedView);\n// CONCATENATED MODULE: ./src/index.js\n//GENERAL\n\n //APP\n\n\n //VIS\n\n\n\n\n\n\n //import './views/vis-tool-view.js';//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL2RvbS5qcz9iNDUzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUuanM/ZTMyYiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGliL21vZGlmeS10ZW1wbGF0ZS5qcz83NjZiIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvZGlyZWN0aXZlLmpzPzc4MWMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9wYXJ0LmpzP2Q1NTIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi90ZW1wbGF0ZS1pbnN0YW5jZS5qcz9lYWU5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtcmVzdWx0LmpzPzE4YzAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9wYXJ0cy5qcz81YzhlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvdGVtcGxhdGUtZmFjdG9yeS5qcz8zZWE5Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvcmVuZGVyLmpzP2MyNjgiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpYi9kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcz9kMDU4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saXQtaHRtbC5qcz8wMWExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saWIvc2hhZHktcmVuZGVyLmpzP2E5YzkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi91cGRhdGluZy1lbGVtZW50LmpzP2IyMmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9kZWNvcmF0b3JzLmpzP2Q0OTkiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpYi9jc3MtdGFnLmpzPzZiYmIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1lbGVtZW50L2xpdC1lbGVtZW50LmpzPzA5MDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FnZW50cy9oZWxsby1hZ2VudC5qcz9kM2MzIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9hcHAtdmlldy5qcz8zZTVmIiwid2VicGFjazovLy8uL3NyYy92aWV3cy9sb2dpbi1lbGVtZW50LmpzPzBlOTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL3Zpcy12aWV3LmpzPzUwOTAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL24zL3NyYy9OM0RhdGFGYWN0b3J5LmpzPzk3OTMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL24zL3NyYy9OM1dyaXRlci5qcz85ZWRhIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9uMy9zcmMvTjNQYXJzZXIuanM/NGU4YiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbjMvc3JjL04zU3RvcmUuanM/MDAyYSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHJpcGxlZG9jL2Rpc3QvaW5kZXguZXMuanM/NGQ4ZCIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3MvYnJvd3Nlci12aWV3LmpzPzU0MDciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2lucHV0LXZpZXcuanM/MDkzOSIsIndlYnBhY2s6Ly8vLi9zcmMvdmlld3Mvbm9kZS12aWV3LmpzPzk1ODciLCJ3ZWJwYWNrOi8vLy4vc3JjL3ZpZXdzL2VkZ2Utdmlldy5qcz8xYjI4Iiwid2VicGFjazovLy8uL3NyYy92aWV3cy9zZWxlY3RlZC12aWV3LmpzPzY5YTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LmpzP2I2MzUiXSwibmFtZXMiOlsiSGVsbG9BZ2VudCIsImlkIiwiZXZlIiwiQWdlbnQiLCJjYWxsIiwiY29ubmVjdCIsInN5c3RlbSIsInRyYW5zcG9ydHMiLCJnZXRBbGwiLCJwcm90b3R5cGUiLCJPYmplY3QiLCJjcmVhdGUiLCJjb25zdHJ1Y3RvciIsInNheUhlbGxvIiwidG8iLCJzZW5kIiwicmVjZWl2ZSIsImZyb20iLCJtZXNzYWdlIiwiY29uc29sZSIsImxvZyIsIkpTT04iLCJzdHJpbmdpZnkiLCJpbmRleE9mIiwiYnJvYWRjYXN0IiwibWUiLCJhbGxBZ2VudHMiLCJrZXlzIiwiY29ubmVjdGlvbnMiLCJ0cmFuc3BvcnQiLCJhZ2VudHMiLCJmb3JFYWNoIiwiYWdlbnQiLCJzZW5kTXVsdGkiLCJyZWNpcGllbnRzIiwiQXBwVmlldyIsIkxpdEVsZW1lbnQiLCJwcm9wZXJ0aWVzIiwibmFtZSIsInR5cGUiLCJTdHJpbmciLCJsZXZlbHMiLCJBcnJheSIsImxldmVsIiwicmVuZGVyIiwiaHRtbCIsIm1hcCIsImwiLCJsZXZlbENoYW5nZWQiLCJlIiwidGFyZ2V0IiwiZ2V0QXR0cmlidXRlIiwiZmlyc3RVcGRhdGVkIiwiYXBwIiwiaGFzT3duUHJvcGVydHkiLCJhY3Rpb24iLCJjb25maWdDaGFuZ2VkIiwiY29uZmlnIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJMb2dpbkVsZW1lbnQiLCJ3ZWJJZCIsImRlc3RpbmF0YWlyZXMiLCJsb2dpbiIsImxvZ291dCIsIndlYklkQ2hhbmdlZCIsInNvbGlkIiwiYXV0aCIsInRyYWNrU2Vzc2lvbiIsInNlc3Npb24iLCJwb3B1cExvZ2luIiwid2kiLCJ0aGVuIiwiYWxlcnQiLCJjdXJyZW50U2Vzc2lvbiIsInBvcHVwVXJpIiwiVmlzVmlldyIsImdyb3VwcyIsInZpc0hpZGUiLCJCb29sZWFuIiwiZmFjZSIsIm9yZ2FuaXphdGlvbnMiLCJsYWJlbCIsInNoYXBlIiwiaWNvbiIsIndlaWdodCIsImNvZGUiLCJzaXplIiwiY29sb3IiLCJ1c2VyZ3JvdXBzIiwidXNlcnMiLCJyb2xlcyIsInRlbnNpb25zIiwid2hhdGlzIiwid2hhdHNiIiwibm9kZXMiLCJ2aXMiLCJEYXRhU2V0IiwiZ3JvdXAiLCJlZGdlcyIsInRpdGxlIiwiZGF0YSIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsImNsZWFyIiwidG9nZ2xlSGlkZSIsIm5vZGVVcGRhdGUiLCJub2RlIiwiZWRnZVVwZGF0ZSIsImVkZ2UiLCJ0cmlwbGVzQ2hhbmdlZCIsInRyaXBsZXMiLCJhZGRUcmlwbGUiLCJ0cmlwbGUiLCJjdXJyZW50RmlsZSIsImluaXQiLCJ0Iiwibl9zdWIiLCJzdWJqZWN0IiwibG9jYWxOYW1lIiwiYWRkTm9kZUlmTm90RXhpc3QiLCJuX29iaiIsIm9iamVjdCIsInByZWRpY2F0ZSIsImFkZEVkZ2VJZk5vdEV4aXN0IiwiY29uZmlybSIsImxlbmd0aCIsImkiLCJzdHJQcm9taXNlIiwic3RyIiwibG4iLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsIm5ldHdvcmsiLCJib2R5IiwidXBkYXRlIiwiaXRlbXMiLCJnZXQiLCJmaWx0ZXIiLCJpdGVtIiwiYWRkIiwiZXhpc3ROb2RlIiwibm9kZUlkIiwibiIsIngiLCJ5IiwiZXJyIiwiY29udGFpbmVyIiwic2hhZG93Um9vdCIsImdldEVsZW1lbnRCeUlkIiwiY2VudHJhbEdyYXZpdHlWYWx1ZURlZmF1bHQiLCJzcHJpbmdMZW5ndGhWYWx1ZURlZmF1bHQiLCJzcHJpbmdDb25zdGFudFZhbHVlRGVmYXVsdCIsIm5vZGVEaXN0YW5jZVZhbHVlRGVmYXVsdCIsImRhbXBpbmdWYWx1ZURlZmF1bHQiLCJvcHRpb25zIiwibG9jYWxlIiwibmF2aWdhdG9yIiwibGFuZ3VhZ2UiLCJzbGljZSIsImludGVyYWN0aW9uIiwibmF2aWdhdGlvbkJ1dHRvbnMiLCJtdWx0aXNlbGVjdCIsImFycm93cyIsImVuYWJsZWQiLCJzY2FsZUZhY3RvciIsImZvbnQiLCJ3aWR0aCIsInNoYWRvdyIsImluaGVyaXQiLCJib3JkZXJXaWR0aCIsImhpZ2hsaWdodCIsImJvcmRlciIsImJhY2tncm91bmQiLCJwaHlzaWNzIiwiYmFybmVzSHV0IiwiZ3Jhdml0YXRpb25hbENvbnN0YW50IiwiY2VudHJhbEdyYXZpdHkiLCJzcHJpbmdMZW5ndGgiLCJzcHJpbmdDb25zdGFudCIsImRhbXBpbmciLCJhdm9pZE92ZXJsYXAiLCJmb3JjZUF0bGFzMkJhc2VkIiwicmVwdWxzaW9uIiwibm9kZURpc3RhbmNlIiwiaGllcmFyY2hpY2FsUmVwdWxzaW9uIiwic29sdmVyIiwibWFuaXB1bGF0aW9uIiwiYWRkTm9kZSIsImNhbGxiYWNrIiwiaW5uZXJIVE1MIiwiZWRpdE5vZGUiLCJjbGVhck5vZGVQb3BVcCIsImNhbmNlbE5vZGVFZGl0IiwiYWRkRWRnZSIsInIiLCJlZGl0RWRnZVdpdGhvdXREcmFnIiwiZWRpdEVkZ2UiLCJOZXR3b3JrIiwib24iLCJwYXJhbXMiLCJzaG93Iiwic2VuZFNlbGVjdGVkIiwiY2FuY2VsQWN0aW9uIiwib25jbGljayIsInNhdmVOb2RlRGF0YSIsImJpbmQiLCJvbmtleWRvd24iLCJrZXlkb3duTm9kZSIsInN0eWxlIiwiZGlzcGxheSIsInNhdmVFZGdlRGF0YSIsImNhbmNlbEVkZ2VFZGl0Iiwia2V5ZG93bkVkZ2UiLCJjbGVhckVkZ2VQb3BVcCIsIndoaWNoIiwicHJldmVudERlZmF1bHQiLCJCcm93c2VyVmlldyIsInN0b3JhZ2UiLCJwYXRoIiwibGFzdCIsImZvbGRlciIsImZvbGRlck5hbWUiLCJmaWxlTmFtZSIsImNyZWF0ZUhpZGRlbiIsImZvbGRlcnMiLCJmaWxlcyIsImZjIiwiU29saWRGaWxlQ2xpZW50IiwidXAiLCJwcmVjIiwibmV3IiwiY2xvc2VDcmVhdGVJbnB1dCIsImYiLCJ1cmwiLCJjaGFuZ2VQYXRoIiwiZGVsZXRlRmlsZSIsImRlbGV0ZSIsImlucHV0X3R5cGUiLCJzZXRBdHRyaWJ1dGUiLCJEYXRlIiwidG9JU09TdHJpbmciLCJyZXBsYWNlIiwidHJpbSIsImNyZWF0ZV9wYXRoIiwiZW5kc1dpdGgiLCJkZWZhdWx0Q29udGVudCIsImNyZWF0ZUZpbGUiLCJjYXRjaCIsImVycm9yIiwiY3JlYXRlRm9sZGVyIiwidXBkYXRlRm9sZGVyIiwiZGVsIiwiZ2V0RmlsZSIsImRvYyIsImZldGNoRG9jdW1lbnQiLCJnZXRUcmlwbGVzIiwic3RhdGVtZW50czJ2aXMiLCJzdGF0ZW1lbnRzIiwic3RhdGVtZW50IiwicyIsInAiLCJvIiwidyIsIndoeSIsIm5vZGVBbmRMYWJlbCIsIk1hdGgiLCJyYW5kb20iLCJwdXNoIiwibm9kZVN1amV0VGVtcCIsImRldGFpbE5vZXVkIiwibm9kZU9iamV0VGVtcCIsImxvY2FsbmFtZSIsInVyaSIsInRlcm1UeXBlIiwiZWxlbWVudHMiLCJlbGVtIiwiaW1hZ2UiLCJ1bmRlZmluZWQiLCJsYWJlbFUiLCJ1TGFiZWwiLCJzcGxpdCIsIml0ZW1FeGlzdHMiLCJuZXdmaWxlbmFtZSIsInJlYWRGb2xkZXIiLCJuYW1lZE5vZGUiLCJwYXJlbnQiLCJJbnB1dFZpZXciLCJkZWJ1ZyIsInRyaXBsZXNMaXN0Iiwia2V5ZG93biIsImFkZF90cmlwbGUiLCJuZXdfdHJpcGxlIiwicmVzIiwiY2F0Y2hDb21tYW5kIiwic3RhcnRzV2l0aCIsImNvbW1hbmQiLCJ1cGRhdGVJbnB1dCIsInJlc3VsdCIsImlucHV0TmV3IiwibGFzdENoYXIiLCJtZXNzYWdlQ3V0IiwiaXNUcmlwbGV0IiwiZGV0ZWN0TGl0ZXJhbCIsIm1lc3NhZ2VDdXRUZW1wIiwicGFydCIsInN1YnN0ciIsInBvcCIsInRyaXBsZXR2YWx1ZSIsIk5vZGVWaWV3IiwiY2hhbmdlIiwiRWRnZVZpZXciLCJTZWxlY3RlZFZpZXciLCJzZWxlY3RlZF9ub2RlcyIsInNlbGVjdGVkX2VkZ2VzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QVEsV0FBVztBQUNuQjtBQUNBLFFBQVEsWUFBSztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDOztBQzlSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksa0JBQUU7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEMsd0JBQXdCLElBQUk7QUFDNUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFFO0FBQ2xCLDRDOztBQzdwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxhQUFhO0FBQzFEO0FBQ0EsYUFBYSxFQUFFO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLHFCQUFxQixxR0FBcUc7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLHlDQUF5QyxhQUFhO0FBQ3REO0FBQ0EsU0FBUyxFQUFFO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixjQUFjO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsY0FBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0JBQW9CLFNBQVMsUUFBUTtBQUM3RTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdELGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0M7O0FDclZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLE1BQU07QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxtQzs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0Q7QUFDTTtBQUNsQjtBQUNOO0FBQ2dEO0FBQ3JCO0FBQzlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sTUFBTSxzQkFBVSxTQUFTLGVBQWU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBLGtDQUFrQyxlQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsZ0RBQWdEO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFVLFVBQVUsbUJBQU07QUFDMUIsdUM7Ozs7Ozs7QUN2TUE7QUFFQSxTQUFTQSxVQUFULENBQW9CQyxFQUFwQixFQUF1QjtBQUNyQjtBQUNBQyxLQUFHLENBQUNDLEtBQUosQ0FBVUMsSUFBVixDQUFlLElBQWYsRUFBcUJILEVBQXJCLEVBRnFCLENBR3JCOztBQUNBLE9BQUtJLE9BQUwsQ0FBYUgsR0FBRyxDQUFDSSxNQUFKLENBQVdDLFVBQVgsQ0FBc0JDLE1BQXRCLEVBQWI7QUFDRCxDLENBRUQ7OztBQUNBUixVQUFVLENBQUNTLFNBQVgsR0FBdUJDLE1BQU0sQ0FBQ0MsTUFBUCxDQUFjVCxHQUFHLENBQUNDLEtBQUosQ0FBVU0sU0FBeEIsQ0FBdkI7QUFDQVQsVUFBVSxDQUFDUyxTQUFYLENBQXFCRyxXQUFyQixHQUFtQ1osVUFBbkM7O0FBQ0FBLFVBQVUsQ0FBQ1MsU0FBWCxDQUFxQkksUUFBckIsR0FBZ0MsVUFBU0MsRUFBVCxFQUFhO0FBQzNDLE9BQUtDLElBQUwsQ0FBVUQsRUFBVixFQUFjLFdBQVdBLEVBQVgsR0FBZ0IsR0FBOUI7QUFDRCxDQUZEOztBQUlBZCxVQUFVLENBQUNTLFNBQVgsQ0FBcUJPLE9BQXJCLEdBQStCLFVBQVNDLElBQVQsRUFBZUMsT0FBZixFQUF3QjtBQUNyRDtBQUNBQyxTQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFLbkIsRUFBTCxHQUFRLGtCQUFSLEdBQTJCZ0IsSUFBM0IsR0FBa0MsaUJBQWxDLEdBQXNESSxJQUFJLENBQUNDLFNBQUwsQ0FBZUosT0FBZixDQUFsRTs7QUFDQSxNQUFJRyxJQUFJLENBQUNDLFNBQUwsQ0FBZUosT0FBZixFQUF3QkssT0FBeEIsQ0FBZ0MsT0FBaEMsTUFBNkMsQ0FBakQsRUFBb0Q7QUFDbEQ7QUFDQSxTQUFLUixJQUFMLENBQVVFLElBQVYsRUFBZ0IsUUFBUUEsSUFBUixHQUFlLHFCQUEvQjtBQUNEO0FBQ0YsQ0FQRDs7QUFVQWpCLFVBQVUsQ0FBQ1MsU0FBWCxDQUFxQmUsU0FBckIsR0FBaUMsVUFBU04sT0FBVCxFQUFpQjtBQUNoRCxNQUFJTyxFQUFFLEdBQUcsSUFBVDtBQUNBLE1BQUlDLFNBQVMsR0FBR2hCLE1BQU0sQ0FBQ2lCLElBQVAsQ0FBWSxLQUFLQyxXQUFMLENBQWlCLENBQWpCLEVBQW9CQyxTQUFwQixDQUE4QkMsTUFBMUMsQ0FBaEI7QUFDRFgsU0FBTyxDQUFDQyxHQUFSLENBQVlNLFNBQVo7QUFDQ0EsV0FBUyxDQUFDSyxPQUFWLENBQWtCLFVBQVVDLEtBQVYsRUFBZ0I7QUFDaENQLE1BQUUsQ0FBQ1YsSUFBSCxDQUFRaUIsS0FBUixFQUFlZCxPQUFmO0FBQ0QsR0FGRDtBQUdELENBUEQ7O0FBU0FsQixVQUFVLENBQUNTLFNBQVgsQ0FBcUJ3QixTQUFyQixHQUFpQyxVQUFTQyxVQUFULEVBQXFCaEIsT0FBckIsRUFBNkI7QUFDNUQsTUFBSU8sRUFBRSxHQUFHLElBQVQ7QUFDQVMsWUFBVSxDQUFDSCxPQUFYLENBQW1CLFVBQVVDLEtBQVYsRUFBZ0I7QUFDbkM7QUFDRVAsTUFBRSxDQUFDVixJQUFILENBQVFpQixLQUFSLEVBQWVkLE9BQWY7QUFDRCxHQUhEO0FBSUQsQ0FORDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuQ0E7QUFDQTs7QUFFQSxNQUFNaUIsZ0JBQU4sU0FBc0JDLHNCQUF0QixDQUFpQztBQUUvQixhQUFXQyxVQUFYLEdBQXdCO0FBQ3RCLFdBQU87QUFDTEMsVUFBSSxFQUFFO0FBQUNDLFlBQUksRUFBRUM7QUFBUCxPQUREO0FBRUxDLFlBQU0sRUFBRTtBQUFDRixZQUFJLEVBQUVHO0FBQVAsT0FGSDtBQUdMQyxXQUFLLEVBQUU7QUFBQ0osWUFBSSxFQUFFQztBQUFQO0FBSEYsS0FBUDtBQUtEOztBQUVENUIsYUFBVyxHQUFHO0FBQ1o7QUFDQSxTQUFLMEIsSUFBTCxHQUFZLEtBQVo7QUFDQSxTQUFLRyxNQUFMLEdBQWMsQ0FBRSxTQUFGLEVBQWEsUUFBYixFQUF1QixNQUF2QixDQUFkLENBSFksQ0FHaUM7O0FBQzdDLFNBQUtFLEtBQUwsR0FBYSxLQUFLRixNQUFMLENBQVksQ0FBWixDQUFiO0FBQ0Q7O0FBRURHLFFBQU0sR0FBRTtBQUNOLFdBQU9DLGFBQVAsb0JBVUUsS0FBS0osTUFBTCxDQUFZSyxHQUFaLENBQWdCQyxDQUFDLElBQ2pCRixhQURpQixxQkFFd0IsS0FBS0YsS0FBTCxJQUFjSSxDQUFkLEdBQWtCLFFBQWxCLEdBQTRCLEVBRnBELEVBRWtFQSxDQUZsRSxFQUVnRixLQUFLQyxZQUZyRixFQUVzR0QsQ0FGdEcsQ0FBakIsQ0FWRixFQXNCSSxLQUFLSixLQXRCVCxFQXdCMEMsS0FBS0EsS0FBTCxJQUFjLFNBeEJ4RCxFQTBCc0MsS0FBS0EsS0FBTCxJQUFjLFFBMUJwRCxFQTJCNEMsS0FBS0EsS0FBTCxJQUFjLE1BM0IxRDtBQWdDQzs7QUFFREssY0FBWSxDQUFDQyxDQUFELEVBQUc7QUFDYixTQUFLTixLQUFMLEdBQWFNLENBQUMsQ0FBQ0MsTUFBRixDQUFTQyxZQUFULENBQXNCLE9BQXRCLENBQWI7QUFDRDtBQUNEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBb0JKQyxjQUFZLEdBQUU7QUFDWixRQUFJQyxHQUFHLEdBQUcsSUFBVjtBQUNBLFNBQUtyQixLQUFMLEdBQWEsSUFBSWhDLFVBQUosQ0FBZSxLQUFLc0MsSUFBcEIsQ0FBYjtBQUNBbkIsV0FBTyxDQUFDQyxHQUFSLENBQVksS0FBS1ksS0FBakI7O0FBQ0EsU0FBS0EsS0FBTCxDQUFXaEIsT0FBWCxHQUFxQixVQUFTQyxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDM0M7QUFDQSxVQUFJQSxPQUFPLENBQUNvQyxjQUFSLENBQXVCLFFBQXZCLENBQUosRUFBcUM7QUFDbkM7QUFDQSxnQkFBT3BDLE9BQU8sQ0FBQ3FDLE1BQWY7QUFDRSxlQUFLLGNBQUw7QUFDQUYsZUFBRyxDQUFDVixLQUFKLEdBQVl6QixPQUFPLENBQUN5QixLQUFwQjtBQUNBOztBQUNBO0FBQ0F4QixtQkFBTyxDQUFDQyxHQUFSLENBQVksaUJBQVosRUFBOEJGLE9BQTlCO0FBTEY7QUFPRDtBQUNGLEtBWkQ7QUFhRDs7QUFFRHNDLGVBQWEsQ0FBQ0MsTUFBRCxFQUFRO0FBQ25CLFNBQUtBLE1BQUwsR0FBY0EsTUFBZDtBQUNBdEMsV0FBTyxDQUFDQyxHQUFSLENBQVksS0FBS3FDLE1BQWpCO0FBQ0Q7O0FBakdnQzs7QUFxR2pDQyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsVUFBdEIsRUFBa0N4QixnQkFBbEMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hHQTtDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE1BQU15QiwwQkFBTixTQUEyQnhCLHNCQUEzQixDQUFzQztBQUVwQyxhQUFXQyxVQUFYLEdBQXdCO0FBQ3RCLFdBQU87QUFDTEMsVUFBSSxFQUFFO0FBQUNDLFlBQUksRUFBRUM7QUFBUCxPQUREO0FBRUxxQixXQUFLLEVBQUU7QUFBQ3RCLFlBQUksRUFBRUM7QUFBUCxPQUZGO0FBR0xzQixtQkFBYSxFQUFFO0FBQUN2QixZQUFJLEVBQUVDO0FBQVA7QUFIVixLQUFQO0FBS0Q7O0FBRUQ1QixhQUFXLEdBQUc7QUFDWjtBQUNBLFNBQUtpRCxLQUFMLEdBQWEsSUFBYixDQUZZLENBR1o7O0FBQ0EsU0FBS0MsYUFBTCxHQUFxQixDQUFDLFNBQUQsRUFBWSxPQUFaLENBQXJCO0FBRUQ7O0FBRURsQixRQUFNLEdBQUU7QUFDTixXQUFPQyxhQUFQLGlDQUlFLEtBQUtnQixLQUFMLElBQWMsSUFBZCxHQUNBaEIsYUFEQSxrQ0FFdUQsS0FBS2tCLEtBRjVELElBSUVsQixhQUpGLHFCQUtxRSxLQUFLbUIsTUFMMUUsQ0FKRjtBQWFEOztBQUVEWixjQUFZLEdBQUU7QUFDWixRQUFJQyxHQUFHLEdBQUcsSUFBVjtBQUNBLFNBQUtyQixLQUFMLEdBQWEsSUFBSWhDLFVBQUosQ0FBZSxLQUFLc0MsSUFBcEIsQ0FBYjtBQUNBbkIsV0FBTyxDQUFDQyxHQUFSLENBQVksS0FBS1ksS0FBakI7O0FBQ0EsU0FBS0EsS0FBTCxDQUFXaEIsT0FBWCxHQUFxQixVQUFTQyxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDM0NDLGFBQU8sQ0FBQ0MsR0FBUixDQUFZLFFBQVosRUFBcUJGLE9BQXJCOztBQUNBLFVBQUlBLE9BQU8sQ0FBQ29DLGNBQVIsQ0FBdUIsUUFBdkIsQ0FBSixFQUFxQztBQUNuQztBQUNBLGdCQUFPcEMsT0FBTyxDQUFDcUMsTUFBZjtBQUNFLGVBQUssY0FBTDtBQUNBRixlQUFHLENBQUNZLFlBQUosQ0FBaUIvQyxPQUFPLENBQUMyQyxLQUF6QjtBQUNBOztBQUNBO0FBQ0ExQyxtQkFBTyxDQUFDQyxHQUFSLENBQVksaUJBQVosRUFBOEJGLE9BQTlCO0FBTEY7QUFPRDtBQUNGLEtBWkQ7O0FBYUFnRCxTQUFLLENBQUNDLElBQU4sQ0FBV0MsWUFBWCxDQUF3QixnQkFBZUMsT0FBZixFQUF3QjtBQUM5QyxVQUFJLENBQUNBLE9BQUwsRUFBYTtBQUNYaEIsV0FBRyxDQUFDUSxLQUFKLEdBQVUsSUFBVjtBQUNBMUMsZUFBTyxDQUFDQyxHQUFSLENBQVksT0FBWixFQUFvQmlDLEdBQUcsQ0FBQ1EsS0FBeEI7QUFDQVIsV0FBRyxDQUFDckIsS0FBSixDQUFVQyxTQUFWLENBQW9Cb0IsR0FBRyxDQUFDUyxhQUF4QixFQUF3QztBQUFDUCxnQkFBTSxFQUFDLGNBQVI7QUFBd0JNLGVBQUssRUFBRVIsR0FBRyxDQUFDUTtBQUFuQyxTQUF4QztBQUNELE9BSkQsTUFLSTtBQUNGUixXQUFHLENBQUNRLEtBQUosR0FBWVEsT0FBTyxDQUFDUixLQUFwQjtBQUNBMUMsZUFBTyxDQUFDQyxHQUFSLENBQVksT0FBWixFQUFvQmlDLEdBQUcsQ0FBQ1EsS0FBeEI7QUFDQVIsV0FBRyxDQUFDckIsS0FBSixDQUFVQyxTQUFWLENBQW9Cb0IsR0FBRyxDQUFDUyxhQUF4QixFQUF1QztBQUFDUCxnQkFBTSxFQUFDLGNBQVI7QUFBd0JNLGVBQUssRUFBRVIsR0FBRyxDQUFDUTtBQUFuQyxTQUF2QztBQUNEO0FBQ0YsS0FYRDs7QUFhQSxTQUFLN0IsS0FBTCxDQUFXaEIsT0FBWCxHQUFxQixVQUFTQyxJQUFULEVBQWVDLE9BQWYsRUFBd0I7QUFDM0MsVUFBSUEsT0FBTyxDQUFDb0MsY0FBUixDQUF1QixRQUF2QixDQUFKLEVBQXFDO0FBQ25DLGdCQUFPcEMsT0FBTyxDQUFDcUMsTUFBZjtBQUNFLGVBQUssUUFBTDtBQUNBRixlQUFHLENBQUNXLE1BQUosQ0FBVyxJQUFYO0FBQ0E7O0FBQ0E7QUFDQTdDLG1CQUFPLENBQUNDLEdBQVIsQ0FBWSxpQkFBWixFQUE4QkYsT0FBOUI7QUFMRjtBQU9EO0FBQ0YsS0FWRDtBQVdEOztBQUVENkMsT0FBSyxHQUFHO0FBQ04sU0FBS08sVUFBTDtBQUNEOztBQUVETixRQUFNLEdBQUc7QUFDUCxRQUFJTyxFQUFFLEdBQUcsS0FBS1YsS0FBZDtBQUNBSyxTQUFLLENBQUNDLElBQU4sQ0FBV0gsTUFBWCxHQUFvQlEsSUFBcEIsQ0FBeUIsTUFBTUMsS0FBSyxDQUFDLGFBQVdGLEVBQVgsR0FBYyxJQUFmLENBQXBDO0FBQ0Q7O0FBRUQsUUFBTUQsVUFBTixHQUFtQjtBQUNqQixRQUFJRCxPQUFPLEdBQUcsTUFBTUgsS0FBSyxDQUFDQyxJQUFOLENBQVdPLGNBQVgsRUFBcEI7QUFDQSxRQUFJQyxRQUFRLEdBQUcseUJBQWYsQ0FGaUIsQ0FHakI7O0FBQ0EsUUFBSSxDQUFDTixPQUFMLEVBQ0FBLE9BQU8sR0FBRyxNQUFNSCxLQUFLLENBQUNDLElBQU4sQ0FBV0csVUFBWCxDQUFzQjtBQUFFSztBQUFGLEtBQXRCLENBQWhCO0FBQ0Q7O0FBNUZtQzs7QUErRnRDakIsY0FBYyxDQUFDQyxNQUFmLENBQXNCLGVBQXRCLEVBQXVDQywwQkFBdkMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RHQTtDQUVBOztBQUVBLE1BQU1nQixnQkFBTixTQUFzQnhDLHNCQUF0QixDQUFpQztBQUUvQixhQUFXQyxVQUFYLEdBQXdCO0FBQ3RCLFdBQU87QUFDTEMsVUFBSSxFQUFFO0FBQUNDLFlBQUksRUFBRUM7QUFBUCxPQUREO0FBRUxxQyxZQUFNLEVBQUU7QUFBQ3RDLFlBQUksRUFBRzdCO0FBQVIsT0FGSDtBQUdMb0UsYUFBTyxFQUFFO0FBQUN2QyxZQUFJLEVBQUV3QztBQUFQO0FBSEosS0FBUDtBQUtEOztBQUVEbkUsYUFBVyxHQUFHO0FBQ1o7QUFDQSxRQUFJb0UsSUFBSSxHQUFHLHVCQUFYO0FBQ0EsU0FBSzFDLElBQUwsR0FBWSxLQUFaO0FBQ0EsU0FBS3dDLE9BQUwsR0FBZSxLQUFmO0FBQ0EsU0FBS0QsTUFBTCxHQUFjO0FBQ1pJLG1CQUFhLEVBQUU7QUFDYkMsYUFBSyxFQUFFLE1BRE07QUFFYkMsYUFBSyxFQUFFLE1BRk07QUFHYkMsWUFBSSxFQUFFO0FBQ0pKLGNBQUksRUFBRUEsSUFERjtBQUVKSyxnQkFBTSxFQUFFLE1BRko7QUFFWTtBQUNoQkMsY0FBSSxFQUFFLFFBSEY7QUFJSkMsY0FBSSxFQUFFLEVBSkY7QUFLSkMsZUFBSyxFQUFFO0FBTEg7QUFITyxPQURIO0FBWVpDLGdCQUFVLEVBQUU7QUFDVlAsYUFBSyxFQUFFLFlBREc7QUFFVkMsYUFBSyxFQUFFLE1BRkc7QUFHVkMsWUFBSSxFQUFFO0FBQ0pKLGNBQUksRUFBRUEsSUFERjtBQUVKSyxnQkFBTSxFQUFFLE1BRko7QUFFWTtBQUNoQkMsY0FBSSxFQUFFLFFBSEY7QUFJSkMsY0FBSSxFQUFFLEVBSkY7QUFLSkMsZUFBSyxFQUFFO0FBTEg7QUFISSxPQVpBO0FBdUJaRSxXQUFLLEVBQUU7QUFDTFIsYUFBSyxFQUFFLE1BREY7QUFFTEMsYUFBSyxFQUFFLE1BRkY7QUFHTEMsWUFBSSxFQUFFO0FBQ0pKLGNBQUksRUFBRUEsSUFERjtBQUVKSyxnQkFBTSxFQUFFLE1BRko7QUFFWTtBQUNoQkMsY0FBSSxFQUFFLFFBSEY7QUFJSkMsY0FBSSxFQUFFLEVBSkY7QUFLSkMsZUFBSyxFQUFFO0FBTEg7QUFIRCxPQXZCSztBQWtDWkcsV0FBSyxFQUFFO0FBQ0xULGFBQUssRUFBRSxNQURGO0FBRUxDLGFBQUssRUFBRSxNQUZGO0FBR0xDLFlBQUksRUFBRTtBQUNKSixjQUFJLEVBQUVBLElBREY7QUFFSkssZ0JBQU0sRUFBRSxNQUZKO0FBRVk7QUFDaEJDLGNBQUksRUFBRSxRQUhGO0FBSUpDLGNBQUksRUFBRSxFQUpGO0FBS0pDLGVBQUssRUFBRTtBQUxIO0FBSEQsT0FsQ0s7QUE2Q1pJLGNBQVEsRUFBRTtBQUNSVixhQUFLLEVBQUUsMkVBREM7QUFFUkMsYUFBSyxFQUFFLE1BRkM7QUFHUkMsWUFBSSxFQUFFO0FBQ0pKLGNBQUksRUFBRUEsSUFERjtBQUVKSyxnQkFBTSxFQUFFLE1BRko7QUFFWTtBQUNoQkMsY0FBSSxFQUFFLFFBSEY7QUFJSkMsY0FBSSxFQUFFLEVBSkY7QUFLSkMsZUFBSyxFQUFFO0FBTEg7QUFIRSxPQTdDRTtBQXdEWkssWUFBTSxFQUFFO0FBQ05YLGFBQUssRUFBRSxnQ0FERDtBQUVOQyxhQUFLLEVBQUUsTUFGRDtBQUdOQyxZQUFJLEVBQUU7QUFDSkosY0FBSSxFQUFFQSxJQURGO0FBRUpLLGdCQUFNLEVBQUUsTUFGSjtBQUVZO0FBQ2hCQyxjQUFJLEVBQUUsUUFIRjtBQUlKQyxjQUFJLEVBQUUsRUFKRjtBQUtKQyxlQUFLLEVBQUU7QUFMSDtBQUhBLE9BeERJO0FBbUVaTSxZQUFNLEVBQUU7QUFDTlosYUFBSyxFQUFFLDRDQUREO0FBRU5DLGFBQUssRUFBRSxNQUZEO0FBR05DLFlBQUksRUFBRTtBQUNKSixjQUFJLEVBQUVBLElBREY7QUFFSkssZ0JBQU0sRUFBRSxNQUZKO0FBRVk7QUFDaEJDLGNBQUksRUFBRSxRQUhGO0FBSUpDLGNBQUksRUFBRSxFQUpGO0FBS0pDLGVBQUssRUFBRTtBQUxIO0FBSEE7QUFuRUksS0FBZDtBQStFQSxRQUFJTyxLQUFLLEdBQUcsSUFBSUMsR0FBRyxDQUFDQyxPQUFSLENBQWdCLENBQzFCO0FBQ0VoRyxRQUFFLEVBQUUsQ0FETjtBQUVFaUYsV0FBSyxFQUFFLE1BRlQ7QUFHRWdCLFdBQUssRUFBRTtBQUhULEtBRDBCLEVBS3ZCO0FBQ0RqRyxRQUFFLEVBQUUsQ0FESDtBQUVEaUYsV0FBSyxFQUFFLE1BRk47QUFHRGdCLFdBQUssRUFBRTtBQUhOLEtBTHVCLEVBU3ZCO0FBQ0RqRyxRQUFFLEVBQUUsQ0FESDtBQUVEaUYsV0FBSyxFQUFFLGFBRk47QUFHRGdCLFdBQUssRUFBRTtBQUhOLEtBVHVCLEVBYXZCO0FBQ0RqRyxRQUFFLEVBQUUsQ0FESDtBQUVEaUYsV0FBSyxFQUFFLGFBRk47QUFHRGdCLFdBQUssRUFBRTtBQUhOLEtBYnVCLEVBaUJ2QjtBQUNEakcsUUFBRSxFQUFFLENBREg7QUFFRGlGLFdBQUssRUFBRSxnQkFGTjtBQUdEZ0IsV0FBSyxFQUFFO0FBSE4sS0FqQnVCLEVBc0IxQjtBQUNFakcsUUFBRSxFQUFFLENBRE47QUFFRWlGLFdBQUssRUFBRSxXQUZUO0FBR0VnQixXQUFLLEVBQUU7QUFIVCxLQXRCMEIsRUEyQjFCO0FBQ0VqRyxRQUFFLEVBQUUsQ0FETjtBQUVFaUYsV0FBSyxFQUFFLHlDQUZUO0FBR0VnQixXQUFLLEVBQUU7QUFIVCxLQTNCMEIsRUFnQzFCO0FBQ0VqRyxRQUFFLEVBQUUsQ0FETjtBQUVFaUYsV0FBSyxFQUFFLHdDQUZUO0FBR0VnQixXQUFLLEVBQUUsUUFIVCxDQUdrQjs7QUFIbEIsS0FoQzBCLEVBcUMxQjtBQUNFakcsUUFBRSxFQUFFLENBRE47QUFFRWlGLFdBQUssRUFBRSx1RUFGVDtBQUdFZ0IsV0FBSyxFQUFFLFFBSFQsQ0FHa0I7O0FBSGxCLEtBckMwQixDQUFoQixDQUFaLENBcEZZLENBZ0laOztBQUNBLFFBQUlDLEtBQUssR0FBRyxJQUFJSCxHQUFHLENBQUNDLE9BQVIsQ0FBZ0IsQ0FDMUI7QUFBQ2hGLFVBQUksRUFBRSxDQUFQO0FBQVVILFFBQUUsRUFBRSxDQUFkO0FBQWlCb0UsV0FBSyxFQUFFLFVBQXhCO0FBQW9Da0IsV0FBSyxFQUFFO0FBQTNDLEtBRDBCLEVBRTFCO0FBQUNuRixVQUFJLEVBQUUsQ0FBUDtBQUFVSCxRQUFFLEVBQUUsQ0FBZDtBQUFpQm9FLFdBQUssRUFBRSxRQUF4QjtBQUFrQ2tCLFdBQUssRUFBRTtBQUF6QyxLQUYwQixFQUcxQjtBQUFDbkYsVUFBSSxFQUFFLENBQVA7QUFBVUgsUUFBRSxFQUFFLENBQWQ7QUFBaUJvRSxXQUFLLEVBQUUsVUFBeEI7QUFBb0NrQixXQUFLLEVBQUU7QUFBM0MsS0FIMEIsRUFJMUI7QUFBQ25GLFVBQUksRUFBRSxDQUFQO0FBQVVILFFBQUUsRUFBRSxDQUFkO0FBQWlCb0UsV0FBSyxFQUFFLFVBQXhCO0FBQW9Da0IsV0FBSyxFQUFFO0FBQTNDLEtBSjBCLEVBSzFCO0FBQUNuRixVQUFJLEVBQUUsQ0FBUDtBQUFVSCxRQUFFLEVBQUUsQ0FBZDtBQUFpQm9FLFdBQUssRUFBRSxTQUF4QjtBQUFtQ2tCLFdBQUssRUFBRTtBQUExQyxLQUwwQixFQU0xQjtBQUFDbkYsVUFBSSxFQUFFLENBQVA7QUFBVUgsUUFBRSxFQUFFLENBQWQ7QUFBaUJvRSxXQUFLLEVBQUUsUUFBeEI7QUFBa0NrQixXQUFLLEVBQUU7QUFBekMsS0FOMEIsRUFPMUI7QUFBQ25GLFVBQUksRUFBRSxDQUFQO0FBQVVILFFBQUUsRUFBRSxDQUFkO0FBQWlCb0UsV0FBSyxFQUFFLFVBQXhCO0FBQW9Da0IsV0FBSyxFQUFFO0FBQTNDLEtBUDBCLEVBUTFCO0FBQUNuRixVQUFJLEVBQUUsQ0FBUDtBQUFVSCxRQUFFLEVBQUUsQ0FBZDtBQUFpQm9FLFdBQUssRUFBRSxRQUF4QjtBQUFrQ2tCLFdBQUssRUFBRTtBQUF6QyxLQVIwQixFQVMxQjtBQUFDbkYsVUFBSSxFQUFFLENBQVA7QUFBVUgsUUFBRSxFQUFFLENBQWQ7QUFBaUJvRSxXQUFLLEVBQUUsY0FBeEI7QUFBd0NrQixXQUFLLEVBQUU7QUFBL0MsS0FUMEIsQ0FBaEIsQ0FBWjtBQVdBLFNBQUtDLElBQUwsR0FBWTtBQUNWTixXQUFLLEVBQUVBLEtBREc7QUFFVkksV0FBSyxFQUFFQTtBQUZHLEtBQVo7QUFJRDs7QUFFRHZELFFBQU0sR0FBRTtBQUNOLFdBQU9DLGFBQVAsNEJBNkNFbkMsTUFBTSxDQUFDNEYsT0FBUCxDQUFlLEtBQUt6QixNQUFwQixFQUE0Qi9CLEdBQTVCLENBQWdDLENBQUMsQ0FBQ3lELEdBQUQsRUFBTUMsS0FBTixDQUFELEtBQWtCM0QsYUFBbEIsQ0FBQyw0QkFDeEIyRCxLQUFLLENBQUN0QixLQURpQixDQUFoQyxDQTdDRixFQWtHK0IsS0FBS0osT0FsR3BDLEVBc0c0QyxLQUFLMkIsS0F0R2pELEVBeUdJLEtBQUszQixPQUFMLElBQWdCLElBQWhCLEdBQ0FqQyxhQURBLDZCQUMrQyxLQUFLNkQsVUFEcEQsSUFHQzdELGFBSEQscUJBR2dELEtBQUs2RCxVQUhyRCxDQXpHSjtBQWdIRzs7QUFDREEsWUFBVSxHQUFFO0FBQ1YsU0FBSzVCLE9BQUwsR0FBZSxDQUFDLEtBQUtBLE9BQXJCO0FBQ0Q7O0FBRUQyQixPQUFLLEdBQUU7QUFDTCxTQUFLSixJQUFMLENBQVVOLEtBQVYsQ0FBZ0JVLEtBQWhCO0FBQ0EsU0FBS0osSUFBTCxDQUFVRixLQUFWLENBQWdCTSxLQUFoQjtBQUNEOztBQUVEckQsY0FBWSxHQUFFO0FBQ1osUUFBSUMsR0FBRyxHQUFHLElBQVY7QUFDQSxTQUFLckIsS0FBTCxHQUFhLElBQUloQyxVQUFKLENBQWUsS0FBS3NDLElBQXBCLENBQWI7QUFDQW5CLFdBQU8sQ0FBQ0MsR0FBUixDQUFZLEtBQUtZLEtBQWpCOztBQUNBLFNBQUtBLEtBQUwsQ0FBV2hCLE9BQVgsR0FBcUIsVUFBU0MsSUFBVCxFQUFlQyxPQUFmLEVBQXdCO0FBQzNDO0FBQ0EsVUFBSUEsT0FBTyxDQUFDb0MsY0FBUixDQUF1QixRQUF2QixDQUFKLEVBQXFDO0FBQ25DO0FBQ0EsZ0JBQU9wQyxPQUFPLENBQUNxQyxNQUFmO0FBQ0UsZUFBSyxZQUFMO0FBQ0FGLGVBQUcsQ0FBQ3NELFVBQUosQ0FBZXpGLE9BQU8sQ0FBQzBGLElBQXZCO0FBQ0E7O0FBQ0EsZUFBSyxZQUFMO0FBQ0F2RCxlQUFHLENBQUN3RCxVQUFKLENBQWUzRixPQUFPLENBQUM0RixJQUF2QjtBQUNBOztBQUNBLGVBQUssZ0JBQUw7QUFDQXpELGVBQUcsQ0FBQzBELGNBQUosQ0FBbUI3RixPQUFPLENBQUM4RixPQUEzQjtBQUNBOztBQUNBLGVBQUssV0FBTDtBQUNBM0QsZUFBRyxDQUFDNEQsU0FBSixDQUFjL0YsT0FBTyxDQUFDZ0csTUFBdEI7QUFDQTs7QUFDQSxlQUFLLE9BQUw7QUFDQTdELGVBQUcsQ0FBQ29ELEtBQUo7QUFDQTs7QUFDQSxlQUFLLG9CQUFMO0FBQ0FwRCxlQUFHLENBQUM4RCxXQUFKLEdBQWtCakcsT0FBTyxDQUFDaUcsV0FBMUI7QUFDQTs7QUFDQTtBQUNBaEcsbUJBQU8sQ0FBQ0MsR0FBUixDQUFZLGlCQUFaLEVBQThCRixPQUE5QjtBQXBCRjtBQXNCRDtBQUNGLEtBM0JEOztBQTRCQSxTQUFLa0csSUFBTDtBQUNEOztBQUVESCxXQUFTLENBQUNJLENBQUQsRUFBRztBQUNWO0FBQ0FsRyxXQUFPLENBQUNDLEdBQVIsQ0FBWWlHLENBQVo7QUFDQSxRQUFJQyxLQUFLLEdBQUc7QUFBQ3JILFFBQUUsRUFBRW9ILENBQUMsQ0FBQ0UsT0FBUDtBQUFnQnJDLFdBQUssRUFBRSxLQUFLc0MsU0FBTCxDQUFlSCxDQUFDLENBQUNFLE9BQWpCLENBQXZCO0FBQWtEbkIsV0FBSyxFQUFFaUIsQ0FBQyxDQUFDRTtBQUEzRCxLQUFaO0FBQ0EsU0FBS0UsaUJBQUwsQ0FBdUJILEtBQXZCO0FBQ0EsUUFBSUksS0FBSyxHQUFHO0FBQUN6SCxRQUFFLEVBQUVvSCxDQUFDLENBQUNNLE1BQVA7QUFBZXpDLFdBQUssRUFBRSxLQUFLc0MsU0FBTCxDQUFlSCxDQUFDLENBQUNNLE1BQWpCLENBQXRCO0FBQWdEdkIsV0FBSyxFQUFFaUIsQ0FBQyxDQUFDTTtBQUF6RCxLQUFaO0FBQ0EsU0FBS0YsaUJBQUwsQ0FBdUJDLEtBQXZCO0FBQ0EsUUFBSVosSUFBSSxHQUFHO0FBQUM3RixVQUFJLEVBQUVxRyxLQUFLLENBQUNySCxFQUFiO0FBQWlCYSxRQUFFLEVBQUU0RyxLQUFLLENBQUN6SCxFQUEzQjtBQUErQmlGLFdBQUssRUFBRSxLQUFLc0MsU0FBTCxDQUFlSCxDQUFDLENBQUNPLFNBQWpCLENBQXRDO0FBQW1FeEIsV0FBSyxFQUFFaUIsQ0FBQyxDQUFDTztBQUE1RSxLQUFYLENBUFUsQ0FRVjs7QUFDQSxTQUFLQyxpQkFBTCxDQUF1QmYsSUFBdkI7QUFDRDs7QUFHREMsZ0JBQWMsQ0FBQ0MsT0FBRCxFQUFTO0FBQ3JCO0FBQ0EsUUFBSTNELEdBQUcsR0FBRyxJQUFWO0FBQ0EsUUFBSW9ELEtBQUssR0FBR3FCLE9BQU8sQ0FBQyxvQ0FBRCxDQUFuQjtBQUNBckIsU0FBSyxJQUFLLElBQVYsR0FBaUIsS0FBS0EsS0FBTCxFQUFqQixHQUFnQyxFQUFoQzs7QUFFQSxRQUFJTyxPQUFPLENBQUNlLE1BQVIsSUFBa0IsQ0FBdEIsRUFBd0I7QUFDdEJmLGFBQU8sQ0FBQ2pGLE9BQVIsQ0FBZ0IsQ0FBQ3NGLENBQUQsRUFBSVcsQ0FBSixLQUFVO0FBQ3hCLFlBQUlWLEtBQUssR0FBRztBQUFDckgsWUFBRSxFQUFFb0gsQ0FBQyxDQUFDRSxPQUFGLENBQVV0SCxFQUFmO0FBQW1CaUYsZUFBSyxFQUFFN0IsR0FBRyxDQUFDbUUsU0FBSixDQUFjSCxDQUFDLENBQUNFLE9BQUYsQ0FBVXRILEVBQXhCLENBQTFCO0FBQXVEbUcsZUFBSyxFQUFFaUIsQ0FBQyxDQUFDRSxPQUFGLENBQVV0SDtBQUF4RSxTQUFaO0FBQ0FvRCxXQUFHLENBQUNvRSxpQkFBSixDQUFzQkgsS0FBdEI7QUFDQSxZQUFJSSxLQUFLLEdBQUc7QUFBQ3pILFlBQUUsRUFBRW9ILENBQUMsQ0FBQ00sTUFBRixDQUFTMUgsRUFBZDtBQUFrQmlGLGVBQUssRUFBRTdCLEdBQUcsQ0FBQ21FLFNBQUosQ0FBY0gsQ0FBQyxDQUFDTSxNQUFGLENBQVMxSCxFQUF2QixDQUF6QjtBQUFxRG1HLGVBQUssRUFBRWlCLENBQUMsQ0FBQ00sTUFBRixDQUFTMUg7QUFBckUsU0FBWjtBQUNBb0QsV0FBRyxDQUFDb0UsaUJBQUosQ0FBc0JDLEtBQXRCO0FBQ0EsWUFBSVosSUFBSSxHQUFHO0FBQUM3RixjQUFJLEVBQUVxRyxLQUFLLENBQUNySCxFQUFiO0FBQWlCYSxZQUFFLEVBQUU0RyxLQUFLLENBQUN6SCxFQUEzQjtBQUErQmlGLGVBQUssRUFBRTdCLEdBQUcsQ0FBQ21FLFNBQUosQ0FBY0gsQ0FBQyxDQUFDTyxTQUFGLENBQVkzSCxFQUExQixDQUF0QztBQUFxRW1HLGVBQUssRUFBRWlCLENBQUMsQ0FBQ08sU0FBRixDQUFZM0g7QUFBeEYsU0FBWDtBQUNBOztBQUNBLGFBQUs0SCxpQkFBTCxDQUF1QmYsSUFBdkI7QUFDRCxPQVJEO0FBVUQsS0FYRCxNQVdLO0FBQ0hyQyxXQUFLLENBQUMsd0NBQUQsQ0FBTDtBQUNEO0FBRUY7O0FBR0QrQyxXQUFTLENBQUNTLFVBQUQsRUFBWTtBQUNuQixRQUFJQyxHQUFHLGFBQU1ELFVBQU4sQ0FBUDtBQUNBLFFBQUlFLEVBQUUsR0FBR0QsR0FBRyxDQUFDRSxTQUFKLENBQWNGLEdBQUcsQ0FBQ0csV0FBSixDQUFnQixHQUFoQixJQUFxQixDQUFuQyxDQUFUO0FBQ0FGLE1BQUUsSUFBSUQsR0FBTixHQUFZQyxFQUFFLEdBQUdELEdBQUcsQ0FBQ0UsU0FBSixDQUFjRixHQUFHLENBQUNHLFdBQUosQ0FBZ0IsR0FBaEIsSUFBcUIsQ0FBbkMsQ0FBakIsR0FBeUQsRUFBekQ7QUFDQSxXQUFPRixFQUFQO0FBQ0Q7O0FBRUR4QixZQUFVLENBQUNDLElBQUQsRUFBTTtBQUNkekYsV0FBTyxDQUFDQyxHQUFSLENBQVl3RixJQUFaO0FBQ0EsU0FBSzBCLE9BQUwsQ0FBYUMsSUFBYixDQUFrQmxDLElBQWxCLENBQXVCTixLQUF2QixDQUE2QnlDLE1BQTdCLENBQW9DNUIsSUFBcEM7QUFDRDs7QUFFREMsWUFBVSxDQUFDQyxJQUFELEVBQU07QUFDZDNGLFdBQU8sQ0FBQ0MsR0FBUixDQUFZMEYsSUFBWjtBQUNBLFNBQUt3QixPQUFMLENBQWFDLElBQWIsQ0FBa0JsQyxJQUFsQixDQUF1QkYsS0FBdkIsQ0FBNkJxQyxNQUE3QixDQUFvQzFCLElBQXBDO0FBQ0Q7O0FBRURlLG1CQUFpQixDQUFFZixJQUFGLEVBQU87QUFDdEIsUUFBSTdHLEVBQUUsR0FBRyxFQUFULENBRHNCLENBRXRCOztBQUNBLFFBQUl3SSxLQUFLLEdBQUcsS0FBS0gsT0FBTCxDQUFhQyxJQUFiLENBQWtCbEMsSUFBbEIsQ0FBdUJGLEtBQXZCLENBQTZCdUMsR0FBN0IsQ0FBaUM7QUFDM0NDLFlBQU0sRUFBRSxnQkFBVUMsSUFBVixFQUFnQjtBQUN0QixlQUFPQSxJQUFJLENBQUMzSCxJQUFMLElBQWE2RixJQUFJLENBQUM3RixJQUFsQixJQUEwQjJILElBQUksQ0FBQzlILEVBQUwsSUFBV2dHLElBQUksQ0FBQ2hHLEVBQTFDLElBQWdEOEgsSUFBSSxDQUFDMUQsS0FBTCxJQUFjNEIsSUFBSSxDQUFDNUIsS0FBMUU7QUFDRDtBQUgwQyxLQUFqQyxDQUFaOztBQUtBLFFBQUl1RCxLQUFLLENBQUNWLE1BQU4sR0FBZSxDQUFuQixFQUFxQjtBQUNuQjlILFFBQUUsR0FBR3dJLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU3hJLEVBQWQsQ0FEbUIsQ0FFbkI7O0FBQ0FrQixhQUFPLENBQUNDLEdBQVIsQ0FBWSxZQUFVbkIsRUFBdEI7QUFFRCxLQUxELENBTUE7QUFOQSxTQU9JO0FBQ0ZBLFVBQUUsR0FBRyxLQUFLcUksT0FBTCxDQUFhQyxJQUFiLENBQWtCbEMsSUFBbEIsQ0FBdUJGLEtBQXZCLENBQTZCMEMsR0FBN0IsQ0FBaUMvQixJQUFqQyxDQUFMO0FBQ0EzRixlQUFPLENBQUNDLEdBQVIsQ0FBWSxjQUFZbkIsRUFBeEI7QUFDRDtBQUNGOztBQUdEd0gsbUJBQWlCLENBQUNwQixJQUFELEVBQU07QUFDckIsUUFBSWlDLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtBQUNBLFFBQUlRLFNBQVMsR0FBRyxLQUFoQixDQUZxQixDQUdyQjs7QUFDQSxRQUFJQyxNQUFKOztBQUNBLFFBQUc7QUFDREQsZUFBUyxHQUFHUixPQUFPLENBQUNDLElBQVIsQ0FBYWxDLElBQWIsQ0FBa0JOLEtBQWxCLENBQXdCMkMsR0FBeEIsQ0FBNEI7QUFDdENDLGNBQU0sRUFBRSxnQkFBU0ssQ0FBVCxFQUFXO0FBQ2pCLGlCQUFRQSxDQUFDLENBQUMvSSxFQUFGLElBQVFvRyxJQUFJLENBQUNwRyxFQUFiLElBQW9CK0ksQ0FBQyxDQUFDOUQsS0FBRixJQUFXbUIsSUFBSSxDQUFDbkIsS0FBNUMsQ0FEaUIsQ0FDb0M7QUFDdEQ7QUFIcUMsT0FBNUIsQ0FBWixDQURDLENBTUQ7O0FBQ0EsVUFBSTRELFNBQVMsQ0FBQ2YsTUFBVixJQUFvQixDQUF4QixFQUEwQjtBQUN4QjtBQUNBZ0IsY0FBTSxHQUFLVCxPQUFPLENBQUNDLElBQVIsQ0FBYWxDLElBQWIsQ0FBa0JOLEtBQWxCLENBQXdCOEMsR0FBeEIsQ0FBNEJ4QyxJQUE1QixFQUFrQyxDQUFsQyxDQUFYO0FBQ0QsT0FIRCxNQUdLO0FBQ0g7QUFDQSxlQUFPQSxJQUFJLENBQUM0QyxDQUFaO0FBQ0EsZUFBTzVDLElBQUksQ0FBQzZDLENBQVo7QUFDQUgsY0FBTSxHQUFJVCxPQUFPLENBQUNDLElBQVIsQ0FBYWxDLElBQWIsQ0FBa0JOLEtBQWxCLENBQXdCeUMsTUFBeEIsQ0FBK0JuQyxJQUEvQixFQUFxQyxDQUFyQyxDQUFWO0FBQ0Q7QUFDRixLQWhCRCxDQWlCQSxPQUFPOEMsR0FBUCxFQUFXO0FBQ1RoSSxhQUFPLENBQUNDLEdBQVIsQ0FBWStILEdBQVo7QUFDRDtBQUNGOztBQUlEL0IsTUFBSSxHQUFFO0FBQ0osUUFBSS9ELEdBQUcsR0FBRyxJQUFWO0FBQ0EsUUFBSTJCLElBQUksR0FBRyx1QkFBWDtBQUNBLFFBQUlvRSxTQUFTLEdBQUcsS0FBS0MsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsV0FBL0IsQ0FBaEI7QUFDQSxRQUFLQywwQkFBMEIsR0FBRyxLQUFsQyxDQUpJLENBSW1DOztBQUN2QyxRQUFJQyx3QkFBd0IsR0FBRyxHQUEvQixDQUxJLENBSzhCOztBQUNoQyxRQUFLQywwQkFBMEIsR0FBRyxJQUFsQyxDQU5FLENBTW9DOztBQUN0QyxRQUFJQyx3QkFBd0IsR0FBRyxHQUEvQixDQVBFLENBT2dDOztBQUNsQyxRQUFJQyxtQkFBbUIsR0FBRyxJQUExQjtBQUVBLFFBQUlDLE9BQU8sR0FBRztBQUNaQyxZQUFNLEVBQUVDLFNBQVMsQ0FBQ0MsUUFBVixDQUFtQkMsS0FBbkIsQ0FBeUIsQ0FBekIsRUFBNEIsQ0FBNUIsS0FBa0MsSUFEOUI7QUFFWkMsaUJBQVcsRUFBRTtBQUNYQyx5QkFBaUIsRUFBRSxJQURSO0FBRVg7QUFDQUMsbUJBQVcsRUFBRTtBQUhGLE9BRkQ7QUFPWmhFLFdBQUssRUFBQztBQUNKaUUsY0FBTSxFQUFFO0FBQ050SixZQUFFLEVBQU07QUFBQ3VKLG1CQUFPLEVBQUUsSUFBVjtBQUFnQkMsdUJBQVcsRUFBQyxDQUE1QjtBQUErQi9ILGdCQUFJLEVBQUM7QUFBcEM7QUFERixTQURKO0FBSUpnSSxZQUFJLEVBQUU7QUFDSmhGLGNBQUksRUFBRTtBQURGLFNBSkY7QUFPSmlGLGFBQUssRUFBRSxDQVBIO0FBUUpDLGNBQU0sRUFBQyxJQVJIO0FBU0pqRixhQUFLLEVBQUM7QUFDSmtGLGlCQUFPLEVBQUMsTUFESixDQUVKO0FBQ0E7O0FBSEk7QUFURixPQVBNO0FBc0JaM0UsV0FBSyxFQUFFO0FBQ0xaLGFBQUssRUFBRSxLQURGO0FBRUxJLFlBQUksRUFBRSxFQUZEO0FBR0xnRixZQUFJLEVBQUU7QUFDSmhGLGNBQUksRUFBRTtBQURGLFNBSEQ7QUFNTG9GLG1CQUFXLEVBQUUsQ0FOUjtBQU9MRixjQUFNLEVBQUMsSUFQRjtBQVFMakYsYUFBSyxFQUFFO0FBQ0xvRixtQkFBUyxFQUFFO0FBQUNDLGtCQUFNLEVBQUUsU0FBVDtBQUFvQkMsc0JBQVUsRUFBQztBQUEvQjtBQUROO0FBUkYsT0F0Qks7QUFrQ1pqRyxZQUFNLEVBQUUsS0FBS0EsTUFsQ0Q7QUFtQ1prRyxhQUFPLEVBQUM7QUFDTlYsZUFBTyxFQUFFLElBREg7QUFFTlcsaUJBQVMsRUFBRTtBQUNUQywrQkFBcUIsRUFBRSxDQUFDLENBRGY7QUFFVEMsd0JBQWMsRUFBRSxHQUZQO0FBR1RDLHNCQUFZLEVBQUUsRUFITDtBQUlUQyx3QkFBYyxFQUFFLElBSlA7QUFLVEMsaUJBQU8sRUFBRSxJQUxBO0FBTVRDLHNCQUFZLEVBQUU7QUFOTCxTQUZMO0FBVU5DLHdCQUFnQixFQUFFO0FBQ2hCTiwrQkFBcUIsRUFBRSxDQUFDLEVBRFI7QUFFaEJDLHdCQUFjLEVBQUUsSUFGQTtBQUdoQkUsd0JBQWMsRUFBRSxJQUhBO0FBSWhCRCxzQkFBWSxFQUFFLEdBSkU7QUFLaEJFLGlCQUFPLEVBQUUsR0FMTztBQU1oQkMsc0JBQVksRUFBRTtBQU5FLFNBVlo7QUFrQk5FLGlCQUFTLEVBQUU7QUFDVE4sd0JBQWMsRUFBRTNCLDBCQURQO0FBQ29DO0FBQzdDNEIsc0JBQVksRUFBRTNCLHdCQUZMO0FBRWlDO0FBQ3hDNEIsd0JBQWMsRUFBRTNCLDBCQUhUO0FBR3FDO0FBQzVDZ0Msc0JBQVksRUFBRy9CLHdCQUpSO0FBSWtDO0FBQ3pDMkIsaUJBQU8sRUFBRTFCLG1CQUxGLENBS3VCOztBQUx2QixTQWxCTDtBQXlCSitCLDZCQUFxQixFQUFFO0FBQ3JCUix3QkFBYyxFQUFFLEdBREs7QUFFckJDLHNCQUFZLEVBQUUsR0FGTztBQUdyQkMsd0JBQWMsRUFBRSxJQUhLO0FBSXJCSyxzQkFBWSxFQUFFLEdBSk87QUFLckJKLGlCQUFPLEVBQUU7QUFMWSxTQXpCbkI7QUFnQ0o7QUFDQTtBQUNBTSxjQUFNLEVBQUU7QUFDUjs7Ozs7OztBQU9GO0FBQ0E7O0FBM0NNLE9BbkNJO0FBZ0ZaQyxrQkFBWSxFQUFFO0FBQ1o7QUFDQUMsZUFBTyxFQUFFLGlCQUFVeEYsSUFBVixFQUFnQnlGLFFBQWhCLEVBQTBCO0FBQ2pDekksYUFBRyxDQUFDZ0csVUFBSixDQUFlQyxjQUFmLENBQThCLGdCQUE5QixFQUFnRHlDLFNBQWhELEdBQTRELFVBQTVEO0FBQ0ExRixjQUFJLENBQUNuQixLQUFMLEdBQWEsRUFBYixDQUZpQyxDQUdqQzs7QUFFQTdCLGFBQUcsQ0FBQzJJLFFBQUosQ0FBYTNGLElBQWIsRUFBbUJoRCxHQUFHLENBQUM0SSxjQUF2QixFQUF1Q0gsUUFBdkM7QUFDRCxTQVJXO0FBU1pFLGdCQUFRLEVBQUUsa0JBQVUzRixJQUFWLEVBQWdCeUYsUUFBaEIsRUFBMEI7QUFDbEN6SSxhQUFHLENBQUNnRyxVQUFKLENBQWVDLGNBQWYsQ0FBOEIsZ0JBQTlCLEVBQWdEeUMsU0FBaEQsR0FBNEQsV0FBNUQ7QUFDQTFJLGFBQUcsQ0FBQzJJLFFBQUosQ0FBYTNGLElBQWIsRUFBbUJoRCxHQUFHLENBQUM2SSxjQUF2QixFQUF1Q0osUUFBdkM7QUFDRCxTQVpXO0FBYVpLLGVBQU8sRUFBRSxpQkFBVTlGLElBQVYsRUFBZ0J5RixRQUFoQixFQUEwQjtBQUNqQyxjQUFJekYsSUFBSSxDQUFDcEYsSUFBTCxJQUFhb0YsSUFBSSxDQUFDdkYsRUFBdEIsRUFBMEI7QUFDeEIsZ0JBQUlzTCxDQUFDLEdBQUd0RSxPQUFPLENBQUMsNENBQUQsQ0FBZjs7QUFDQSxnQkFBSXNFLENBQUMsSUFBSSxJQUFULEVBQWU7QUFDYk4sc0JBQVEsQ0FBQyxJQUFELENBQVI7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0R6SSxhQUFHLENBQUNnRyxVQUFKLENBQWVDLGNBQWYsQ0FBOEIsZ0JBQTlCLEVBQWdEeUMsU0FBaEQsR0FBNEQsVUFBNUQ7QUFDQTFGLGNBQUksQ0FBQ25CLEtBQUwsR0FBYSxFQUFiLENBVGlDLENBVWpDOztBQUNBL0QsaUJBQU8sQ0FBQ0MsR0FBUixDQUFZaUYsSUFBWjtBQUNBaEQsYUFBRyxDQUFDZ0osbUJBQUosQ0FBd0JoRyxJQUF4QixFQUE4QnlGLFFBQTlCO0FBQ0QsU0ExQlc7QUEyQlpRLGdCQUFRLEVBQUUsa0JBQVVqRyxJQUFWLEVBQWdCeUYsUUFBaEIsRUFBMEI7QUFDbEN6SSxhQUFHLENBQUNnRyxVQUFKLENBQWVDLGNBQWYsQ0FBOEIsZ0JBQTlCLEVBQWdEeUMsU0FBaEQsR0FBNEQsV0FBNUQ7QUFDQTFJLGFBQUcsQ0FBQ2dKLG1CQUFKLENBQXdCaEcsSUFBeEIsRUFBOEJ5RixRQUE5QjtBQUNEO0FBOUJXO0FBaEZGLEtBQWQ7QUFrSEEsU0FBS3hELE9BQUwsR0FBZSxJQUFJdEMsR0FBRyxDQUFDdUcsT0FBUixDQUFnQm5ELFNBQWhCLEVBQTJCLEtBQUsvQyxJQUFoQyxFQUFzQ3VELE9BQXRDLENBQWY7QUFFQSxTQUFLdEIsT0FBTCxDQUFha0UsRUFBYixDQUFnQixZQUFoQixFQUE4QixVQUFVQyxNQUFWLEVBQWtCO0FBQzlDQSxZQUFNLENBQUNDLElBQVAsR0FBYyxJQUFkO0FBQ0FySixTQUFHLENBQUNzSixZQUFKLENBQWlCRixNQUFqQjtBQUNELEtBSEQ7QUFLQSxTQUFLbkUsT0FBTCxDQUFha0UsRUFBYixDQUFnQixZQUFoQixFQUE4QixVQUFVQyxNQUFWLEVBQWtCO0FBQzlDQSxZQUFNLENBQUNDLElBQVAsR0FBYyxJQUFkO0FBQ0FySixTQUFHLENBQUNzSixZQUFKLENBQWlCRixNQUFqQjtBQUNELEtBSEQ7QUFJQSxTQUFLbkUsT0FBTCxDQUFha0UsRUFBYixDQUFnQixjQUFoQixFQUFnQyxVQUFVQyxNQUFWLEVBQWtCO0FBQ2hEQSxZQUFNLENBQUNDLElBQVAsR0FBYyxJQUFkO0FBQ0FySixTQUFHLENBQUNzSixZQUFKLENBQWlCRixNQUFqQjtBQUNELEtBSEQ7QUFJQSxTQUFLbkUsT0FBTCxDQUFha0UsRUFBYixDQUFnQixjQUFoQixFQUFnQyxVQUFVQyxNQUFWLEVBQWtCO0FBQ2hEQSxZQUFNLENBQUNDLElBQVAsR0FBYyxLQUFkO0FBQ0FySixTQUFHLENBQUNzSixZQUFKLENBQWlCRixNQUFqQjtBQUNELEtBSEQ7QUFJRCxHQWxqQndCLENBbWpCekI7OztBQUVBRSxjQUFZLENBQUNGLE1BQUQsRUFBUTtBQUNsQixTQUFLekssS0FBTCxDQUFXakIsSUFBWCxDQUFnQixVQUFoQixFQUE0QjtBQUFDd0MsWUFBTSxFQUFHLGlCQUFWO0FBQzVCd0MsV0FBSyxFQUFHLEtBQUt1QyxPQUFMLENBQWFDLElBQWIsQ0FBa0JsQyxJQUFsQixDQUF1Qk4sS0FBdkIsQ0FBNkIyQyxHQUE3QixDQUFpQytELE1BQU0sQ0FBQzFHLEtBQXhDLENBRG9CO0FBRTVCSSxXQUFLLEVBQUUsS0FBS21DLE9BQUwsQ0FBYUMsSUFBYixDQUFrQmxDLElBQWxCLENBQXVCRixLQUF2QixDQUE2QnVDLEdBQTdCLENBQWlDK0QsTUFBTSxDQUFDdEcsS0FBeEM7QUFGcUIsS0FBNUI7QUFHQXNHLFVBQU0sQ0FBQ0MsSUFBUCxJQUFlLElBQWYsR0FBc0IsS0FBSzFLLEtBQUwsQ0FBV2pCLElBQVgsQ0FBZ0IsS0FBaEIsRUFBdUI7QUFBQ3dDLFlBQU0sRUFBQyxjQUFSO0FBQXdCWixXQUFLLEVBQUU7QUFBL0IsS0FBdkIsQ0FBdEIsR0FBdUYsRUFBdkY7QUFDRDs7QUFFRHFKLFVBQVEsQ0FBQzNGLElBQUQsRUFBT3VHLFlBQVAsRUFBcUJkLFFBQXJCLEVBQThCO0FBQ3BDM0ssV0FBTyxDQUFDQyxHQUFSLENBQVlpRixJQUFaO0FBQ0EsU0FBS2dELFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLFlBQS9CLEVBQTZDOUMsS0FBN0MsR0FBcURILElBQUksQ0FBQ25CLEtBQTFEO0FBQ0EsU0FBS21FLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLGlCQUEvQixFQUFrRHVELE9BQWxELEdBQTRELEtBQUtDLFlBQUwsQ0FBa0JDLElBQWxCLENBQXVCLElBQXZCLEVBQTZCMUcsSUFBN0IsRUFBbUN5RixRQUFuQyxDQUE1RDtBQUNBLFNBQUt6QyxVQUFMLENBQWdCQyxjQUFoQixDQUErQixtQkFBL0IsRUFBb0R1RCxPQUFwRCxHQUE4REQsWUFBWSxDQUFDRyxJQUFiLENBQWtCLElBQWxCLEVBQXdCakIsUUFBeEIsQ0FBOUQ7QUFDQSxTQUFLekMsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkN1RCxPQUE3QyxHQUF1REQsWUFBWSxDQUFDRyxJQUFiLENBQWtCLElBQWxCLEVBQXdCakIsUUFBeEIsQ0FBdkQ7QUFFQSxTQUFLekMsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkMwRCxTQUE3QyxHQUF5RCxLQUFLQyxXQUFMLENBQWlCRixJQUFqQixDQUFzQixJQUF0QixFQUE0QjFHLElBQTVCLEVBQWtDeUYsUUFBbEMsQ0FBekQsQ0FQb0MsQ0FRcEM7O0FBQ0EsU0FBS3pDLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLFlBQS9CLEVBQTZDNEQsS0FBN0MsQ0FBbURDLE9BQW5ELEdBQTZELE9BQTdELENBVG9DLENBVXBDO0FBQ0E7QUFDRCxHQXhrQndCLENBMGtCekI7OztBQUNBbEIsZ0JBQWMsR0FBRztBQUNmLFNBQUs1QyxVQUFMLENBQWdCQyxjQUFoQixDQUErQixpQkFBL0IsRUFBa0R1RCxPQUFsRCxHQUE0RCxJQUE1RDtBQUNBLFNBQUt4RCxVQUFMLENBQWdCQyxjQUFoQixDQUErQixtQkFBL0IsRUFBb0R1RCxPQUFwRCxHQUE4RCxJQUE5RDtBQUNBLFNBQUt4RCxVQUFMLENBQWdCQyxjQUFoQixDQUErQixZQUEvQixFQUE2QzRELEtBQTdDLENBQW1EQyxPQUFuRCxHQUE2RCxNQUE3RDtBQUNEOztBQUVEakIsZ0JBQWMsQ0FBQ0osUUFBRCxFQUFXO0FBQ3ZCLFNBQUtHLGNBQUw7QUFDQUgsWUFBUSxDQUFDLElBQUQsQ0FBUjtBQUNEOztBQUVEZ0IsY0FBWSxDQUFDekcsSUFBRCxFQUFPeUYsUUFBUCxFQUFpQjtBQUMzQnpGLFFBQUksQ0FBQ25CLEtBQUwsR0FBYSxLQUFLbUUsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkM5QyxLQUExRDtBQUNBSCxRQUFJLENBQUNwRyxFQUFMLEdBQVUsS0FBS2tILFdBQUwsR0FBaUIsR0FBakIsR0FBcUJkLElBQUksQ0FBQ25CLEtBQXBDO0FBQ0EsU0FBSytHLGNBQUw7QUFDQUgsWUFBUSxDQUFDekYsSUFBRCxDQUFSO0FBQ0Q7O0FBRURnRyxxQkFBbUIsQ0FBQ2hHLElBQUQsRUFBT3lGLFFBQVAsRUFBZ0I7QUFDakMzSyxXQUFPLENBQUNDLEdBQVIsQ0FBWWlGLElBQVo7QUFDQSxTQUFLZ0QsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkM5QyxLQUE3QyxHQUFxREgsSUFBSSxDQUFDbkIsS0FBMUQ7QUFDQSxTQUFLbUUsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsaUJBQS9CLEVBQWtEdUQsT0FBbEQsR0FBNEQsS0FBS08sWUFBTCxDQUFrQkwsSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkIxRyxJQUE3QixFQUFtQ3lGLFFBQW5DLENBQTVEO0FBQ0EsU0FBS3pDLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLG1CQUEvQixFQUFvRHVELE9BQXBELEdBQThELEtBQUtRLGNBQUwsQ0FBb0JOLElBQXBCLENBQXlCLElBQXpCLEVBQThCakIsUUFBOUIsQ0FBOUQ7QUFDQSxTQUFLekMsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkN1RCxPQUE3QyxHQUF1RCxLQUFLUSxjQUFMLENBQW9CTixJQUFwQixDQUF5QixJQUF6QixFQUE4QmpCLFFBQTlCLENBQXZEO0FBQ0EsU0FBS3pDLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLFlBQS9CLEVBQTZDMEQsU0FBN0MsR0FBeUQsS0FBS00sV0FBTCxDQUFpQlAsSUFBakIsQ0FBc0IsSUFBdEIsRUFBNEIxRyxJQUE1QixFQUFrQ3lGLFFBQWxDLENBQXpEO0FBQ0EsU0FBS3pDLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLFlBQS9CLEVBQTZDNEQsS0FBN0MsQ0FBbURDLE9BQW5ELEdBQTZELE9BQTdEO0FBQ0Q7O0FBRURJLGdCQUFjLEdBQUc7QUFDZixTQUFLbEUsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsaUJBQS9CLEVBQWtEdUQsT0FBbEQsR0FBNEQsSUFBNUQ7QUFDQSxTQUFLeEQsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsbUJBQS9CLEVBQW9EdUQsT0FBcEQsR0FBOEQsSUFBOUQ7QUFDQSxTQUFLeEQsVUFBTCxDQUFnQkMsY0FBaEIsQ0FBK0IsWUFBL0IsRUFBNkM0RCxLQUE3QyxDQUFtREMsT0FBbkQsR0FBNkQsTUFBN0Q7QUFDRDs7QUFFREUsZ0JBQWMsQ0FBQ3ZCLFFBQUQsRUFBVztBQUN2QixTQUFLeUIsY0FBTDtBQUNBekIsWUFBUSxDQUFDLElBQUQsQ0FBUjtBQUNEOztBQUVEc0IsY0FBWSxDQUFDL0csSUFBRCxFQUFPeUYsUUFBUCxFQUFpQjtBQUMzQjNLLFdBQU8sQ0FBQ0MsR0FBUixDQUFZaUYsSUFBWjtBQUNBLFFBQUksT0FBT0EsSUFBSSxDQUFDdkYsRUFBWixLQUFtQixRQUF2QixFQUNBdUYsSUFBSSxDQUFDdkYsRUFBTCxHQUFVdUYsSUFBSSxDQUFDdkYsRUFBTCxDQUFRYixFQUFsQjtBQUNBLFFBQUksT0FBT29HLElBQUksQ0FBQ3BGLElBQVosS0FBcUIsUUFBekIsRUFDQW9GLElBQUksQ0FBQ3BGLElBQUwsR0FBWW9GLElBQUksQ0FBQ3BGLElBQUwsQ0FBVWhCLEVBQXRCO0FBQ0FvRyxRQUFJLENBQUNuQixLQUFMLEdBQWEsS0FBS21FLFVBQUwsQ0FBZ0JDLGNBQWhCLENBQStCLFlBQS9CLEVBQTZDOUMsS0FBMUQ7QUFDQSxRQUFJZSxPQUFPLEdBQUksS0FBS2UsT0FBTCxDQUFhQyxJQUFiLENBQWtCbEMsSUFBbEIsQ0FBdUJOLEtBQXZCLENBQTZCMkMsR0FBN0IsQ0FBaUNyQyxJQUFJLENBQUNwRixJQUF0QyxFQUE0Q2lFLEtBQTNEO0FBQ0EsUUFBSXlDLE1BQU0sR0FBRyxLQUFLVyxPQUFMLENBQWFDLElBQWIsQ0FBa0JsQyxJQUFsQixDQUF1Qk4sS0FBdkIsQ0FBNkIyQyxHQUE3QixDQUFpQ3JDLElBQUksQ0FBQ3ZGLEVBQXRDLEVBQTBDb0UsS0FBdkQ7QUFDQSxRQUFJZ0MsTUFBTSxHQUFHO0FBQUNLLGFBQU8sRUFBRUEsT0FBVjtBQUFvQkssZUFBUyxFQUFFdkIsSUFBSSxDQUFDbkIsS0FBcEM7QUFBMkN5QyxZQUFNLEVBQUVBO0FBQW5ELEtBQWI7QUFDQXhHLFdBQU8sQ0FBQ0MsR0FBUixDQUFZOEYsTUFBWjtBQUNBLFNBQUtsRixLQUFMLENBQVdqQixJQUFYLENBQWdCLFNBQWhCLEVBQTJCO0FBQUN3QyxZQUFNLEVBQUUsV0FBVDtBQUFzQjJELFlBQU0sRUFBRUE7QUFBOUIsS0FBM0I7QUFDQSxTQUFLcUcsY0FBTCxHQVoyQixDQWEzQjtBQUNEOztBQUVETixhQUFXLENBQUM1RyxJQUFELEVBQU95RixRQUFQLEVBQWlCN0ksQ0FBakIsRUFBbUI7QUFDNUI5QixXQUFPLENBQUNDLEdBQVIsQ0FBWTZCLENBQVosRUFBY29ELElBQWQsRUFBb0J5RixRQUFwQjs7QUFDQSxRQUFLN0ksQ0FBQyxDQUFDdUssS0FBRixLQUFZLEVBQWpCLEVBQXNCO0FBQ3BCO0FBQ0EsV0FBS1YsWUFBTCxDQUFrQnpHLElBQWxCLEVBQXdCeUYsUUFBeEI7QUFDQTdJLE9BQUMsQ0FBQ3dLLGNBQUY7QUFDQSxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVESCxhQUFXLENBQUNqSCxJQUFELEVBQU95RixRQUFQLEVBQWlCN0ksQ0FBakIsRUFBbUI7QUFDNUIsUUFBS0EsQ0FBQyxDQUFDdUssS0FBRixLQUFZLEVBQWpCLEVBQXNCO0FBQ3BCO0FBQ0EsV0FBS0osWUFBTCxDQUFrQi9HLElBQWxCLEVBQXdCeUYsUUFBeEI7QUFDQTdJLE9BQUMsQ0FBQ3dLLGNBQUY7QUFDQSxhQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEakssZUFBYSxDQUFDQyxNQUFELEVBQVE7QUFDbkIsU0FBS0EsTUFBTCxHQUFjQSxNQUFkO0FBQ0F0QyxXQUFPLENBQUNDLEdBQVIsQ0FBWSxLQUFLcUMsTUFBakI7QUFDRDs7QUF4cEJ3Qjs7QUE0cEIzQkMsY0FBYyxDQUFDQyxNQUFmLENBQXNCLFVBQXRCLEVBQWtDaUIsZ0JBQWxDLEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNocUJOO0FBQ0E7O0FBRWdDO0FBQ2hDLE9BQU8sV0FBVyxHQUFHLHVCQUFVOztBQUUvQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0RBQW9EO0FBQ3JFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sVUFBVSxrQkFBSTs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDZSw2REFBVyxFQUFDOztBQUUzQjtBQUNBLFNBQVMsdUJBQVM7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLG9CQUFvQjtBQUN6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsa0JBQUk7QUFDYjtBQUNBOzs7QUN2VUE7QUFDZ0M7QUFDWTs7QUFFNUMsTUFBTSxxQkFBWSxHQUFHLGFBQWE7O0FBRWxDLE9BQU8sSUFBSSxtQkFBSyxnQkFBRSxHQUFHLHVCQUFVOztBQUUvQjtBQUNBLElBQUksZUFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHVCQUFjLFNBQVMsYUFBYTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGlCQUFpQixnQkFBZ0IsRUFBRTtBQUN6RSxnQ0FBZ0MsNEJBQTRCLEVBQUU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLHFCQUFZO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RixxQkFBcUIscUJBQVkseURBQXlEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIscUJBQXFCO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxlQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsWUFBRztBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsK0JBQStCLFlBQUc7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QscUJBQVk7QUFDOUQ7QUFDQTtBQUNBLDJEQUEyRCxxQkFBWTtBQUN2RTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLGtCQUFrQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFELG1DQUFtQyx1Q0FBdUM7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHVCQUFjO0FBQ2xELG1CQUFtQix1QkFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFlBQVk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsdUJBQWM7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBLGVBQWUsdUJBQWM7QUFDN0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1REFBdUQsd0NBQXdDO0FBQy9GO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUN0VUE7QUFDZ0M7QUFDWTtBQUNaOztBQUVoQzs7QUFFQTtBQUNlLE1BQU0saUJBQVE7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQSx1Q0FBdUMsMEJBQU8sRUFBRSxpQ0FBaUM7QUFDakY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDLFdBQVc7QUFDWDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QyxXQUFXO0FBQ1g7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELDJDQUEyQyxFQUFFO0FBQzVHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtELHNDQUFzQyxFQUFFLFNBQVMsRUFBRTtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFbVI7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QUFKLEdBQXFCeFMsT0FBTyxDQUFDNkUsS0FBN0I7QUFDQTFDLGVBQUcsQ0FBQ3NRLGNBQUosR0FBcUJ6UyxPQUFPLENBQUNpRixLQUE3QjtBQUNBOztBQUNBO0FBQ0FoRixtQkFBTyxDQUFDQyxHQUFSLENBQVksaUJBQVosRUFBOEJGLE9BQTlCO0FBTkY7QUFRRDtBQUNGLEtBYkQ7QUFjRDs7QUFoRW1DOztBQXFFdEN3QyxjQUFjLENBQUNDLE1BQWYsQ0FBc0IsZUFBdEIsRUFBdUM4UCwwQkFBdkMsRTs7QUN4RUE7QUFDQTtDQUdBOztBQUNBO0NBR0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtDQUdBIiwiZmlsZSI6IjEwNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogVHJ1ZSBpZiB0aGUgY3VzdG9tIGVsZW1lbnRzIHBvbHlmaWxsIGlzIGluIHVzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzQ0VQb2x5ZmlsbCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzICE9IG51bGwgJiZcbiAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayAhPT1cbiAgICAgICAgdW5kZWZpbmVkO1xuLyoqXG4gKiBSZXBhcmVudHMgbm9kZXMsIHN0YXJ0aW5nIGZyb20gYHN0YXJ0YCAoaW5jbHVzaXZlKSB0byBgZW5kYCAoZXhjbHVzaXZlKSxcbiAqIGludG8gYW5vdGhlciBjb250YWluZXIgKGNvdWxkIGJlIHRoZSBzYW1lIGNvbnRhaW5lciksIGJlZm9yZSBgYmVmb3JlYC4gSWZcbiAqIGBiZWZvcmVgIGlzIG51bGwsIGl0IGFwcGVuZHMgdGhlIG5vZGVzIHRvIHRoZSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBhcmVudE5vZGVzID0gKGNvbnRhaW5lciwgc3RhcnQsIGVuZCA9IG51bGwsIGJlZm9yZSA9IG51bGwpID0+IHtcbiAgICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgICAgICBjb25zdCBuID0gc3RhcnQubmV4dFNpYmxpbmc7XG4gICAgICAgIGNvbnRhaW5lci5pbnNlcnRCZWZvcmUoc3RhcnQsIGJlZm9yZSk7XG4gICAgICAgIHN0YXJ0ID0gbjtcbiAgICB9XG59O1xuLyoqXG4gKiBSZW1vdmVzIG5vZGVzLCBzdGFydGluZyBmcm9tIGBzdGFydGAgKGluY2x1c2l2ZSkgdG8gYGVuZGAgKGV4Y2x1c2l2ZSksIGZyb21cbiAqIGBjb250YWluZXJgLlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlTm9kZXMgPSAoY29udGFpbmVyLCBzdGFydCwgZW5kID0gbnVsbCkgPT4ge1xuICAgIHdoaWxlIChzdGFydCAhPT0gZW5kKSB7XG4gICAgICAgIGNvbnN0IG4gPSBzdGFydC5uZXh0U2libGluZztcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHN0YXJ0KTtcbiAgICAgICAgc3RhcnQgPSBuO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kb20uanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBBbiBleHByZXNzaW9uIG1hcmtlciB3aXRoIGVtYmVkZGVkIHVuaXF1ZSBrZXkgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGhcbiAqIHBvc3NpYmxlIHRleHQgaW4gdGVtcGxhdGVzLlxuICovXG5leHBvcnQgY29uc3QgbWFya2VyID0gYHt7bGl0LSR7U3RyaW5nKE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpfX19YDtcbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgdXNlZCB0ZXh0LXBvc2l0aW9ucywgbXVsdGktYmluZGluZyBhdHRyaWJ1dGVzLCBhbmRcbiAqIGF0dHJpYnV0ZXMgd2l0aCBtYXJrdXAtbGlrZSB0ZXh0IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vZGVNYXJrZXIgPSBgPCEtLSR7bWFya2VyfS0tPmA7XG5leHBvcnQgY29uc3QgbWFya2VyUmVnZXggPSBuZXcgUmVnRXhwKGAke21hcmtlcn18JHtub2RlTWFya2VyfWApO1xuLyoqXG4gKiBTdWZmaXggYXBwZW5kZWQgdG8gYWxsIGJvdW5kIGF0dHJpYnV0ZSBuYW1lcy5cbiAqL1xuZXhwb3J0IGNvbnN0IGJvdW5kQXR0cmlidXRlU3VmZml4ID0gJyRsaXQkJztcbi8qKlxuICogQW4gdXBkYXRhYmxlIFRlbXBsYXRlIHRoYXQgdHJhY2tzIHRoZSBsb2NhdGlvbiBvZiBkeW5hbWljIHBhcnRzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCwgZWxlbWVudCkge1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBbXTtcbiAgICAgICAgLy8gRWRnZSBuZWVkcyBhbGwgNCBwYXJhbWV0ZXJzIHByZXNlbnQ7IElFMTEgbmVlZHMgM3JkIHBhcmFtZXRlciB0byBiZSBudWxsXG4gICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudC5jb250ZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX3tFTEVNRU5UfENPTU1FTlR8VEVYVH0gKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgLy8gS2VlcHMgdHJhY2sgb2YgdGhlIGxhc3QgaW5kZXggYXNzb2NpYXRlZCB3aXRoIGEgcGFydC4gV2UgdHJ5IHRvIGRlbGV0ZVxuICAgICAgICAvLyB1bm5lY2Vzc2FyeSBub2RlcywgYnV0IHdlIG5ldmVyIHdhbnQgdG8gYXNzb2NpYXRlIHR3byBkaWZmZXJlbnQgcGFydHNcbiAgICAgICAgLy8gdG8gdGhlIHNhbWUgaW5kZXguIFRoZXkgbXVzdCBoYXZlIGEgY29uc3RhbnQgbm9kZSBiZXR3ZWVuLlxuICAgICAgICBsZXQgbGFzdFBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgY29uc3QgeyBzdHJpbmdzLCB2YWx1ZXM6IHsgbGVuZ3RoIH0gfSA9IHJlc3VsdDtcbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgaWYgKG5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSd2ZSBleGhhdXN0ZWQgdGhlIGNvbnRlbnQgaW5zaWRlIGEgbmVzdGVkIHRlbXBsYXRlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB3ZSBzdGlsbCBoYXZlIHBhcnRzICh0aGUgb3V0ZXIgZm9yLWxvb3ApLCB3ZSBrbm93OlxuICAgICAgICAgICAgICAgIC8vIC0gVGhlcmUgaXMgYSB0ZW1wbGF0ZSBpbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICAvLyAtIFRoZSB3YWxrZXIgd2lsbCBmaW5kIGEgbmV4dE5vZGUgb3V0c2lkZSB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICAgICAgLy8gUGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9OYW1lZE5vZGVNYXAsXG4gICAgICAgICAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMgYXJlIG5vdCBndWFyYW50ZWVkIHRvIGJlIHJldHVybmVkIGluIGRvY3VtZW50IG9yZGVyLlxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBwYXJ0aWN1bGFyLCBFZGdlL0lFIGNhbiByZXR1cm4gdGhlbSBvdXQgb2Ygb3JkZXIsIHNvIHdlIGNhbm5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgYSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIHBhcnQgaW5kZXggYW5kIGF0dHJpYnV0ZSBpbmRleC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVuZHNXaXRoKGF0dHJpYnV0ZXNbaV0ubmFtZSwgYm91bmRBdHRyaWJ1dGVTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBzZWN0aW9uIGxlYWRpbmcgdXAgdG8gdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIGluIHRoaXMgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdGb3JQYXJ0ID0gc3RyaW5nc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4LmV4ZWMoc3RyaW5nRm9yUGFydClbMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxsIGJvdW5kIGF0dHJpYnV0ZXMgaGF2ZSBoYWQgYSBzdWZmaXggYWRkZWQgaW5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRlbXBsYXRlUmVzdWx0I2dldEhUTUwgdG8gb3B0IG91dCBvZiBzcGVjaWFsIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxpbmcuIFRvIGxvb2sgdXAgdGhlIGF0dHJpYnV0ZSB2YWx1ZSB3ZSBhbHNvIG5lZWQgdG8gYWRkXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgc3VmZml4LlxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlTG9va3VwTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKSArIGJvdW5kQXR0cmlidXRlU3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVMb29rdXBOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZUxvb2t1cE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGljcyA9IGF0dHJpYnV0ZVZhbHVlLnNwbGl0KG1hcmtlclJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdhdHRyaWJ1dGUnLCBpbmRleCwgbmFtZSwgc3RyaW5nczogc3RhdGljcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBzdGF0aWNzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBOb2RlLlRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBub2RlLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaW5kZXhPZihtYXJrZXIpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdzID0gZGF0YS5zcGxpdChtYXJrZXJSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgdGV4dCBub2RlIGZvciBlYWNoIGxpdGVyYWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBub2RlcyBhcmUgYWxzbyB1c2VkIGFzIHRoZSBtYXJrZXJzIGZvciBub2RlIHBhcnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpbnNlcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgcyA9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocyA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnQgPSBjcmVhdGVNYXJrZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCAmJiBlbmRzV2l0aChtYXRjaFsyXSwgYm91bmRBdHRyaWJ1dGVTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLnNsaWNlKDAsIG1hdGNoLmluZGV4KSArIG1hdGNoWzFdICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzJdLnNsaWNlKDAsIC1ib3VuZEF0dHJpYnV0ZVN1ZmZpeC5sZW5ndGgpICsgbWF0Y2hbM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc2VydCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnNlcnQsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKHsgdHlwZTogJ25vZGUnLCBpbmRleDogKytpbmRleCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIHRleHQsIHdlIG11c3QgaW5zZXJ0IGEgY29tbWVudCB0byBtYXJrIG91ciBwbGFjZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWxzZSwgd2UgY2FuIHRydXN0IGl0IHdpbGwgc3RpY2sgYXJvdW5kIGFmdGVyIGNsb25pbmcuXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzW2xhc3RJbmRleF0gPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNyZWF0ZU1hcmtlcigpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHN0cmluZ3NbbGFzdEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgcGFydCBmb3IgZWFjaCBtYXRjaCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogTm9kZS5DT01NRU5UX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5kYXRhID09PSBtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBuZXcgbWFya2VyIG5vZGUgdG8gYmUgdGhlIHN0YXJ0Tm9kZSBvZiB0aGUgUGFydCBpZiBhbnkgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZvbGxvd2luZyBhcmUgdHJ1ZTpcbiAgICAgICAgICAgICAgICAgICAgLy8gICogV2UgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzU2libGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyAgKiBUaGUgcHJldmlvdXNTaWJsaW5nIGlzIGFscmVhZHkgdGhlIHN0YXJ0IG9mIGEgcHJldmlvdXMgcGFydFxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IG51bGwgfHwgaW5kZXggPT09IGxhc3RQYXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGNyZWF0ZU1hcmtlcigpLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYXN0UGFydEluZGV4ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaCh7IHR5cGU6ICdub2RlJywgaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBuZXh0U2libGluZywga2VlcCB0aGlzIG5vZGUgc28gd2UgaGF2ZSBhbiBlbmQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIHdlIGNhbiByZW1vdmUgaXQgdG8gc2F2ZSBmdXR1cmUgY29zdHMuXG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKGkgPSBub2RlLmRhdGEuaW5kZXhPZihtYXJrZXIsIGkgKyAxKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb21tZW50IG5vZGUgaGFzIGEgYmluZGluZyBtYXJrZXIgaW5zaWRlLCBtYWtlIGFuIGluYWN0aXZlIHBhcnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBiaW5kaW5nIHdvbid0IHdvcmssIGJ1dCBzdWJzZXF1ZW50IGJpbmRpbmdzIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gKGp1c3RpbmZhZ25hbmkpOiBjb25zaWRlciB3aGV0aGVyIGl0J3MgZXZlbiB3b3J0aCBpdCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFrZSBiaW5kaW5ncyBpbiBjb21tZW50cyB3b3JrXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2goeyB0eXBlOiAnbm9kZScsIGluZGV4OiAtMSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0ZXh0IGJpbmRpbmcgbm9kZXMgYWZ0ZXIgdGhlIHdhbGsgdG8gbm90IGRpc3R1cmIgdGhlIFRyZWVXYWxrZXJcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGVuZHNXaXRoID0gKHN0ciwgc3VmZml4KSA9PiB7XG4gICAgY29uc3QgaW5kZXggPSBzdHIubGVuZ3RoIC0gc3VmZml4Lmxlbmd0aDtcbiAgICByZXR1cm4gaW5kZXggPj0gMCAmJiBzdHIuc2xpY2UoaW5kZXgpID09PSBzdWZmaXg7XG59O1xuZXhwb3J0IGNvbnN0IGlzVGVtcGxhdGVQYXJ0QWN0aXZlID0gKHBhcnQpID0+IHBhcnQuaW5kZXggIT09IC0xO1xuLy8gQWxsb3dzIGBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKWAgdG8gYmUgcmVuYW1lZCBmb3IgYVxuLy8gc21hbGwgbWFudWFsIHNpemUtc2F2aW5ncy5cbmV4cG9ydCBjb25zdCBjcmVhdGVNYXJrZXIgPSAoKSA9PiBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcnKTtcbi8qKlxuICogVGhpcyByZWdleCBleHRyYWN0cyB0aGUgYXR0cmlidXRlIG5hbWUgcHJlY2VkaW5nIGFuIGF0dHJpYnV0ZS1wb3NpdGlvblxuICogZXhwcmVzc2lvbi4gSXQgZG9lcyB0aGlzIGJ5IG1hdGNoaW5nIHRoZSBzeW50YXggYWxsb3dlZCBmb3IgYXR0cmlidXRlc1xuICogYWdhaW5zdCB0aGUgc3RyaW5nIGxpdGVyYWwgZGlyZWN0bHkgcHJlY2VkaW5nIHRoZSBleHByZXNzaW9uLCBhc3N1bWluZyB0aGF0XG4gKiB0aGUgZXhwcmVzc2lvbiBpcyBpbiBhbiBhdHRyaWJ1dGUtdmFsdWUgcG9zaXRpb24uXG4gKlxuICogU2VlIGF0dHJpYnV0ZXMgaW4gdGhlIEhUTUwgc3BlYzpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50cy1hdHRyaWJ1dGVzXG4gKlxuICogXCIgXFx4MDlcXHgwYVxceDBjXFx4MGRcIiBhcmUgSFRNTCBzcGFjZSBjaGFyYWN0ZXJzOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZnJhc3RydWN0dXJlLmh0bWwjc3BhY2UtY2hhcmFjdGVyc1xuICpcbiAqIFwiXFwwLVxceDFGXFx4N0YtXFx4OUZcIiBhcmUgVW5pY29kZSBjb250cm9sIGNoYXJhY3RlcnMsIHdoaWNoIGluY2x1ZGVzIGV2ZXJ5XG4gKiBzcGFjZSBjaGFyYWN0ZXIgZXhjZXB0IFwiIFwiLlxuICpcbiAqIFNvIGFuIGF0dHJpYnV0ZSBpczpcbiAqICAqIFRoZSBuYW1lOiBhbnkgY2hhcmFjdGVyIGV4Y2VwdCBhIGNvbnRyb2wgY2hhcmFjdGVyLCBzcGFjZSBjaGFyYWN0ZXIsICgnKSxcbiAqICAgIChcIiksIFwiPlwiLCBcIj1cIiwgb3IgXCIvXCJcbiAqICAqIEZvbGxvd2VkIGJ5IHplcm8gb3IgbW9yZSBzcGFjZSBjaGFyYWN0ZXJzXG4gKiAgKiBGb2xsb3dlZCBieSBcIj1cIlxuICogICogRm9sbG93ZWQgYnkgemVybyBvciBtb3JlIHNwYWNlIGNoYXJhY3RlcnNcbiAqICAqIEZvbGxvd2VkIGJ5OlxuICogICAgKiBBbnkgY2hhcmFjdGVyIGV4Y2VwdCBzcGFjZSwgKCcpLCAoXCIpLCBcIjxcIiwgXCI+XCIsIFwiPVwiLCAoYCksIG9yXG4gKiAgICAqIChcIikgdGhlbiBhbnkgbm9uLShcIiksIG9yXG4gKiAgICAqICgnKSB0aGVuIGFueSBub24tKCcpXG4gKi9cbmV4cG9ydCBjb25zdCBsYXN0QXR0cmlidXRlTmFtZVJlZ2V4ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxuLyhbIFxceDA5XFx4MGFcXHgwY1xceDBkXSkoW15cXDAtXFx4MUZcXHg3Ri1cXHg5RiBcIic+PS9dKykoWyBcXHgwOVxceDBhXFx4MGNcXHgwZF0qPVsgXFx4MDlcXHgwYVxceDBjXFx4MGRdKig/OlteIFxceDA5XFx4MGFcXHgwY1xceDBkXCInYDw+PV0qfFwiW15cIl0qfCdbXiddKikpJC87XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIEBtb2R1bGUgc2hhZHktcmVuZGVyXG4gKi9cbmltcG9ydCB7IGlzVGVtcGxhdGVQYXJ0QWN0aXZlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG5jb25zdCB3YWxrZXJOb2RlRmlsdGVyID0gMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV197RUxFTUVOVHxDT01NRU5UfFRFWFR9ICovO1xuLyoqXG4gKiBSZW1vdmVzIHRoZSBsaXN0IG9mIG5vZGVzIGZyb20gYSBUZW1wbGF0ZSBzYWZlbHkuIEluIGFkZGl0aW9uIHRvIHJlbW92aW5nXG4gKiBub2RlcyBmcm9tIHRoZSBUZW1wbGF0ZSwgdGhlIFRlbXBsYXRlIHBhcnQgaW5kaWNlcyBhcmUgdXBkYXRlZCB0byBtYXRjaFxuICogdGhlIG11dGF0ZWQgVGVtcGxhdGUgRE9NLlxuICpcbiAqIEFzIHRoZSB0ZW1wbGF0ZSBpcyB3YWxrZWQgdGhlIHJlbW92YWwgc3RhdGUgaXMgdHJhY2tlZCBhbmRcbiAqIHBhcnQgaW5kaWNlcyBhcmUgYWRqdXN0ZWQgYXMgbmVlZGVkLlxuICpcbiAqIGRpdlxuICogICBkaXYjMSAocmVtb3ZlKSA8LS0gc3RhcnQgcmVtb3ZpbmcgKHJlbW92aW5nIG5vZGUgaXMgZGl2IzEpXG4gKiAgICAgZGl2XG4gKiAgICAgICBkaXYjMiAocmVtb3ZlKSAgPC0tIGNvbnRpbnVlIHJlbW92aW5nIChyZW1vdmluZyBub2RlIGlzIHN0aWxsIGRpdiMxKVxuICogICAgICAgICBkaXZcbiAqIGRpdiA8LS0gc3RvcCByZW1vdmluZyBzaW5jZSBwcmV2aW91cyBzaWJsaW5nIGlzIHRoZSByZW1vdmluZyBub2RlIChkaXYjMSxcbiAqIHJlbW92ZWQgNCBub2RlcylcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZU5vZGVzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBub2Rlc1RvUmVtb3ZlKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiB7IGNvbnRlbnQgfSwgcGFydHMgfSA9IHRlbXBsYXRlO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoY29udGVudCwgd2Fsa2VyTm9kZUZpbHRlciwgbnVsbCwgZmFsc2UpO1xuICAgIGxldCBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMpO1xuICAgIGxldCBwYXJ0ID0gcGFydHNbcGFydEluZGV4XTtcbiAgICBsZXQgbm9kZUluZGV4ID0gLTE7XG4gICAgbGV0IHJlbW92ZUNvdW50ID0gMDtcbiAgICBjb25zdCBub2Rlc1RvUmVtb3ZlSW5UZW1wbGF0ZSA9IFtdO1xuICAgIGxldCBjdXJyZW50UmVtb3ZpbmdOb2RlID0gbnVsbDtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgbm9kZUluZGV4Kys7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgIC8vIEVuZCByZW1vdmFsIGlmIHN0ZXBwZWQgcGFzdCB0aGUgcmVtb3Zpbmcgbm9kZVxuICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IGN1cnJlbnRSZW1vdmluZ05vZGUpIHtcbiAgICAgICAgICAgIGN1cnJlbnRSZW1vdmluZ05vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgbm9kZSB0byByZW1vdmUgd2FzIGZvdW5kIGluIHRoZSB0ZW1wbGF0ZVxuICAgICAgICBpZiAobm9kZXNUb1JlbW92ZS5oYXMobm9kZSkpIHtcbiAgICAgICAgICAgIG5vZGVzVG9SZW1vdmVJblRlbXBsYXRlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAvLyBUcmFjayBub2RlIHdlJ3JlIHJlbW92aW5nXG4gICAgICAgICAgICBpZiAoY3VycmVudFJlbW92aW5nTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRSZW1vdmluZ05vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gcmVtb3ZpbmcsIGluY3JlbWVudCBjb3VudCBieSB3aGljaCB0byBhZGp1c3Qgc3Vic2VxdWVudCBwYXJ0IGluZGljZXNcbiAgICAgICAgaWYgKGN1cnJlbnRSZW1vdmluZ05vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlbW92ZUNvdW50Kys7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBhcnQgIT09IHVuZGVmaW5lZCAmJiBwYXJ0LmluZGV4ID09PSBub2RlSW5kZXgpIHtcbiAgICAgICAgICAgIC8vIElmIHBhcnQgaXMgaW4gYSByZW1vdmVkIG5vZGUgZGVhY3RpdmF0ZSBpdCBieSBzZXR0aW5nIGluZGV4IHRvIC0xIG9yXG4gICAgICAgICAgICAvLyBhZGp1c3QgdGhlIGluZGV4IGFzIG5lZWRlZC5cbiAgICAgICAgICAgIHBhcnQuaW5kZXggPSBjdXJyZW50UmVtb3ZpbmdOb2RlICE9PSBudWxsID8gLTEgOiBwYXJ0LmluZGV4IC0gcmVtb3ZlQ291bnQ7XG4gICAgICAgICAgICAvLyBnbyB0byB0aGUgbmV4dCBhY3RpdmUgcGFydC5cbiAgICAgICAgICAgIHBhcnRJbmRleCA9IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyhwYXJ0cywgcGFydEluZGV4KTtcbiAgICAgICAgICAgIHBhcnQgPSBwYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5vZGVzVG9SZW1vdmVJblRlbXBsYXRlLmZvckVhY2goKG4pID0+IG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKSk7XG59XG5jb25zdCBjb3VudE5vZGVzID0gKG5vZGUpID0+IHtcbiAgICBsZXQgY291bnQgPSAobm9kZS5ub2RlVHlwZSA9PT0gMTEgLyogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFICovKSA/IDAgOiAxO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIobm9kZSwgd2Fsa2VyTm9kZUZpbHRlciwgbnVsbCwgZmFsc2UpO1xuICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICBjb3VudCsrO1xuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG59O1xuY29uc3QgbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzID0gKHBhcnRzLCBzdGFydEluZGV4ID0gLTEpID0+IHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleCArIDE7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIGlmIChpc1RlbXBsYXRlUGFydEFjdGl2ZShwYXJ0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcbi8qKlxuICogSW5zZXJ0cyB0aGUgZ2l2ZW4gbm9kZSBpbnRvIHRoZSBUZW1wbGF0ZSwgb3B0aW9uYWxseSBiZWZvcmUgdGhlIGdpdmVuXG4gKiByZWZOb2RlLiBJbiBhZGRpdGlvbiB0byBpbnNlcnRpbmcgdGhlIG5vZGUgaW50byB0aGUgVGVtcGxhdGUsIHRoZSBUZW1wbGF0ZVxuICogcGFydCBpbmRpY2VzIGFyZSB1cGRhdGVkIHRvIG1hdGNoIHRoZSBtdXRhdGVkIFRlbXBsYXRlIERPTS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc2VydE5vZGVJbnRvVGVtcGxhdGUodGVtcGxhdGUsIG5vZGUsIHJlZk5vZGUgPSBudWxsKSB7XG4gICAgY29uc3QgeyBlbGVtZW50OiB7IGNvbnRlbnQgfSwgcGFydHMgfSA9IHRlbXBsYXRlO1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVmTm9kZSwgdGhlbiBwdXQgbm9kZSBhdCBlbmQgb2YgdGVtcGxhdGUuXG4gICAgLy8gTm8gcGFydCBpbmRpY2VzIG5lZWQgdG8gYmUgc2hpZnRlZCBpbiB0aGlzIGNhc2UuXG4gICAgaWYgKHJlZk5vZGUgPT09IG51bGwgfHwgcmVmTm9kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihjb250ZW50LCB3YWxrZXJOb2RlRmlsdGVyLCBudWxsLCBmYWxzZSk7XG4gICAgbGV0IHBhcnRJbmRleCA9IG5leHRBY3RpdmVJbmRleEluVGVtcGxhdGVQYXJ0cyhwYXJ0cyk7XG4gICAgbGV0IGluc2VydENvdW50ID0gMDtcbiAgICBsZXQgd2Fsa2VySW5kZXggPSAtMTtcbiAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgd2Fsa2VySW5kZXgrKztcbiAgICAgICAgY29uc3Qgd2Fsa2VyTm9kZSA9IHdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgaWYgKHdhbGtlck5vZGUgPT09IHJlZk5vZGUpIHtcbiAgICAgICAgICAgIGluc2VydENvdW50ID0gY291bnROb2Rlcyhub2RlKTtcbiAgICAgICAgICAgIHJlZk5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgcmVmTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCAhPT0gLTEgJiYgcGFydHNbcGFydEluZGV4XS5pbmRleCA9PT0gd2Fsa2VySW5kZXgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGluc2VydGVkIHRoZSBub2RlLCBzaW1wbHkgYWRqdXN0IGFsbCBzdWJzZXF1ZW50IHBhcnRzXG4gICAgICAgICAgICBpZiAoaW5zZXJ0Q291bnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydHNbcGFydEluZGV4XS5pbmRleCArPSBpbnNlcnRDb3VudDtcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ID0gbmV4dEFjdGl2ZUluZGV4SW5UZW1wbGF0ZVBhcnRzKHBhcnRzLCBwYXJ0SW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0SW5kZXggPSBuZXh0QWN0aXZlSW5kZXhJblRlbXBsYXRlUGFydHMocGFydHMsIHBhcnRJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RpZnktdGVtcGxhdGUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuY29uc3QgZGlyZWN0aXZlcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIEJyYW5kcyBhIGZ1bmN0aW9uIGFzIGEgZGlyZWN0aXZlIGZhY3RvcnkgZnVuY3Rpb24gc28gdGhhdCBsaXQtaHRtbCB3aWxsIGNhbGxcbiAqIHRoZSBmdW5jdGlvbiBkdXJpbmcgdGVtcGxhdGUgcmVuZGVyaW5nLCByYXRoZXIgdGhhbiBwYXNzaW5nIGFzIGEgdmFsdWUuXG4gKlxuICogQSBfZGlyZWN0aXZlXyBpcyBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBQYXJ0IGFzIGFuIGFyZ3VtZW50LiBJdCBoYXMgdGhlXG4gKiBzaWduYXR1cmU6IGAocGFydDogUGFydCkgPT4gdm9pZGAuXG4gKlxuICogQSBkaXJlY3RpdmUgX2ZhY3RvcnlfIGlzIGEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhcmd1bWVudHMgZm9yIGRhdGEgYW5kXG4gKiBjb25maWd1cmF0aW9uIGFuZCByZXR1cm5zIGEgZGlyZWN0aXZlLiBVc2VycyBvZiBkaXJlY3RpdmUgdXN1YWxseSByZWZlciB0b1xuICogdGhlIGRpcmVjdGl2ZSBmYWN0b3J5IGFzIHRoZSBkaXJlY3RpdmUuIEZvciBleGFtcGxlLCBcIlRoZSByZXBlYXQgZGlyZWN0aXZlXCIuXG4gKlxuICogVXN1YWxseSBhIHRlbXBsYXRlIGF1dGhvciB3aWxsIGludm9rZSBhIGRpcmVjdGl2ZSBmYWN0b3J5IGluIHRoZWlyIHRlbXBsYXRlXG4gKiB3aXRoIHJlbGV2YW50IGFyZ3VtZW50cywgd2hpY2ggd2lsbCB0aGVuIHJldHVybiBhIGRpcmVjdGl2ZSBmdW5jdGlvbi5cbiAqXG4gKiBIZXJlJ3MgYW4gZXhhbXBsZSBvZiB1c2luZyB0aGUgYHJlcGVhdCgpYCBkaXJlY3RpdmUgZmFjdG9yeSB0aGF0IHRha2VzIGFuXG4gKiBhcnJheSBhbmQgYSBmdW5jdGlvbiB0byByZW5kZXIgYW4gaXRlbTpcbiAqXG4gKiBgYGBqc1xuICogaHRtbGA8dWw+PCR7cmVwZWF0KGl0ZW1zLCAoaXRlbSkgPT4gaHRtbGA8bGk+JHtpdGVtfTwvbGk+YCl9PC91bD5gXG4gKiBgYGBcbiAqXG4gKiBXaGVuIGByZXBlYXRgIGlzIGludm9rZWQsIGl0IHJldHVybnMgYSBkaXJlY3RpdmUgZnVuY3Rpb24gdGhhdCBjbG9zZXMgb3ZlclxuICogYGl0ZW1zYCBhbmQgdGhlIHRlbXBsYXRlIGZ1bmN0aW9uLiBXaGVuIHRoZSBvdXRlciB0ZW1wbGF0ZSBpcyByZW5kZXJlZCwgdGhlXG4gKiByZXR1cm4gZGlyZWN0aXZlIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIHRoZSBQYXJ0IGZvciB0aGUgZXhwcmVzc2lvbi5cbiAqIGByZXBlYXRgIHRoZW4gcGVyZm9ybXMgaXQncyBjdXN0b20gbG9naWMgdG8gcmVuZGVyIG11bHRpcGxlIGl0ZW1zLlxuICpcbiAqIEBwYXJhbSBmIFRoZSBkaXJlY3RpdmUgZmFjdG9yeSBmdW5jdGlvbi4gTXVzdCBiZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhXG4gKiBmdW5jdGlvbiBvZiB0aGUgc2lnbmF0dXJlIGAocGFydDogUGFydCkgPT4gdm9pZGAuIFRoZSByZXR1cm5lZCBmdW5jdGlvbiB3aWxsXG4gKiBiZSBjYWxsZWQgd2l0aCB0aGUgcGFydCBvYmplY3QuXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBpbXBvcnQge2RpcmVjdGl2ZSwgaHRtbH0gZnJvbSAnbGl0LWh0bWwnO1xuICpcbiAqIGNvbnN0IGltbXV0YWJsZSA9IGRpcmVjdGl2ZSgodikgPT4gKHBhcnQpID0+IHtcbiAqICAgaWYgKHBhcnQudmFsdWUgIT09IHYpIHtcbiAqICAgICBwYXJ0LnNldFZhbHVlKHYpXG4gKiAgIH1cbiAqIH0pO1xuICovXG5leHBvcnQgY29uc3QgZGlyZWN0aXZlID0gKGYpID0+ICgoLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IGQgPSBmKC4uLmFyZ3MpO1xuICAgIGRpcmVjdGl2ZXMuc2V0KGQsIHRydWUpO1xuICAgIHJldHVybiBkO1xufSk7XG5leHBvcnQgY29uc3QgaXNEaXJlY3RpdmUgPSAobykgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgbyA9PT0gJ2Z1bmN0aW9uJyAmJiBkaXJlY3RpdmVzLmhhcyhvKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kaXJlY3RpdmUuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE4IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBBIHNlbnRpbmVsIHZhbHVlIHRoYXQgc2lnbmFscyB0aGF0IGEgdmFsdWUgd2FzIGhhbmRsZWQgYnkgYSBkaXJlY3RpdmUgYW5kXG4gKiBzaG91bGQgbm90IGJlIHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAqL1xuZXhwb3J0IGNvbnN0IG5vQ2hhbmdlID0ge307XG4vKipcbiAqIEEgc2VudGluZWwgdmFsdWUgdGhhdCBzaWduYWxzIGEgTm9kZVBhcnQgdG8gZnVsbHkgY2xlYXIgaXRzIGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBub3RoaW5nID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyBpc0NFUG9seWZpbGwgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBpc1RlbXBsYXRlUGFydEFjdGl2ZSB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBhIGBUZW1wbGF0ZWAgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdXBkYXRlZFxuICogd2l0aCBuZXcgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHByb2Nlc3Nvciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9fcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnByb2Nlc3NvciA9IHByb2Nlc3NvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnNldFZhbHVlKHZhbHVlc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX19wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb25lKCkge1xuICAgICAgICAvLyBUaGVyZSBhcmUgYSBudW1iZXIgb2Ygc3RlcHMgaW4gdGhlIGxpZmVjeWNsZSBvZiBhIHRlbXBsYXRlIGluc3RhbmNlJ3NcbiAgICAgICAgLy8gRE9NIGZyYWdtZW50OlxuICAgICAgICAvLyAgMS4gQ2xvbmUgLSBjcmVhdGUgdGhlIGluc3RhbmNlIGZyYWdtZW50XG4gICAgICAgIC8vICAyLiBBZG9wdCAtIGFkb3B0IGludG8gdGhlIG1haW4gZG9jdW1lbnRcbiAgICAgICAgLy8gIDMuIFByb2Nlc3MgLSBmaW5kIHBhcnQgbWFya2VycyBhbmQgY3JlYXRlIHBhcnRzXG4gICAgICAgIC8vICA0LiBVcGdyYWRlIC0gdXBncmFkZSBjdXN0b20gZWxlbWVudHNcbiAgICAgICAgLy8gIDUuIFVwZGF0ZSAtIHNldCBub2RlLCBhdHRyaWJ1dGUsIHByb3BlcnR5LCBldGMuLCB2YWx1ZXNcbiAgICAgICAgLy8gIDYuIENvbm5lY3QgLSBjb25uZWN0IHRvIHRoZSBkb2N1bWVudC4gT3B0aW9uYWwgYW5kIG91dHNpZGUgb2YgdGhpc1xuICAgICAgICAvLyAgICAgbWV0aG9kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSBoYXZlIGEgZmV3IGNvbnN0cmFpbnRzIG9uIHRoZSBvcmRlcmluZyBvZiB0aGVzZSBzdGVwczpcbiAgICAgICAgLy8gICogV2UgbmVlZCB0byB1cGdyYWRlIGJlZm9yZSB1cGRhdGluZywgc28gdGhhdCBwcm9wZXJ0eSB2YWx1ZXMgd2lsbCBwYXNzXG4gICAgICAgIC8vICAgIHRocm91Z2ggYW55IHByb3BlcnR5IHNldHRlcnMuXG4gICAgICAgIC8vICAqIFdlIHdvdWxkIGxpa2UgdG8gcHJvY2VzcyBiZWZvcmUgdXBncmFkaW5nIHNvIHRoYXQgd2UncmUgc3VyZSB0aGF0IHRoZVxuICAgICAgICAvLyAgICBjbG9uZWQgZnJhZ21lbnQgaXMgaW5lcnQgYW5kIG5vdCBkaXN0dXJiZWQgYnkgc2VsZi1tb2RpZnlpbmcgRE9NLlxuICAgICAgICAvLyAgKiBXZSB3YW50IGN1c3RvbSBlbGVtZW50cyB0byB1cGdyYWRlIGV2ZW4gaW4gZGlzY29ubmVjdGVkIGZyYWdtZW50cy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2l2ZW4gdGhlc2UgY29uc3RyYWludHMsIHdpdGggZnVsbCBjdXN0b20gZWxlbWVudHMgc3VwcG9ydCB3ZSB3b3VsZFxuICAgICAgICAvLyBwcmVmZXIgdGhlIG9yZGVyOiBDbG9uZSwgUHJvY2VzcywgQWRvcHQsIFVwZ3JhZGUsIFVwZGF0ZSwgQ29ubmVjdFxuICAgICAgICAvL1xuICAgICAgICAvLyBCdXQgU2FmYXJpIGRvZXMgbm90IGltcGxlbWVudCBDdXN0b21FbGVtZW50UmVnaXN0cnkjdXBncmFkZSwgc28gd2VcbiAgICAgICAgLy8gY2FuIG5vdCBpbXBsZW1lbnQgdGhhdCBvcmRlciBhbmQgc3RpbGwgaGF2ZSB1cGdyYWRlLWJlZm9yZS11cGRhdGUgYW5kXG4gICAgICAgIC8vIHVwZ3JhZGUgZGlzY29ubmVjdGVkIGZyYWdtZW50cy4gU28gd2UgaW5zdGVhZCBzYWNyaWZpY2UgdGhlXG4gICAgICAgIC8vIHByb2Nlc3MtYmVmb3JlLXVwZ3JhZGUgY29uc3RyYWludCwgc2luY2UgaW4gQ3VzdG9tIEVsZW1lbnRzIHYxIGVsZW1lbnRzXG4gICAgICAgIC8vIG11c3Qgbm90IG1vZGlmeSB0aGVpciBsaWdodCBET00gaW4gdGhlIGNvbnN0cnVjdG9yLiBXZSBzdGlsbCBoYXZlIGlzc3Vlc1xuICAgICAgICAvLyB3aGVuIGNvLWV4aXN0aW5nIHdpdGggQ0V2MCBlbGVtZW50cyBsaWtlIFBvbHltZXIgMSwgYW5kIHdpdGggcG9seWZpbGxzXG4gICAgICAgIC8vIHRoYXQgZG9uJ3Qgc3RyaWN0bHkgYWRoZXJlIHRvIHRoZSBuby1tb2RpZmljYXRpb24gcnVsZSBiZWNhdXNlIHNoYWRvd1xuICAgICAgICAvLyBET00sIHdoaWNoIG1heSBiZSBjcmVhdGVkIGluIHRoZSBjb25zdHJ1Y3RvciwgaXMgZW11bGF0ZWQgYnkgYmVpbmcgcGxhY2VkXG4gICAgICAgIC8vIGluIHRoZSBsaWdodCBET00uXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSByZXN1bHRpbmcgb3JkZXIgaXMgb24gbmF0aXZlIGlzOiBDbG9uZSwgQWRvcHQsIFVwZ3JhZGUsIFByb2Nlc3MsXG4gICAgICAgIC8vIFVwZGF0ZSwgQ29ubmVjdC4gZG9jdW1lbnQuaW1wb3J0Tm9kZSgpIHBlcmZvcm1zIENsb25lLCBBZG9wdCwgYW5kIFVwZ3JhZGVcbiAgICAgICAgLy8gaW4gb25lIHN0ZXAuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBDdXN0b20gRWxlbWVudHMgdjEgcG9seWZpbGwgc3VwcG9ydHMgdXBncmFkZSgpLCBzbyB0aGUgb3JkZXIgd2hlblxuICAgICAgICAvLyBwb2x5ZmlsbGVkIGlzIHRoZSBtb3JlIGlkZWFsOiBDbG9uZSwgUHJvY2VzcywgQWRvcHQsIFVwZ3JhZGUsIFVwZGF0ZSxcbiAgICAgICAgLy8gQ29ubmVjdC5cbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpc0NFUG9seWZpbGwgP1xuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQuY2xvbmVOb2RlKHRydWUpIDpcbiAgICAgICAgICAgIGRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQsIHRydWUpO1xuICAgICAgICBjb25zdCBzdGFjayA9IFtdO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMudGVtcGxhdGUucGFydHM7XG4gICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmUgbnVsbFxuICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGZyYWdtZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX3tFTEVNRU5UfENPTU1FTlR8VEVYVH0gKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBub2RlSW5kZXggPSAwO1xuICAgICAgICBsZXQgcGFydDtcbiAgICAgICAgbGV0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgLy8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgbm9kZXMgYW5kIHBhcnRzIG9mIGEgdGVtcGxhdGVcbiAgICAgICAgd2hpbGUgKHBhcnRJbmRleCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFydCA9IHBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICBpZiAoIWlzVGVtcGxhdGVQYXJ0QWN0aXZlKHBhcnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX3BhcnRzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2dyZXNzIHRoZSB0cmVlIHdhbGtlciB1bnRpbCB3ZSBmaW5kIG91ciBuZXh0IHBhcnQncyBub2RlLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IG11bHRpcGxlIHBhcnRzIG1heSBzaGFyZSB0aGUgc2FtZSBub2RlIChhdHRyaWJ1dGUgcGFydHNcbiAgICAgICAgICAgIC8vIG9uIGEgc2luZ2xlIGVsZW1lbnQpLCBzbyB0aGlzIGxvb3AgbWF5IG5vdCBydW4gYXQgYWxsLlxuICAgICAgICAgICAgd2hpbGUgKG5vZGVJbmRleCA8IHBhcnQuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICBub2RlSW5kZXgrKztcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5ub2RlTmFtZSA9PT0gJ1RFTVBMQVRFJykge1xuICAgICAgICAgICAgICAgICAgICBzdGFjay5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB3YWxrZXIuY3VycmVudE5vZGUgPSBub2RlLmNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgobm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpKSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBleGhhdXN0ZWQgdGhlIGNvbnRlbnQgaW5zaWRlIGEgbmVzdGVkIHRlbXBsYXRlIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJlY2F1c2Ugd2Ugc3RpbGwgaGF2ZSBwYXJ0cyAodGhlIG91dGVyIGZvci1sb29wKSwgd2Uga25vdzpcbiAgICAgICAgICAgICAgICAgICAgLy8gLSBUaGVyZSBpcyBhIHRlbXBsYXRlIGluIHRoZSBzdGFja1xuICAgICAgICAgICAgICAgICAgICAvLyAtIFRoZSB3YWxrZXIgd2lsbCBmaW5kIGEgbmV4dE5vZGUgb3V0c2lkZSB0aGUgdGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgd2Fsa2VyLmN1cnJlbnROb2RlID0gc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXZSd2ZSBhcnJpdmVkIGF0IG91ciBwYXJ0J3Mgbm9kZS5cbiAgICAgICAgICAgIGlmIChwYXJ0LnR5cGUgPT09ICdub2RlJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSB0aGlzLnByb2Nlc3Nvci5oYW5kbGVUZXh0RXhwcmVzc2lvbih0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHBhcnQuaW5zZXJ0QWZ0ZXJOb2RlKG5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9fcGFydHMucHVzaChwYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX19wYXJ0cy5wdXNoKC4uLnRoaXMucHJvY2Vzc29yLmhhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKG5vZGUsIHBhcnQubmFtZSwgcGFydC5zdHJpbmdzLCB0aGlzLm9wdGlvbnMpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0NFUG9seWZpbGwpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmFkb3B0Tm9kZShmcmFnbWVudCk7XG4gICAgICAgICAgICBjdXN0b21FbGVtZW50cy51cGdyYWRlKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGVtcGxhdGUtaW5zdGFuY2UuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBAbW9kdWxlIGxpdC1odG1sXG4gKi9cbmltcG9ydCB7IHJlcGFyZW50Tm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBib3VuZEF0dHJpYnV0ZVN1ZmZpeCwgbGFzdEF0dHJpYnV0ZU5hbWVSZWdleCwgbWFya2VyLCBub2RlTWFya2VyIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG5jb25zdCBjb21tZW50TWFya2VyID0gYCAke21hcmtlcn0gYDtcbi8qKlxuICogVGhlIHJldHVybiB0eXBlIG9mIGBodG1sYCwgd2hpY2ggaG9sZHMgYSBUZW1wbGF0ZSBhbmQgdGhlIHZhbHVlcyBmcm9tXG4gKiBpbnRlcnBvbGF0ZWQgZXhwcmVzc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgdmFsdWVzLCB0eXBlLCBwcm9jZXNzb3IpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIEhUTUwgdXNlZCB0byBjcmVhdGUgYSBgPHRlbXBsYXRlPmAgZWxlbWVudC5cbiAgICAgKi9cbiAgICBnZXRIVE1MKCkge1xuICAgICAgICBjb25zdCBsID0gdGhpcy5zdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBodG1sID0gJyc7XG4gICAgICAgIGxldCBpc0NvbW1lbnRCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5zdHJpbmdzW2ldO1xuICAgICAgICAgICAgLy8gRm9yIGVhY2ggYmluZGluZyB3ZSB3YW50IHRvIGRldGVybWluZSB0aGUga2luZCBvZiBtYXJrZXIgdG8gaW5zZXJ0XG4gICAgICAgICAgICAvLyBpbnRvIHRoZSB0ZW1wbGF0ZSBzb3VyY2UgYmVmb3JlIGl0J3MgcGFyc2VkIGJ5IHRoZSBicm93c2VyJ3MgSFRNTFxuICAgICAgICAgICAgLy8gcGFyc2VyLiBUaGUgbWFya2VyIHR5cGUgaXMgYmFzZWQgb24gd2hldGhlciB0aGUgZXhwcmVzc2lvbiBpcyBpbiBhblxuICAgICAgICAgICAgLy8gYXR0cmlidXRlLCB0ZXh0LCBvciBjb21tZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgLy8gICAqIEZvciBub2RlLXBvc2l0aW9uIGJpbmRpbmdzIHdlIGluc2VydCBhIGNvbW1lbnQgd2l0aCB0aGUgbWFya2VyXG4gICAgICAgICAgICAvLyAgICAgc2VudGluZWwgYXMgaXRzIHRleHQgY29udGVudCwgbGlrZSA8IS0te3tsaXQtZ3VpZH19LS0+LlxuICAgICAgICAgICAgLy8gICAqIEZvciBhdHRyaWJ1dGUgYmluZGluZ3Mgd2UgaW5zZXJ0IGp1c3QgdGhlIG1hcmtlciBzZW50aW5lbCBmb3IgdGhlXG4gICAgICAgICAgICAvLyAgICAgZmlyc3QgYmluZGluZywgc28gdGhhdCB3ZSBzdXBwb3J0IHVucXVvdGVkIGF0dHJpYnV0ZSBiaW5kaW5ncy5cbiAgICAgICAgICAgIC8vICAgICBTdWJzZXF1ZW50IGJpbmRpbmdzIGNhbiB1c2UgYSBjb21tZW50IG1hcmtlciBiZWNhdXNlIG11bHRpLWJpbmRpbmdcbiAgICAgICAgICAgIC8vICAgICBhdHRyaWJ1dGVzIG11c3QgYmUgcXVvdGVkLlxuICAgICAgICAgICAgLy8gICAqIEZvciBjb21tZW50IGJpbmRpbmdzIHdlIGluc2VydCBqdXN0IHRoZSBtYXJrZXIgc2VudGluZWwgc28gd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vICAgICBjbG9zZSB0aGUgY29tbWVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGNvZGUgc2NhbnMgdGhlIHRlbXBsYXRlIHNvdXJjZSwgYnV0IGlzICpub3QqIGFuIEhUTUxcbiAgICAgICAgICAgIC8vIHBhcnNlci4gV2UgZG9uJ3QgbmVlZCB0byB0cmFjayB0aGUgdHJlZSBzdHJ1Y3R1cmUgb2YgdGhlIEhUTUwsIG9ubHlcbiAgICAgICAgICAgIC8vIHdoZXRoZXIgYSBiaW5kaW5nIGlzIGluc2lkZSBhIGNvbW1lbnQsIGFuZCBpZiBub3QsIGlmIGl0IGFwcGVhcnMgdG8gYmVcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCBiaW5kaW5nIGluIGFuIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGNvbnN0IGNvbW1lbnRPcGVuID0gcy5sYXN0SW5kZXhPZignPCEtLScpO1xuICAgICAgICAgICAgLy8gV2UncmUgaW4gY29tbWVudCBwb3NpdGlvbiBpZiB3ZSBoYXZlIGEgY29tbWVudCBvcGVuIHdpdGggbm8gZm9sbG93aW5nXG4gICAgICAgICAgICAvLyBjb21tZW50IGNsb3NlLiBCZWNhdXNlIDwtLSBjYW4gYXBwZWFyIGluIGFuIGF0dHJpYnV0ZSB2YWx1ZSB0aGVyZSBjYW5cbiAgICAgICAgICAgIC8vIGJlIGZhbHNlIHBvc2l0aXZlcy5cbiAgICAgICAgICAgIGlzQ29tbWVudEJpbmRpbmcgPSAoY29tbWVudE9wZW4gPiAtMSB8fCBpc0NvbW1lbnRCaW5kaW5nKSAmJlxuICAgICAgICAgICAgICAgIHMuaW5kZXhPZignLS0+JywgY29tbWVudE9wZW4gKyAxKSA9PT0gLTE7XG4gICAgICAgICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhbiBhdHRyaWJ1dGUtbGlrZSBzZXF1ZW5jZSBwcmVjZWRpbmcgdGhlXG4gICAgICAgICAgICAvLyBleHByZXNzaW9uLiBUaGlzIGNhbiBtYXRjaCBcIm5hbWU9dmFsdWVcIiBsaWtlIHN0cnVjdHVyZXMgaW4gdGV4dCxcbiAgICAgICAgICAgIC8vIGNvbW1lbnRzLCBhbmQgYXR0cmlidXRlIHZhbHVlcywgc28gdGhlcmUgY2FuIGJlIGZhbHNlLXBvc2l0aXZlcy5cbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU1hdGNoID0gbGFzdEF0dHJpYnV0ZU5hbWVSZWdleC5leGVjKHMpO1xuICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZU1hdGNoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UncmUgb25seSBpbiB0aGlzIGJyYW5jaCBpZiB3ZSBkb24ndCBoYXZlIGEgYXR0cmlidXRlLWxpa2VcbiAgICAgICAgICAgICAgICAvLyBwcmVjZWRpbmcgc2VxdWVuY2UuIEZvciBjb21tZW50cywgdGhpcyBndWFyZHMgYWdhaW5zdCB1bnVzdWFsXG4gICAgICAgICAgICAgICAgLy8gYXR0cmlidXRlIHZhbHVlcyBsaWtlIDxkaXYgZm9vPVwiPCEtLSR7J2Jhcid9XCI+LiBDYXNlcyBsaWtlXG4gICAgICAgICAgICAgICAgLy8gPCEtLSBmb289JHsnYmFyJ30tLT4gYXJlIGhhbmRsZWQgY29ycmVjdGx5IGluIHRoZSBhdHRyaWJ1dGUgYnJhbmNoXG4gICAgICAgICAgICAgICAgLy8gYmVsb3cuXG4gICAgICAgICAgICAgICAgaHRtbCArPSBzICsgKGlzQ29tbWVudEJpbmRpbmcgPyBjb21tZW50TWFya2VyIDogbm9kZU1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGb3IgYXR0cmlidXRlcyB3ZSB1c2UganVzdCBhIG1hcmtlciBzZW50aW5lbCwgYW5kIGFsc28gYXBwZW5kIGFcbiAgICAgICAgICAgICAgICAvLyAkbGl0JCBzdWZmaXggdG8gdGhlIG5hbWUgdG8gb3B0LW91dCBvZiBhdHRyaWJ1dGUtc3BlY2lmaWMgcGFyc2luZ1xuICAgICAgICAgICAgICAgIC8vIHRoYXQgSUUgYW5kIEVkZ2UgZG8gZm9yIHN0eWxlIGFuZCBjZXJ0YWluIFNWRyBhdHRyaWJ1dGVzLlxuICAgICAgICAgICAgICAgIGh0bWwgKz0gcy5zdWJzdHIoMCwgYXR0cmlidXRlTWF0Y2guaW5kZXgpICsgYXR0cmlidXRlTWF0Y2hbMV0gK1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVNYXRjaFsyXSArIGJvdW5kQXR0cmlidXRlU3VmZml4ICsgYXR0cmlidXRlTWF0Y2hbM10gK1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaHRtbCArPSB0aGlzLnN0cmluZ3NbbF07XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICBnZXRUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGVtcGxhdGUuaW5uZXJIVE1MID0gdGhpcy5nZXRIVE1MKCk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG59XG4vKipcbiAqIEEgVGVtcGxhdGVSZXN1bHQgZm9yIFNWRyBmcmFnbWVudHMuXG4gKlxuICogVGhpcyBjbGFzcyB3cmFwcyBIVE1MIGluIGFuIGA8c3ZnPmAgdGFnIGluIG9yZGVyIHRvIHBhcnNlIGl0cyBjb250ZW50cyBpbiB0aGVcbiAqIFNWRyBuYW1lc3BhY2UsIHRoZW4gbW9kaWZpZXMgdGhlIHRlbXBsYXRlIHRvIHJlbW92ZSB0aGUgYDxzdmc+YCB0YWcgc28gdGhhdFxuICogY2xvbmVzIG9ubHkgY29udGFpbmVyIHRoZSBvcmlnaW5hbCBmcmFnbWVudC5cbiAqL1xuZXhwb3J0IGNsYXNzIFNWR1RlbXBsYXRlUmVzdWx0IGV4dGVuZHMgVGVtcGxhdGVSZXN1bHQge1xuICAgIGdldEhUTUwoKSB7XG4gICAgICAgIHJldHVybiBgPHN2Zz4ke3N1cGVyLmdldEhUTUwoKX08L3N2Zz5gO1xuICAgIH1cbiAgICBnZXRUZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gc3VwZXIuZ2V0VGVtcGxhdGVFbGVtZW50KCk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0ZW1wbGF0ZS5jb250ZW50O1xuICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICBjb250ZW50LnJlbW92ZUNoaWxkKHN2Z0VsZW1lbnQpO1xuICAgICAgICByZXBhcmVudE5vZGVzKGNvbnRlbnQsIHN2Z0VsZW1lbnQuZmlyc3RDaGlsZCk7XG4gICAgICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1yZXN1bHQuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBAbW9kdWxlIGxpdC1odG1sXG4gKi9cbmltcG9ydCB7IGlzRGlyZWN0aXZlIH0gZnJvbSAnLi9kaXJlY3RpdmUuanMnO1xuaW1wb3J0IHsgcmVtb3ZlTm9kZXMgfSBmcm9tICcuL2RvbS5qcyc7XG5pbXBvcnQgeyBub0NoYW5nZSwgbm90aGluZyB9IGZyb20gJy4vcGFydC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlIH0gZnJvbSAnLi90ZW1wbGF0ZS1pbnN0YW5jZS5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vdGVtcGxhdGUtcmVzdWx0LmpzJztcbmltcG9ydCB7IGNyZWF0ZU1hcmtlciB9IGZyb20gJy4vdGVtcGxhdGUuanMnO1xuZXhwb3J0IGNvbnN0IGlzUHJpbWl0aXZlID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSk7XG59O1xuZXhwb3J0IGNvbnN0IGlzSXRlcmFibGUgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHxcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgISEodmFsdWUgJiYgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSk7XG59O1xuLyoqXG4gKiBXcml0ZXMgYXR0cmlidXRlIHZhbHVlcyB0byB0aGUgRE9NIGZvciBhIGdyb3VwIG9mIEF0dHJpYnV0ZVBhcnRzIGJvdW5kIHRvIGFcbiAqIHNpbmdsZSBhdHRyaWJ1dGUuIFRoZSB2YWx1ZSBpcyBvbmx5IHNldCBvbmNlIGV2ZW4gaWYgdGhlcmUgYXJlIG11bHRpcGxlIHBhcnRzXG4gKiBmb3IgYW4gYXR0cmlidXRlLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlQ29tbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucGFydHNbaV0gPSB0aGlzLl9jcmVhdGVQYXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNpbmdsZSBwYXJ0LiBPdmVycmlkZSB0aGlzIHRvIGNyZWF0ZSBhIGRpZmZlcm50IHR5cGUgb2YgcGFydC5cbiAgICAgKi9cbiAgICBfY3JlYXRlUGFydCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQYXJ0KHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIGNvbnN0IGwgPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICBjb25zdCBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcbiAgICAgICAgICAgIGlmIChwYXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gcGFydC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmltaXRpdmUodikgfHwgIWlzSXRlcmFibGUodikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0eXBlb2YgdiA9PT0gJ3N0cmluZycgPyB2IDogU3RyaW5nKHYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdHlwZW9mIHQgPT09ICdzdHJpbmcnID8gdCA6IFN0cmluZyh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0ZXh0ICs9IHN0cmluZ3NbbF07XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgdGhpcy5fZ2V0VmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEEgUGFydCB0aGF0IGNvbnRyb2xzIGFsbCBvciBwYXJ0IG9mIGFuIGF0dHJpYnV0ZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbW1pdHRlcikge1xuICAgICAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmNvbW1pdHRlciA9IGNvbW1pdHRlcjtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBub0NoYW5nZSAmJiAoIWlzUHJpbWl0aXZlKHZhbHVlKSB8fCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBpcyBhIG5vdCBhIGRpcmVjdGl2ZSwgZGlydHkgdGhlIGNvbW1pdHRlciBzbyB0aGF0IGl0J2xsXG4gICAgICAgICAgICAvLyBjYWxsIHNldEF0dHJpYnV0ZS4gSWYgdGhlIHZhbHVlIGlzIGEgZGlyZWN0aXZlLCBpdCdsbCBkaXJ0eSB0aGVcbiAgICAgICAgICAgIC8vIGNvbW1pdHRlciBpZiBpdCBjYWxscyBzZXRWYWx1ZSgpLlxuICAgICAgICAgICAgaWYgKCFpc0RpcmVjdGl2ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1pdHRlci5kaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICB3aGlsZSAoaXNEaXJlY3RpdmUodGhpcy52YWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGl2ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gbm9DaGFuZ2U7XG4gICAgICAgICAgICBkaXJlY3RpdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IG5vQ2hhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21taXR0ZXIuY29tbWl0KCk7XG4gICAgfVxufVxuLyoqXG4gKiBBIFBhcnQgdGhhdCBjb250cm9scyBhIGxvY2F0aW9uIHdpdGhpbiBhIE5vZGUgdHJlZS4gTGlrZSBhIFJhbmdlLCBOb2RlUGFydFxuICogaGFzIHN0YXJ0IGFuZCBlbmQgbG9jYXRpb25zIGFuZCBjYW4gc2V0IGFuZCB1cGRhdGUgdGhlIE5vZGVzIGJldHdlZW4gdGhvc2VcbiAqIGxvY2F0aW9ucy5cbiAqXG4gKiBOb2RlUGFydHMgc3VwcG9ydCBzZXZlcmFsIHZhbHVlIHR5cGVzOiBwcmltaXRpdmVzLCBOb2RlcywgVGVtcGxhdGVSZXN1bHRzLFxuICogYXMgd2VsbCBhcyBhcnJheXMgYW5kIGl0ZXJhYmxlcyBvZiB0aG9zZSB0eXBlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIE5vZGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGVuZHMgdGhpcyBwYXJ0IGludG8gYSBjb250YWluZXIuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBhcHBlbmRJbnRvKGNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVNYXJrZXIoKSk7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IGNvbnRhaW5lci5hcHBlbmRDaGlsZChjcmVhdGVNYXJrZXIoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluc2VydHMgdGhpcyBwYXJ0IGFmdGVyIHRoZSBgcmVmYCBub2RlIChiZXR3ZWVuIGByZWZgIGFuZCBgcmVmYCdzIG5leHRcbiAgICAgKiBzaWJsaW5nKS4gQm90aCBgcmVmYCBhbmQgaXRzIG5leHQgc2libGluZyBtdXN0IGJlIHN0YXRpYywgdW5jaGFuZ2luZyBub2Rlc1xuICAgICAqIHN1Y2ggYXMgdGhvc2UgdGhhdCBhcHBlYXIgaW4gYSBsaXRlcmFsIHNlY3Rpb24gb2YgYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIFRoaXMgcGFydCBtdXN0IGJlIGVtcHR5LCBhcyBpdHMgY29udGVudHMgYXJlIG5vdCBhdXRvbWF0aWNhbGx5IG1vdmVkLlxuICAgICAqL1xuICAgIGluc2VydEFmdGVyTm9kZShyZWYpIHtcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSByZWY7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IHJlZi5uZXh0U2libGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0aGlzIHBhcnQgaW50byBhIHBhcmVudCBwYXJ0LlxuICAgICAqXG4gICAgICogVGhpcyBwYXJ0IG11c3QgYmUgZW1wdHksIGFzIGl0cyBjb250ZW50cyBhcmUgbm90IGF1dG9tYXRpY2FsbHkgbW92ZWQuXG4gICAgICovXG4gICAgYXBwZW5kSW50b1BhcnQocGFydCkge1xuICAgICAgICBwYXJ0Ll9faW5zZXJ0KHRoaXMuc3RhcnROb2RlID0gY3JlYXRlTWFya2VyKCkpO1xuICAgICAgICBwYXJ0Ll9faW5zZXJ0KHRoaXMuZW5kTm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB0aGlzIHBhcnQgYWZ0ZXIgdGhlIGByZWZgIHBhcnQuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhcnQgbXVzdCBiZSBlbXB0eSwgYXMgaXRzIGNvbnRlbnRzIGFyZSBub3QgYXV0b21hdGljYWxseSBtb3ZlZC5cbiAgICAgKi9cbiAgICBpbnNlcnRBZnRlclBhcnQocmVmKSB7XG4gICAgICAgIHJlZi5fX2luc2VydCh0aGlzLnN0YXJ0Tm9kZSA9IGNyZWF0ZU1hcmtlcigpKTtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gcmVmLmVuZE5vZGU7XG4gICAgICAgIHJlZi5lbmROb2RlID0gdGhpcy5zdGFydE5vZGU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY29tbWl0KCkge1xuICAgICAgICBpZiAodGhpcy5zdGFydE5vZGUucGFyZW50Tm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpc0RpcmVjdGl2ZSh0aGlzLl9fcGVuZGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZGlyZWN0aXZlID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuX19wZW5kaW5nVmFsdWUgPSBub0NoYW5nZTtcbiAgICAgICAgICAgIGRpcmVjdGl2ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX19wZW5kaW5nVmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbm9DaGFuZ2UpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcmltaXRpdmUodmFsdWUpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IHRoaXMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9fY29tbWl0VGV4dCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX19jb21taXROb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0l0ZXJhYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gbm90aGluZykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IG5vdGhpbmc7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjaywgd2lsbCByZW5kZXIgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdFRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9faW5zZXJ0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5lbmROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMuZW5kTm9kZSk7XG4gICAgfVxuICAgIF9fY29tbWl0Tm9kZSh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX19pbnNlcnQodmFsdWUpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9fY29tbWl0VGV4dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgPT0gbnVsbCA/ICcnIDogdmFsdWU7XG4gICAgICAgIC8vIElmIGB2YWx1ZWAgaXNuJ3QgYWxyZWFkeSBhIHN0cmluZywgd2UgZXhwbGljaXRseSBjb252ZXJ0IGl0IGhlcmUgaW4gY2FzZVxuICAgICAgICAvLyBpdCBjYW4ndCBiZSBpbXBsaWNpdGx5IGNvbnZlcnRlZCAtIGkuZS4gaXQncyBhIHN5bWJvbC5cbiAgICAgICAgY29uc3QgdmFsdWVBc1N0cmluZyA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyB2YWx1ZSA6IFN0cmluZyh2YWx1ZSk7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nICYmXG4gICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBvbmx5IGhhdmUgYSBzaW5nbGUgdGV4dCBub2RlIGJldHdlZW4gdGhlIG1hcmtlcnMsIHdlIGNhbiBqdXN0XG4gICAgICAgICAgICAvLyBzZXQgaXRzIHZhbHVlLCByYXRoZXIgdGhhbiByZXBsYWNpbmcgaXQuXG4gICAgICAgICAgICAvLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBDYW4gd2UganVzdCBjaGVjayBpZiB0aGlzLnZhbHVlIGlzIHByaW1pdGl2ZT9cbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlQXNTdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fY29tbWl0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZUFzU3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfX2NvbW1pdFRlbXBsYXRlUmVzdWx0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5vcHRpb25zLnRlbXBsYXRlRmFjdG9yeSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVJbnN0YW5jZSAmJlxuICAgICAgICAgICAgdGhpcy52YWx1ZS50ZW1wbGF0ZSA9PT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUudXBkYXRlKHZhbHVlLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgd2UgcHJvcGFnYXRlIHRoZSB0ZW1wbGF0ZSBwcm9jZXNzb3IgZnJvbSB0aGUgVGVtcGxhdGVSZXN1bHRcbiAgICAgICAgICAgIC8vIHNvIHRoYXQgd2UgdXNlIGl0cyBzeW50YXggZXh0ZW5zaW9uLCBldGMuIFRoZSB0ZW1wbGF0ZSBmYWN0b3J5IGNvbWVzXG4gICAgICAgICAgICAvLyBmcm9tIHRoZSByZW5kZXIgZnVuY3Rpb24gb3B0aW9ucyBzbyB0aGF0IGl0IGNhbiBjb250cm9sIHRlbXBsYXRlXG4gICAgICAgICAgICAvLyBjYWNoaW5nIGFuZCBwcmVwcm9jZXNzaW5nLlxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZSh0ZW1wbGF0ZSwgdmFsdWUucHJvY2Vzc29yLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBpbnN0YW5jZS5fY2xvbmUoKTtcbiAgICAgICAgICAgIGluc3RhbmNlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgICAgICAgICAgdGhpcy5fX2NvbW1pdE5vZGUoZnJhZ21lbnQpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9fY29tbWl0SXRlcmFibGUodmFsdWUpIHtcbiAgICAgICAgLy8gRm9yIGFuIEl0ZXJhYmxlLCB3ZSBjcmVhdGUgYSBuZXcgSW5zdGFuY2VQYXJ0IHBlciBpdGVtLCB0aGVuIHNldCBpdHNcbiAgICAgICAgLy8gdmFsdWUgdG8gdGhlIGl0ZW0uIFRoaXMgaXMgYSBsaXR0bGUgYml0IG9mIG92ZXJoZWFkIGZvciBldmVyeSBpdGVtIGluXG4gICAgICAgIC8vIGFuIEl0ZXJhYmxlLCBidXQgaXQgbGV0cyB1cyByZWN1cnNlIGVhc2lseSBhbmQgZWZmaWNpZW50bHkgdXBkYXRlIEFycmF5c1xuICAgICAgICAvLyBvZiBUZW1wbGF0ZVJlc3VsdHMgdGhhdCB3aWxsIGJlIGNvbW1vbmx5IHJldHVybmVkIGZyb20gZXhwcmVzc2lvbnMgbGlrZTpcbiAgICAgICAgLy8gYXJyYXkubWFwKChpKSA9PiBodG1sYCR7aX1gKSwgYnkgcmV1c2luZyBleGlzdGluZyBUZW1wbGF0ZUluc3RhbmNlcy5cbiAgICAgICAgLy8gSWYgX3ZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG9mIGFuXG4gICAgICAgIC8vIGl0ZXJhYmxlIGFuZCBfdmFsdWUgd2lsbCBjb250YWluIHRoZSBOb2RlUGFydHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJZiBfdmFsdWUgaXMgbm90IGFuIGFycmF5LCBjbGVhciB0aGlzIHBhcnQgYW5kIG1ha2UgYSBuZXdcbiAgICAgICAgLy8gYXJyYXkgZm9yIE5vZGVQYXJ0cy5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGl0ZW1zIHdlIHN0YW1wZWQgc28gd2UgY2FuIGNsZWFyIGxlZnRvdmVyXG4gICAgICAgIC8vIGl0ZW1zIGZyb20gYSBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgY29uc3QgaXRlbVBhcnRzID0gdGhpcy52YWx1ZTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGxldCBpdGVtUGFydDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmV1c2UgYW4gZXhpc3RpbmcgcGFydFxuICAgICAgICAgICAgaXRlbVBhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIHBhcnQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgIGlmIChpdGVtUGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnQgPSBuZXcgTm9kZVBhcnQodGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgICAgICBpdGVtUGFydHMucHVzaChpdGVtUGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtUGFydC5hcHBlbmRJbnRvUGFydCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1QYXJ0Lmluc2VydEFmdGVyUGFydChpdGVtUGFydHNbcGFydEluZGV4IC0gMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1QYXJ0LnNldFZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbVBhcnQuY29tbWl0KCk7XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEluZGV4IDwgaXRlbVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIHBhcnRzIGFycmF5IHNvIF92YWx1ZSByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgaXRlbVBhcnRzLmxlbmd0aCA9IHBhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoaXRlbVBhcnQgJiYgaXRlbVBhcnQuZW5kTm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYXIoc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUpIHtcbiAgICAgICAgcmVtb3ZlTm9kZXModGhpcy5zdGFydE5vZGUucGFyZW50Tm9kZSwgc3RhcnROb2RlLm5leHRTaWJsaW5nLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbn1cbi8qKlxuICogSW1wbGVtZW50cyBhIGJvb2xlYW4gYXR0cmlidXRlLCByb3VnaGx5IGFzIGRlZmluZWQgaW4gdGhlIEhUTUxcbiAqIHNwZWNpZmljYXRpb24uXG4gKlxuICogSWYgdGhlIHZhbHVlIGlzIHRydXRoeSwgdGhlbiB0aGUgYXR0cmlidXRlIGlzIHByZXNlbnQgd2l0aCBhIHZhbHVlIG9mXG4gKiAnJy4gSWYgdGhlIHZhbHVlIGlzIGZhbHNleSwgdGhlIGF0dHJpYnV0ZSBpcyByZW1vdmVkLlxuICovXG5leHBvcnQgY2xhc3MgQm9vbGVhbkF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoICE9PSAyIHx8IHN0cmluZ3NbMF0gIT09ICcnIHx8IHN0cmluZ3NbMV0gIT09ICcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jvb2xlYW4gYXR0cmlidXRlcyBjYW4gb25seSBjb250YWluIGEgc2luZ2xlIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1ZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gISF0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCAnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKHRoaXMubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgIH1cbn1cbi8qKlxuICogU2V0cyBhdHRyaWJ1dGUgdmFsdWVzIGZvciBQcm9wZXJ0eVBhcnRzLCBzbyB0aGF0IHRoZSB2YWx1ZSBpcyBvbmx5IHNldCBvbmNlXG4gKiBldmVuIGlmIHRoZXJlIGFyZSBtdWx0aXBsZSBwYXJ0cyBmb3IgYSBwcm9wZXJ0eS5cbiAqXG4gKiBJZiBhbiBleHByZXNzaW9uIGNvbnRyb2xzIHRoZSB3aG9sZSBwcm9wZXJ0eSB2YWx1ZSwgdGhlbiB0aGUgdmFsdWUgaXMgc2ltcGx5XG4gKiBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgdW5kZXIgY29udHJvbC4gSWYgdGhlcmUgYXJlIHN0cmluZyBsaXRlcmFscyBvclxuICogbXVsdGlwbGUgZXhwcmVzc2lvbnMsIHRoZW4gdGhlIHN0cmluZ3MgYXJlIGV4cHJlc3Npb25zIGFyZSBpbnRlcnBvbGF0ZWQgaW50b1xuICogYSBzdHJpbmcgZmlyc3QuXG4gKi9cbmV4cG9ydCBjbGFzcyBQcm9wZXJ0eUNvbW1pdHRlciBleHRlbmRzIEF0dHJpYnV0ZUNvbW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICBzdXBlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgdGhpcy5zaW5nbGUgPVxuICAgICAgICAgICAgKHN0cmluZ3MubGVuZ3RoID09PSAyICYmIHN0cmluZ3NbMF0gPT09ICcnICYmIHN0cmluZ3NbMV0gPT09ICcnKTtcbiAgICB9XG4gICAgX2NyZWF0ZVBhcnQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcGVydHlQYXJ0KHRoaXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFydHNbMF0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLl9nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpcnR5KSB7XG4gICAgICAgICAgICB0aGlzLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgdGhpcy5lbGVtZW50W3RoaXMubmFtZV0gPSB0aGlzLl9nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFByb3BlcnR5UGFydCBleHRlbmRzIEF0dHJpYnV0ZVBhcnQge1xufVxuLy8gRGV0ZWN0IGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgc3VwcG9ydC4gSWYgdGhlIGBjYXB0dXJlYCBwcm9wZXJ0eSBpcyByZWFkXG4vLyBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCwgdGhlbiBvcHRpb25zIGFyZSBzdXBwb3J0ZWQuIElmIG5vdCwgdGhlbiB0aGUgdGhpcmRcbi8vIGFyZ3VtZW50IHRvIGFkZC9yZW1vdmVFdmVudExpc3RlbmVyIGlzIGludGVycHJldGVkIGFzIHRoZSBib29sZWFuIGNhcHR1cmVcbi8vIHZhbHVlIHNvIHdlIHNob3VsZCBvbmx5IHBhc3MgdGhlIGBjYXB0dXJlYCBwcm9wZXJ0eS5cbmxldCBldmVudE9wdGlvbnNTdXBwb3J0ZWQgPSBmYWxzZTtcbi8vIFdyYXAgaW50byBhbiBJSUZFIGJlY2F1c2UgTVMgRWRnZSA8PSB2NDEgZG9lcyBub3Qgc3VwcG9ydCBoYXZpbmcgdHJ5L2NhdGNoXG4vLyBibG9ja3MgcmlnaHQgaW50byB0aGUgYm9keSBvZiBhIG1vZHVsZVxuKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgZ2V0IGNhcHR1cmUoKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRPcHRpb25zU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0Jywgb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChfZSkge1xuICAgICAgICAvLyBldmVudCBvcHRpb25zIG5vdCBzdXBwb3J0ZWRcbiAgICB9XG59KSgpO1xuZXhwb3J0IGNsYXNzIEV2ZW50UGFydCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZXZlbnROYW1lLCBldmVudENvbnRleHQpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5ldmVudE5hbWUgPSBldmVudE5hbWU7XG4gICAgICAgIHRoaXMuZXZlbnRDb250ZXh0ID0gZXZlbnRDb250ZXh0O1xuICAgICAgICB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCA9IChlKSA9PiB0aGlzLmhhbmRsZUV2ZW50KGUpO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9fcGVuZGluZ1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbW1pdCgpIHtcbiAgICAgICAgd2hpbGUgKGlzRGlyZWN0aXZlKHRoaXMuX19wZW5kaW5nVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3RpdmUgPSB0aGlzLl9fcGVuZGluZ1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgICAgICAgICAgZGlyZWN0aXZlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9fcGVuZGluZ1ZhbHVlID09PSBub0NoYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0xpc3RlbmVyID0gdGhpcy5fX3BlbmRpbmdWYWx1ZTtcbiAgICAgICAgY29uc3Qgb2xkTGlzdGVuZXIgPSB0aGlzLnZhbHVlO1xuICAgICAgICBjb25zdCBzaG91bGRSZW1vdmVMaXN0ZW5lciA9IG5ld0xpc3RlbmVyID09IG51bGwgfHxcbiAgICAgICAgICAgIG9sZExpc3RlbmVyICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICAobmV3TGlzdGVuZXIuY2FwdHVyZSAhPT0gb2xkTGlzdGVuZXIuY2FwdHVyZSB8fFxuICAgICAgICAgICAgICAgICAgICBuZXdMaXN0ZW5lci5vbmNlICE9PSBvbGRMaXN0ZW5lci5vbmNlIHx8XG4gICAgICAgICAgICAgICAgICAgIG5ld0xpc3RlbmVyLnBhc3NpdmUgIT09IG9sZExpc3RlbmVyLnBhc3NpdmUpO1xuICAgICAgICBjb25zdCBzaG91bGRBZGRMaXN0ZW5lciA9IG5ld0xpc3RlbmVyICE9IG51bGwgJiYgKG9sZExpc3RlbmVyID09IG51bGwgfHwgc2hvdWxkUmVtb3ZlTGlzdGVuZXIpO1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCwgdGhpcy5fX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaG91bGRBZGRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdGhpcy5fX29wdGlvbnMgPSBnZXRPcHRpb25zKG5ld0xpc3RlbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLl9fYm91bmRIYW5kbGVFdmVudCwgdGhpcy5fX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWUgPSBuZXdMaXN0ZW5lcjtcbiAgICAgICAgdGhpcy5fX3BlbmRpbmdWYWx1ZSA9IG5vQ2hhbmdlO1xuICAgIH1cbiAgICBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuY2FsbCh0aGlzLmV2ZW50Q29udGV4dCB8fCB0aGlzLmVsZW1lbnQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmFsdWUuaGFuZGxlRXZlbnQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gV2UgY29weSBvcHRpb25zIGJlY2F1c2Ugb2YgdGhlIGluY29uc2lzdGVudCBiZWhhdmlvciBvZiBicm93c2VycyB3aGVuIHJlYWRpbmdcbi8vIHRoZSB0aGlyZCBhcmd1bWVudCBvZiBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lci4gSUUxMSBkb2Vzbid0IHN1cHBvcnQgb3B0aW9uc1xuLy8gYXQgYWxsLiBDaHJvbWUgNDEgb25seSByZWFkcyBgY2FwdHVyZWAgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIG9iamVjdC5cbmNvbnN0IGdldE9wdGlvbnMgPSAobykgPT4gbyAmJlxuICAgIChldmVudE9wdGlvbnNTdXBwb3J0ZWQgP1xuICAgICAgICB7IGNhcHR1cmU6IG8uY2FwdHVyZSwgcGFzc2l2ZTogby5wYXNzaXZlLCBvbmNlOiBvLm9uY2UgfSA6XG4gICAgICAgIG8uY2FwdHVyZSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJ0cy5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5pbXBvcnQgeyBtYXJrZXIsIFRlbXBsYXRlIH0gZnJvbSAnLi90ZW1wbGF0ZS5qcyc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IFRlbXBsYXRlRmFjdG9yeSB3aGljaCBjYWNoZXMgVGVtcGxhdGVzIGtleWVkIG9uXG4gKiByZXN1bHQudHlwZSBhbmQgcmVzdWx0LnN0cmluZ3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUZhY3RvcnkocmVzdWx0KSB7XG4gICAgbGV0IHRlbXBsYXRlQ2FjaGUgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQocmVzdWx0LnR5cGUpO1xuICAgIGlmICh0ZW1wbGF0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZSA9IHtcbiAgICAgICAgICAgIHN0cmluZ3NBcnJheTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgIGtleVN0cmluZzogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRlbXBsYXRlQ2FjaGVzLnNldChyZXN1bHQudHlwZSwgdGVtcGxhdGVDYWNoZSk7XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgVGVtcGxhdGVTdHJpbmdzQXJyYXkgaXMgbmV3LCBnZW5lcmF0ZSBhIGtleSBmcm9tIHRoZSBzdHJpbmdzXG4gICAgLy8gVGhpcyBrZXkgaXMgc2hhcmVkIGJldHdlZW4gYWxsIHRlbXBsYXRlcyB3aXRoIGlkZW50aWNhbCBjb250ZW50XG4gICAgY29uc3Qga2V5ID0gcmVzdWx0LnN0cmluZ3Muam9pbihtYXJrZXIpO1xuICAgIC8vIENoZWNrIGlmIHdlIGFscmVhZHkgaGF2ZSBhIFRlbXBsYXRlIGZvciB0aGlzIGtleVxuICAgIHRlbXBsYXRlID0gdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuZ2V0KGtleSk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBub3Qgc2VlbiB0aGlzIGtleSBiZWZvcmUsIGNyZWF0ZSBhIG5ldyBUZW1wbGF0ZVxuICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZShyZXN1bHQsIHJlc3VsdC5nZXRUZW1wbGF0ZUVsZW1lbnQoKSk7XG4gICAgICAgIC8vIENhY2hlIHRoZSBUZW1wbGF0ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgdGVtcGxhdGVDYWNoZS5rZXlTdHJpbmcuc2V0KGtleSwgdGVtcGxhdGUpO1xuICAgIH1cbiAgICAvLyBDYWNoZSBhbGwgZnV0dXJlIHF1ZXJpZXMgZm9yIHRoaXMgVGVtcGxhdGVTdHJpbmdzQXJyYXlcbiAgICB0ZW1wbGF0ZUNhY2hlLnN0cmluZ3NBcnJheS5zZXQocmVzdWx0LnN0cmluZ3MsIHRlbXBsYXRlKTtcbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5leHBvcnQgY29uc3QgdGVtcGxhdGVDYWNoZXMgPSBuZXcgTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD10ZW1wbGF0ZS1mYWN0b3J5LmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogQG1vZHVsZSBsaXQtaHRtbFxuICovXG5pbXBvcnQgeyByZW1vdmVOb2RlcyB9IGZyb20gJy4vZG9tLmpzJztcbmltcG9ydCB7IE5vZGVQYXJ0IH0gZnJvbSAnLi9wYXJ0cy5qcyc7XG5pbXBvcnQgeyB0ZW1wbGF0ZUZhY3RvcnkgfSBmcm9tICcuL3RlbXBsYXRlLWZhY3RvcnkuanMnO1xuZXhwb3J0IGNvbnN0IHBhcnRzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogUmVuZGVycyBhIHRlbXBsYXRlIHJlc3VsdCBvciBvdGhlciB2YWx1ZSB0byBhIGNvbnRhaW5lci5cbiAqXG4gKiBUbyB1cGRhdGUgYSBjb250YWluZXIgd2l0aCBuZXcgdmFsdWVzLCByZWV2YWx1YXRlIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIGFuZFxuICogY2FsbCBgcmVuZGVyYCB3aXRoIHRoZSBuZXcgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSByZXN1bHQgQW55IHZhbHVlIHJlbmRlcmFibGUgYnkgTm9kZVBhcnQgLSB0eXBpY2FsbHkgYSBUZW1wbGF0ZVJlc3VsdFxuICogICAgIGNyZWF0ZWQgYnkgZXZhbHVhdGluZyBhIHRlbXBsYXRlIHRhZyBsaWtlIGBodG1sYCBvciBgc3ZnYC5cbiAqIEBwYXJhbSBjb250YWluZXIgQSBET00gcGFyZW50IHRvIHJlbmRlciB0by4gVGhlIGVudGlyZSBjb250ZW50cyBhcmUgZWl0aGVyXG4gKiAgICAgcmVwbGFjZWQsIG9yIGVmZmljaWVudGx5IHVwZGF0ZWQgaWYgdGhlIHNhbWUgcmVzdWx0IHR5cGUgd2FzIHByZXZpb3VzXG4gKiAgICAgcmVuZGVyZWQgdGhlcmUuXG4gKiBAcGFyYW0gb3B0aW9ucyBSZW5kZXJPcHRpb25zIGZvciB0aGUgZW50aXJlIHJlbmRlciB0cmVlIHJlbmRlcmVkIHRvIHRoaXNcbiAqICAgICBjb250YWluZXIuIFJlbmRlciBvcHRpb25zIG11c3QgKm5vdCogY2hhbmdlIGJldHdlZW4gcmVuZGVycyB0byB0aGUgc2FtZVxuICogICAgIGNvbnRhaW5lciwgYXMgdGhvc2UgY2hhbmdlcyB3aWxsIG5vdCBlZmZlY3QgcHJldmlvdXNseSByZW5kZXJlZCBET00uXG4gKi9cbmV4cG9ydCBjb25zdCByZW5kZXIgPSAocmVzdWx0LCBjb250YWluZXIsIG9wdGlvbnMpID0+IHtcbiAgICBsZXQgcGFydCA9IHBhcnRzLmdldChjb250YWluZXIpO1xuICAgIGlmIChwYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmVtb3ZlTm9kZXMoY29udGFpbmVyLCBjb250YWluZXIuZmlyc3RDaGlsZCk7XG4gICAgICAgIHBhcnRzLnNldChjb250YWluZXIsIHBhcnQgPSBuZXcgTm9kZVBhcnQoT2JqZWN0LmFzc2lnbih7IHRlbXBsYXRlRmFjdG9yeSB9LCBvcHRpb25zKSkpO1xuICAgICAgICBwYXJ0LmFwcGVuZEludG8oY29udGFpbmVyKTtcbiAgICB9XG4gICAgcGFydC5zZXRWYWx1ZShyZXN1bHQpO1xuICAgIHBhcnQuY29tbWl0KCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVuZGVyLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IEF0dHJpYnV0ZUNvbW1pdHRlciwgQm9vbGVhbkF0dHJpYnV0ZVBhcnQsIEV2ZW50UGFydCwgTm9kZVBhcnQsIFByb3BlcnR5Q29tbWl0dGVyIH0gZnJvbSAnLi9wYXJ0cy5qcyc7XG4vKipcbiAqIENyZWF0ZXMgUGFydHMgd2hlbiBhIHRlbXBsYXRlIGlzIGluc3RhbnRpYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhbiBhdHRyaWJ1dGUtcG9zaXRpb24gYmluZGluZywgZ2l2ZW4gdGhlIGV2ZW50LCBhdHRyaWJ1dGVcbiAgICAgKiBuYW1lLCBhbmQgc3RyaW5nIGxpdGVyYWxzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVsZW1lbnQgVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgYmluZGluZ1xuICAgICAqIEBwYXJhbSBuYW1lICBUaGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0gc3RyaW5ncyBUaGUgc3RyaW5nIGxpdGVyYWxzLiBUaGVyZSBhcmUgYWx3YXlzIGF0IGxlYXN0IHR3byBzdHJpbmdzLFxuICAgICAqICAgZXZlbnQgZm9yIGZ1bGx5LWNvbnRyb2xsZWQgYmluZGluZ3Mgd2l0aCBhIHNpbmdsZSBleHByZXNzaW9uLlxuICAgICAqL1xuICAgIGhhbmRsZUF0dHJpYnV0ZUV4cHJlc3Npb25zKGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gbmFtZVswXTtcbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBjb25zdCBjb21taXR0ZXIgPSBuZXcgUHJvcGVydHlDb21taXR0ZXIoZWxlbWVudCwgbmFtZS5zbGljZSgxKSwgc3RyaW5ncyk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWl0dGVyLnBhcnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmVmaXggPT09ICdAJykge1xuICAgICAgICAgICAgcmV0dXJuIFtuZXcgRXZlbnRQYXJ0KGVsZW1lbnQsIG5hbWUuc2xpY2UoMSksIG9wdGlvbnMuZXZlbnRDb250ZXh0KV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeCA9PT0gJz8nKSB7XG4gICAgICAgICAgICByZXR1cm4gW25ldyBCb29sZWFuQXR0cmlidXRlUGFydChlbGVtZW50LCBuYW1lLnNsaWNlKDEpLCBzdHJpbmdzKV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tbWl0dGVyID0gbmV3IEF0dHJpYnV0ZUNvbW1pdHRlcihlbGVtZW50LCBuYW1lLCBzdHJpbmdzKTtcbiAgICAgICAgcmV0dXJuIGNvbW1pdHRlci5wYXJ0cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIHBhcnRzIGZvciBhIHRleHQtcG9zaXRpb24gYmluZGluZy5cbiAgICAgKiBAcGFyYW0gdGVtcGxhdGVGYWN0b3J5XG4gICAgICovXG4gICAgaGFuZGxlVGV4dEV4cHJlc3Npb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQYXJ0KG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IgPSBuZXcgRGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LXRlbXBsYXRlLXByb2Nlc3Nvci5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqXG4gKiBNYWluIGxpdC1odG1sIG1vZHVsZS5cbiAqXG4gKiBNYWluIGV4cG9ydHM6XG4gKlxuICogLSAgW1todG1sXV1cbiAqIC0gIFtbc3ZnXV1cbiAqIC0gIFtbcmVuZGVyXV1cbiAqXG4gKiBAbW9kdWxlIGxpdC1odG1sXG4gKiBAcHJlZmVycmVkXG4gKi9cbi8qKlxuICogRG8gbm90IHJlbW92ZSB0aGlzIGNvbW1lbnQ7IGl0IGtlZXBzIHR5cGVkb2MgZnJvbSBtaXNwbGFjaW5nIHRoZSBtb2R1bGVcbiAqIGRvY3MuXG4gKi9cbmltcG9ydCB7IGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmltcG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBEZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IsIGRlZmF1bHRUZW1wbGF0ZVByb2Nlc3NvciB9IGZyb20gJy4vbGliL2RlZmF1bHQtdGVtcGxhdGUtcHJvY2Vzc29yLmpzJztcbmV4cG9ydCB7IGRpcmVjdGl2ZSwgaXNEaXJlY3RpdmUgfSBmcm9tICcuL2xpYi9kaXJlY3RpdmUuanMnO1xuLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogcmVtb3ZlIGxpbmUgd2hlbiB3ZSBnZXQgTm9kZVBhcnQgbW92aW5nIG1ldGhvZHNcbmV4cG9ydCB7IHJlbW92ZU5vZGVzLCByZXBhcmVudE5vZGVzIH0gZnJvbSAnLi9saWIvZG9tLmpzJztcbmV4cG9ydCB7IG5vQ2hhbmdlLCBub3RoaW5nIH0gZnJvbSAnLi9saWIvcGFydC5qcyc7XG5leHBvcnQgeyBBdHRyaWJ1dGVDb21taXR0ZXIsIEF0dHJpYnV0ZVBhcnQsIEJvb2xlYW5BdHRyaWJ1dGVQYXJ0LCBFdmVudFBhcnQsIGlzSXRlcmFibGUsIGlzUHJpbWl0aXZlLCBOb2RlUGFydCwgUHJvcGVydHlDb21taXR0ZXIsIFByb3BlcnR5UGFydCB9IGZyb20gJy4vbGliL3BhcnRzLmpzJztcbmV4cG9ydCB7IHBhcnRzLCByZW5kZXIgfSBmcm9tICcuL2xpYi9yZW5kZXIuanMnO1xuZXhwb3J0IHsgdGVtcGxhdGVDYWNoZXMsIHRlbXBsYXRlRmFjdG9yeSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWZhY3RvcnkuanMnO1xuZXhwb3J0IHsgVGVtcGxhdGVJbnN0YW5jZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmV4cG9ydCB7IFNWR1RlbXBsYXRlUmVzdWx0LCBUZW1wbGF0ZVJlc3VsdCB9IGZyb20gJy4vbGliL3RlbXBsYXRlLXJlc3VsdC5qcyc7XG5leHBvcnQgeyBjcmVhdGVNYXJrZXIsIGlzVGVtcGxhdGVQYXJ0QWN0aXZlLCBUZW1wbGF0ZSB9IGZyb20gJy4vbGliL3RlbXBsYXRlLmpzJztcbi8vIElNUE9SVEFOVDogZG8gbm90IGNoYW5nZSB0aGUgcHJvcGVydHkgbmFtZSBvciB0aGUgYXNzaWdubWVudCBleHByZXNzaW9uLlxuLy8gVGhpcyBsaW5lIHdpbGwgYmUgdXNlZCBpbiByZWdleGVzIHRvIHNlYXJjaCBmb3IgbGl0LWh0bWwgdXNhZ2UuXG4vLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBpbmplY3QgdmVyc2lvbiBudW1iZXIgYXQgYnVpbGQgdGltZVxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gfHwgKHdpbmRvd1snbGl0SHRtbFZlcnNpb25zJ10gPSBbXSkpLnB1c2goJzEuMi4xJyk7XG59XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIEhUTUwgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdodG1sJywgZGVmYXVsdFRlbXBsYXRlUHJvY2Vzc29yKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gU1ZHIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN2ZyA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IG5ldyBTVkdUZW1wbGF0ZVJlc3VsdChzdHJpbmdzLCB2YWx1ZXMsICdzdmcnLCBkZWZhdWx0VGVtcGxhdGVQcm9jZXNzb3IpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWh0bWwuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBNb2R1bGUgdG8gYWRkIHNoYWR5IERPTS9zaGFkeSBDU1MgcG9seWZpbGwgc3VwcG9ydCB0byBsaXQtaHRtbCB0ZW1wbGF0ZVxuICogcmVuZGVyaW5nLiBTZWUgdGhlIFtbcmVuZGVyXV0gbWV0aG9kIGZvciBkZXRhaWxzLlxuICpcbiAqIEBtb2R1bGUgc2hhZHktcmVuZGVyXG4gKiBAcHJlZmVycmVkXG4gKi9cbi8qKlxuICogRG8gbm90IHJlbW92ZSB0aGlzIGNvbW1lbnQ7IGl0IGtlZXBzIHR5cGVkb2MgZnJvbSBtaXNwbGFjaW5nIHRoZSBtb2R1bGVcbiAqIGRvY3MuXG4gKi9cbmltcG9ydCB7IHJlbW92ZU5vZGVzIH0gZnJvbSAnLi9kb20uanMnO1xuaW1wb3J0IHsgaW5zZXJ0Tm9kZUludG9UZW1wbGF0ZSwgcmVtb3ZlTm9kZXNGcm9tVGVtcGxhdGUgfSBmcm9tICcuL21vZGlmeS10ZW1wbGF0ZS5qcyc7XG5pbXBvcnQgeyBwYXJ0cywgcmVuZGVyIGFzIGxpdFJlbmRlciB9IGZyb20gJy4vcmVuZGVyLmpzJztcbmltcG9ydCB7IHRlbXBsYXRlQ2FjaGVzIH0gZnJvbSAnLi90ZW1wbGF0ZS1mYWN0b3J5LmpzJztcbmltcG9ydCB7IFRlbXBsYXRlSW5zdGFuY2UgfSBmcm9tICcuL3RlbXBsYXRlLWluc3RhbmNlLmpzJztcbmltcG9ydCB7IG1hcmtlciwgVGVtcGxhdGUgfSBmcm9tICcuL3RlbXBsYXRlLmpzJztcbmV4cG9ydCB7IGh0bWwsIHN2ZywgVGVtcGxhdGVSZXN1bHQgfSBmcm9tICcuLi9saXQtaHRtbC5qcyc7XG4vLyBHZXQgYSBrZXkgdG8gbG9va3VwIGluIGB0ZW1wbGF0ZUNhY2hlc2AuXG5jb25zdCBnZXRUZW1wbGF0ZUNhY2hlS2V5ID0gKHR5cGUsIHNjb3BlTmFtZSkgPT4gYCR7dHlwZX0tLSR7c2NvcGVOYW1lfWA7XG5sZXQgY29tcGF0aWJsZVNoYWR5Q1NTVmVyc2lvbiA9IHRydWU7XG5pZiAodHlwZW9mIHdpbmRvdy5TaGFkeUNTUyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb21wYXRpYmxlU2hhZHlDU1NWZXJzaW9uID0gZmFsc2U7XG59XG5lbHNlIGlmICh0eXBlb2Ygd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLndhcm4oYEluY29tcGF0aWJsZSBTaGFkeUNTUyB2ZXJzaW9uIGRldGVjdGVkLiBgICtcbiAgICAgICAgYFBsZWFzZSB1cGRhdGUgdG8gYXQgbGVhc3QgQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzQDIuMC4yIGFuZCBgICtcbiAgICAgICAgYEB3ZWJjb21wb25lbnRzL3NoYWR5Y3NzQDEuMy4xLmApO1xuICAgIGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24gPSBmYWxzZTtcbn1cbi8qKlxuICogVGVtcGxhdGUgZmFjdG9yeSB3aGljaCBzY29wZXMgdGVtcGxhdGUgRE9NIHVzaW5nIFNoYWR5Q1NTLlxuICogQHBhcmFtIHNjb3BlTmFtZSB7c3RyaW5nfVxuICovXG5jb25zdCBzaGFkeVRlbXBsYXRlRmFjdG9yeSA9IChzY29wZU5hbWUpID0+IChyZXN1bHQpID0+IHtcbiAgICBjb25zdCBjYWNoZUtleSA9IGdldFRlbXBsYXRlQ2FjaGVLZXkocmVzdWx0LnR5cGUsIHNjb3BlTmFtZSk7XG4gICAgbGV0IHRlbXBsYXRlQ2FjaGUgPSB0ZW1wbGF0ZUNhY2hlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICh0ZW1wbGF0ZUNhY2hlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGVDYWNoZSA9IHtcbiAgICAgICAgICAgIHN0cmluZ3NBcnJheTogbmV3IFdlYWtNYXAoKSxcbiAgICAgICAgICAgIGtleVN0cmluZzogbmV3IE1hcCgpXG4gICAgICAgIH07XG4gICAgICAgIHRlbXBsYXRlQ2FjaGVzLnNldChjYWNoZUtleSwgdGVtcGxhdGVDYWNoZSk7XG4gICAgfVxuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlQ2FjaGUuc3RyaW5nc0FycmF5LmdldChyZXN1bHQuc3RyaW5ncyk7XG4gICAgaWYgKHRlbXBsYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRlbXBsYXRlO1xuICAgIH1cbiAgICBjb25zdCBrZXkgPSByZXN1bHQuc3RyaW5ncy5qb2luKG1hcmtlcik7XG4gICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZUNhY2hlLmtleVN0cmluZy5nZXQoa2V5KTtcbiAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVzdWx0LmdldFRlbXBsYXRlRWxlbWVudCgpO1xuICAgICAgICBpZiAoY29tcGF0aWJsZVNoYWR5Q1NTVmVyc2lvbikge1xuICAgICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZURvbShlbGVtZW50LCBzY29wZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHJlc3VsdCwgZWxlbWVudCk7XG4gICAgICAgIHRlbXBsYXRlQ2FjaGUua2V5U3RyaW5nLnNldChrZXksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgdGVtcGxhdGVDYWNoZS5zdHJpbmdzQXJyYXkuc2V0KHJlc3VsdC5zdHJpbmdzLCB0ZW1wbGF0ZSk7XG4gICAgcmV0dXJuIHRlbXBsYXRlO1xufTtcbmNvbnN0IFRFTVBMQVRFX1RZUEVTID0gWydodG1sJywgJ3N2ZyddO1xuLyoqXG4gKiBSZW1vdmVzIGFsbCBzdHlsZSBlbGVtZW50cyBmcm9tIFRlbXBsYXRlcyBmb3IgdGhlIGdpdmVuIHNjb3BlTmFtZS5cbiAqL1xuY29uc3QgcmVtb3ZlU3R5bGVzRnJvbUxpdFRlbXBsYXRlcyA9IChzY29wZU5hbWUpID0+IHtcbiAgICBURU1QTEFURV9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRlbXBsYXRlcyA9IHRlbXBsYXRlQ2FjaGVzLmdldChnZXRUZW1wbGF0ZUNhY2hlS2V5KHR5cGUsIHNjb3BlTmFtZSkpO1xuICAgICAgICBpZiAodGVtcGxhdGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRlbXBsYXRlcy5rZXlTdHJpbmcuZm9yRWFjaCgodGVtcGxhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVsZW1lbnQ6IHsgY29udGVudCB9IH0gPSB0ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAvLyBJRSAxMSBkb2Vzbid0IHN1cHBvcnQgdGhlIGl0ZXJhYmxlIHBhcmFtIFNldCBjb25zdHJ1Y3RvclxuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBBcnJheS5mcm9tKGNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKSkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMuYWRkKHMpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJlbW92ZU5vZGVzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBzdHlsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBzaGFkeVJlbmRlclNldCA9IG5ldyBTZXQoKTtcbi8qKlxuICogRm9yIHRoZSBnaXZlbiBzY29wZSBuYW1lLCBlbnN1cmVzIHRoYXQgU2hhZHlDU1Mgc3R5bGUgc2NvcGluZyBpcyBwZXJmb3JtZWQuXG4gKiBUaGlzIGlzIGRvbmUganVzdCBvbmNlIHBlciBzY29wZSBuYW1lIHNvIHRoZSBmcmFnbWVudCBhbmQgdGVtcGxhdGUgY2Fubm90XG4gKiBiZSBtb2RpZmllZC5cbiAqICgxKSBleHRyYWN0cyBzdHlsZXMgZnJvbSB0aGUgcmVuZGVyZWQgZnJhZ21lbnQgYW5kIGhhbmRzIHRoZW0gdG8gU2hhZHlDU1NcbiAqIHRvIGJlIHNjb3BlZCBhbmQgYXBwZW5kZWQgdG8gdGhlIGRvY3VtZW50XG4gKiAoMikgcmVtb3ZlcyBzdHlsZSBlbGVtZW50cyBmcm9tIGFsbCBsaXQtaHRtbCBUZW1wbGF0ZXMgZm9yIHRoaXMgc2NvcGUgbmFtZS5cbiAqXG4gKiBOb3RlLCA8c3R5bGU+IGVsZW1lbnRzIGNhbiBvbmx5IGJlIHBsYWNlZCBpbnRvIHRlbXBsYXRlcyBmb3IgdGhlXG4gKiBpbml0aWFsIHJlbmRlcmluZyBvZiB0aGUgc2NvcGUuIElmIDxzdHlsZT4gZWxlbWVudHMgYXJlIGluY2x1ZGVkIGluIHRlbXBsYXRlc1xuICogZHluYW1pY2FsbHkgcmVuZGVyZWQgdG8gdGhlIHNjb3BlIChhZnRlciB0aGUgZmlyc3Qgc2NvcGUgcmVuZGVyKSwgdGhleSB3aWxsXG4gKiBub3QgYmUgc2NvcGVkIGFuZCB0aGUgPHN0eWxlPiB3aWxsIGJlIGxlZnQgaW4gdGhlIHRlbXBsYXRlIGFuZCByZW5kZXJlZFxuICogb3V0cHV0LlxuICovXG5jb25zdCBwcmVwYXJlVGVtcGxhdGVTdHlsZXMgPSAoc2NvcGVOYW1lLCByZW5kZXJlZERPTSwgdGVtcGxhdGUpID0+IHtcbiAgICBzaGFkeVJlbmRlclNldC5hZGQoc2NvcGVOYW1lKTtcbiAgICAvLyBJZiBgcmVuZGVyZWRET01gIGlzIHN0YW1wZWQgZnJvbSBhIFRlbXBsYXRlLCB0aGVuIHdlIG5lZWQgdG8gZWRpdCB0aGF0XG4gICAgLy8gVGVtcGxhdGUncyB1bmRlcmx5aW5nIHRlbXBsYXRlIGVsZW1lbnQuIE90aGVyd2lzZSwgd2UgY3JlYXRlIG9uZSBoZXJlXG4gICAgLy8gdG8gZ2l2ZSB0byBTaGFkeUNTUywgd2hpY2ggc3RpbGwgcmVxdWlyZXMgb25lIHdoaWxlIHNjb3BpbmcuXG4gICAgY29uc3QgdGVtcGxhdGVFbGVtZW50ID0gISF0ZW1wbGF0ZSA/IHRlbXBsYXRlLmVsZW1lbnQgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgIC8vIE1vdmUgc3R5bGVzIG91dCBvZiByZW5kZXJlZCBET00gYW5kIHN0b3JlLlxuICAgIGNvbnN0IHN0eWxlcyA9IHJlbmRlcmVkRE9NLnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0eWxlcztcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gc3R5bGVzLCBza2lwIHVubmVjZXNzYXJ5IHdvcmtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIEVuc3VyZSBwcmVwYXJlVGVtcGxhdGVTdHlsZXMgaXMgY2FsbGVkIHRvIHN1cHBvcnQgYWRkaW5nXG4gICAgICAgIC8vIHN0eWxlcyB2aWEgYHByZXBhcmVBZG9wdGVkQ3NzVGV4dGAgc2luY2UgdGhhdCByZXF1aXJlcyB0aGF0XG4gICAgICAgIC8vIGBwcmVwYXJlVGVtcGxhdGVTdHlsZXNgIGlzIGNhbGxlZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gU2hhZHlDU1Mgd2lsbCBvbmx5IHVwZGF0ZSBzdHlsZXMgY29udGFpbmluZyBAYXBwbHkgaW4gdGhlIHRlbXBsYXRlXG4gICAgICAgIC8vIGdpdmVuIHRvIGBwcmVwYXJlVGVtcGxhdGVTdHlsZXNgLiBJZiBubyBsaXQgVGVtcGxhdGUgd2FzIGdpdmVuLFxuICAgICAgICAvLyBTaGFkeUNTUyB3aWxsIG5vdCBiZSBhYmxlIHRvIHVwZGF0ZSB1c2VzIG9mIEBhcHBseSBpbiBhbnkgcmVsZXZhbnRcbiAgICAgICAgLy8gdGVtcGxhdGUuIEhvd2V2ZXIsIHRoaXMgaXMgbm90IGEgcHJvYmxlbSBiZWNhdXNlIHdlIG9ubHkgY3JlYXRlIHRoZVxuICAgICAgICAvLyB0ZW1wbGF0ZSBmb3IgdGhlIHB1cnBvc2Ugb2Ygc3VwcG9ydGluZyBgcHJlcGFyZUFkb3B0ZWRDc3NUZXh0YCxcbiAgICAgICAgLy8gd2hpY2ggZG9lc24ndCBzdXBwb3J0IEBhcHBseSBhdCBhbGwuXG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVTdHlsZXModGVtcGxhdGVFbGVtZW50LCBzY29wZU5hbWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbmRlbnNlZFN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAvLyBDb2xsZWN0IHN0eWxlcyBpbnRvIGEgc2luZ2xlIHN0eWxlLiBUaGlzIGhlbHBzIHVzIG1ha2Ugc3VyZSBTaGFkeUNTU1xuICAgIC8vIG1hbmlwdWxhdGlvbnMgd2lsbCBub3QgcHJldmVudCB1cyBmcm9tIGJlaW5nIGFibGUgdG8gZml4IHVwIHRlbXBsYXRlXG4gICAgLy8gcGFydCBpbmRpY2VzLlxuICAgIC8vIE5PVEU6IGNvbGxlY3Rpbmcgc3R5bGVzIGlzIGluZWZmaWNpZW50IGZvciBicm93c2VycyBidXQgU2hhZHlDU1NcbiAgICAvLyBjdXJyZW50bHkgZG9lcyB0aGlzIGFueXdheS4gV2hlbiBpdCBkb2VzIG5vdCwgdGhpcyBzaG91bGQgYmUgY2hhbmdlZC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzW2ldO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgICAgY29uZGVuc2VkU3R5bGUudGV4dENvbnRlbnQgKz0gc3R5bGUudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIC8vIFJlbW92ZSBzdHlsZXMgZnJvbSBuZXN0ZWQgdGVtcGxhdGVzIGluIHRoaXMgc2NvcGUuXG4gICAgcmVtb3ZlU3R5bGVzRnJvbUxpdFRlbXBsYXRlcyhzY29wZU5hbWUpO1xuICAgIC8vIEFuZCB0aGVuIHB1dCB0aGUgY29uZGVuc2VkIHN0eWxlIGludG8gdGhlIFwicm9vdFwiIHRlbXBsYXRlIHBhc3NlZCBpbiBhc1xuICAgIC8vIGB0ZW1wbGF0ZWAuXG4gICAgY29uc3QgY29udGVudCA9IHRlbXBsYXRlRWxlbWVudC5jb250ZW50O1xuICAgIGlmICghIXRlbXBsYXRlKSB7XG4gICAgICAgIGluc2VydE5vZGVJbnRvVGVtcGxhdGUodGVtcGxhdGUsIGNvbmRlbnNlZFN0eWxlLCBjb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29udGVudC5pbnNlcnRCZWZvcmUoY29uZGVuc2VkU3R5bGUsIGNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRoYXQgU2hhZHlDU1MgZ2V0cyB0aGUgdGVtcGxhdGUgdGhhdCBgbGl0LWh0bWxgXG4gICAgLy8gd2lsbCBhY3R1YWxseSByZW5kZXIgc28gdGhhdCBpdCBjYW4gdXBkYXRlIHRoZSBzdHlsZSBpbnNpZGUgd2hlblxuICAgIC8vIG5lZWRlZCAoZS5nLiBAYXBwbHkgbmF0aXZlIFNoYWRvdyBET00gY2FzZSkuXG4gICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZVN0eWxlcyh0ZW1wbGF0ZUVsZW1lbnQsIHNjb3BlTmFtZSk7XG4gICAgY29uc3Qgc3R5bGUgPSBjb250ZW50LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJyk7XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVTaGFkb3cgJiYgc3R5bGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2hlbiBpbiBuYXRpdmUgU2hhZG93IERPTSwgZW5zdXJlIHRoZSBzdHlsZSBjcmVhdGVkIGJ5IFNoYWR5Q1NTIGlzXG4gICAgICAgIC8vIGluY2x1ZGVkIGluIGluaXRpYWxseSByZW5kZXJlZCBvdXRwdXQgKGByZW5kZXJlZERPTWApLlxuICAgICAgICByZW5kZXJlZERPTS5pbnNlcnRCZWZvcmUoc3R5bGUuY2xvbmVOb2RlKHRydWUpLCByZW5kZXJlZERPTS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoISF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBXaGVuIG5vIHN0eWxlIGlzIGxlZnQgaW4gdGhlIHRlbXBsYXRlLCBwYXJ0cyB3aWxsIGJlIGJyb2tlbiBhcyBhXG4gICAgICAgIC8vIHJlc3VsdC4gVG8gZml4IHRoaXMsIHdlIHB1dCBiYWNrIHRoZSBzdHlsZSBub2RlIFNoYWR5Q1NTIHJlbW92ZWRcbiAgICAgICAgLy8gYW5kIHRoZW4gdGVsbCBsaXQgdG8gcmVtb3ZlIHRoYXQgbm9kZSBmcm9tIHRoZSB0ZW1wbGF0ZS5cbiAgICAgICAgLy8gVGhlcmUgY2FuIGJlIG5vIHN0eWxlIGluIHRoZSB0ZW1wbGF0ZSBpbiAyIGNhc2VzICgxKSB3aGVuIFNoYWR5IERPTVxuICAgICAgICAvLyBpcyBpbiB1c2UsIFNoYWR5Q1NTIHJlbW92ZXMgYWxsIHN0eWxlcywgKDIpIHdoZW4gbmF0aXZlIFNoYWRvdyBET01cbiAgICAgICAgLy8gaXMgaW4gdXNlIFNoYWR5Q1NTIHJlbW92ZXMgdGhlIHN0eWxlIGlmIGl0IGNvbnRhaW5zIG5vIGNvbnRlbnQuXG4gICAgICAgIC8vIE5PVEUsIFNoYWR5Q1NTIGNyZWF0ZXMgaXRzIG93biBzdHlsZSBzbyB3ZSBjYW4gc2FmZWx5IGFkZC9yZW1vdmVcbiAgICAgICAgLy8gYGNvbmRlbnNlZFN0eWxlYCBoZXJlLlxuICAgICAgICBjb250ZW50Lmluc2VydEJlZm9yZShjb25kZW5zZWRTdHlsZSwgY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgcmVtb3Zlcy5hZGQoY29uZGVuc2VkU3R5bGUpO1xuICAgICAgICByZW1vdmVOb2Rlc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgcmVtb3Zlcyk7XG4gICAgfVxufTtcbi8qKlxuICogRXh0ZW5zaW9uIHRvIHRoZSBzdGFuZGFyZCBgcmVuZGVyYCBtZXRob2Qgd2hpY2ggc3VwcG9ydHMgcmVuZGVyaW5nXG4gKiB0byBTaGFkb3dSb290cyB3aGVuIHRoZSBTaGFkeURPTSAoaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHlkb20pXG4gKiBhbmQgU2hhZHlDU1MgKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzKSBwb2x5ZmlsbHMgYXJlIHVzZWRcbiAqIG9yIHdoZW4gdGhlIHdlYmNvbXBvbmVudHNqc1xuICogKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcykgcG9seWZpbGwgaXMgdXNlZC5cbiAqXG4gKiBBZGRzIGEgYHNjb3BlTmFtZWAgb3B0aW9uIHdoaWNoIGlzIHVzZWQgdG8gc2NvcGUgZWxlbWVudCBET00gYW5kIHN0eWxlc2hlZXRzXG4gKiB3aGVuIG5hdGl2ZSBTaGFkb3dET00gaXMgdW5hdmFpbGFibGUuIFRoZSBgc2NvcGVOYW1lYCB3aWxsIGJlIGFkZGVkIHRvXG4gKiB0aGUgY2xhc3MgYXR0cmlidXRlIG9mIGFsbCByZW5kZXJlZCBET00uIEluIGFkZGl0aW9uLCBhbnkgc3R5bGUgZWxlbWVudHMgd2lsbFxuICogYmUgYXV0b21hdGljYWxseSByZS13cml0dGVuIHdpdGggdGhpcyBgc2NvcGVOYW1lYCBzZWxlY3RvciBhbmQgbW92ZWQgb3V0XG4gKiBvZiB0aGUgcmVuZGVyZWQgRE9NIGFuZCBpbnRvIHRoZSBkb2N1bWVudCBgPGhlYWQ+YC5cbiAqXG4gKiBJdCBpcyBjb21tb24gdG8gdXNlIHRoaXMgcmVuZGVyIG1ldGhvZCBpbiBjb25qdW5jdGlvbiB3aXRoIGEgY3VzdG9tIGVsZW1lbnRcbiAqIHdoaWNoIHJlbmRlcnMgYSBzaGFkb3dSb290LiBXaGVuIHRoaXMgaXMgZG9uZSwgdHlwaWNhbGx5IHRoZSBlbGVtZW50J3NcbiAqIGBsb2NhbE5hbWVgIHNob3VsZCBiZSB1c2VkIGFzIHRoZSBgc2NvcGVOYW1lYC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB0byBET00gc2NvcGluZywgU2hhZHlDU1MgYWxzbyBzdXBwb3J0cyBhIGJhc2ljIHNoaW0gZm9yIGNzc1xuICogY3VzdG9tIHByb3BlcnRpZXMgKG5lZWRlZCBvbmx5IG9uIG9sZGVyIGJyb3dzZXJzIGxpa2UgSUUxMSkgYW5kIGEgc2hpbSBmb3JcbiAqIGEgZGVwcmVjYXRlZCBmZWF0dXJlIGNhbGxlZCBgQGFwcGx5YCB0aGF0IHN1cHBvcnRzIGFwcGx5aW5nIGEgc2V0IG9mIGNzc1xuICogY3VzdG9tIHByb3BlcnRpZXMgdG8gYSBnaXZlbiBsb2NhdGlvbi5cbiAqXG4gKiBVc2FnZSBjb25zaWRlcmF0aW9uczpcbiAqXG4gKiAqIFBhcnQgdmFsdWVzIGluIGA8c3R5bGU+YCBlbGVtZW50cyBhcmUgb25seSBhcHBsaWVkIHRoZSBmaXJzdCB0aW1lIGEgZ2l2ZW5cbiAqIGBzY29wZU5hbWVgIHJlbmRlcnMuIFN1YnNlcXVlbnQgY2hhbmdlcyB0byBwYXJ0cyBpbiBzdHlsZSBlbGVtZW50cyB3aWxsIGhhdmVcbiAqIG5vIGVmZmVjdC4gQmVjYXVzZSBvZiB0aGlzLCBwYXJ0cyBpbiBzdHlsZSBlbGVtZW50cyBzaG91bGQgb25seSBiZSB1c2VkIGZvclxuICogdmFsdWVzIHRoYXQgd2lsbCBuZXZlciBjaGFuZ2UsIGZvciBleGFtcGxlIHBhcnRzIHRoYXQgc2V0IHNjb3BlLXdpZGUgdGhlbWVcbiAqIHZhbHVlcyBvciBwYXJ0cyB3aGljaCByZW5kZXIgc2hhcmVkIHN0eWxlIGVsZW1lbnRzLlxuICpcbiAqICogTm90ZSwgZHVlIHRvIGEgbGltaXRhdGlvbiBvZiB0aGUgU2hhZHlET00gcG9seWZpbGwsIHJlbmRlcmluZyBpbiBhXG4gKiBjdXN0b20gZWxlbWVudCdzIGBjb25zdHJ1Y3RvcmAgaXMgbm90IHN1cHBvcnRlZC4gSW5zdGVhZCByZW5kZXJpbmcgc2hvdWxkXG4gKiBlaXRoZXIgZG9uZSBhc3luY2hyb25vdXNseSwgZm9yIGV4YW1wbGUgYXQgbWljcm90YXNrIHRpbWluZyAoZm9yIGV4YW1wbGVcbiAqIGBQcm9taXNlLnJlc29sdmUoKWApLCBvciBiZSBkZWZlcnJlZCB1bnRpbCB0aGUgZmlyc3QgdGltZSB0aGUgZWxlbWVudCdzXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIHJ1bnMuXG4gKlxuICogVXNhZ2UgY29uc2lkZXJhdGlvbnMgd2hlbiB1c2luZyBzaGltbWVkIGN1c3RvbSBwcm9wZXJ0aWVzIG9yIGBAYXBwbHlgOlxuICpcbiAqICogV2hlbmV2ZXIgYW55IGR5bmFtaWMgY2hhbmdlcyBhcmUgbWFkZSB3aGljaCBhZmZlY3RcbiAqIGNzcyBjdXN0b20gcHJvcGVydGllcywgYFNoYWR5Q1NTLnN0eWxlRWxlbWVudChlbGVtZW50KWAgbXVzdCBiZSBjYWxsZWRcbiAqIHRvIHVwZGF0ZSB0aGUgZWxlbWVudC4gVGhlcmUgYXJlIHR3byBjYXNlcyB3aGVuIHRoaXMgaXMgbmVlZGVkOlxuICogKDEpIHRoZSBlbGVtZW50IGlzIGNvbm5lY3RlZCB0byBhIG5ldyBwYXJlbnQsICgyKSBhIGNsYXNzIGlzIGFkZGVkIHRvIHRoZVxuICogZWxlbWVudCB0aGF0IGNhdXNlcyBpdCB0byBtYXRjaCBkaWZmZXJlbnQgY3VzdG9tIHByb3BlcnRpZXMuXG4gKiBUbyBhZGRyZXNzIHRoZSBmaXJzdCBjYXNlIHdoZW4gcmVuZGVyaW5nIGEgY3VzdG9tIGVsZW1lbnQsIGBzdHlsZUVsZW1lbnRgXG4gKiBzaG91bGQgYmUgY2FsbGVkIGluIHRoZSBlbGVtZW50J3MgYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAqXG4gKiAqIFNoaW1tZWQgY3VzdG9tIHByb3BlcnRpZXMgbWF5IG9ubHkgYmUgZGVmaW5lZCBlaXRoZXIgZm9yIGFuIGVudGlyZVxuICogc2hhZG93Um9vdCAoZm9yIGV4YW1wbGUsIGluIGEgYDpob3N0YCBydWxlKSBvciB2aWEgYSBydWxlIHRoYXQgZGlyZWN0bHlcbiAqIG1hdGNoZXMgYW4gZWxlbWVudCB3aXRoIGEgc2hhZG93Um9vdC4gSW4gb3RoZXIgd29yZHMsIGluc3RlYWQgb2YgZmxvd2luZyBmcm9tXG4gKiBwYXJlbnQgdG8gY2hpbGQgYXMgZG8gbmF0aXZlIGNzcyBjdXN0b20gcHJvcGVydGllcywgc2hpbW1lZCBjdXN0b20gcHJvcGVydGllc1xuICogZmxvdyBvbmx5IGZyb20gc2hhZG93Um9vdHMgdG8gbmVzdGVkIHNoYWRvd1Jvb3RzLlxuICpcbiAqICogV2hlbiB1c2luZyBgQGFwcGx5YCBtaXhpbmcgY3NzIHNob3J0aGFuZCBwcm9wZXJ0eSBuYW1lcyB3aXRoXG4gKiBub24tc2hvcnRoYW5kIG5hbWVzIChmb3IgZXhhbXBsZSBgYm9yZGVyYCBhbmQgYGJvcmRlci13aWR0aGApIGlzIG5vdFxuICogc3VwcG9ydGVkLlxuICovXG5leHBvcnQgY29uc3QgcmVuZGVyID0gKHJlc3VsdCwgY29udGFpbmVyLCBvcHRpb25zKSA9PiB7XG4gICAgaWYgKCFvcHRpb25zIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0JyB8fCAhb3B0aW9ucy5zY29wZU5hbWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgYHNjb3BlTmFtZWAgb3B0aW9uIGlzIHJlcXVpcmVkLicpO1xuICAgIH1cbiAgICBjb25zdCBzY29wZU5hbWUgPSBvcHRpb25zLnNjb3BlTmFtZTtcbiAgICBjb25zdCBoYXNSZW5kZXJlZCA9IHBhcnRzLmhhcyhjb250YWluZXIpO1xuICAgIGNvbnN0IG5lZWRzU2NvcGluZyA9IGNvbXBhdGlibGVTaGFkeUNTU1ZlcnNpb24gJiZcbiAgICAgICAgY29udGFpbmVyLm5vZGVUeXBlID09PSAxMSAvKiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgKi8gJiZcbiAgICAgICAgISFjb250YWluZXIuaG9zdDtcbiAgICAvLyBIYW5kbGUgZmlyc3QgcmVuZGVyIHRvIGEgc2NvcGUgc3BlY2lhbGx5Li4uXG4gICAgY29uc3QgZmlyc3RTY29wZVJlbmRlciA9IG5lZWRzU2NvcGluZyAmJiAhc2hhZHlSZW5kZXJTZXQuaGFzKHNjb3BlTmFtZSk7XG4gICAgLy8gT24gZmlyc3Qgc2NvcGUgcmVuZGVyLCByZW5kZXIgaW50byBhIGZyYWdtZW50OyB0aGlzIGNhbm5vdCBiZSBhIHNpbmdsZVxuICAgIC8vIGZyYWdtZW50IHRoYXQgaXMgcmV1c2VkIHNpbmNlIG5lc3RlZCByZW5kZXJzIGNhbiBvY2N1ciBzeW5jaHJvbm91c2x5LlxuICAgIGNvbnN0IHJlbmRlckNvbnRhaW5lciA9IGZpcnN0U2NvcGVSZW5kZXIgPyBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkgOiBjb250YWluZXI7XG4gICAgbGl0UmVuZGVyKHJlc3VsdCwgcmVuZGVyQ29udGFpbmVyLCBPYmplY3QuYXNzaWduKHsgdGVtcGxhdGVGYWN0b3J5OiBzaGFkeVRlbXBsYXRlRmFjdG9yeShzY29wZU5hbWUpIH0sIG9wdGlvbnMpKTtcbiAgICAvLyBXaGVuIHBlcmZvcm1pbmcgZmlyc3Qgc2NvcGUgcmVuZGVyLFxuICAgIC8vICgxKSBXZSd2ZSByZW5kZXJlZCBpbnRvIGEgZnJhZ21lbnQgc28gdGhhdCB0aGVyZSdzIGEgY2hhbmNlIHRvXG4gICAgLy8gYHByZXBhcmVUZW1wbGF0ZVN0eWxlc2AgYmVmb3JlIHN1Yi1lbGVtZW50cyBoaXQgdGhlIERPTVxuICAgIC8vICh3aGljaCBtaWdodCBjYXVzZSB0aGVtIHRvIHJlbmRlciBiYXNlZCBvbiBhIGNvbW1vbiBwYXR0ZXJuIG9mXG4gICAgLy8gcmVuZGVyaW5nIGluIGEgY3VzdG9tIGVsZW1lbnQncyBgY29ubmVjdGVkQ2FsbGJhY2tgKTtcbiAgICAvLyAoMikgU2NvcGUgdGhlIHRlbXBsYXRlIHdpdGggU2hhZHlDU1Mgb25lIHRpbWUgb25seSBmb3IgdGhpcyBzY29wZS5cbiAgICAvLyAoMykgUmVuZGVyIHRoZSBmcmFnbWVudCBpbnRvIHRoZSBjb250YWluZXIgYW5kIG1ha2Ugc3VyZSB0aGVcbiAgICAvLyBjb250YWluZXIga25vd3MgaXRzIGBwYXJ0YCBpcyB0aGUgb25lIHdlIGp1c3QgcmVuZGVyZWQuIFRoaXMgZW5zdXJlc1xuICAgIC8vIERPTSB3aWxsIGJlIHJlLXVzZWQgb24gc3Vic2VxdWVudCByZW5kZXJzLlxuICAgIGlmIChmaXJzdFNjb3BlUmVuZGVyKSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBwYXJ0cy5nZXQocmVuZGVyQ29udGFpbmVyKTtcbiAgICAgICAgcGFydHMuZGVsZXRlKHJlbmRlckNvbnRhaW5lcik7XG4gICAgICAgIC8vIFNoYWR5Q1NTIG1pZ2h0IGhhdmUgc3R5bGUgc2hlZXRzIChlLmcuIGZyb20gYHByZXBhcmVBZG9wdGVkQ3NzVGV4dGApXG4gICAgICAgIC8vIHRoYXQgc2hvdWxkIGFwcGx5IHRvIGByZW5kZXJDb250YWluZXJgIGV2ZW4gaWYgdGhlIHJlbmRlcmVkIHZhbHVlIGlzXG4gICAgICAgIC8vIG5vdCBhIFRlbXBsYXRlSW5zdGFuY2UuIEhvd2V2ZXIsIGl0IHdpbGwgb25seSBpbnNlcnQgc2NvcGVkIHN0eWxlc1xuICAgICAgICAvLyBpbnRvIHRoZSBkb2N1bWVudCBpZiBgcHJlcGFyZVRlbXBsYXRlU3R5bGVzYCBoYXMgYWxyZWFkeSBiZWVuIGNhbGxlZFxuICAgICAgICAvLyBmb3IgdGhlIGdpdmVuIHNjb3BlIG5hbWUuXG4gICAgICAgIGNvbnN0IHRlbXBsYXRlID0gcGFydC52YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlSW5zdGFuY2UgP1xuICAgICAgICAgICAgcGFydC52YWx1ZS50ZW1wbGF0ZSA6XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIHByZXBhcmVUZW1wbGF0ZVN0eWxlcyhzY29wZU5hbWUsIHJlbmRlckNvbnRhaW5lciwgdGVtcGxhdGUpO1xuICAgICAgICByZW1vdmVOb2Rlcyhjb250YWluZXIsIGNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHJlbmRlckNvbnRhaW5lcik7XG4gICAgICAgIHBhcnRzLnNldChjb250YWluZXIsIHBhcnQpO1xuICAgIH1cbiAgICAvLyBBZnRlciBlbGVtZW50cyBoYXZlIGhpdCB0aGUgRE9NLCB1cGRhdGUgc3R5bGluZyBpZiB0aGlzIGlzIHRoZVxuICAgIC8vIGluaXRpYWwgcmVuZGVyIHRvIHRoaXMgY29udGFpbmVyLlxuICAgIC8vIFRoaXMgaXMgbmVlZGVkIHdoZW5ldmVyIGR5bmFtaWMgY2hhbmdlcyBhcmUgbWFkZSBzbyBpdCB3b3VsZCBiZVxuICAgIC8vIHNhZmVzdCB0byBkbyBldmVyeSByZW5kZXI7IGhvd2V2ZXIsIHRoaXMgd291bGQgcmVncmVzcyBwZXJmb3JtYW5jZVxuICAgIC8vIHNvIHdlIGxlYXZlIGl0IHVwIHRvIHRoZSB1c2VyIHRvIGNhbGwgYFNoYWR5Q1NTLnN0eWxlRWxlbWVudGBcbiAgICAvLyBmb3IgZHluYW1pYyBjaGFuZ2VzLlxuICAgIGlmICghaGFzUmVuZGVyZWQgJiYgbmVlZHNTY29waW5nKSB7XG4gICAgICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZUVsZW1lbnQoY29udGFpbmVyLmhvc3QpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGFkeS1yZW5kZXIuanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xudmFyIF9hO1xuLyoqXG4gKiBXaGVuIHVzaW5nIENsb3N1cmUgQ29tcGlsZXIsIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkocHJvcGVydHksIG9iamVjdCkgaXNcbiAqIHJlcGxhY2VkIGF0IGNvbXBpbGUgdGltZSBieSB0aGUgbXVuZ2VkIG5hbWUgZm9yIG9iamVjdFtwcm9wZXJ0eV0uIFdlIGNhbm5vdFxuICogYWxpYXMgdGhpcyBmdW5jdGlvbiwgc28gd2UgaGF2ZSB0byB1c2UgYSBzbWFsbCBzaGltIHRoYXQgaGFzIHRoZSBzYW1lXG4gKiBiZWhhdmlvciB3aGVuIG5vdCBjb21waWxpbmcuXG4gKi9cbndpbmRvdy5KU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5ID1cbiAgICAocHJvcCwgX29iaikgPT4gcHJvcDtcbmV4cG9ydCBjb25zdCBkZWZhdWx0Q29udmVydGVyID0ge1xuICAgIHRvQXR0cmlidXRlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA/ICcnIDogbnVsbDtcbiAgICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgIHBhc3MgdGhpcyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgLy8gdG8gYWxsb3cgcmVtb3Zpbmcvbm8gY2hhbmdlIGJlaGF2aW9yLlxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgZnJvbUF0dHJpYnV0ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgIT09IG51bGw7XG4gICAgICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBudWxsIDogTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG4vKipcbiAqIENoYW5nZSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIGRpZmZlcmVudCBmcm9tIGBvbGRWYWx1ZWAuXG4gKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGFzIHRoZSBkZWZhdWx0IGZvciBhIHByb3BlcnR5J3MgYGhhc0NoYW5nZWRgIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY29uc3Qgbm90RXF1YWwgPSAodmFsdWUsIG9sZCkgPT4ge1xuICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgcmV0dXJuIG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSk7XG59O1xuY29uc3QgZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24gPSB7XG4gICAgYXR0cmlidXRlOiB0cnVlLFxuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb252ZXJ0ZXI6IGRlZmF1bHRDb252ZXJ0ZXIsXG4gICAgcmVmbGVjdDogZmFsc2UsXG4gICAgaGFzQ2hhbmdlZDogbm90RXF1YWxcbn07XG5jb25zdCBTVEFURV9IQVNfVVBEQVRFRCA9IDE7XG5jb25zdCBTVEFURV9VUERBVEVfUkVRVUVTVEVEID0gMSA8PCAyO1xuY29uc3QgU1RBVEVfSVNfUkVGTEVDVElOR19UT19BVFRSSUJVVEUgPSAxIDw8IDM7XG5jb25zdCBTVEFURV9JU19SRUZMRUNUSU5HX1RPX1BST1BFUlRZID0gMSA8PCA0O1xuLyoqXG4gKiBUaGUgQ2xvc3VyZSBKUyBDb21waWxlciBkb2Vzbid0IGN1cnJlbnRseSBoYXZlIGdvb2Qgc3VwcG9ydCBmb3Igc3RhdGljXG4gKiBwcm9wZXJ0eSBzZW1hbnRpY3Mgd2hlcmUgXCJ0aGlzXCIgaXMgZHluYW1pYyAoZS5nLlxuICogaHR0cHM6Ly9naXRodWIuY29tL2dvb2dsZS9jbG9zdXJlLWNvbXBpbGVyL2lzc3Vlcy8zMTc3IGFuZCBvdGhlcnMpIHNvIHdlIHVzZVxuICogdGhpcyBoYWNrIHRvIGJ5cGFzcyBhbnkgcmV3cml0aW5nIGJ5IHRoZSBjb21waWxlci5cbiAqL1xuY29uc3QgZmluYWxpemVkID0gJ2ZpbmFsaXplZCc7XG4vKipcbiAqIEJhc2UgZWxlbWVudCBjbGFzcyB3aGljaCBtYW5hZ2VzIGVsZW1lbnQgcHJvcGVydGllcyBhbmQgYXR0cmlidXRlcy4gV2hlblxuICogcHJvcGVydGllcyBjaGFuZ2UsIHRoZSBgdXBkYXRlYCBtZXRob2QgaXMgYXN5bmNocm9ub3VzbHkgY2FsbGVkLiBUaGlzIG1ldGhvZFxuICogc2hvdWxkIGJlIHN1cHBsaWVkIGJ5IHN1YmNsYXNzZXJzIHRvIHJlbmRlciB1cGRhdGVzIGFzIGRlc2lyZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBVcGRhdGluZ0VsZW1lbnQgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gMDtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBJbml0aWFsaXplIHRvIGFuIHVucmVzb2x2ZWQgUHJvbWlzZSBzbyB3ZSBjYW4gbWFrZSBzdXJlIHRoZSBlbGVtZW50IGhhc1xuICAgICAgICAvLyBjb25uZWN0ZWQgYmVmb3JlIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgdGhpcy5fdXBkYXRlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMpID0+IHRoaXMuX2VuYWJsZVVwZGF0aW5nUmVzb2x2ZXIgPSByZXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogTWFwIHdpdGgga2V5cyBmb3IgYW55IHByb3BlcnRpZXMgdGhhdCBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgICAgICogdXBkYXRlIGN5Y2xlIHdpdGggcHJldmlvdXMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY2hhbmdlZFByb3BlcnRpZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXAgd2l0aCBrZXlzIG9mIHByb3BlcnRpZXMgdGhhdCBzaG91bGQgYmUgcmVmbGVjdGVkIHdoZW4gdXBkYXRlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLmluaXRpYWxpemUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgYXR0cmlidXRlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgLy8gbm90ZTogcGlnZ3kgYmFja2luZyBvbiB0aGlzIHRvIGVuc3VyZSB3ZSdyZSBmaW5hbGl6ZWQuXG4gICAgICAgIHRoaXMuZmluYWxpemUoKTtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IFtdO1xuICAgICAgICAvLyBVc2UgZm9yRWFjaCBzbyB0aGlzIHdvcmtzIGV2ZW4gaWYgZm9yL29mIGxvb3BzIGFyZSBjb21waWxlZCB0byBmb3IgbG9vcHNcbiAgICAgICAgLy8gZXhwZWN0aW5nIGFycmF5c1xuICAgICAgICB0aGlzLl9jbGFzc1Byb3BlcnRpZXMuZm9yRWFjaCgodiwgcCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXR0ciA9IHRoaXMuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShwLCB2KTtcbiAgICAgICAgICAgIGlmIChhdHRyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwLnNldChhdHRyLCBwKTtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnB1c2goYXR0cik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGUgcHJpdmF0ZSBgX2NsYXNzUHJvcGVydGllc2AgcHJvcGVydHkgbWV0YWRhdGEgaXMgY3JlYXRlZC5cbiAgICAgKiBJbiBhZGRpdGlvbiB0byBgZmluYWxpemVgIHRoaXMgaXMgYWxzbyBjYWxsZWQgaW4gYGNyZWF0ZVByb3BlcnR5YCB0b1xuICAgICAqIGVuc3VyZSB0aGUgYEBwcm9wZXJ0eWAgZGVjb3JhdG9yIGNhbiBhZGQgcHJvcGVydHkgbWV0YWRhdGEuXG4gICAgICovXG4gICAgLyoqIEBub2NvbGxhcHNlICovXG4gICAgc3RhdGljIF9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKSB7XG4gICAgICAgIC8vIGVuc3VyZSBwcml2YXRlIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGRlY2xhcmF0aW9ucy5cbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19jbGFzc1Byb3BlcnRpZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsYXNzUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIC8vIE5PVEU6IFdvcmthcm91bmQgSUUxMSBub3Qgc3VwcG9ydGluZyBNYXAgY29uc3RydWN0b3IgYXJndW1lbnQuXG4gICAgICAgICAgICBjb25zdCBzdXBlclByb3BlcnRpZXMgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2NsYXNzUHJvcGVydGllcztcbiAgICAgICAgICAgIGlmIChzdXBlclByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHN1cGVyUHJvcGVydGllcy5mb3JFYWNoKCh2LCBrKSA9PiB0aGlzLl9jbGFzc1Byb3BlcnRpZXMuc2V0KGssIHYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcHJvcGVydHkgYWNjZXNzb3Igb24gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGlmIG9uZSBkb2VzIG5vdCBleGlzdFxuICAgICAqIGFuZCBzdG9yZXMgYSBQcm9wZXJ0eURlY2xhcmF0aW9uIGZvciB0aGUgcHJvcGVydHkgd2l0aCB0aGUgZ2l2ZW4gb3B0aW9ucy5cbiAgICAgKiBUaGUgcHJvcGVydHkgc2V0dGVyIGNhbGxzIHRoZSBwcm9wZXJ0eSdzIGBoYXNDaGFuZ2VkYCBwcm9wZXJ0eSBvcHRpb25cbiAgICAgKiBvciB1c2VzIGEgc3RyaWN0IGlkZW50aXR5IGNoZWNrIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0byByZXF1ZXN0XG4gICAgICogYW4gdXBkYXRlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gY3VzdG9taXplIHByb3BlcnRpZXM7IGhvd2V2ZXIsXG4gICAgICogd2hlbiBkb2luZyBzbywgaXQncyBpbXBvcnRhbnQgdG8gY2FsbCBgc3VwZXIuY3JlYXRlUHJvcGVydHlgIHRvIGVuc3VyZVxuICAgICAqIHRoZSBwcm9wZXJ0eSBpcyBzZXR1cCBjb3JyZWN0bHkuIFRoaXMgbWV0aG9kIGNhbGxzXG4gICAgICogYGdldFByb3BlcnR5RGVzY3JpcHRvcmAgaW50ZXJuYWxseSB0byBnZXQgYSBkZXNjcmlwdG9yIHRvIGluc3RhbGwuXG4gICAgICogVG8gY3VzdG9taXplIHdoYXQgcHJvcGVydGllcyBkbyB3aGVuIHRoZXkgYXJlIGdldCBvciBzZXQsIG92ZXJyaWRlXG4gICAgICogYGdldFByb3BlcnR5RGVzY3JpcHRvcmAuIFRvIGN1c3RvbWl6ZSB0aGUgb3B0aW9ucyBmb3IgYSBwcm9wZXJ0eSxcbiAgICAgKiBpbXBsZW1lbnQgYGNyZWF0ZVByb3BlcnR5YCBsaWtlIHRoaXM6XG4gICAgICpcbiAgICAgKiBzdGF0aWMgY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucykge1xuICAgICAqICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24ob3B0aW9ucywge215T3B0aW9uOiB0cnVlfSk7XG4gICAgICogICBzdXBlci5jcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0eShuYW1lLCBvcHRpb25zID0gZGVmYXVsdFByb3BlcnR5RGVjbGFyYXRpb24pIHtcbiAgICAgICAgLy8gTm90ZSwgc2luY2UgdGhpcyBjYW4gYmUgY2FsbGVkIGJ5IHRoZSBgQHByb3BlcnR5YCBkZWNvcmF0b3Igd2hpY2hcbiAgICAgICAgLy8gaXMgY2FsbGVkIGJlZm9yZSBgZmluYWxpemVgLCB3ZSBlbnN1cmUgc3RvcmFnZSBleGlzdHMgZm9yIHByb3BlcnR5XG4gICAgICAgIC8vIG1ldGFkYXRhLlxuICAgICAgICB0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5fY2xhc3NQcm9wZXJ0aWVzLnNldChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgLy8gRG8gbm90IGdlbmVyYXRlIGFuIGFjY2Vzc29yIGlmIHRoZSBwcm90b3R5cGUgYWxyZWFkeSBoYXMgb25lLCBzaW5jZVxuICAgICAgICAvLyBpdCB3b3VsZCBiZSBsb3N0IG90aGVyd2lzZSBhbmQgdGhhdCB3b3VsZCBuZXZlciBiZSB0aGUgdXNlcidzIGludGVudGlvbjtcbiAgICAgICAgLy8gSW5zdGVhZCwgd2UgZXhwZWN0IHVzZXJzIHRvIGNhbGwgYHJlcXVlc3RVcGRhdGVgIHRoZW1zZWx2ZXMgZnJvbVxuICAgICAgICAvLyB1c2VyLWRlZmluZWQgYWNjZXNzb3JzLiBOb3RlIHRoYXQgaWYgdGhlIHN1cGVyIGhhcyBhbiBhY2Nlc3NvciB3ZSB3aWxsXG4gICAgICAgIC8vIHN0aWxsIG92ZXJ3cml0ZSBpdFxuICAgICAgICBpZiAob3B0aW9ucy5ub0FjY2Vzc29yIHx8IHRoaXMucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5hbWUgPT09ICdzeW1ib2wnID8gU3ltYm9sKCkgOiBgX18ke25hbWV9YDtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMuZ2V0UHJvcGVydHlEZXNjcmlwdG9yKG5hbWUsIGtleSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLnByb3RvdHlwZSwgbmFtZSwgZGVzY3JpcHRvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHByb3BlcnR5IGRlc2NyaXB0b3IgdG8gYmUgZGVmaW5lZCBvbiB0aGUgZ2l2ZW4gbmFtZWQgcHJvcGVydHkuXG4gICAgICogSWYgbm8gZGVzY3JpcHRvciBpcyByZXR1cm5lZCwgdGhlIHByb3BlcnR5IHdpbGwgbm90IGJlY29tZSBhbiBhY2Nlc3Nvci5cbiAgICAgKiBGb3IgZXhhbXBsZSxcbiAgICAgKlxuICAgICAqICAgY2xhc3MgTXlFbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XG4gICAgICogICAgIHN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICogICAgICAgY29uc3QgZGVmYXVsdERlc2NyaXB0b3IgPVxuICAgICAqICAgICAgICAgICBzdXBlci5nZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBvcHRpb25zKTtcbiAgICAgKiAgICAgICBjb25zdCBzZXR0ZXIgPSBkZWZhdWx0RGVzY3JpcHRvci5zZXQ7XG4gICAgICogICAgICAgcmV0dXJuIHtcbiAgICAgKiAgICAgICAgIGdldDogZGVmYXVsdERlc2NyaXB0b3IuZ2V0LFxuICAgICAqICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICogICAgICAgICAgIHNldHRlci5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICAgKiAgICAgICAgICAgLy8gY3VzdG9tIGFjdGlvbi5cbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICogICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcm9wZXJ0eURlc2NyaXB0b3IobmFtZSwga2V5LCBfb3B0aW9ucykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBubyBzeW1ib2wgaW4gaW5kZXhcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1trZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXF1ZXN0VXBkYXRlKG5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG9wdGlvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBUaGVzZSBvcHRpb25zIGFyZSBkZWZpbmVkIHdpdGggYSBQcm9wZXJ0eURlY2xhcmF0aW9uIHZpYSB0aGUgYHByb3BlcnRpZXNgXG4gICAgICogb2JqZWN0IG9yIHRoZSBgQHByb3BlcnR5YCBkZWNvcmF0b3IgYW5kIGFyZSByZWdpc3RlcmVkIGluXG4gICAgICogYGNyZWF0ZVByb3BlcnR5KC4uLilgLlxuICAgICAqXG4gICAgICogTm90ZSwgdGhpcyBtZXRob2Qgc2hvdWxkIGJlIGNvbnNpZGVyZWQgXCJmaW5hbFwiIGFuZCBub3Qgb3ZlcnJpZGRlbi4gVG9cbiAgICAgKiBjdXN0b21pemUgdGhlIG9wdGlvbnMgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIG92ZXJyaWRlIGBjcmVhdGVQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqIEBmaW5hbFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXRQcm9wZXJ0eU9wdGlvbnMobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xhc3NQcm9wZXJ0aWVzICYmIHRoaXMuX2NsYXNzUHJvcGVydGllcy5nZXQobmFtZSkgfHxcbiAgICAgICAgICAgIGRlZmF1bHRQcm9wZXJ0eURlY2xhcmF0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgcmVnaXN0ZXJlZCBwcm9wZXJ0aWVzIGFuZCBlbnN1cmVzXG4gICAgICogYW55IHN1cGVyY2xhc3NlcyBhcmUgYWxzbyBmaW5hbGl6ZWQuXG4gICAgICogQG5vY29sbGFwc2VcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICAgIC8vIGZpbmFsaXplIGFueSBzdXBlcmNsYXNzZXNcbiAgICAgICAgY29uc3Qgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgICBpZiAoIXN1cGVyQ3Rvci5oYXNPd25Qcm9wZXJ0eShmaW5hbGl6ZWQpKSB7XG4gICAgICAgICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzW2ZpbmFsaXplZF0gPSB0cnVlO1xuICAgICAgICB0aGlzLl9lbnN1cmVDbGFzc1Byb3BlcnRpZXMoKTtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBNYXAgcG9wdWxhdGVkIGluIG9ic2VydmVkQXR0cmlidXRlc1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBtYWtlIGFueSBwcm9wZXJ0aWVzXG4gICAgICAgIC8vIE5vdGUsIG9ubHkgcHJvY2VzcyBcIm93blwiIHByb3BlcnRpZXMgc2luY2UgdGhpcyBlbGVtZW50IHdpbGwgaW5oZXJpdFxuICAgICAgICAvLyBhbnkgcHJvcGVydGllcyBkZWZpbmVkIG9uIHRoZSBzdXBlckNsYXNzLCBhbmQgZmluYWxpemF0aW9uIGVuc3VyZXNcbiAgICAgICAgLy8gdGhlIGVudGlyZSBwcm90b3R5cGUgY2hhaW4gaXMgZmluYWxpemVkLlxuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdwcm9wZXJ0aWVzJywgdGhpcykpKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgICAgIC8vIHN1cHBvcnQgc3ltYm9scyBpbiBwcm9wZXJ0aWVzIChJRTExIGRvZXMgbm90IHN1cHBvcnQgdGhpcylcbiAgICAgICAgICAgIGNvbnN0IHByb3BLZXlzID0gW1xuICAgICAgICAgICAgICAgIC4uLk9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3BzKSxcbiAgICAgICAgICAgICAgICAuLi4odHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbicpID9cbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhwcm9wcykgOlxuICAgICAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIC8vIFRoaXMgZm9yL29mIGlzIG9rIGJlY2F1c2UgcHJvcEtleXMgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiBwcm9wS2V5cykge1xuICAgICAgICAgICAgICAgIC8vIG5vdGUsIHVzZSBvZiBgYW55YCBpcyBkdWUgdG8gVHlwZVNyaXB0IGxhY2sgb2Ygc3VwcG9ydCBmb3Igc3ltYm9sIGluXG4gICAgICAgICAgICAgICAgLy8gaW5kZXggdHlwZXNcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IG5vIHN5bWJvbCBpbiBpbmRleFxuICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlUHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHByb3BlcnR5IG5hbWUgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgYG5hbWVgLlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIF9hdHRyaWJ1dGVOYW1lRm9yUHJvcGVydHkobmFtZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBvcHRpb25zLmF0dHJpYnV0ZTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZSA9PT0gZmFsc2UgP1xuICAgICAgICAgICAgdW5kZWZpbmVkIDpcbiAgICAgICAgICAgICh0eXBlb2YgYXR0cmlidXRlID09PSAnc3RyaW5nJyA/XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlIDpcbiAgICAgICAgICAgICAgICAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnID8gbmFtZS50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiBhIHByb3BlcnR5IHNob3VsZCByZXF1ZXN0IGFuIHVwZGF0ZS5cbiAgICAgKiBDYWxsZWQgd2hlbiBhIHByb3BlcnR5IHZhbHVlIGlzIHNldCBhbmQgdXNlcyB0aGUgYGhhc0NoYW5nZWRgXG4gICAgICogb3B0aW9uIGZvciB0aGUgcHJvcGVydHkgaWYgcHJlc2VudCBvciBhIHN0cmljdCBpZGVudGl0eSBjaGVjay5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfdmFsdWVIYXNDaGFuZ2VkKHZhbHVlLCBvbGQsIGhhc0NoYW5nZWQgPSBub3RFcXVhbCkge1xuICAgICAgICByZXR1cm4gaGFzQ2hhbmdlZCh2YWx1ZSwgb2xkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUgZm9yIHRoZSBnaXZlbiBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQ2FsbGVkIHZpYSB0aGUgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgYW5kIHVzZXMgdGhlIHByb3BlcnR5J3NcbiAgICAgKiBgY29udmVydGVyYCBvciBgY29udmVydGVyLmZyb21BdHRyaWJ1dGVgIHByb3BlcnR5IG9wdGlvbi5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcHJvcGVydHlWYWx1ZUZyb21BdHRyaWJ1dGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IG9wdGlvbnMudHlwZTtcbiAgICAgICAgY29uc3QgY29udmVydGVyID0gb3B0aW9ucy5jb252ZXJ0ZXIgfHwgZGVmYXVsdENvbnZlcnRlcjtcbiAgICAgICAgY29uc3QgZnJvbUF0dHJpYnV0ZSA9ICh0eXBlb2YgY29udmVydGVyID09PSAnZnVuY3Rpb24nID8gY29udmVydGVyIDogY29udmVydGVyLmZyb21BdHRyaWJ1dGUpO1xuICAgICAgICByZXR1cm4gZnJvbUF0dHJpYnV0ZSA/IGZyb21BdHRyaWJ1dGUodmFsdWUsIHR5cGUpIDogdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGF0dHJpYnV0ZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IHZhbHVlLiBJZiB0aGlzXG4gICAgICogcmV0dXJucyB1bmRlZmluZWQsIHRoZSBwcm9wZXJ0eSB3aWxsICpub3QqIGJlIHJlZmxlY3RlZCB0byBhbiBhdHRyaWJ1dGUuXG4gICAgICogSWYgdGhpcyByZXR1cm5zIG51bGwsIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZW1vdmVkLCBvdGhlcndpc2UgdGhlXG4gICAgICogYXR0cmlidXRlIHdpbGwgYmUgc2V0IHRvIHRoZSB2YWx1ZS5cbiAgICAgKiBUaGlzIHVzZXMgdGhlIHByb3BlcnR5J3MgYHJlZmxlY3RgIGFuZCBgdHlwZS50b0F0dHJpYnV0ZWAgcHJvcGVydHkgb3B0aW9ucy5cbiAgICAgKiBAbm9jb2xsYXBzZVxuICAgICAqL1xuICAgIHN0YXRpYyBfcHJvcGVydHlWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zLnJlZmxlY3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIGNvbnN0IGNvbnZlcnRlciA9IG9wdGlvbnMuY29udmVydGVyO1xuICAgICAgICBjb25zdCB0b0F0dHJpYnV0ZSA9IGNvbnZlcnRlciAmJiBjb252ZXJ0ZXIudG9BdHRyaWJ1dGUgfHxcbiAgICAgICAgICAgIGRlZmF1bHRDb252ZXJ0ZXIudG9BdHRyaWJ1dGU7XG4gICAgICAgIHJldHVybiB0b0F0dHJpYnV0ZSh2YWx1ZSwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGVsZW1lbnQgaW5pdGlhbGl6YXRpb24uIEJ5IGRlZmF1bHQgY2FwdHVyZXMgYW55IHByZS1zZXQgdmFsdWVzIGZvclxuICAgICAqIHJlZ2lzdGVyZWQgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBpbml0aWFsaXplKCkge1xuICAgICAgICB0aGlzLl9zYXZlSW5zdGFuY2VQcm9wZXJ0aWVzKCk7XG4gICAgICAgIC8vIGVuc3VyZXMgZmlyc3QgdXBkYXRlIHdpbGwgYmUgY2F1Z2h0IGJ5IGFuIGVhcmx5IGFjY2VzcyBvZlxuICAgICAgICAvLyBgdXBkYXRlQ29tcGxldGVgXG4gICAgICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRml4ZXMgYW55IHByb3BlcnRpZXMgc2V0IG9uIHRoZSBpbnN0YW5jZSBiZWZvcmUgdXBncmFkZSB0aW1lLlxuICAgICAqIE90aGVyd2lzZSB0aGVzZSB3b3VsZCBzaGFkb3cgdGhlIGFjY2Vzc29yIGFuZCBicmVhayB0aGVzZSBwcm9wZXJ0aWVzLlxuICAgICAqIFRoZSBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgaW4gYSBNYXAgd2hpY2ggaXMgcGxheWVkIGJhY2sgYWZ0ZXIgdGhlXG4gICAgICogY29uc3RydWN0b3IgcnVucy4gTm90ZSwgb24gdmVyeSBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpICg8PTkpIG9yIENocm9tZVxuICAgICAqICg8PTQxKSwgcHJvcGVydGllcyBjcmVhdGVkIGZvciBuYXRpdmUgcGxhdGZvcm0gcHJvcGVydGllcyBsaWtlIChgaWRgIG9yXG4gICAgICogYG5hbWVgKSBtYXkgbm90IGhhdmUgZGVmYXVsdCB2YWx1ZXMgc2V0IGluIHRoZSBlbGVtZW50IGNvbnN0cnVjdG9yLiBPblxuICAgICAqIHRoZXNlIGJyb3dzZXJzIG5hdGl2ZSBwcm9wZXJ0aWVzIGFwcGVhciBvbiBpbnN0YW5jZXMgYW5kIHRoZXJlZm9yZSB0aGVpclxuICAgICAqIGRlZmF1bHQgdmFsdWUgd2lsbCBvdmVyd3JpdGUgYW55IGVsZW1lbnQgZGVmYXVsdCAoZS5nLiBpZiB0aGUgZWxlbWVudCBzZXRzXG4gICAgICogdGhpcy5pZCA9ICdpZCcgaW4gdGhlIGNvbnN0cnVjdG9yLCB0aGUgJ2lkJyB3aWxsIGJlY29tZSAnJyBzaW5jZSB0aGlzIGlzXG4gICAgICogdGhlIG5hdGl2ZSBwbGF0Zm9ybSBkZWZhdWx0KS5cbiAgICAgKi9cbiAgICBfc2F2ZUluc3RhbmNlUHJvcGVydGllcygpIHtcbiAgICAgICAgLy8gVXNlIGZvckVhY2ggc28gdGhpcyB3b3JrcyBldmVuIGlmIGZvci9vZiBsb29wcyBhcmUgY29tcGlsZWQgdG8gZm9yIGxvb3BzXG4gICAgICAgIC8vIGV4cGVjdGluZyBhcnJheXNcbiAgICAgICAgdGhpcy5jb25zdHJ1Y3RvclxuICAgICAgICAgICAgLl9jbGFzc1Byb3BlcnRpZXMuZm9yRWFjaCgoX3YsIHApID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzW3BdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc3RhbmNlUHJvcGVydGllcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzLnNldChwLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHByZXZpb3VzbHkgc2F2ZWQgaW5zdGFuY2UgcHJvcGVydGllcy5cbiAgICAgKi9cbiAgICBfYXBwbHlJbnN0YW5jZVByb3BlcnRpZXMoKSB7XG4gICAgICAgIC8vIFVzZSBmb3JFYWNoIHNvIHRoaXMgd29ya3MgZXZlbiBpZiBmb3Ivb2YgbG9vcHMgYXJlIGNvbXBpbGVkIHRvIGZvciBsb29wc1xuICAgICAgICAvLyBleHBlY3RpbmcgYXJyYXlzXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICAgdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzLmZvckVhY2goKHYsIHApID0+IHRoaXNbcF0gPSB2KTtcbiAgICAgICAgdGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gRW5zdXJlIGZpcnN0IGNvbm5lY3Rpb24gY29tcGxldGVzIGFuIHVwZGF0ZS4gVXBkYXRlcyBjYW5ub3QgY29tcGxldGVcbiAgICAgICAgLy8gYmVmb3JlIGNvbm5lY3Rpb24uXG4gICAgICAgIHRoaXMuZW5hYmxlVXBkYXRpbmcoKTtcbiAgICB9XG4gICAgZW5hYmxlVXBkYXRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9lbmFibGVVcGRhdGluZ1Jlc29sdmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVVwZGF0aW5nUmVzb2x2ZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2VuYWJsZVVwZGF0aW5nUmVzb2x2ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIGZvciBgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKWAgaW4gZXh0ZW5zaW9ucyB3aGlsZVxuICAgICAqIHJlc2VydmluZyB0aGUgcG9zc2liaWxpdHkgb2YgbWFraW5nIG5vbi1icmVha2luZyBmZWF0dXJlIGFkZGl0aW9uc1xuICAgICAqIHdoZW4gZGlzY29ubmVjdGluZyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN5bmNocm9uaXplcyBwcm9wZXJ0eSB2YWx1ZXMgd2hlbiBhdHRyaWJ1dGVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUobmFtZSwgdmFsdWUsIG9wdGlvbnMgPSBkZWZhdWx0UHJvcGVydHlEZWNsYXJhdGlvbikge1xuICAgICAgICBjb25zdCBjdG9yID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgY29uc3QgYXR0ciA9IGN0b3IuX2F0dHJpYnV0ZU5hbWVGb3JQcm9wZXJ0eShuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgYXR0clZhbHVlID0gY3Rvci5fcHJvcGVydHlWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIGFuIHVuZGVmaW5lZCB2YWx1ZSBkb2VzIG5vdCBjaGFuZ2UgdGhlIGF0dHJpYnV0ZS5cbiAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyYWNrIGlmIHRoZSBwcm9wZXJ0eSBpcyBiZWluZyByZWZsZWN0ZWQgdG8gYXZvaWRcbiAgICAgICAgICAgIC8vIHNldHRpbmcgdGhlIHByb3BlcnR5IGFnYWluIHZpYSBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYC4gTm90ZTpcbiAgICAgICAgICAgIC8vIDEuIHRoaXMgdGFrZXMgYWR2YW50YWdlIG9mIHRoZSBmYWN0IHRoYXQgdGhlIGNhbGxiYWNrIGlzIHN5bmNocm9ub3VzLlxuICAgICAgICAgICAgLy8gMi4gd2lsbCBiZWhhdmUgaW5jb3JyZWN0bHkgaWYgbXVsdGlwbGUgYXR0cmlidXRlcyBhcmUgaW4gdGhlIHJlYWN0aW9uXG4gICAgICAgICAgICAvLyBzdGFjayBhdCB0aW1lIG9mIGNhbGxpbmcuIEhvd2V2ZXIsIHNpbmNlIHdlIHByb2Nlc3MgYXR0cmlidXRlc1xuICAgICAgICAgICAgLy8gaW4gYHVwZGF0ZWAgdGhpcyBzaG91bGQgbm90IGJlIHBvc3NpYmxlIChvciBhbiBleHRyZW1lIGNvcm5lciBjYXNlXG4gICAgICAgICAgICAvLyB0aGF0IHdlJ2QgbGlrZSB0byBkaXNjb3ZlcikuXG4gICAgICAgICAgICAvLyBtYXJrIHN0YXRlIHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgfCBTVEFURV9JU19SRUZMRUNUSU5HX1RPX0FUVFJJQlVURTtcbiAgICAgICAgICAgIGlmIChhdHRyVmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoYXR0ciwgYXR0clZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG1hcmsgc3RhdGUgbm90IHJlZmxlY3RpbmdcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgJiB+U1RBVEVfSVNfUkVGTEVDVElOR19UT19BVFRSSUJVVEU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gVXNlIHRyYWNraW5nIGluZm8gdG8gYXZvaWQgZGVzZXJpYWxpemluZyBhdHRyaWJ1dGUgdmFsdWUgaWYgaXQgd2FzXG4gICAgICAgIC8vIGp1c3Qgc2V0IGZyb20gYSBwcm9wZXJ0eSBzZXR0ZXIuXG4gICAgICAgIGlmICh0aGlzLl91cGRhdGVTdGF0ZSAmIFNUQVRFX0lTX1JFRkxFQ1RJTkdfVE9fQVRUUklCVVRFKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIC8vIE5vdGUsIGhpbnQgdGhpcyBhcyBhbiBgQXR0cmlidXRlTWFwYCBzbyBjbG9zdXJlIGNsZWFybHkgdW5kZXJzdGFuZHNcbiAgICAgICAgLy8gdGhlIHR5cGU7IGl0IGhhcyBpc3N1ZXMgd2l0aCB0cmFja2luZyB0eXBlcyB0aHJvdWdoIHN0YXRpY3NcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVubmVjZXNzYXJ5LXR5cGUtYXNzZXJ0aW9uXG4gICAgICAgIGNvbnN0IHByb3BOYW1lID0gY3Rvci5fYXR0cmlidXRlVG9Qcm9wZXJ0eU1hcC5nZXQobmFtZSk7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY3Rvci5nZXRQcm9wZXJ0eU9wdGlvbnMocHJvcE5hbWUpO1xuICAgICAgICAgICAgLy8gbWFyayBzdGF0ZSByZWZsZWN0aW5nXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlIHwgU1RBVEVfSVNfUkVGTEVDVElOR19UT19QUk9QRVJUWTtcbiAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID1cbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAgICAgICAgICAgY3Rvci5fcHJvcGVydHlWYWx1ZUZyb21BdHRyaWJ1dGUodmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gbWFyayBzdGF0ZSBub3QgcmVmbGVjdGluZ1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlU3RhdGUgPSB0aGlzLl91cGRhdGVTdGF0ZSAmIH5TVEFURV9JU19SRUZMRUNUSU5HX1RPX1BST1BFUlRZO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMgcHJpdmF0ZSB2ZXJzaW9uIG9mIGByZXF1ZXN0VXBkYXRlYCBkb2VzIG5vdCBhY2Nlc3Mgb3IgcmV0dXJuIHRoZVxuICAgICAqIGB1cGRhdGVDb21wbGV0ZWAgcHJvbWlzZS4gVGhpcyBwcm9taXNlIGNhbiBiZSBvdmVycmlkZGVuIGFuZCBpcyB0aGVyZWZvcmVcbiAgICAgKiBub3QgZnJlZSB0byBhY2Nlc3MuXG4gICAgICovXG4gICAgX3JlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgbGV0IHNob3VsZFJlcXVlc3RVcGRhdGUgPSB0cnVlO1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcHJvcGVydHkga2V5LCBwZXJmb3JtIHByb3BlcnR5IHVwZGF0ZSBzdGVwcy5cbiAgICAgICAgaWYgKG5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3RvciA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gY3Rvci5nZXRQcm9wZXJ0eU9wdGlvbnMobmFtZSk7XG4gICAgICAgICAgICBpZiAoY3Rvci5fdmFsdWVIYXNDaGFuZ2VkKHRoaXNbbmFtZV0sIG9sZFZhbHVlLCBvcHRpb25zLmhhc0NoYW5nZWQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGFuZ2VkUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlZFByb3BlcnRpZXMuc2V0KG5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHJlZmxlY3RpbmcgcHJvcGVydGllcyBzZXQuXG4gICAgICAgICAgICAgICAgLy8gTm90ZSwgaXQncyBpbXBvcnRhbnQgdGhhdCBldmVyeSBjaGFuZ2UgaGFzIGEgY2hhbmNlIHRvIGFkZCB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSB0byBgX3JlZmxlY3RpbmdQcm9wZXJ0aWVzYC4gVGhpcyBlbnN1cmVzIHNldHRpbmdcbiAgICAgICAgICAgICAgICAvLyBhdHRyaWJ1dGUgKyBwcm9wZXJ0eSByZWZsZWN0cyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMucmVmbGVjdCA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhKHRoaXMuX3VwZGF0ZVN0YXRlICYgU1RBVEVfSVNfUkVGTEVDVElOR19UT19QUk9QRVJUWSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZmxlY3RpbmdQcm9wZXJ0aWVzLnNldChuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBYm9ydCB0aGUgcmVxdWVzdCBpZiB0aGUgcHJvcGVydHkgc2hvdWxkIG5vdCBiZSBjb25zaWRlcmVkIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVxdWVzdFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5faGFzUmVxdWVzdGVkVXBkYXRlICYmIHNob3VsZFJlcXVlc3RVcGRhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVByb21pc2UgPSB0aGlzLl9lbnF1ZXVlVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYW4gdXBkYXRlIHdoaWNoIGlzIHByb2Nlc3NlZCBhc3luY2hyb25vdXNseS4gVGhpcyBzaG91bGRcbiAgICAgKiBiZSBjYWxsZWQgd2hlbiBhbiBlbGVtZW50IHNob3VsZCB1cGRhdGUgYmFzZWQgb24gc29tZSBzdGF0ZSBub3QgdHJpZ2dlcmVkXG4gICAgICogYnkgc2V0dGluZyBhIHByb3BlcnR5LiBJbiB0aGlzIGNhc2UsIHBhc3Mgbm8gYXJndW1lbnRzLiBJdCBzaG91bGQgYWxzbyBiZVxuICAgICAqIGNhbGxlZCB3aGVuIG1hbnVhbGx5IGltcGxlbWVudGluZyBhIHByb3BlcnR5IHNldHRlci4gSW4gdGhpcyBjYXNlLCBwYXNzIHRoZVxuICAgICAqIHByb3BlcnR5IGBuYW1lYCBhbmQgYG9sZFZhbHVlYCB0byBlbnN1cmUgdGhhdCBhbnkgY29uZmlndXJlZCBwcm9wZXJ0eVxuICAgICAqIG9wdGlvbnMgYXJlIGhvbm9yZWQuIFJldHVybnMgdGhlIGB1cGRhdGVDb21wbGV0ZWAgUHJvbWlzZSB3aGljaCBpcyByZXNvbHZlZFxuICAgICAqIHdoZW4gdGhlIHVwZGF0ZSBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSB7UHJvcGVydHlLZXl9IChvcHRpb25hbCkgbmFtZSBvZiByZXF1ZXN0aW5nIHByb3BlcnR5XG4gICAgICogQHBhcmFtIG9sZFZhbHVlIHthbnl9IChvcHRpb25hbCkgb2xkIHZhbHVlIG9mIHJlcXVlc3RpbmcgcHJvcGVydHlcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2hlbiB0aGUgdXBkYXRlIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICByZXF1ZXN0VXBkYXRlKG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RVcGRhdGUobmFtZSwgb2xkVmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVDb21wbGV0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCB0aGUgZWxlbWVudCB0byBhc3luY2hyb25vdXNseSB1cGRhdGUuXG4gICAgICovXG4gICAgYXN5bmMgX2VucXVldWVVcGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVN0YXRlID0gdGhpcy5fdXBkYXRlU3RhdGUgfCBTVEFURV9VUERBVEVfUkVRVUVTVEVEO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRW5zdXJlIGFueSBwcmV2aW91cyB1cGRhdGUgaGFzIHJlc29sdmVkIGJlZm9yZSB1cGRhdGluZy5cbiAgICAgICAgICAgIC8vIFRoaXMgYGF3YWl0YCBhbHNvIGVuc3VyZXMgdGhhdCBwcm9wZXJ0eSBjaGFuZ2VzIGFyZSBiYXRjaGVkLlxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlUHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gSWdub3JlIGFueSBwcmV2aW91cyBlcnJvcnMuIFdlIG9ubHkgY2FyZSB0aGF0IHRoZSBwcmV2aW91cyBjeWNsZSBpc1xuICAgICAgICAgICAgLy8gZG9uZS4gQW55IGVycm9yIHNob3VsZCBoYXZlIGJlZW4gaGFuZGxlZCBpbiB0aGUgcHJldmlvdXMgdXBkYXRlLlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMucGVyZm9ybVVwZGF0ZSgpO1xuICAgICAgICAvLyBJZiBgcGVyZm9ybVVwZGF0ZWAgcmV0dXJucyBhIFByb21pc2UsIHdlIGF3YWl0IGl0LiBUaGlzIGlzIGRvbmUgdG9cbiAgICAgICAgLy8gZW5hYmxlIGNvb3JkaW5hdGluZyB1cGRhdGVzIHdpdGggYSBzY2hlZHVsZXIuIE5vdGUsIHRoZSByZXN1bHQgaXNcbiAgICAgICAgLy8gY2hlY2tlZCB0byBhdm9pZCBkZWxheWluZyBhbiBhZGRpdGlvbmFsIG1pY3JvdGFzayB1bmxlc3Mgd2UgbmVlZCB0by5cbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBhd2FpdCByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICF0aGlzLl9oYXNSZXF1ZXN0ZWRVcGRhdGU7XG4gICAgfVxuICAgIGdldCBfaGFzUmVxdWVzdGVkVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3VwZGF0ZVN0YXRlICYgU1RBVEVfVVBEQVRFX1JFUVVFU1RFRCk7XG4gICAgfVxuICAgIGdldCBoYXNVcGRhdGVkKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3VwZGF0ZVN0YXRlICYgU1RBVEVfSEFTX1VQREFURUQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhbiBlbGVtZW50IHVwZGF0ZS4gTm90ZSwgaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBkdXJpbmcgdGhlXG4gICAgICogdXBkYXRlLCBgZmlyc3RVcGRhdGVkYCBhbmQgYHVwZGF0ZWRgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY2hhbmdlIHRoZSB0aW1pbmcgb2YgdXBkYXRlcy4gSWYgdGhpc1xuICAgICAqIG1ldGhvZCBpcyBvdmVycmlkZGVuLCBgc3VwZXIucGVyZm9ybVVwZGF0ZSgpYCBtdXN0IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEZvciBpbnN0YW5jZSwgdG8gc2NoZWR1bGUgdXBkYXRlcyB0byBvY2N1ciBqdXN0IGJlZm9yZSB0aGUgbmV4dCBmcmFtZTpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHByb3RlY3RlZCBhc3luYyBwZXJmb3JtVXBkYXRlKCk6IFByb21pc2U8dW5rbm93bj4ge1xuICAgICAqICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiByZXNvbHZlKCkpKTtcbiAgICAgKiAgIHN1cGVyLnBlcmZvcm1VcGRhdGUoKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcGVyZm9ybVVwZGF0ZSgpIHtcbiAgICAgICAgLy8gTWl4aW4gaW5zdGFuY2UgcHJvcGVydGllcyBvbmNlLCBpZiB0aGV5IGV4aXN0LlxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2VQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBseUluc3RhbmNlUHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2hhbmdlZFByb3BlcnRpZXMgPSB0aGlzLl9jaGFuZ2VkUHJvcGVydGllcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IHRoaXMuc2hvdWxkVXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZShjaGFuZ2VkUHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXJrVXBkYXRlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGBmaXJzdFVwZGF0ZWRgIGFuZCBgdXBkYXRlZGAgZnJvbSBydW5uaW5nIHdoZW4gdGhlcmUncyBhblxuICAgICAgICAgICAgLy8gdXBkYXRlIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gRW5zdXJlIGVsZW1lbnQgY2FuIGFjY2VwdCBhZGRpdGlvbmFsIHVwZGF0ZXMgYWZ0ZXIgYW4gZXhjZXB0aW9uLlxuICAgICAgICAgICAgdGhpcy5fbWFya1VwZGF0ZWQoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKCEodGhpcy5fdXBkYXRlU3RhdGUgJiBTVEFURV9IQVNfVVBEQVRFRCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlIHwgU1RBVEVfSEFTX1VQREFURUQ7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFVwZGF0ZWQoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy51cGRhdGVkKGNoYW5nZWRQcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfbWFya1VwZGF0ZWQoKSB7XG4gICAgICAgIHRoaXMuX2NoYW5nZWRQcm9wZXJ0aWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVTdGF0ZSA9IHRoaXMuX3VwZGF0ZVN0YXRlICYgflNUQVRFX1VQREFURV9SRVFVRVNURUQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZWxlbWVudCBoYXMgY29tcGxldGVkIHVwZGF0aW5nLlxuICAgICAqIFRoZSBQcm9taXNlIHZhbHVlIGlzIGEgYm9vbGVhbiB0aGF0IGlzIGB0cnVlYCBpZiB0aGUgZWxlbWVudCBjb21wbGV0ZWQgdGhlXG4gICAgICogdXBkYXRlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS4gVGhlIFByb21pc2UgcmVzdWx0IGlzIGBmYWxzZWAgaWZcbiAgICAgKiBhIHByb3BlcnR5IHdhcyBzZXQgaW5zaWRlIGB1cGRhdGVkKClgLiBJZiB0aGUgUHJvbWlzZSBpcyByZWplY3RlZCwgYW5cbiAgICAgKiBleGNlcHRpb24gd2FzIHRocm93biBkdXJpbmcgdGhlIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIFRvIGF3YWl0IGFkZGl0aW9uYWwgYXN5bmNocm9ub3VzIHdvcmssIG92ZXJyaWRlIHRoZSBgX2dldFVwZGF0ZUNvbXBsZXRlYFxuICAgICAqIG1ldGhvZC4gRm9yIGV4YW1wbGUsIGl0IGlzIHNvbWV0aW1lcyB1c2VmdWwgdG8gYXdhaXQgYSByZW5kZXJlZCBlbGVtZW50XG4gICAgICogYmVmb3JlIGZ1bGZpbGxpbmcgdGhpcyBQcm9taXNlLiBUbyBkbyB0aGlzLCBmaXJzdCBhd2FpdFxuICAgICAqIGBzdXBlci5fZ2V0VXBkYXRlQ29tcGxldGUoKWAsIHRoZW4gYW55IHN1YnNlcXVlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgcmV0dXJucyBhIGJvb2xlYW4gdGhhdCBpbmRpY2F0ZXMgaWYgdGhlXG4gICAgICogdXBkYXRlIHJlc29sdmVkIHdpdGhvdXQgdHJpZ2dlcmluZyBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKi9cbiAgICBnZXQgdXBkYXRlQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRVcGRhdGVDb21wbGV0ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgdGhlIGB1cGRhdGVDb21wbGV0ZWAgcHJvbWlzZS5cbiAgICAgKlxuICAgICAqIEl0IGlzIG5vdCBzYWZlIHRvIG92ZXJyaWRlIHRoZSBgdXBkYXRlQ29tcGxldGVgIGdldHRlciBkaXJlY3RseSBkdWUgdG8gYVxuICAgICAqIGxpbWl0YXRpb24gaW4gVHlwZVNjcmlwdCB3aGljaCBtZWFucyBpdCBpcyBub3QgcG9zc2libGUgdG8gY2FsbCBhXG4gICAgICogc3VwZXJjbGFzcyBnZXR0ZXIgKGUuZy4gYHN1cGVyLnVwZGF0ZUNvbXBsZXRlLnRoZW4oLi4uKWApIHdoZW4gdGhlIHRhcmdldFxuICAgICAqIGxhbmd1YWdlIGlzIEVTNSAoaHR0cHM6Ly9naXRodWIuY29tL21pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8zMzgpLlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBvdmVycmlkZGVuIGluc3RlYWQuIEZvciBleGFtcGxlOlxuICAgICAqXG4gICAgICogICBjbGFzcyBNeUVsZW1lbnQgZXh0ZW5kcyBMaXRFbGVtZW50IHtcbiAgICAgKiAgICAgYXN5bmMgX2dldFVwZGF0ZUNvbXBsZXRlKCkge1xuICAgICAqICAgICAgIGF3YWl0IHN1cGVyLl9nZXRVcGRhdGVDb21wbGV0ZSgpO1xuICAgICAqICAgICAgIGF3YWl0IHRoaXMuX215Q2hpbGQudXBkYXRlQ29tcGxldGU7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKi9cbiAgICBfZ2V0VXBkYXRlQ29tcGxldGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGRhdGVQcm9taXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb250cm9scyB3aGV0aGVyIG9yIG5vdCBgdXBkYXRlYCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGVsZW1lbnQgcmVxdWVzdHNcbiAgICAgKiBhbiB1cGRhdGUuIEJ5IGRlZmF1bHQsIHRoaXMgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGB0cnVlYCwgYnV0IHRoaXMgY2FuIGJlXG4gICAgICogY3VzdG9taXplZCB0byBjb250cm9sIHdoZW4gdG8gdXBkYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHNob3VsZFVwZGF0ZShfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGVsZW1lbnQuIFRoaXMgbWV0aG9kIHJlZmxlY3RzIHByb3BlcnR5IHZhbHVlcyB0byBhdHRyaWJ1dGVzLlxuICAgICAqIEl0IGNhbiBiZSBvdmVycmlkZGVuIHRvIHJlbmRlciBhbmQga2VlcCB1cGRhdGVkIGVsZW1lbnQgRE9NLlxuICAgICAqIFNldHRpbmcgcHJvcGVydGllcyBpbnNpZGUgdGhpcyBtZXRob2Qgd2lsbCAqbm90KiB0cmlnZ2VyXG4gICAgICogYW5vdGhlciB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gX2NoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAgICovXG4gICAgdXBkYXRlKF9jaGFuZ2VkUHJvcGVydGllcykge1xuICAgICAgICBpZiAodGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIC8vIFVzZSBmb3JFYWNoIHNvIHRoaXMgd29ya3MgZXZlbiBpZiBmb3Ivb2YgbG9vcHMgYXJlIGNvbXBpbGVkIHRvIGZvclxuICAgICAgICAgICAgLy8gbG9vcHMgZXhwZWN0aW5nIGFycmF5c1xuICAgICAgICAgICAgdGhpcy5fcmVmbGVjdGluZ1Byb3BlcnRpZXMuZm9yRWFjaCgodiwgaykgPT4gdGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShrLCB0aGlzW2tdLCB2KSk7XG4gICAgICAgICAgICB0aGlzLl9yZWZsZWN0aW5nUHJvcGVydGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXJrVXBkYXRlZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZva2VkIHdoZW5ldmVyIHRoZSBlbGVtZW50IGlzIHVwZGF0ZWQuIEltcGxlbWVudCB0byBwZXJmb3JtXG4gICAgICogcG9zdC11cGRhdGluZyB0YXNrcyB2aWEgRE9NIEFQSXMsIGZvciBleGFtcGxlLCBmb2N1c2luZyBhbiBlbGVtZW50LlxuICAgICAqXG4gICAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAgICogYWdhaW4gYWZ0ZXIgdGhpcyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIHVwZGF0ZWQoX2NoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludm9rZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBmaXJzdCB1cGRhdGVkLiBJbXBsZW1lbnQgdG8gcGVyZm9ybSBvbmUgdGltZVxuICAgICAqIHdvcmsgb24gdGhlIGVsZW1lbnQgYWZ0ZXIgdXBkYXRlLlxuICAgICAqXG4gICAgICogU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZSB0aGlzIG1ldGhvZCB3aWxsIHRyaWdnZXIgdGhlIGVsZW1lbnQgdG8gdXBkYXRlXG4gICAgICogYWdhaW4gYWZ0ZXIgdGhpcyB1cGRhdGUgY3ljbGUgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF9jaGFuZ2VkUHJvcGVydGllcyBNYXAgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIHdpdGggb2xkIHZhbHVlc1xuICAgICAqL1xuICAgIGZpcnN0VXBkYXRlZChfY2hhbmdlZFByb3BlcnRpZXMpIHtcbiAgICB9XG59XG5fYSA9IGZpbmFsaXplZDtcbi8qKlxuICogTWFya3MgY2xhc3MgYXMgaGF2aW5nIGZpbmlzaGVkIGNyZWF0aW5nIHByb3BlcnRpZXMuXG4gKi9cblVwZGF0aW5nRWxlbWVudFtfYV0gPSB0cnVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXBkYXRpbmctZWxlbWVudC5qcy5tYXAiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5jb25zdCBsZWdhY3lDdXN0b21FbGVtZW50ID0gKHRhZ05hbWUsIGNsYXp6KSA9PiB7XG4gICAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSh0YWdOYW1lLCBjbGF6eik7XG4gICAgLy8gQ2FzdCBhcyBhbnkgYmVjYXVzZSBUUyBkb2Vzbid0IHJlY29nbml6ZSB0aGUgcmV0dXJuIHR5cGUgYXMgYmVpbmcgYVxuICAgIC8vIHN1YnR5cGUgb2YgdGhlIGRlY29yYXRlZCBjbGFzcyB3aGVuIGNsYXp6IGlzIHR5cGVkIGFzXG4gICAgLy8gYENvbnN0cnVjdG9yPEhUTUxFbGVtZW50PmAgZm9yIHNvbWUgcmVhc29uLlxuICAgIC8vIGBDb25zdHJ1Y3RvcjxIVE1MRWxlbWVudD5gIGlzIGhlbHBmdWwgdG8gbWFrZSBzdXJlIHRoZSBkZWNvcmF0b3IgaXNcbiAgICAvLyBhcHBsaWVkIHRvIGVsZW1lbnRzIGhvd2V2ZXIuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHJldHVybiBjbGF6ejtcbn07XG5jb25zdCBzdGFuZGFyZEN1c3RvbUVsZW1lbnQgPSAodGFnTmFtZSwgZGVzY3JpcHRvcikgPT4ge1xuICAgIGNvbnN0IHsga2luZCwgZWxlbWVudHMgfSA9IGRlc2NyaXB0b3I7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZCxcbiAgICAgICAgZWxlbWVudHMsXG4gICAgICAgIC8vIFRoaXMgY2FsbGJhY2sgaXMgY2FsbGVkIG9uY2UgdGhlIGNsYXNzIGlzIG90aGVyd2lzZSBmdWxseSBkZWZpbmVkXG4gICAgICAgIGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICB3aW5kb3cuY3VzdG9tRWxlbWVudHMuZGVmaW5lKHRhZ05hbWUsIGNsYXp6KTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLyoqXG4gKiBDbGFzcyBkZWNvcmF0b3IgZmFjdG9yeSB0aGF0IGRlZmluZXMgdGhlIGRlY29yYXRlZCBjbGFzcyBhcyBhIGN1c3RvbSBlbGVtZW50LlxuICpcbiAqIGBgYFxuICogQGN1c3RvbUVsZW1lbnQoJ215LWVsZW1lbnQnKVxuICogY2xhc3MgTXlFbGVtZW50IHtcbiAqICAgcmVuZGVyKCkge1xuICogICAgIHJldHVybiBodG1sYGA7XG4gKiAgIH1cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSB0YWdOYW1lIFRoZSBuYW1lIG9mIHRoZSBjdXN0b20gZWxlbWVudCB0byBkZWZpbmUuXG4gKi9cbmV4cG9ydCBjb25zdCBjdXN0b21FbGVtZW50ID0gKHRhZ05hbWUpID0+IChjbGFzc09yRGVzY3JpcHRvcikgPT4gKHR5cGVvZiBjbGFzc09yRGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykgP1xuICAgIGxlZ2FjeUN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY2xhc3NPckRlc2NyaXB0b3IpIDpcbiAgICBzdGFuZGFyZEN1c3RvbUVsZW1lbnQodGFnTmFtZSwgY2xhc3NPckRlc2NyaXB0b3IpO1xuY29uc3Qgc3RhbmRhcmRQcm9wZXJ0eSA9IChvcHRpb25zLCBlbGVtZW50KSA9PiB7XG4gICAgLy8gV2hlbiBkZWNvcmF0aW5nIGFuIGFjY2Vzc29yLCBwYXNzIGl0IHRocm91Z2ggYW5kIGFkZCBwcm9wZXJ0eSBtZXRhZGF0YS5cbiAgICAvLyBOb3RlLCB0aGUgYGhhc093blByb3BlcnR5YCBjaGVjayBpbiBgY3JlYXRlUHJvcGVydHlgIGVuc3VyZXMgd2UgZG9uJ3RcbiAgICAvLyBzdG9tcCBvdmVyIHRoZSB1c2VyJ3MgYWNjZXNzb3IuXG4gICAgaWYgKGVsZW1lbnQua2luZCA9PT0gJ21ldGhvZCcgJiYgZWxlbWVudC5kZXNjcmlwdG9yICYmXG4gICAgICAgICEoJ3ZhbHVlJyBpbiBlbGVtZW50LmRlc2NyaXB0b3IpKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVsZW1lbnQpLCB7IGZpbmlzaGVyKGNsYXp6KSB7XG4gICAgICAgICAgICAgICAgY2xhenouY3JlYXRlUHJvcGVydHkoZWxlbWVudC5rZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZVByb3BlcnR5KCkgdGFrZXMgY2FyZSBvZiBkZWZpbmluZyB0aGUgcHJvcGVydHksIGJ1dCB3ZSBzdGlsbFxuICAgICAgICAvLyBtdXN0IHJldHVybiBzb21lIGtpbmQgb2YgZGVzY3JpcHRvciwgc28gcmV0dXJuIGEgZGVzY3JpcHRvciBmb3IgYW5cbiAgICAgICAgLy8gdW51c2VkIHByb3RvdHlwZSBmaWVsZC4gVGhlIGZpbmlzaGVyIGNhbGxzIGNyZWF0ZVByb3BlcnR5KCkuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiAnZmllbGQnLFxuICAgICAgICAgICAga2V5OiBTeW1ib2woKSxcbiAgICAgICAgICAgIHBsYWNlbWVudDogJ293bicsXG4gICAgICAgICAgICBkZXNjcmlwdG9yOiB7fSxcbiAgICAgICAgICAgIC8vIFdoZW4gQGJhYmVsL3BsdWdpbi1wcm9wb3NhbC1kZWNvcmF0b3JzIGltcGxlbWVudHMgaW5pdGlhbGl6ZXJzLFxuICAgICAgICAgICAgLy8gZG8gdGhpcyBpbnN0ZWFkIG9mIHRoZSBpbml0aWFsaXplciBiZWxvdy4gU2VlOlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2JhYmVsL2JhYmVsL2lzc3Vlcy85MjYwIGV4dHJhczogW1xuICAgICAgICAgICAgLy8gICB7XG4gICAgICAgICAgICAvLyAgICAga2luZDogJ2luaXRpYWxpemVyJyxcbiAgICAgICAgICAgIC8vICAgICBwbGFjZW1lbnQ6ICdvd24nLFxuICAgICAgICAgICAgLy8gICAgIGluaXRpYWxpemVyOiBkZXNjcmlwdG9yLmluaXRpYWxpemVyLFxuICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAvLyBdLFxuICAgICAgICAgICAgaW5pdGlhbGl6ZXIoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbGVtZW50LmluaXRpYWxpemVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbZWxlbWVudC5rZXldID0gZWxlbWVudC5pbml0aWFsaXplci5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hlcihjbGF6eikge1xuICAgICAgICAgICAgICAgIGNsYXp6LmNyZWF0ZVByb3BlcnR5KGVsZW1lbnQua2V5LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59O1xuY29uc3QgbGVnYWN5UHJvcGVydHkgPSAob3B0aW9ucywgcHJvdG8sIG5hbWUpID0+IHtcbiAgICBwcm90by5jb25zdHJ1Y3RvclxuICAgICAgICAuY3JlYXRlUHJvcGVydHkobmFtZSwgb3B0aW9ucyk7XG59O1xuLyoqXG4gKiBBIHByb3BlcnR5IGRlY29yYXRvciB3aGljaCBjcmVhdGVzIGEgTGl0RWxlbWVudCBwcm9wZXJ0eSB3aGljaCByZWZsZWN0cyBhXG4gKiBjb3JyZXNwb25kaW5nIGF0dHJpYnV0ZSB2YWx1ZS4gQSBgUHJvcGVydHlEZWNsYXJhdGlvbmAgbWF5IG9wdGlvbmFsbHkgYmVcbiAqIHN1cHBsaWVkIHRvIGNvbmZpZ3VyZSBwcm9wZXJ0eSBmZWF0dXJlcy5cbiAqXG4gKiBUaGlzIGRlY29yYXRvciBzaG91bGQgb25seSBiZSB1c2VkIGZvciBwdWJsaWMgZmllbGRzLiBQcml2YXRlIG9yIHByb3RlY3RlZFxuICogZmllbGRzIHNob3VsZCB1c2UgdGhlIGludGVybmFsUHJvcGVydHkgZGVjb3JhdG9yLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgICAgICBAcHJvcGVydHkoeyB0eXBlOiBCb29sZWFuIH0pXG4gKiAgICAgICBjbGlja2VkID0gZmFsc2U7XG4gKiAgICAgfVxuICpcbiAqIEBFeHBvcnREZWNvcmF0ZWRJdGVtc1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHkob3B0aW9ucykge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnkgZGVjb3JhdG9yXG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgPT4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICBsZWdhY3lQcm9wZXJ0eShvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICBzdGFuZGFyZFByb3BlcnR5KG9wdGlvbnMsIHByb3RvT3JEZXNjcmlwdG9yKTtcbn1cbi8qKlxuICogRGVjbGFyZXMgYSBwcml2YXRlIG9yIHByb3RlY3RlZCBwcm9wZXJ0eSB0aGF0IHN0aWxsIHRyaWdnZXJzIHVwZGF0ZXMgdG8gdGhlXG4gKiBlbGVtZW50IHdoZW4gaXQgY2hhbmdlcy5cbiAqXG4gKiBQcm9wZXJ0aWVzIGRlY2xhcmVkIHRoaXMgd2F5IG11c3Qgbm90IGJlIHVzZWQgZnJvbSBIVE1MIG9yIEhUTUwgdGVtcGxhdGluZ1xuICogc3lzdGVtcywgdGhleSdyZSBzb2xlbHkgZm9yIHByb3BlcnRpZXMgaW50ZXJuYWwgdG8gdGhlIGVsZW1lbnQuIFRoZXNlXG4gKiBwcm9wZXJ0aWVzIG1heSBiZSByZW5hbWVkIGJ5IG9wdGltaXphdGlvbiB0b29scyBsaWtlIGNsb3N1cmUgY29tcGlsZXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRlcm5hbFByb3BlcnR5KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcHJvcGVydHkoeyBhdHRyaWJ1dGU6IGZhbHNlLCBoYXNDaGFuZ2VkOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuaGFzQ2hhbmdlZCB9KTtcbn1cbi8qKlxuICogQSBwcm9wZXJ0eSBkZWNvcmF0b3IgdGhhdCBjb252ZXJ0cyBhIGNsYXNzIHByb3BlcnR5IGludG8gYSBnZXR0ZXIgdGhhdFxuICogZXhlY3V0ZXMgYSBxdWVyeVNlbGVjdG9yIG9uIHRoZSBlbGVtZW50J3MgcmVuZGVyUm9vdC5cbiAqXG4gKiBAcGFyYW0gc2VsZWN0b3IgQSBET01TdHJpbmcgY29udGFpbmluZyBvbmUgb3IgbW9yZSBzZWxlY3RvcnMgdG8gbWF0Y2guXG4gKlxuICogU2VlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvclxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgICAgICBAcXVlcnkoJyNmaXJzdCcpXG4gKiAgICAgICBmaXJzdDtcbiAqXG4gKiAgICAgICByZW5kZXIoKSB7XG4gKiAgICAgICAgIHJldHVybiBodG1sYFxuICogICAgICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgICAgIDxkaXYgaWQ9XCJzZWNvbmRcIj48L2Rpdj5cbiAqICAgICAgICAgYDtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnkoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKHByb3RvT3JEZXNjcmlwdG9yLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGRlY29yYXRvclxuICAgIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJSb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiAobmFtZSAhPT0gdW5kZWZpbmVkKSA/XG4gICAgICAgICAgICBsZWdhY3lRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICAgICAgc3RhbmRhcmRRdWVyeShkZXNjcmlwdG9yLCBwcm90b09yRGVzY3JpcHRvcik7XG4gICAgfTtcbn1cbi8vIE5vdGUsIGluIHRoZSBmdXR1cmUsIHdlIG1heSBleHRlbmQgdGhpcyBkZWNvcmF0b3IgdG8gc3VwcG9ydCB0aGUgdXNlIGNhc2Vcbi8vIHdoZXJlIHRoZSBxdWVyaWVkIGVsZW1lbnQgbWF5IG5lZWQgdG8gZG8gd29yayB0byBiZWNvbWUgcmVhZHkgdG8gaW50ZXJhY3Rcbi8vIHdpdGggKGUuZy4gbG9hZCBzb21lIGltcGxlbWVudGF0aW9uIGNvZGUpLiBJZiBzbywgd2UgbWlnaHQgZWxlY3QgdG9cbi8vIGFkZCBhIHNlY29uZCBhcmd1bWVudCBkZWZpbmluZyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0byBtYWtlIHRoZVxuLy8gcXVlcmllZCBlbGVtZW50IGxvYWRlZC91cGRhdGVkL3JlYWR5LlxuLyoqXG4gKiBBIHByb3BlcnR5IGRlY29yYXRvciB0aGF0IGNvbnZlcnRzIGEgY2xhc3MgcHJvcGVydHkgaW50byBhIGdldHRlciB0aGF0XG4gKiByZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXN1bHQgb2YgYSBxdWVyeVNlbGVjdG9yIG9uIHRoZVxuICogZWxlbWVudCdzIHJlbmRlclJvb3QgZG9uZSBhZnRlciB0aGUgZWxlbWVudCdzIGB1cGRhdGVDb21wbGV0ZWAgcHJvbWlzZVxuICogcmVzb2x2ZXMuIFdoZW4gdGhlIHF1ZXJpZWQgcHJvcGVydHkgbWF5IGNoYW5nZSB3aXRoIGVsZW1lbnQgc3RhdGUsIHRoaXNcbiAqIGRlY29yYXRvciBjYW4gYmUgdXNlZCBpbnN0ZWFkIG9mIHJlcXVpcmluZyB1c2VycyB0byBhd2FpdCB0aGVcbiAqIGB1cGRhdGVDb21wbGV0ZWAgYmVmb3JlIGFjY2Vzc2luZyB0aGUgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHNlbGVjdG9yIEEgRE9NU3RyaW5nIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgc2VsZWN0b3JzIHRvIG1hdGNoLlxuICpcbiAqIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L3F1ZXJ5U2VsZWN0b3JcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqICAgICBjbGFzcyBNeUVsZW1lbnQge1xuICogICAgICAgQHF1ZXJ5QXN5bmMoJyNmaXJzdCcpXG4gKiAgICAgICBmaXJzdDtcbiAqXG4gKiAgICAgICByZW5kZXIoKSB7XG4gKiAgICAgICAgIHJldHVybiBodG1sYFxuICogICAgICAgICAgIDxkaXYgaWQ9XCJmaXJzdFwiPjwvZGl2PlxuICogICAgICAgICAgIDxkaXYgaWQ9XCJzZWNvbmRcIj48L2Rpdj5cbiAqICAgICAgICAgYDtcbiAqICAgICAgIH1cbiAqICAgICB9XG4gKlxuICogICAgIC8vIGV4dGVybmFsIHVzYWdlXG4gKiAgICAgYXN5bmMgZG9Tb21ldGhpbmdXaXRoRmlyc3QoKSB7XG4gKiAgICAgIChhd2FpdCBhTXlFbGVtZW50LmZpcnN0KS5kb1NvbWV0aGluZygpO1xuICogICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5QXN5bmMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gKHByb3RvT3JEZXNjcmlwdG9yLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGRlY29yYXRvclxuICAgIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGFzeW5jIGdldCgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwZGF0ZUNvbXBsZXRlO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlclJvb3QucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA6XG4gICAgICAgICAgICBzdGFuZGFyZFF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuLyoqXG4gKiBBIHByb3BlcnR5IGRlY29yYXRvciB0aGF0IGNvbnZlcnRzIGEgY2xhc3MgcHJvcGVydHkgaW50byBhIGdldHRlclxuICogdGhhdCBleGVjdXRlcyBhIHF1ZXJ5U2VsZWN0b3JBbGwgb24gdGhlIGVsZW1lbnQncyByZW5kZXJSb290LlxuICpcbiAqIEBwYXJhbSBzZWxlY3RvciBBIERPTVN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHNlbGVjdG9ycyB0byBtYXRjaC5cbiAqXG4gKiBTZWU6XG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvcXVlcnlTZWxlY3RvckFsbFxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgICAgICBAcXVlcnlBbGwoJ2RpdicpXG4gKiAgICAgICBkaXZzO1xuICpcbiAqICAgICAgIHJlbmRlcigpIHtcbiAqICAgICAgICAgcmV0dXJuIGh0bWxgXG4gKiAgICAgICAgICAgPGRpdiBpZD1cImZpcnN0XCI+PC9kaXY+XG4gKiAgICAgICAgICAgPGRpdiBpZD1cInNlY29uZFwiPjwvZGl2PlxuICogICAgICAgICBgO1xuICogICAgICAgfVxuICogICAgIH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5QWxsKHNlbGVjdG9yKSB7XG4gICAgcmV0dXJuIChwcm90b09yRGVzY3JpcHRvciwgXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueSBkZWNvcmF0b3JcbiAgICBuYW1lKSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyUm9vdC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKG5hbWUgIT09IHVuZGVmaW5lZCkgP1xuICAgICAgICAgICAgbGVnYWN5UXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IsIG5hbWUpIDpcbiAgICAgICAgICAgIHN0YW5kYXJkUXVlcnkoZGVzY3JpcHRvciwgcHJvdG9PckRlc2NyaXB0b3IpO1xuICAgIH07XG59XG5jb25zdCBsZWdhY3lRdWVyeSA9IChkZXNjcmlwdG9yLCBwcm90bywgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwgZGVzY3JpcHRvcik7XG59O1xuY29uc3Qgc3RhbmRhcmRRdWVyeSA9IChkZXNjcmlwdG9yLCBlbGVtZW50KSA9PiAoe1xuICAgIGtpbmQ6ICdtZXRob2QnLFxuICAgIHBsYWNlbWVudDogJ3Byb3RvdHlwZScsXG4gICAga2V5OiBlbGVtZW50LmtleSxcbiAgICBkZXNjcmlwdG9yLFxufSk7XG5jb25zdCBzdGFuZGFyZEV2ZW50T3B0aW9ucyA9IChvcHRpb25zLCBlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZWxlbWVudCksIHsgZmluaXNoZXIoY2xhenopIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY2xhenoucHJvdG90eXBlW2VsZW1lbnQua2V5XSwgb3B0aW9ucyk7XG4gICAgICAgIH0gfSk7XG59O1xuY29uc3QgbGVnYWN5RXZlbnRPcHRpb25zID0gXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGxlZ2FjeSBkZWNvcmF0b3JcbihvcHRpb25zLCBwcm90bywgbmFtZSkgPT4ge1xuICAgIE9iamVjdC5hc3NpZ24ocHJvdG9bbmFtZV0sIG9wdGlvbnMpO1xufTtcbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lciBvcHRpb25zIHRvIGEgbWV0aG9kIHVzZWQgYXMgYW4gZXZlbnQgbGlzdGVuZXIgaW4gYVxuICogbGl0LWh0bWwgdGVtcGxhdGUuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgQW4gb2JqZWN0IHRoYXQgc3BlY2lmaWVzIGV2ZW50IGxpc3RlbmVyIG9wdGlvbnMgYXMgYWNjZXB0ZWQgYnlcbiAqIGBFdmVudFRhcmdldCNhZGRFdmVudExpc3RlbmVyYCBhbmQgYEV2ZW50VGFyZ2V0I3JlbW92ZUV2ZW50TGlzdGVuZXJgLlxuICpcbiAqIEN1cnJlbnQgYnJvd3NlcnMgc3VwcG9ydCB0aGUgYGNhcHR1cmVgLCBgcGFzc2l2ZWAsIGFuZCBgb25jZWAgb3B0aW9ucy4gU2VlOlxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0V2ZW50VGFyZ2V0L2FkZEV2ZW50TGlzdGVuZXIjUGFyYW1ldGVyc1xuICpcbiAqIEBleGFtcGxlXG4gKlxuICogICAgIGNsYXNzIE15RWxlbWVudCB7XG4gKiAgICAgICBjbGlja2VkID0gZmFsc2U7XG4gKlxuICogICAgICAgcmVuZGVyKCkge1xuICogICAgICAgICByZXR1cm4gaHRtbGBcbiAqICAgICAgICAgICA8ZGl2IEBjbGljaz0ke3RoaXMuX29uQ2xpY2t9YD5cbiAqICAgICAgICAgICAgIDxidXR0b24+PC9idXR0b24+XG4gKiAgICAgICAgICAgPC9kaXY+XG4gKiAgICAgICAgIGA7XG4gKiAgICAgICB9XG4gKlxuICogICAgICAgQGV2ZW50T3B0aW9ucyh7Y2FwdHVyZTogdHJ1ZX0pXG4gKiAgICAgICBfb25DbGljayhlKSB7XG4gKiAgICAgICAgIHRoaXMuY2xpY2tlZCA9IHRydWU7XG4gKiAgICAgICB9XG4gKiAgICAgfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAvLyBSZXR1cm4gdmFsdWUgdHlwZWQgYXMgYW55IHRvIHByZXZlbnQgVHlwZVNjcmlwdCBmcm9tIGNvbXBsYWluaW5nIHRoYXRcbiAgICAvLyBzdGFuZGFyZCBkZWNvcmF0b3IgZnVuY3Rpb24gc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIFR5cGVTY3JpcHQgZGVjb3JhdG9yXG4gICAgLy8gc2lnbmF0dXJlXG4gICAgLy8gVE9ETyhrc2NoYWFmKTogdW5jbGVhciB3aHkgaXQgd2FzIG9ubHkgZmFpbGluZyBvbiB0aGlzIGRlY29yYXRvciBhbmQgbm90XG4gICAgLy8gdGhlIG90aGVyc1xuICAgIHJldHVybiAoKHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA9PiAobmFtZSAhPT0gdW5kZWZpbmVkKSA/XG4gICAgICAgIGxlZ2FjeUV2ZW50T3B0aW9ucyhvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvciwgbmFtZSkgOlxuICAgICAgICBzdGFuZGFyZEV2ZW50T3B0aW9ucyhvcHRpb25zLCBwcm90b09yRGVzY3JpcHRvcikpO1xufVxuLyoqXG4gKiBBIHByb3BlcnR5IGRlY29yYXRvciB0aGF0IGNvbnZlcnRzIGEgY2xhc3MgcHJvcGVydHkgaW50byBhIGdldHRlciB0aGF0XG4gKiByZXR1cm5zIHRoZSBgYXNzaWduZWROb2Rlc2Agb2YgdGhlIGdpdmVuIG5hbWVkIGBzbG90YC4gTm90ZSwgdGhlIHR5cGUgb2ZcbiAqIHRoaXMgcHJvcGVydHkgc2hvdWxkIGJlIGFubm90YXRlZCBhcyBgTm9kZUxpc3RPZjxIVE1MRWxlbWVudD5gLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHF1ZXJ5QXNzaWduZWROb2RlcyhzbG90TmFtZSA9ICcnLCBmbGF0dGVuID0gZmFsc2UpIHtcbiAgICByZXR1cm4gKHByb3RvT3JEZXNjcmlwdG9yLCBcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55IGRlY29yYXRvclxuICAgIG5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IGBzbG90JHtzbG90TmFtZSA/IGBbbmFtZT0ke3Nsb3ROYW1lfV1gIDogJyd9YDtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90ID0gdGhpcy5yZW5kZXJSb290LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzbG90ICYmIHNsb3QuYXNzaWduZWROb2Rlcyh7IGZsYXR0ZW4gfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIChuYW1lICE9PSB1bmRlZmluZWQpID9cbiAgICAgICAgICAgIGxlZ2FjeVF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yLCBuYW1lKSA6XG4gICAgICAgICAgICBzdGFuZGFyZFF1ZXJ5KGRlc2NyaXB0b3IsIHByb3RvT3JEZXNjcmlwdG9yKTtcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGVjb3JhdG9ycy5qcy5tYXAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTkgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG5odHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHQgVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0IFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZVxuZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHQgQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXNcbnBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnRcbmZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgPSAoJ2Fkb3B0ZWRTdHlsZVNoZWV0cycgaW4gRG9jdW1lbnQucHJvdG90eXBlKSAmJlxuICAgICgncmVwbGFjZScgaW4gQ1NTU3R5bGVTaGVldC5wcm90b3R5cGUpO1xuY29uc3QgY29uc3RydWN0aW9uVG9rZW4gPSBTeW1ib2woKTtcbmV4cG9ydCBjbGFzcyBDU1NSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKGNzc1RleHQsIHNhZmVUb2tlbikge1xuICAgICAgICBpZiAoc2FmZVRva2VuICE9PSBjb25zdHJ1Y3Rpb25Ub2tlbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDU1NSZXN1bHQgaXMgbm90IGNvbnN0cnVjdGFibGUuIFVzZSBgdW5zYWZlQ1NTYCBvciBgY3NzYCBpbnN0ZWFkLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3NzVGV4dCA9IGNzc1RleHQ7XG4gICAgfVxuICAgIC8vIE5vdGUsIHRoaXMgaXMgYSBnZXR0ZXIgc28gdGhhdCBpdCdzIGxhenkuIEluIHByYWN0aWNlLCB0aGlzIG1lYW5zXG4gICAgLy8gc3R5bGVzaGVldHMgYXJlIG5vdCBjcmVhdGVkIHVudGlsIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIG1hZGUuXG4gICAgZ2V0IHN0eWxlU2hlZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdHlsZVNoZWV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIE5vdGUsIGlmIGBhZG9wdGVkU3R5bGVTaGVldHNgIGlzIHN1cHBvcnRlZCB0aGVuIHdlIGFzc3VtZSBDU1NTdHlsZVNoZWV0XG4gICAgICAgICAgICAvLyBpcyBjb25zdHJ1Y3RhYmxlLlxuICAgICAgICAgICAgaWYgKHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBuZXcgQ1NTU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQucmVwbGFjZVN5bmModGhpcy5jc3NUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0eWxlU2hlZXQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZVNoZWV0O1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3NzVGV4dDtcbiAgICB9XG59XG4vKipcbiAqIFdyYXAgYSB2YWx1ZSBmb3IgaW50ZXJwb2xhdGlvbiBpbiBhIGNzcyB0YWdnZWQgdGVtcGxhdGUgbGl0ZXJhbC5cbiAqXG4gKiBUaGlzIGlzIHVuc2FmZSBiZWNhdXNlIHVudHJ1c3RlZCBDU1MgdGV4dCBjYW4gYmUgdXNlZCB0byBwaG9uZSBob21lXG4gKiBvciBleGZpbHRyYXRlIGRhdGEgdG8gYW4gYXR0YWNrZXIgY29udHJvbGxlZCBzaXRlLiBUYWtlIGNhcmUgdG8gb25seSB1c2VcbiAqIHRoaXMgd2l0aCB0cnVzdGVkIGlucHV0LlxuICovXG5leHBvcnQgY29uc3QgdW5zYWZlQ1NTID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBDU1NSZXN1bHQoU3RyaW5nKHZhbHVlKSwgY29uc3RydWN0aW9uVG9rZW4pO1xufTtcbmNvbnN0IHRleHRGcm9tQ1NTUmVzdWx0ID0gKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQ1NTUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5jc3NUZXh0O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsdWUgcGFzc2VkIHRvICdjc3MnIGZ1bmN0aW9uIG11c3QgYmUgYSAnY3NzJyBmdW5jdGlvbiByZXN1bHQ6ICR7dmFsdWV9LiBVc2UgJ3Vuc2FmZUNTUycgdG8gcGFzcyBub24tbGl0ZXJhbCB2YWx1ZXMsIGJ1dFxuICAgICAgICAgICAgdGFrZSBjYXJlIHRvIGVuc3VyZSBwYWdlIHNlY3VyaXR5LmApO1xuICAgIH1cbn07XG4vKipcbiAqIFRlbXBsYXRlIHRhZyB3aGljaCB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIExpdEVsZW1lbnQncyBgc3R5bGVgIHByb3BlcnR5IHRvXG4gKiBzZXQgZWxlbWVudCBzdHlsZXMuIEZvciBzZWN1cml0eSByZWFzb25zLCBvbmx5IGxpdGVyYWwgc3RyaW5nIHZhbHVlcyBtYXkgYmVcbiAqIHVzZWQuIFRvIGluY29ycG9yYXRlIG5vbi1saXRlcmFsIHZhbHVlcyBgdW5zYWZlQ1NTYCBtYXkgYmUgdXNlZCBpbnNpZGUgYVxuICogdGVtcGxhdGUgc3RyaW5nIHBhcnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjc3MgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiB7XG4gICAgY29uc3QgY3NzVGV4dCA9IHZhbHVlcy5yZWR1Y2UoKGFjYywgdiwgaWR4KSA9PiBhY2MgKyB0ZXh0RnJvbUNTU1Jlc3VsdCh2KSArIHN0cmluZ3NbaWR4ICsgMV0sIHN0cmluZ3NbMF0pO1xuICAgIHJldHVybiBuZXcgQ1NTUmVzdWx0KGNzc1RleHQsIGNvbnN0cnVjdGlvblRva2VuKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jc3MtdGFnLmpzLm1hcCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbmltcG9ydCB7IHJlbmRlciB9IGZyb20gJ2xpdC1odG1sL2xpYi9zaGFkeS1yZW5kZXIuanMnO1xuaW1wb3J0IHsgVXBkYXRpbmdFbGVtZW50IH0gZnJvbSAnLi9saWIvdXBkYXRpbmctZWxlbWVudC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2xpYi91cGRhdGluZy1lbGVtZW50LmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2RlY29yYXRvcnMuanMnO1xuZXhwb3J0IHsgaHRtbCwgc3ZnLCBUZW1wbGF0ZVJlc3VsdCwgU1ZHVGVtcGxhdGVSZXN1bHQgfSBmcm9tICdsaXQtaHRtbC9saXQtaHRtbC5qcyc7XG5pbXBvcnQgeyBzdXBwb3J0c0Fkb3B0aW5nU3R5bGVTaGVldHMgfSBmcm9tICcuL2xpYi9jc3MtdGFnLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbGliL2Nzcy10YWcuanMnO1xuLy8gSU1QT1JUQU5UOiBkbyBub3QgY2hhbmdlIHRoZSBwcm9wZXJ0eSBuYW1lIG9yIHRoZSBhc3NpZ25tZW50IGV4cHJlc3Npb24uXG4vLyBUaGlzIGxpbmUgd2lsbCBiZSB1c2VkIGluIHJlZ2V4ZXMgdG8gc2VhcmNoIGZvciBMaXRFbGVtZW50IHVzYWdlLlxuLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogaW5qZWN0IHZlcnNpb24gbnVtYmVyIGF0IGJ1aWxkIHRpbWVcbih3aW5kb3dbJ2xpdEVsZW1lbnRWZXJzaW9ucyddIHx8ICh3aW5kb3dbJ2xpdEVsZW1lbnRWZXJzaW9ucyddID0gW10pKVxuICAgIC5wdXNoKCcyLjMuMScpO1xuLyoqXG4gKiBTZW50aW5hbCB2YWx1ZSB1c2VkIHRvIGF2b2lkIGNhbGxpbmcgbGl0LWh0bWwncyByZW5kZXIgZnVuY3Rpb24gd2hlblxuICogc3ViY2xhc3NlcyBkbyBub3QgaW1wbGVtZW50IGByZW5kZXJgXG4gKi9cbmNvbnN0IHJlbmRlck5vdEltcGxlbWVudGVkID0ge307XG5leHBvcnQgY2xhc3MgTGl0RWxlbWVudCBleHRlbmRzIFVwZGF0aW5nRWxlbWVudCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBhcnJheSBvZiBzdHlsZXMgdG8gYXBwbHkgdG8gdGhlIGVsZW1lbnQuXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gaW50ZWdyYXRlIGludG8gYSBzdHlsZSBtYW5hZ2VtZW50IHN5c3RlbS5cbiAgICAgKlxuICAgICAqIEBub2NvbGxhcHNlXG4gICAgICovXG4gICAgc3RhdGljIGdldFN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3R5bGVzO1xuICAgIH1cbiAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICBzdGF0aWMgX2dldFVuaXF1ZVN0eWxlcygpIHtcbiAgICAgICAgLy8gT25seSBnYXRoZXIgc3R5bGVzIG9uY2UgcGVyIGNsYXNzXG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19zdHlsZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUYWtlIGNhcmUgbm90IHRvIGNhbGwgYHRoaXMuZ2V0U3R5bGVzKClgIG11bHRpcGxlIHRpbWVzIHNpbmNlIHRoaXNcbiAgICAgICAgLy8gZ2VuZXJhdGVzIG5ldyBDU1NSZXN1bHRzIGVhY2ggdGltZS5cbiAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogU2luY2Ugd2UgZG8gbm90IGNhY2hlIENTU1Jlc3VsdHMgYnkgaW5wdXQsIGFueVxuICAgICAgICAvLyBzaGFyZWQgc3R5bGVzIHdpbGwgZ2VuZXJhdGUgbmV3IHN0eWxlc2hlZXQgb2JqZWN0cywgd2hpY2ggaXMgd2FzdGVmdWwuXG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFkZHJlc3NlZCB3aGVuIGEgYnJvd3NlciBzaGlwcyBjb25zdHJ1Y3RhYmxlXG4gICAgICAgIC8vIHN0eWxlc2hlZXRzLlxuICAgICAgICBjb25zdCB1c2VyU3R5bGVzID0gdGhpcy5nZXRTdHlsZXMoKTtcbiAgICAgICAgaWYgKHVzZXJTdHlsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh1c2VyU3R5bGVzKSkge1xuICAgICAgICAgICAgLy8gRGUtZHVwbGljYXRlIHN0eWxlcyBwcmVzZXJ2aW5nIHRoZSBfbGFzdF8gaW5zdGFuY2UgaW4gdGhlIHNldC5cbiAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gdG8gYXZvaWQgZHVwbGljYXRlZCBzdHlsZXMgdGhhdCBjYW5cbiAgICAgICAgICAgIC8vIG9jY3VyIGVzcGVjaWFsbHkgd2hlbiBjb21wb3NpbmcgdmlhIHN1YmNsYXNzaW5nLlxuICAgICAgICAgICAgLy8gVGhlIGxhc3QgaXRlbSBpcyBrZXB0IHRvIHRyeSB0byBwcmVzZXJ2ZSB0aGUgY2FzY2FkZSBvcmRlciB3aXRoIHRoZVxuICAgICAgICAgICAgLy8gYXNzdW1wdGlvbiB0aGF0IGl0J3MgbW9zdCBpbXBvcnRhbnQgdGhhdCBsYXN0IGFkZGVkIHN0eWxlcyBvdmVycmlkZVxuICAgICAgICAgICAgLy8gcHJldmlvdXMgc3R5bGVzLlxuICAgICAgICAgICAgY29uc3QgYWRkU3R5bGVzID0gKHN0eWxlcywgc2V0KSA9PiBzdHlsZXMucmVkdWNlUmlnaHQoKHNldCwgcykgPT4gXG4gICAgICAgICAgICAvLyBOb3RlOiBPbiBJRSBzZXQuYWRkKCkgZG9lcyBub3QgcmV0dXJuIHRoZSBzZXRcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkocykgPyBhZGRTdHlsZXMocywgc2V0KSA6IChzZXQuYWRkKHMpLCBzZXQpLCBzZXQpO1xuICAgICAgICAgICAgLy8gQXJyYXkuZnJvbSBkb2VzIG5vdCB3b3JrIG9uIFNldCBpbiBJRSwgb3RoZXJ3aXNlIHJldHVyblxuICAgICAgICAgICAgLy8gQXJyYXkuZnJvbShhZGRTdHlsZXModXNlclN0eWxlcywgbmV3IFNldDxDU1NSZXN1bHQ+KCkpKS5yZXZlcnNlKClcbiAgICAgICAgICAgIGNvbnN0IHNldCA9IGFkZFN0eWxlcyh1c2VyU3R5bGVzLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0gW107XG4gICAgICAgICAgICBzZXQuZm9yRWFjaCgodikgPT4gc3R5bGVzLnVuc2hpZnQodikpO1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gc3R5bGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc3R5bGVzID0gW3VzZXJTdHlsZXNdO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGVsZW1lbnQgaW5pdGlhbGl6YXRpb24uIEJ5IGRlZmF1bHQgdGhpcyBjYWxscyBgY3JlYXRlUmVuZGVyUm9vdGBcbiAgICAgKiB0byBjcmVhdGUgdGhlIGVsZW1lbnQgYHJlbmRlclJvb3RgIG5vZGUgYW5kIGNhcHR1cmVzIGFueSBwcmUtc2V0IHZhbHVlcyBmb3JcbiAgICAgKiByZWdpc3RlcmVkIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpO1xuICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9nZXRVbmlxdWVTdHlsZXMoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSb290ID1cbiAgICAgICAgICAgIHRoaXMuY3JlYXRlUmVuZGVyUm9vdCgpO1xuICAgICAgICAvLyBOb3RlLCBpZiByZW5kZXJSb290IGlzIG5vdCBhIHNoYWRvd1Jvb3QsIHN0eWxlcyB3b3VsZC9jb3VsZCBhcHBseSB0byB0aGVcbiAgICAgICAgLy8gZWxlbWVudCdzIGdldFJvb3ROb2RlKCkuIFdoaWxlIHRoaXMgY291bGQgYmUgZG9uZSwgd2UncmUgY2hvb3Npbmcgbm90IHRvXG4gICAgICAgIC8vIHN1cHBvcnQgdGhpcyBub3cgc2luY2UgaXQgd291bGQgcmVxdWlyZSBkaWZmZXJlbnQgbG9naWMgYXJvdW5kIGRlLWR1cGluZy5cbiAgICAgICAgaWYgKHdpbmRvdy5TaGFkb3dSb290ICYmIHRoaXMucmVuZGVyUm9vdCBpbnN0YW5jZW9mIHdpbmRvdy5TaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0aGlzLmFkb3B0U3R5bGVzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbm9kZSBpbnRvIHdoaWNoIHRoZSBlbGVtZW50IHNob3VsZCByZW5kZXIgYW5kIGJ5IGRlZmF1bHRcbiAgICAgKiBjcmVhdGVzIGFuZCByZXR1cm5zIGFuIG9wZW4gc2hhZG93Um9vdC4gSW1wbGVtZW50IHRvIGN1c3RvbWl6ZSB3aGVyZSB0aGVcbiAgICAgKiBlbGVtZW50J3MgRE9NIGlzIHJlbmRlcmVkLiBGb3IgZXhhbXBsZSwgdG8gcmVuZGVyIGludG8gdGhlIGVsZW1lbnQnc1xuICAgICAqIGNoaWxkTm9kZXMsIHJldHVybiBgdGhpc2AuXG4gICAgICogQHJldHVybnMge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gUmV0dXJucyBhIG5vZGUgaW50byB3aGljaCB0byByZW5kZXIuXG4gICAgICovXG4gICAgY3JlYXRlUmVuZGVyUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoU2hhZG93KHsgbW9kZTogJ29wZW4nIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIHN0eWxpbmcgdG8gdGhlIGVsZW1lbnQgc2hhZG93Um9vdCB1c2luZyB0aGUgYHN0YXRpYyBnZXQgc3R5bGVzYFxuICAgICAqIHByb3BlcnR5LiBTdHlsaW5nIHdpbGwgYXBwbHkgdXNpbmcgYHNoYWRvd1Jvb3QuYWRvcHRlZFN0eWxlU2hlZXRzYCB3aGVyZVxuICAgICAqIGF2YWlsYWJsZSBhbmQgd2lsbCBmYWxsYmFjayBvdGhlcndpc2UuIFdoZW4gU2hhZG93IERPTSBpcyBwb2x5ZmlsbGVkLFxuICAgICAqIFNoYWR5Q1NTIHNjb3BlcyBzdHlsZXMgYW5kIGFkZHMgdGhlbSB0byB0aGUgZG9jdW1lbnQuIFdoZW4gU2hhZG93IERPTVxuICAgICAqIGlzIGF2YWlsYWJsZSBidXQgYGFkb3B0ZWRTdHlsZVNoZWV0c2AgaXMgbm90LCBzdHlsZXMgYXJlIGFwcGVuZGVkIHRvIHRoZVxuICAgICAqIGVuZCBvZiB0aGUgYHNoYWRvd1Jvb3RgIHRvIFttaW1pYyBzcGVjXG4gICAgICogYmVoYXZpb3JdKGh0dHBzOi8vd2ljZy5naXRodWIuaW8vY29uc3RydWN0LXN0eWxlc2hlZXRzLyN1c2luZy1jb25zdHJ1Y3RlZC1zdHlsZXNoZWV0cykuXG4gICAgICovXG4gICAgYWRvcHRTdHlsZXMoKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlcyA9IHRoaXMuY29uc3RydWN0b3IuX3N0eWxlcztcbiAgICAgICAgaWYgKHN0eWxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVyZSBhcmUgdGhyZWUgc2VwYXJhdGUgY2FzZXMgaGVyZSBiYXNlZCBvbiBTaGFkb3cgRE9NIHN1cHBvcnQuXG4gICAgICAgIC8vICgxKSBzaGFkb3dSb290IHBvbHlmaWxsZWQ6IHVzZSBTaGFkeUNTU1xuICAgICAgICAvLyAoMikgc2hhZG93Um9vdC5hZG9wdGVkU3R5bGVTaGVldHMgYXZhaWxhYmxlOiB1c2UgaXQuXG4gICAgICAgIC8vICgzKSBzaGFkb3dSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyBwb2x5ZmlsbGVkOiBhcHBlbmQgc3R5bGVzIGFmdGVyXG4gICAgICAgIC8vIHJlbmRlcmluZ1xuICAgICAgICBpZiAod2luZG93LlNoYWR5Q1NTICE9PSB1bmRlZmluZWQgJiYgIXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVTaGFkb3cpIHtcbiAgICAgICAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5wcmVwYXJlQWRvcHRlZENzc1RleHQoc3R5bGVzLm1hcCgocykgPT4gcy5jc3NUZXh0KSwgdGhpcy5sb2NhbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN1cHBvcnRzQWRvcHRpbmdTdHlsZVNoZWV0cykge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJSb290LmFkb3B0ZWRTdHlsZVNoZWV0cyA9XG4gICAgICAgICAgICAgICAgc3R5bGVzLm1hcCgocykgPT4gcy5zdHlsZVNoZWV0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBiZSBkb25lIGFmdGVyIHJlbmRlcmluZyBzbyB0aGUgYWN0dWFsIHN0eWxlIGluc2VydGlvbiBpcyBkb25lXG4gICAgICAgICAgICAvLyBpbiBgdXBkYXRlYC5cbiAgICAgICAgICAgIHRoaXMuX25lZWRzU2hpbUFkb3B0ZWRTdHlsZVNoZWV0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICAgIC8vIE5vdGUsIGZpcnN0IHVwZGF0ZS9yZW5kZXIgaGFuZGxlcyBzdHlsZUVsZW1lbnQgc28gd2Ugb25seSBjYWxsIHRoaXMgaWZcbiAgICAgICAgLy8gY29ubmVjdGVkIGFmdGVyIGZpcnN0IHVwZGF0ZS5cbiAgICAgICAgaWYgKHRoaXMuaGFzVXBkYXRlZCAmJiB3aW5kb3cuU2hhZHlDU1MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBlbGVtZW50LiBUaGlzIG1ldGhvZCByZWZsZWN0cyBwcm9wZXJ0eSB2YWx1ZXMgdG8gYXR0cmlidXRlc1xuICAgICAqIGFuZCBjYWxscyBgcmVuZGVyYCB0byByZW5kZXIgRE9NIHZpYSBsaXQtaHRtbC4gU2V0dGluZyBwcm9wZXJ0aWVzIGluc2lkZVxuICAgICAqIHRoaXMgbWV0aG9kIHdpbGwgKm5vdCogdHJpZ2dlciBhbm90aGVyIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gX2NoYW5nZWRQcm9wZXJ0aWVzIE1hcCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMgd2l0aCBvbGQgdmFsdWVzXG4gICAgICovXG4gICAgdXBkYXRlKGNoYW5nZWRQcm9wZXJ0aWVzKSB7XG4gICAgICAgIC8vIFNldHRpbmcgcHJvcGVydGllcyBpbiBgcmVuZGVyYCBzaG91bGQgbm90IHRyaWdnZXIgYW4gdXBkYXRlLiBTaW5jZVxuICAgICAgICAvLyB1cGRhdGVzIGFyZSBhbGxvd2VkIGFmdGVyIHN1cGVyLnVwZGF0ZSwgaXQncyBpbXBvcnRhbnQgdG8gY2FsbCBgcmVuZGVyYFxuICAgICAgICAvLyBiZWZvcmUgdGhhdC5cbiAgICAgICAgY29uc3QgdGVtcGxhdGVSZXN1bHQgPSB0aGlzLnJlbmRlcigpO1xuICAgICAgICBzdXBlci51cGRhdGUoY2hhbmdlZFByb3BlcnRpZXMpO1xuICAgICAgICAvLyBJZiByZW5kZXIgaXMgbm90IGltcGxlbWVudGVkIGJ5IHRoZSBjb21wb25lbnQsIGRvbid0IGNhbGwgbGl0LWh0bWwgcmVuZGVyXG4gICAgICAgIGlmICh0ZW1wbGF0ZVJlc3VsdCAhPT0gcmVuZGVyTm90SW1wbGVtZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAucmVuZGVyKHRlbXBsYXRlUmVzdWx0LCB0aGlzLnJlbmRlclJvb3QsIHsgc2NvcGVOYW1lOiB0aGlzLmxvY2FsTmFtZSwgZXZlbnRDb250ZXh0OiB0aGlzIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gbmF0aXZlIFNoYWRvdyBET00gaXMgdXNlZCBidXQgYWRvcHRlZFN0eWxlcyBhcmUgbm90IHN1cHBvcnRlZCxcbiAgICAgICAgLy8gaW5zZXJ0IHN0eWxpbmcgYWZ0ZXIgcmVuZGVyaW5nIHRvIGVuc3VyZSBhZG9wdGVkU3R5bGVzIGhhdmUgaGlnaGVzdFxuICAgICAgICAvLyBwcmlvcml0eS5cbiAgICAgICAgaWYgKHRoaXMuX25lZWRzU2hpbUFkb3B0ZWRTdHlsZVNoZWV0cykge1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNTaGltQWRvcHRlZFN0eWxlU2hlZXRzID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLl9zdHlsZXMuZm9yRWFjaCgocykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHMuY3NzVGV4dDtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclJvb3QuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlZCBvbiBlYWNoIHVwZGF0ZSB0byBwZXJmb3JtIHJlbmRlcmluZyB0YXNrcy4gVGhpcyBtZXRob2QgbWF5IHJldHVyblxuICAgICAqIGFueSB2YWx1ZSByZW5kZXJhYmxlIGJ5IGxpdC1odG1sJ3MgTm9kZVBhcnQgLSB0eXBpY2FsbHkgYSBUZW1wbGF0ZVJlc3VsdC5cbiAgICAgKiBTZXR0aW5nIHByb3BlcnRpZXMgaW5zaWRlIHRoaXMgbWV0aG9kIHdpbGwgKm5vdCogdHJpZ2dlciB0aGUgZWxlbWVudCB0b1xuICAgICAqIHVwZGF0ZS5cbiAgICAgKi9cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJOb3RJbXBsZW1lbnRlZDtcbiAgICB9XG59XG4vKipcbiAqIEVuc3VyZSB0aGlzIGNsYXNzIGlzIG1hcmtlZCBhcyBgZmluYWxpemVkYCBhcyBhbiBvcHRpbWl6YXRpb24gZW5zdXJpbmdcbiAqIGl0IHdpbGwgbm90IG5lZWRsZXNzbHkgdHJ5IHRvIGBmaW5hbGl6ZWAuXG4gKlxuICogTm90ZSB0aGlzIHByb3BlcnR5IG5hbWUgaXMgYSBzdHJpbmcgdG8gcHJldmVudCBicmVha2luZyBDbG9zdXJlIEpTIENvbXBpbGVyXG4gKiBvcHRpbWl6YXRpb25zLiBTZWUgdXBkYXRpbmctZWxlbWVudC50cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuTGl0RWxlbWVudFsnZmluYWxpemVkJ10gPSB0cnVlO1xuLyoqXG4gKiBSZW5kZXIgbWV0aG9kIHVzZWQgdG8gcmVuZGVyIHRoZSB2YWx1ZSB0byB0aGUgZWxlbWVudCdzIERPTS5cbiAqIEBwYXJhbSByZXN1bHQgVGhlIHZhbHVlIHRvIHJlbmRlci5cbiAqIEBwYXJhbSBjb250YWluZXIgTm9kZSBpbnRvIHdoaWNoIHRvIHJlbmRlci5cbiAqIEBwYXJhbSBvcHRpb25zIEVsZW1lbnQgbmFtZS5cbiAqIEBub2NvbGxhcHNlXG4gKi9cbkxpdEVsZW1lbnQucmVuZGVyID0gcmVuZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWVsZW1lbnQuanMubWFwIiwiLy9pbXBvcnQgIGV2ZSBmcm9tICdldmVqcy9kaXN0L2V2ZS5jdXN0b20uanMnO1xyXG5cclxuZnVuY3Rpb24gSGVsbG9BZ2VudChpZCl7XHJcbiAgLy8gZXhlY3V0ZSBzdXBlciBjb25zdHJ1Y3RvclxyXG4gIGV2ZS5BZ2VudC5jYWxsKHRoaXMsIGlkKTtcclxuICAvLyBjb25uZWN0IHRvIGFsbCB0cmFuc3BvcnRzIGNvbmZpZ3VyZWQgYnkgdGhlIHN5c3RlbVxyXG4gIHRoaXMuY29ubmVjdChldmUuc3lzdGVtLnRyYW5zcG9ydHMuZ2V0QWxsKCkpO1xyXG59XHJcblxyXG4vLyBleHRlbmQgdGhlIGV2ZS5BZ2VudCBwcm90b3R5cGVcclxuSGVsbG9BZ2VudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGV2ZS5BZ2VudC5wcm90b3R5cGUpO1xyXG5IZWxsb0FnZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEhlbGxvQWdlbnQ7XHJcbkhlbGxvQWdlbnQucHJvdG90eXBlLnNheUhlbGxvID0gZnVuY3Rpb24odG8pIHtcclxuICB0aGlzLnNlbmQodG8sICdIZWxsbyAnICsgdG8gKyAnIScpO1xyXG59O1xyXG5cclxuSGVsbG9BZ2VudC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAvL3Nsb2codGhpcy5pZCtcIiByZWNlaXZlZCBmcm9tIDpcIitmcm9tICsgJyB0aGlzIG1lc3NhZ2U6ICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgY29uc29sZS5sb2codGhpcy5pZCtcIiByZWNlaXZlZCBmcm9tIDpcIitmcm9tICsgJyB0aGlzIG1lc3NhZ2U6ICcgKyBKU09OLnN0cmluZ2lmeShtZXNzYWdlKSk7XHJcbiAgaWYgKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpLmluZGV4T2YoJ0hlbGxvJykgPT09IDApIHtcclxuICAgIC8vIHJlcGx5IHRvIHRoZSBncmVldGluZ1xyXG4gICAgdGhpcy5zZW5kKGZyb20sICdIaSAnICsgZnJvbSArICcsIG5pY2UgdG8gbWVldCB5b3UhJyk7XHJcbiAgfVxyXG59O1xyXG5cclxuXHJcbkhlbGxvQWdlbnQucHJvdG90eXBlLmJyb2FkY2FzdCA9IGZ1bmN0aW9uKG1lc3NhZ2Upe1xyXG4gIHZhciBtZSA9IHRoaXNcclxuICB2YXIgYWxsQWdlbnRzID0gT2JqZWN0LmtleXModGhpcy5jb25uZWN0aW9uc1swXS50cmFuc3BvcnQuYWdlbnRzKTtcclxuIGNvbnNvbGUubG9nKGFsbEFnZW50cylcclxuICBhbGxBZ2VudHMuZm9yRWFjaChmdW5jdGlvbiAoYWdlbnQpe1xyXG4gICAgbWUuc2VuZChhZ2VudCwgbWVzc2FnZSk7XHJcbiAgfSlcclxufVxyXG5cclxuSGVsbG9BZ2VudC5wcm90b3R5cGUuc2VuZE11bHRpID0gZnVuY3Rpb24ocmVjaXBpZW50cywgbWVzc2FnZSl7XHJcbiAgdmFyIG1lID0gdGhpc1xyXG4gIHJlY2lwaWVudHMuZm9yRWFjaChmdW5jdGlvbiAoYWdlbnQpe1xyXG4gIC8vICBjb25zb2xlLmxvZyhhZ2VudCwgbWVzc2FnZSlcclxuICAgIG1lLnNlbmQoYWdlbnQsIG1lc3NhZ2UpO1xyXG4gIH0pXHJcbn1cclxuXHJcbmV4cG9ydCB7SGVsbG9BZ2VudH07XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgQXBwVmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgbGV2ZWxzOiB7dHlwZTogQXJyYXl9LFxyXG4gICAgICBsZXZlbDoge3R5cGU6IFN0cmluZ31cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkFwcFwiXHJcbiAgICB0aGlzLmxldmVscyA9IFsgXCJCcm93c2VyXCIsIFwiVHJpcGxlXCIsIFwiTm9kZVwiXSAvLyBcIlBvZFwiLCwgXCJHcm91cHNcIiBbXCJXb3JsZFwiLCBcIk9yZ2FuaXphdGlvblwiLCBcIlBvZFwiLCBcIkZvbGRlclwiLCBcIkZpbGVcIiwgXCJUcmlwbGVcIiwgXCJOb2RlXCIgXVxyXG4gICAgdGhpcy5sZXZlbCA9IHRoaXMubGV2ZWxzWzBdXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG4gICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lci1mbHVpZFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgPGRpdiBjbGFzcz1cImNvbFwiPlxyXG4gICAgPHZpcy12aWV3IG5hbWU9XCJWaXNcIj5Mb2FkaW5nIFZJUzwvdmlzLXZpZXc+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJjb2xcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICR7dGhpcy5sZXZlbHMubWFwKGwgPT5cclxuICAgICAgaHRtbGBcclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1wcmltYXJ5ICR7dGhpcy5sZXZlbCA9PSBsID8gXCJhY3RpdmVcIjogXCJcIn1cIiBsZXZlbD1cIiR7bH1cIiBAY2xpY2s9XCIke3RoaXMubGV2ZWxDaGFuZ2VkfVwiPiR7bH08L2J1dHRvbj5cclxuICAgICAgYCl9XHJcbiAgICAgIDxsb2dpbi1lbGVtZW50IG5hbWU9XCJMb2dpblwiPjwvbG9naW4tZWxlbWVudD5cclxuICAgICAgPC9kaXY+XHJcblxyXG5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwhLS0gICAgPHZpcy10b29sLXZpZXcgbmFtZT1cIlZpc1Rvb2xcIj5WaXMgVG9vbDwvdmlzLXRvb2wtdmlldz4gLS0+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwicm93XCI+XHJcbiAgICAgICR7dGhpcy5sZXZlbH1cclxuXHJcbiAgICAgIDxicm93c2VyLXZpZXcgbmFtZT1cIkJyb3dzZXJcIiA/aGlkZGVuPVwiJHt0aGlzLmxldmVsICE9IFwiQnJvd3NlclwifVwiPjwvYnJvd3Nlci12aWV3PlxyXG5cclxuICAgICAgPGlucHV0LXZpZXcgbmFtZT1cIklucHV0XCIgP2hpZGRlbj1cIiR7dGhpcy5sZXZlbCAhPSBcIlRyaXBsZVwifVwiPjwvaW5wdXQtdmlldz5cclxuICAgICAgPHNlbGVjdGVkLXZpZXcgbmFtZT1cIlNlbGVjdGVkXCIgP2hpZGRlbj1cIiR7dGhpcy5sZXZlbCAhPSBcIk5vZGVcIn1cIj48L3NlbGVjdGVkLXZpZXc+XHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIGA7XHJcbiAgICB9XHJcblxyXG4gICAgbGV2ZWxDaGFuZ2VkKGUpe1xyXG4gICAgICB0aGlzLmxldmVsID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwibGV2ZWxcIilcclxuICAgIH1cclxuICAgIC8qZnVuY3Rpb24gcmVjdXBQYXJhbXMoKXtcclxuICAgIC8vY29uc29sZS5sb2cod2luZG93LmxvY2F0aW9uKVxyXG4gICAgdmFyIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2grd2luZG93LmxvY2F0aW9uLmhhc2g7ICAvLyBwb3VyIGNhdGNoZXIgbGVzIC9jYXJkI21lXHJcbiAgICB2YXIgcGFyYW1zID0gKGZ1bmN0aW9uKGEpIHtcclxuICAgIGlmIChhID09IFwiXCIpIHJldHVybiB7fTtcclxuICAgIHZhciBiID0ge307XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpXHJcbiAgICB7ICAgICAgICB2YXIgcD1hW2ldLnNwbGl0KCc9JywgMik7XHJcbiAgICBpZiAocC5sZW5ndGggPT0gMSlcclxuICAgIGJbcFswXV0gPSBcIlwiO1xyXG4gICAgZWxzZVxyXG4gICAgYltwWzBdXSA9IGRlY29kZVVSSUNvbXBvbmVudChwWzFdLnJlcGxhY2UoL1xcKy9nLCBcIiBcIikpO1xyXG4gIH1cclxuICByZXR1cm4gYjtcclxufSkodXJsLnN1YnN0cigxKS5zcGxpdCgnJicpKTtcclxucmV0dXJuIHBhcmFtcztcclxufSovXHJcblxyXG5cclxuXHJcbmZpcnN0VXBkYXRlZCgpe1xyXG4gIHZhciBhcHAgPSB0aGlzO1xyXG4gIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgLy8gIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgIGNhc2UgXCJsZXZlbENoYW5nZWRcIjpcclxuICAgICAgICBhcHAubGV2ZWwgPSBtZXNzYWdlLmxldmVsXHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9O1xyXG59XHJcblxyXG5jb25maWdDaGFuZ2VkKGNvbmZpZyl7XHJcbiAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICBjb25zb2xlLmxvZyh0aGlzLmNvbmZpZylcclxufVxyXG5cclxufVxyXG5cclxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdhcHAtdmlldycsIEFwcFZpZXcpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuLy9pbXBvcnQgeyBCYXNlVmlldyB9IGZyb20gJy4vYmFzZS12aWV3LmpzJztcclxuLy9pbXBvcnQgKiBhcyBhdXRoIGZyb20gJ3NvbGlkLWF1dGgtY2xpZW50JztcclxuLy8vL2xldCBkYXRhID0gc29saWQuZGF0YVxyXG4vL2NvbnNvbGUubG9nKFwiTERGSytMRVhcIixkYXRhKVxyXG5cclxuY2xhc3MgTG9naW5FbGVtZW50IGV4dGVuZHMgTGl0RWxlbWVudCB7XHJcblxyXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICB3ZWJJZDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGRlc3RpbmF0YWlyZXM6IHt0eXBlOiBTdHJpbmd9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy53ZWJJZCA9IG51bGxcclxuICAgIC8vICB0aGlzLmRlc3RpbmF0YWlyZXMgPSBbJ0FwcCcsJ0NvbmZpZycsICdDb25maWdHZXQnLCAnRmFiJywgJ1Bvc3QnLCAnUG9zdFRhYnMnLCAnUHJvZmlsZScsICdQcm9maWxlQ2FydG91Y2hlJywgJ0ZyaWVuZHMnXVxyXG4gICAgdGhpcy5kZXN0aW5hdGFpcmVzID0gWydCcm93c2VyJywgJ0lucHV0J11cclxuXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuICAgICR7dGhpcy53ZWJJZCA9PSBudWxsID9cclxuICAgICAgaHRtbGBcclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXN1Y2Nlc3NcIiBAY2xpY2s9JHt0aGlzLmxvZ2lufT5Mb2dpbjwvYnV0dG9uPlxyXG4gICAgICBgXHJcbiAgICAgIDogaHRtbGBcclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNtIGJ0bi1vdXRsaW5lLWRhbmdlclwiIEBjbGljaz0ke3RoaXMubG9nb3V0fT5Mb2dvdXQ8L2J1dHRvbj5cclxuICAgICAgYFxyXG4gICAgfVxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAgIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgICAgY2FzZSBcIndlYklkQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgYXBwLndlYklkQ2hhbmdlZChtZXNzYWdlLndlYklkKVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfTtcclxuICAgIHNvbGlkLmF1dGgudHJhY2tTZXNzaW9uKGFzeW5jIGZ1bmN0aW9uKHNlc3Npb24pIHtcclxuICAgICAgaWYgKCFzZXNzaW9uKXtcclxuICAgICAgICBhcHAud2ViSWQ9bnVsbFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0VCSURcIixhcHAud2ViSWQpXHJcbiAgICAgICAgYXBwLmFnZW50LnNlbmRNdWx0aShhcHAuZGVzdGluYXRhaXJlcywgIHthY3Rpb246XCJ3ZWJJZENoYW5nZWRcIiwgd2ViSWQ6IGFwcC53ZWJJZH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGVsc2V7XHJcbiAgICAgICAgYXBwLndlYklkID0gc2Vzc2lvbi53ZWJJZFxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiV0VCSURcIixhcHAud2ViSWQpXHJcbiAgICAgICAgYXBwLmFnZW50LnNlbmRNdWx0aShhcHAuZGVzdGluYXRhaXJlcywge2FjdGlvbjpcIndlYklkQ2hhbmdlZFwiLCB3ZWJJZDogYXBwLndlYklkfSk7XHJcbiAgICAgIH1cclxuICAgIH0pXHJcblxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwibG9nb3V0XCI6XHJcbiAgICAgICAgICBhcHAubG9nb3V0KG51bGwpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgbG9naW4oKSB7XHJcbiAgICB0aGlzLnBvcHVwTG9naW4oKTtcclxuICB9XHJcblxyXG4gIGxvZ291dCgpIHtcclxuICAgIGxldCB3aSA9IHRoaXMud2ViSWRcclxuICAgIHNvbGlkLmF1dGgubG9nb3V0KCkudGhlbigoKSA9PiBhbGVydCgnR29vZGJ5ZSAnK3dpKycgIScpKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHBvcHVwTG9naW4oKSB7XHJcbiAgICBsZXQgc2Vzc2lvbiA9IGF3YWl0IHNvbGlkLmF1dGguY3VycmVudFNlc3Npb24oKTtcclxuICAgIGxldCBwb3B1cFVyaSA9ICcuL2Rpc3QtcG9wdXAvcG9wdXAuaHRtbCc7XHJcbiAgICAvLyAgbGV0IHBvcHVwVXJpID0gJ2h0dHBzOi8vc29saWQuY29tbXVuaXR5L2NvbW1vbi9wb3B1cC5odG1sJztcclxuICAgIGlmICghc2Vzc2lvbilcclxuICAgIHNlc3Npb24gPSBhd2FpdCBzb2xpZC5hdXRoLnBvcHVwTG9naW4oe8KgcG9wdXBVcmkgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2xvZ2luLWVsZW1lbnQnLCBMb2dpbkVsZW1lbnQpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuLy8gaW1wb3J0IC8gZXhwb3J0LCB2b2lyIGh0dHBzOi8vZ2l0aHViLmNvbS9zY2VuYXJpc3RldXIvc3BvZ2d5LXNpbXBsZS9ibG9iL2E5YzczZWVjNDNlMzdjNzM2ZmVmNjU2YTcyYzk0OGRkMWM0NTM4ODYvanMvaW1wb3J0LWV4cG9ydC5qc1xyXG5cclxuY2xhc3MgVmlzVmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZ3JvdXBzOiB7dHlwZSA6IE9iamVjdH0sXHJcbiAgICAgIHZpc0hpZGU6IHt0eXBlOiBCb29sZWFufVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgc3VwZXIoKTtcclxuICAgIGxldCBmYWNlID0gXCInRm9udCBBd2Vzb21lIDUgRnJlZSdcIlxyXG4gICAgdGhpcy5uYW1lID0gXCJWaXNcIlxyXG4gICAgdGhpcy52aXNIaWRlID0gZmFsc2VcclxuICAgIHRoaXMuZ3JvdXBzID0ge1xyXG4gICAgICBvcmdhbml6YXRpb25zOiB7XHJcbiAgICAgICAgbGFiZWw6ICdPcmdhJyxcclxuICAgICAgICBzaGFwZTogJ2ljb24nLFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgIGZhY2U6IGZhY2UsXHJcbiAgICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiLCAvLyBGb250IEF3ZXNvbWUgNSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzIGJvbGQuXHJcbiAgICAgICAgICBjb2RlOiAnXFx1ZjFhZCcsXHJcbiAgICAgICAgICBzaXplOiA1MCxcclxuICAgICAgICAgIGNvbG9yOiAnI2YwMGE1NydcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHVzZXJncm91cHM6IHtcclxuICAgICAgICBsYWJlbDogJ1VzZXIgR3JvdXAnLFxyXG4gICAgICAgIHNoYXBlOiAnaWNvbicsXHJcbiAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgZmFjZTogZmFjZSxcclxuICAgICAgICAgIHdlaWdodDogXCJib2xkXCIsIC8vIEZvbnQgQXdlc29tZSA1IGRvZXNuJ3Qgd29yayBwcm9wZXJseSB1bmxlc3MgYm9sZC5cclxuICAgICAgICAgIGNvZGU6ICdcXHVmMGMwJyxcclxuICAgICAgICAgIHNpemU6IDUwLFxyXG4gICAgICAgICAgY29sb3I6ICcjNTcxNjlhJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgdXNlcnM6IHtcclxuICAgICAgICBsYWJlbDogJ1VzZXInLFxyXG4gICAgICAgIHNoYXBlOiAnaWNvbicsXHJcbiAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgZmFjZTogZmFjZSxcclxuICAgICAgICAgIHdlaWdodDogXCJib2xkXCIsIC8vIEZvbnQgQXdlc29tZSA1IGRvZXNuJ3Qgd29yayBwcm9wZXJseSB1bmxlc3MgYm9sZC5cclxuICAgICAgICAgIGNvZGU6ICdcXHVmMDA3JyxcclxuICAgICAgICAgIHNpemU6IDUwLFxyXG4gICAgICAgICAgY29sb3I6ICcjYWEwMGZmJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgcm9sZXM6IHtcclxuICAgICAgICBsYWJlbDogJ1JvbGUnLFxyXG4gICAgICAgIHNoYXBlOiAnaWNvbicsXHJcbiAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgZmFjZTogZmFjZSxcclxuICAgICAgICAgIHdlaWdodDogXCJib2xkXCIsIC8vIEZvbnQgQXdlc29tZSA1IGRvZXNuJ3Qgd29yayBwcm9wZXJseSB1bmxlc3MgYm9sZC5cclxuICAgICAgICAgIGNvZGU6ICdcXHVmOGMxJyxcclxuICAgICAgICAgIHNpemU6IDUwLFxyXG4gICAgICAgICAgY29sb3I6ICcjMGFmMGEzJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgdGVuc2lvbnM6IHtcclxuICAgICAgICBsYWJlbDogJ1RlbnNpb24gKGEgcHJvYmxlbSBvciBpZGVhLCBhIGdhcCBiZXR3ZWVuIFwiV2hhdCBpc1wiIGFuZCBcIldoYXQgc2hvdWxkIGJlXCIpJyxcclxuICAgICAgICBzaGFwZTogJ2ljb24nLFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgIGZhY2U6IGZhY2UsXHJcbiAgICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiLCAvLyBGb250IEF3ZXNvbWUgNSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzIGJvbGQuXHJcbiAgICAgICAgICBjb2RlOiAnXFx1ZjBlNycsXHJcbiAgICAgICAgICBzaXplOiA1MCxcclxuICAgICAgICAgIGNvbG9yOiAnI2YwYTMwYSdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHdoYXRpczoge1xyXG4gICAgICAgIGxhYmVsOiAnV2hhdCBpcyA/ICh0aGUgVGVuc2lvbiBtYXR0ZXIpJyxcclxuICAgICAgICBzaGFwZTogJ2ljb24nLFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgIGZhY2U6IGZhY2UsXHJcbiAgICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiLCAvLyBGb250IEF3ZXNvbWUgNSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzIGJvbGQuXHJcbiAgICAgICAgICBjb2RlOiAnXFx1ZjA1OScsXHJcbiAgICAgICAgICBzaXplOiA1MCxcclxuICAgICAgICAgIGNvbG9yOiAnI2YwYTMwYSdcclxuICAgICAgICB9XHJcbiAgICAgIH0sXHJcbiAgICAgIHdoYXRzYjoge1xyXG4gICAgICAgIGxhYmVsOiAnV2hhdCBzaG91bGQgYmUgISAodGhlIFRlbnNpb24gcHJvcG9zaXRpb24pJyxcclxuICAgICAgICBzaGFwZTogJ2ljb24nLFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgIGZhY2U6IGZhY2UsXHJcbiAgICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiLCAvLyBGb250IEF3ZXNvbWUgNSBkb2Vzbid0IHdvcmsgcHJvcGVybHkgdW5sZXNzIGJvbGQuXHJcbiAgICAgICAgICBjb2RlOiAnXFx1ZjBlYicsXHJcbiAgICAgICAgICBzaXplOiA1MCxcclxuICAgICAgICAgIGNvbG9yOiAnI2YwYTMwYSdcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBub2RlcyA9IG5ldyB2aXMuRGF0YVNldChbXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogMSxcclxuICAgICAgICBsYWJlbDogJ0pvaG4nLFxyXG4gICAgICAgIGdyb3VwOiAndXNlcnMnXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBpZDogMixcclxuICAgICAgICBsYWJlbDogJ01pa2UnLFxyXG4gICAgICAgIGdyb3VwOiAndXNlcnMnXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBpZDogMyxcclxuICAgICAgICBsYWJlbDogJ1VzZXJncm91cCAxJyxcclxuICAgICAgICBncm91cDogJ3VzZXJncm91cHMnXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBpZDogNCxcclxuICAgICAgICBsYWJlbDogJ1VzZXJncm91cCAyJyxcclxuICAgICAgICBncm91cDogJ3VzZXJncm91cHMnXHJcbiAgICAgIH0sIHtcclxuICAgICAgICBpZDogNSxcclxuICAgICAgICBsYWJlbDogJ015IE9yYW5pemF0aW9uJyxcclxuICAgICAgICBncm91cDogJ29yZ2FuaXphdGlvbnMnXHJcbiAgICAgIH0sXHJcbiAgICAgIHtcclxuICAgICAgICBpZDogNixcclxuICAgICAgICBsYWJlbDogJ0RldmVsb3BlcicsXHJcbiAgICAgICAgZ3JvdXA6ICdyb2xlcydcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA3LFxyXG4gICAgICAgIGxhYmVsOiAnV2UgbXVzdCBkZXZlbG9wIGEgY29vbCBHVUkgZm9yIFNwb2dneSAhJyxcclxuICAgICAgICBncm91cDogJ3RlbnNpb25zJ1xyXG4gICAgICB9LFxyXG4gICAgICB7XHJcbiAgICAgICAgaWQ6IDgsXHJcbiAgICAgICAgbGFiZWw6ICdJdCBpcyBub3QgZWFzeSB0byBkZWFsIHdpdGggTGlua2VkRGF0YScsXHJcbiAgICAgICAgZ3JvdXA6ICd3aGF0aXMnIC8vIHdoYXQgaXNcclxuICAgICAgfSxcclxuICAgICAge1xyXG4gICAgICAgIGlkOiA5LFxyXG4gICAgICAgIGxhYmVsOiAnV2UgY2FuIHVzZSBWaXNqcyB0byBwcm92aWRlIGEgc2ltcGxlIHdheSB0byBpbnRlcmFjdCB3aXRoIExpbmtlZERhdGEuJyxcclxuICAgICAgICBncm91cDogJ3doYXRzYicgLy8gd2hhdCBzaG91bGQgYmVcclxuICAgICAgfSxcclxuICAgIF0pO1xyXG5cclxuICAgIC8vIGNyZWF0ZSBhbiBhcnJheSB3aXRoIGVkZ2VzXHJcbiAgICB2YXIgZWRnZXMgPSBuZXcgdmlzLkRhdGFTZXQoW1xyXG4gICAgICB7ZnJvbTogMSwgdG86IDMsIGxhYmVsOiBcIm1lbWJlck9mXCIsIHRpdGxlOiBcIm9yZzptZW1iZXJPZlwifSxcclxuICAgICAge2Zyb206IDEsIHRvOiAyLCBsYWJlbDogXCJmcmllbmRcIiwgdGl0bGU6IFwiZm9hZjpmcmllbmRcIn0sXHJcbiAgICAgIHtmcm9tOiAyLCB0bzogNCwgbGFiZWw6IFwibWVtYmVyT2ZcIiwgdGl0bGU6IFwib3JnOm1lbWJlck9mXCJ9LFxyXG4gICAgICB7ZnJvbTogMiwgdG86IDUsIGxhYmVsOiBcIm1lbWJlck9mXCIsIHRpdGxlOiBcIm9yZzptZW1iZXJPZlwifSxcclxuICAgICAge2Zyb206IDUsIHRvOiA0LCBsYWJlbDogXCJoYXNVbml0XCIsIHRpdGxlOiBcIm9yZzpoYXNVbml0XCJ9LFxyXG4gICAgICB7ZnJvbTogMSwgdG86IDcsIGxhYmVsOiBcInN1Ym1pdFwiLCB0aXRsZTogXCJhczpzdWJtaXRcIn0sXHJcbiAgICAgIHtmcm9tOiAyLCB0bzogNiwgbGFiZWw6IFwidGFrZVJvbGVcIiwgdGl0bGU6IFwidGFrZVJvbGVcIn0sXHJcbiAgICAgIHtmcm9tOiA3LCB0bzogOCwgbGFiZWw6IFwid2hhdElzXCIsIHRpdGxlOiBcIndoYXRJc1wifSxcclxuICAgICAge2Zyb206IDcsIHRvOiA5LCBsYWJlbDogXCJ3aGF0U2hvdWxkQmVcIiwgdGl0bGU6IFwid2hhdFNob3VsZEJlXCJ9LFxyXG4gICAgXSk7XHJcbiAgICB0aGlzLmRhdGEgPSB7XHJcbiAgICAgIG5vZGVzOiBub2RlcyxcclxuICAgICAgZWRnZXM6IGVkZ2VzXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvZm9udGF3ZXNvbWUvY3NzL2FsbC5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2Jvb3RzdHJhcC9ib290c3RyYXAubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvdmlzLW5ldHdvcmsubWluLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuICAgIDxzdHlsZT5cclxuICAgICNteW5ldHdvcmsge1xyXG4gICAgICBtYXgtd2lkdGg6IDUwMHB4OyAvKiA4MDBweCAqL1xyXG4gICAgICBtaW4td2lkdGg6IDMyMHB4O1xyXG4gICAgICBoZWlnaHQ6IDYwMHB4O1xyXG4gICAgICBib3JkZXI6IDFweCBzb2xpZCBsaWdodGdyYXk7XHJcbiAgICAgIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byBib3R0b20sIHJnYmEoMjE1LCAyMTUsIDI1NSksIHJnYmEoMjUwLCAyNTAsIDE3MCkpXHJcbiAgICB9XHJcblxyXG4gICAgI25vZGUtcG9wVXAge1xyXG4gICAgICBkaXNwbGF5Om5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgI2VkZ2UtcG9wVXAge1xyXG4gICAgICBkaXNwbGF5Om5vbmU7XHJcbiAgICB9XHJcblxyXG4gICAgPC9zdHlsZT5cclxuXHJcblxyXG4gICAgPGRpdiAgaWQ9XCJub2RlLXBvcFVwXCIgY2xhc3M9XCJtb2RhbFwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nXCIgcm9sZT1cImRvY3VtZW50XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxyXG4gICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxyXG4gICAgPGg1IGNsYXNzPVwibW9kYWwtdGl0bGVcIiBpZD1cIm5vZGUtb3BlcmF0aW9uXCI+TW9kYWwgdGl0bGU8L2g1PlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJub2RlLWNsb3NlXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+XHJcbiAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxyXG4gICAgPC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1ib2R5XCI+XHJcbiAgICA8IS0tICA8dHI+XHJcbiAgICA8dGQ+aWQ8L3RkPjx0ZD48aW5wdXQgaWQ9XCJub2RlLWlkXCIgdmFsdWU9XCJuZXcgdmFsdWVcIiAvPjwvdGQ+XHJcbiAgICA8L3RyPi0tPlxyXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwIG1iLTNcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XHJcbiAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIiBpZD1cIm5vZGVMXCI+TGFiZWw8L3NwYW4+XHJcbiAgICA8L2Rpdj5cclxuICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwibm9kZS1sYWJlbFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCJMYWJlbFwiIGFyaWEtbGFiZWw9XCJMYWJlbFwiIGFyaWEtZGVzY3JpYmVkYnk9XCJub2RlTFwiPlxyXG4gICAgPC9kaXY+XHJcblxyXG4gICAgPCEtLVxyXG4gICAgJHtPYmplY3QuZW50cmllcyh0aGlzLmdyb3VwcykubWFwKChba2V5LCB2YWx1ZV0pID0+IGh0bWwgYFxyXG4gICAgICAtICBrZXkgJHt2YWx1ZS5sYWJlbH08YnI+XHJcbiAgICAgIGApfVxyXG4gICAgICAtLT5cclxuXHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cIm5vZGUtc2F2ZUJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+U2F2ZSBjaGFuZ2VzPC9idXR0b24+XHJcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGlkPVwibm9kZS1jYW5jZWxCdXR0b25cIiAgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+Q2xvc2U8L2J1dHRvbj5cclxuXHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuXHJcblxyXG4gICAgICA8ZGl2ICBpZD1cImVkZ2UtcG9wVXBcIiBjbGFzcz1cIm1vZGFsXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiIHJvbGU9XCJkb2N1bWVudFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XHJcbiAgICAgIDxoNSBjbGFzcz1cIm1vZGFsLXRpdGxlXCIgaWQ9XCJlZGdlLW9wZXJhdGlvblwiPk1vZGFsIHRpdGxlPC9oNT5cclxuICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgaWQ9XCJlZGdlLWNsb3NlXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+XHJcbiAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XHJcbiAgICAgIDwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cclxuICAgICAgPCEtLSAgPHRyPlxyXG4gICAgICA8dGQ+aWQ8L3RkPjx0ZD48aW5wdXQgaWQ9XCJub2RlLWlkXCIgdmFsdWU9XCJuZXcgdmFsdWVcIiAvPjwvdGQ+XHJcbiAgICAgIDwvdHI+LS0+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XHJcbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiIGlkPVwiZWRnZUxcIj5MYWJlbDwvc3Bhbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGlkPVwiZWRnZS1sYWJlbFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCIgcGxhY2Vob2xkZXI9XCJFZGdlIGxhYmVsXCIgYXJpYS1sYWJlbD1cIkVkZ2UgbGFiZWxcIiBhcmlhLWRlc2NyaWJlZGJ5PVwiZWRnZUxcIj5cclxuICAgICAgPC9kaXY+XHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBpZD1cImVkZ2Utc2F2ZUJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5XCI+U2F2ZSBjaGFuZ2VzPC9idXR0b24+XHJcbiAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGlkPVwiZWRnZS1jYW5jZWxCdXR0b25cIiAgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+Q2xvc2U8L2J1dHRvbj5cclxuXHJcblxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPCEtLSBmaW4gbW9kYWwgLS0+XHJcblxyXG5cclxuXHJcblxyXG4gICAgICA8ZGl2ICBjbGFzcz1cInJvd1wiID9oaWRkZW49XCIke3RoaXMudmlzSGlkZX1cIj5cclxuICAgICAgPGRpdiBpZD1cIm15bmV0d29ya1wiPk5ldHdvcms8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIEBjbGljaz1cIiR7dGhpcy5jbGVhcn1cIj5jbGVhcjwvYnV0dG9uPlxyXG5cclxuXHJcbiAgICAgICR7dGhpcy52aXNIaWRlID09IHRydWUgP1xyXG4gICAgICAgIGh0bWxgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIEBjbGljaz1cIiR7dGhpcy50b2dnbGVIaWRlfVwiPlNob3c8L2J1dHRvbj5cclxuICAgICAgICBgXHJcbiAgICAgICAgOmh0bWxgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeVwiIEBjbGljaz1cIiR7dGhpcy50b2dnbGVIaWRlfVwiPkhpZGU8L2J1dHRvbj5cclxuICAgICAgICBgfVxyXG4gICAgICAgIDwvZGl2PlxyXG4gICAgICAgIGA7XHJcbiAgICAgIH1cclxuICAgICAgdG9nZ2xlSGlkZSgpe1xyXG4gICAgICAgIHRoaXMudmlzSGlkZSA9ICF0aGlzLnZpc0hpZGVcclxuICAgICAgfVxyXG5cclxuICAgICAgY2xlYXIoKXtcclxuICAgICAgICB0aGlzLmRhdGEubm9kZXMuY2xlYXIoKVxyXG4gICAgICAgIHRoaXMuZGF0YS5lZGdlcy5jbGVhcigpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuYWdlbnQgPSBuZXcgSGVsbG9BZ2VudCh0aGlzLm5hbWUpO1xyXG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICAgICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwibWVzc2FoXCIsbWVzc2FnZSlcclxuICAgICAgICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgICAgIHN3aXRjaChtZXNzYWdlLmFjdGlvbikge1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJub2RlVXBkYXRlXCI6XHJcbiAgICAgICAgICAgICAgYXBwLm5vZGVVcGRhdGUobWVzc2FnZS5ub2RlKVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJlZGdlVXBkYXRlXCI6XHJcbiAgICAgICAgICAgICAgYXBwLmVkZ2VVcGRhdGUobWVzc2FnZS5lZGdlKVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGNhc2UgXCJ0cmlwbGVzQ2hhbmdlZFwiOlxyXG4gICAgICAgICAgICAgIGFwcC50cmlwbGVzQ2hhbmdlZChtZXNzYWdlLnRyaXBsZXMpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSBcImFkZFRyaXBsZVwiOlxyXG4gICAgICAgICAgICAgIGFwcC5hZGRUcmlwbGUobWVzc2FnZS50cmlwbGUpXHJcbiAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSBcImNsZWFyXCI6XHJcbiAgICAgICAgICAgICAgYXBwLmNsZWFyKClcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICBjYXNlIFwiY3VycmVudEZpbGVDaGFuZ2VkXCI6XHJcbiAgICAgICAgICAgICAgYXBwLmN1cnJlbnRGaWxlID0gbWVzc2FnZS5jdXJyZW50RmlsZVxyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLmluaXQoKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBhZGRUcmlwbGUodCl7XHJcbiAgICAgICAgLy8gZnJvbSBpbnB1dC12aWV3XHJcbiAgICAgICAgY29uc29sZS5sb2codClcclxuICAgICAgICBsZXQgbl9zdWIgPSB7aWQ6IHQuc3ViamVjdCwgbGFiZWw6IHRoaXMubG9jYWxOYW1lKHQuc3ViamVjdCksIHRpdGxlOiB0LnN1YmplY3R9XHJcbiAgICAgICAgdGhpcy5hZGROb2RlSWZOb3RFeGlzdChuX3N1YilcclxuICAgICAgICBsZXQgbl9vYmogPSB7aWQ6IHQub2JqZWN0LCBsYWJlbDogdGhpcy5sb2NhbE5hbWUodC5vYmplY3QpLCB0aXRsZTogdC5vYmplY3R9XHJcbiAgICAgICAgdGhpcy5hZGROb2RlSWZOb3RFeGlzdChuX29iailcclxuICAgICAgICBsZXQgZWRnZSA9IHtmcm9tOiBuX3N1Yi5pZCwgdG86IG5fb2JqLmlkLCBsYWJlbDogdGhpcy5sb2NhbE5hbWUodC5wcmVkaWNhdGUpLCB0aXRsZTogdC5wcmVkaWNhdGV9XHJcbiAgICAgICAgLy8gIHRoaXMubmV0d29yay5ib2R5LmRhdGEuZWRnZXMudXBkYXRlKGVkZ2UpXHJcbiAgICAgICAgdGhpcy5hZGRFZGdlSWZOb3RFeGlzdChlZGdlKVxyXG4gICAgICB9XHJcblxyXG5cclxuICAgICAgdHJpcGxlc0NoYW5nZWQodHJpcGxlcyl7XHJcbiAgICAgICAgLy9mcm9tIHRyaXBsZWRvYyBpbiBicm93c2VyLXZpZXdcclxuICAgICAgICBsZXQgYXBwID0gdGhpc1xyXG4gICAgICAgIHZhciBjbGVhciA9IGNvbmZpcm0oXCJEbyB5b3Ugd2FudCB0byBjbGVhciB0aGUgbmV0d29yayA/XCIpO1xyXG4gICAgICAgIGNsZWFyID09ICB0cnVlID8gdGhpcy5jbGVhcigpIDogXCJcIlxyXG5cclxuICAgICAgICBpZiAodHJpcGxlcy5sZW5ndGggIT0gMCl7XHJcbiAgICAgICAgICB0cmlwbGVzLmZvckVhY2goKHQsIGkpID0+IHtcclxuICAgICAgICAgICAgbGV0IG5fc3ViID0ge2lkOiB0LnN1YmplY3QuaWQsIGxhYmVsOiBhcHAubG9jYWxOYW1lKHQuc3ViamVjdC5pZCksIHRpdGxlOiB0LnN1YmplY3QuaWR9XHJcbiAgICAgICAgICAgIGFwcC5hZGROb2RlSWZOb3RFeGlzdChuX3N1YilcclxuICAgICAgICAgICAgbGV0IG5fb2JqID0ge2lkOiB0Lm9iamVjdC5pZCwgbGFiZWw6IGFwcC5sb2NhbE5hbWUodC5vYmplY3QuaWQpLCB0aXRsZTogdC5vYmplY3QuaWR9XHJcbiAgICAgICAgICAgIGFwcC5hZGROb2RlSWZOb3RFeGlzdChuX29iailcclxuICAgICAgICAgICAgbGV0IGVkZ2UgPSB7ZnJvbTogbl9zdWIuaWQsIHRvOiBuX29iai5pZCwgbGFiZWw6IGFwcC5sb2NhbE5hbWUodC5wcmVkaWNhdGUuaWQpLCB0aXRsZTogdC5wcmVkaWNhdGUuaWR9XHJcbiAgICAgICAgICAgIC8qICBhcHAubmV0d29yay5ib2R5LmRhdGEuZWRnZXMudXBkYXRlKGVkZ2UpKi9cclxuICAgICAgICAgICAgdGhpcy5hZGRFZGdlSWZOb3RFeGlzdChlZGdlKVxyXG4gICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgYWxlcnQoXCJ0aGlzIGZpbGUgZG9lcyBub3QgY29udGFpbiBhbnkgdHJpcGxlLlwiKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcblxyXG4gICAgICBsb2NhbE5hbWUoc3RyUHJvbWlzZSl7XHJcbiAgICAgICAgbGV0IHN0ciA9IGAke3N0clByb21pc2V9YFxyXG4gICAgICAgIHZhciBsbiA9IHN0ci5zdWJzdHJpbmcoc3RyLmxhc3RJbmRleE9mKCcjJykrMSk7XHJcbiAgICAgICAgbG4gPT0gc3RyID8gbG4gPSBzdHIuc3Vic3RyaW5nKHN0ci5sYXN0SW5kZXhPZignLycpKzEpIDogXCJcIjtcclxuICAgICAgICByZXR1cm4gbG5cclxuICAgICAgfVxyXG5cclxuICAgICAgbm9kZVVwZGF0ZShub2RlKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhub2RlKVxyXG4gICAgICAgIHRoaXMubmV0d29yay5ib2R5LmRhdGEubm9kZXMudXBkYXRlKG5vZGUpXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGVkZ2VVcGRhdGUoZWRnZSl7XHJcbiAgICAgICAgY29uc29sZS5sb2coZWRnZSlcclxuICAgICAgICB0aGlzLm5ldHdvcmsuYm9keS5kYXRhLmVkZ2VzLnVwZGF0ZShlZGdlKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBhZGRFZGdlSWZOb3RFeGlzdCAoZWRnZSl7XHJcbiAgICAgICAgbGV0IGlkID0gXCJcIlxyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcInJlY2hlcmNoZSBcIitpZF9zdWpldCtcIiBcIitpZF9vYmpldCtcIiBcIitwcm9wcmlldGUpXHJcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5uZXR3b3JrLmJvZHkuZGF0YS5lZGdlcy5nZXQoe1xyXG4gICAgICAgICAgZmlsdGVyOiBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5mcm9tID09IGVkZ2UuZnJvbSAmJiBpdGVtLnRvID09IGVkZ2UudG8gJiYgaXRlbS5sYWJlbCA9PSBlZGdlLmxhYmVsO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAwKXtcclxuICAgICAgICAgIGlkID0gaXRlbXNbMF0uaWQ7XHJcbiAgICAgICAgICAvLyBtdXN0IHVwZGF0ZSB0aGUgZWRnZSA/XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcInRyb3V2w6kgXCIraWQpO1xyXG5cclxuICAgICAgICB9XHJcbiAgICAgICAgLy9lbHNlIGNyZWF0ZSBub2RlIGFuZCBnZXQgaWRcclxuICAgICAgICBlbHNle1xyXG4gICAgICAgICAgaWQgPSB0aGlzLm5ldHdvcmsuYm9keS5kYXRhLmVkZ2VzLmFkZChlZGdlKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKFwiY3JlYXRpb24gXCIraWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcbiAgICAgIGFkZE5vZGVJZk5vdEV4aXN0KGRhdGEpe1xyXG4gICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrXHJcbiAgICAgICAgdmFyIGV4aXN0Tm9kZSA9IGZhbHNlO1xyXG4gICAgICAgIC8vY29uc29sZS5sb2coZGF0YSk7XHJcbiAgICAgICAgdmFyIG5vZGVJZDtcclxuICAgICAgICB0cnl7XHJcbiAgICAgICAgICBleGlzdE5vZGUgPSBuZXR3b3JrLmJvZHkuZGF0YS5ub2Rlcy5nZXQoe1xyXG4gICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uKG4pe1xyXG4gICAgICAgICAgICAgIHJldHVybiAobi5pZCA9PSBkYXRhLmlkIHx8IChuLmxhYmVsID09IGRhdGEubGFiZWwpKTsgLy8gIHx8IG4udGl0bGUgPT0gZGF0YS5sYWJlbFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coZXhpc3ROb2RlKTtcclxuICAgICAgICAgIGlmIChleGlzdE5vZGUubGVuZ3RoID09IDApe1xyXG4gICAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCJuJ2V4aXN0ZSBwYXNcIilcclxuICAgICAgICAgICAgbm9kZUlkID0gICBuZXR3b3JrLmJvZHkuZGF0YS5ub2Rlcy5hZGQoZGF0YSlbMF07XHJcbiAgICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwiZXhpc3RlXCIpXHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLng7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhLnlcclxuICAgICAgICAgICAgbm9kZUlkID0gIG5ldHdvcmsuYm9keS5kYXRhLm5vZGVzLnVwZGF0ZShkYXRhKVswXTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycil7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuXHJcblxyXG4gICAgICBpbml0KCl7XHJcbiAgICAgICAgbGV0IGFwcCA9IHRoaXNcclxuICAgICAgICBsZXQgZmFjZSA9IFwiJ0ZvbnQgQXdlc29tZSA1IEZyZWUnXCJcclxuICAgICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdteW5ldHdvcmsnKTtcclxuICAgICAgICBsZXQgIGNlbnRyYWxHcmF2aXR5VmFsdWVEZWZhdWx0ID0gMC4wMDEvLywgLy8wLjAwMSA/IEEgcXVvaSBzZXJ0IGNldHRlIHZhbGV1ciA/XHJcbiAgICAgICAgbGV0IHNwcmluZ0xlbmd0aFZhbHVlRGVmYXVsdCA9IDIyMC8vIC8vMjIwICgvLzIwMCAvLzMwMClcclxuICAgICAgICAgIGxldCAgc3ByaW5nQ29uc3RhbnRWYWx1ZURlZmF1bHQgPSAwLjAxLy8sIC8vMC4wMVxyXG4gICAgICAgICAgbGV0IG5vZGVEaXN0YW5jZVZhbHVlRGVmYXVsdCA9IDE1MC8vLCAvLzEwMCAvLzM1MFxyXG4gICAgICAgICAgbGV0IGRhbXBpbmdWYWx1ZURlZmF1bHQgPSAwLjA4XHJcblxyXG4gICAgICAgICAgbGV0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgIGxvY2FsZTogbmF2aWdhdG9yLmxhbmd1YWdlLnNsaWNlKDAsIDIpIHx8IFwiZW5cIixcclxuICAgICAgICAgICAgaW50ZXJhY3Rpb246IHtcclxuICAgICAgICAgICAgICBuYXZpZ2F0aW9uQnV0dG9uczogdHJ1ZSxcclxuICAgICAgICAgICAgICAvLyAga2V5Ym9hcmQ6IHRydWUsIC8vIGluY29tcGF0aWJsZSBhdmVjIGxlIGTDqXBsYWNlbWVudCBwYXIgZmzDqGNoZXMgZGFucyBsZSBjaGFtcCBpbnB1dFxyXG4gICAgICAgICAgICAgIG11bHRpc2VsZWN0OiB0cnVlXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGVkZ2VzOntcclxuICAgICAgICAgICAgICBhcnJvd3M6IHtcclxuICAgICAgICAgICAgICAgIHRvOiAgICAge2VuYWJsZWQ6IHRydWUsIHNjYWxlRmFjdG9yOjEsIHR5cGU6J2Fycm93J31cclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGZvbnQ6IHtcclxuICAgICAgICAgICAgICAgIHNpemU6IDI0XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICB3aWR0aDogMixcclxuICAgICAgICAgICAgICBzaGFkb3c6dHJ1ZSxcclxuICAgICAgICAgICAgICBjb2xvcjp7XHJcbiAgICAgICAgICAgICAgICBpbmhlcml0Oidib3RoJyxcclxuICAgICAgICAgICAgICAgIC8vICBoaWdobGlnaHQ6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICAgIC8vICBjb2xvcjogJyMyQjdDRTknXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBub2Rlczoge1xyXG4gICAgICAgICAgICAgIHNoYXBlOiAnZG90JyxcclxuICAgICAgICAgICAgICBzaXplOiAzMCxcclxuICAgICAgICAgICAgICBmb250OiB7XHJcbiAgICAgICAgICAgICAgICBzaXplOiAyNFxyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsXHJcbiAgICAgICAgICAgICAgc2hhZG93OnRydWUsXHJcbiAgICAgICAgICAgICAgY29sb3I6IHtcclxuICAgICAgICAgICAgICAgIGhpZ2hsaWdodDoge2JvcmRlcjogJyMwMDAwMDAnLCBiYWNrZ3JvdW5kOicjRkZGRkZGJ31cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdyb3VwczogdGhpcy5ncm91cHMsXHJcbiAgICAgICAgICAgIHBoeXNpY3M6e1xyXG4gICAgICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgYmFybmVzSHV0OiB7XHJcbiAgICAgICAgICAgICAgICBncmF2aXRhdGlvbmFsQ29uc3RhbnQ6IC0xLFxyXG4gICAgICAgICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMyxcclxuICAgICAgICAgICAgICAgIHNwcmluZ0xlbmd0aDogOTUsXHJcbiAgICAgICAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wNCxcclxuICAgICAgICAgICAgICAgIGRhbXBpbmc6IDAuMDksXHJcbiAgICAgICAgICAgICAgICBhdm9pZE92ZXJsYXA6IDFcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGZvcmNlQXRsYXMyQmFzZWQ6IHtcclxuICAgICAgICAgICAgICAgIGdyYXZpdGF0aW9uYWxDb25zdGFudDogLTUwLFxyXG4gICAgICAgICAgICAgICAgY2VudHJhbEdyYXZpdHk6IDAuMDEsXHJcbiAgICAgICAgICAgICAgICBzcHJpbmdDb25zdGFudDogMC4wOCxcclxuICAgICAgICAgICAgICAgIHNwcmluZ0xlbmd0aDogMTAwLFxyXG4gICAgICAgICAgICAgICAgZGFtcGluZzogMC40LFxyXG4gICAgICAgICAgICAgICAgYXZvaWRPdmVybGFwOiAwXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICByZXB1bHNpb246IHtcclxuICAgICAgICAgICAgICAgIGNlbnRyYWxHcmF2aXR5OiBjZW50cmFsR3Jhdml0eVZhbHVlRGVmYXVsdCwgIC8vMC4wMDEsIC8vMC4wMDEgPyBBIHF1b2kgc2VydCBjZXR0ZSB2YWxldXIgP1xyXG4gICAgICAgICAgICAgICAgc3ByaW5nTGVuZ3RoOiBzcHJpbmdMZW5ndGhWYWx1ZURlZmF1bHQsICAgLy8gMjIwLCAvLzIyMCAoLy8yMDAgLy8zMDApXHJcbiAgICAgICAgICAgICAgICAgIHNwcmluZ0NvbnN0YW50OiBzcHJpbmdDb25zdGFudFZhbHVlRGVmYXVsdCwgLy8wLjAxLCAvLzAuMDFcclxuICAgICAgICAgICAgICAgICAgbm9kZURpc3RhbmNlOiAgbm9kZURpc3RhbmNlVmFsdWVEZWZhdWx0LCAvLzE1MCwgLy8xMDAgLy8zNTBcclxuICAgICAgICAgICAgICAgICAgZGFtcGluZzogZGFtcGluZ1ZhbHVlRGVmYXVsdCwgLy8vMC4wOFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGhpZXJhcmNoaWNhbFJlcHVsc2lvbjoge1xyXG4gICAgICAgICAgICAgICAgICBjZW50cmFsR3Jhdml0eTogMC4wLFxyXG4gICAgICAgICAgICAgICAgICBzcHJpbmdMZW5ndGg6IDEwMCxcclxuICAgICAgICAgICAgICAgICAgc3ByaW5nQ29uc3RhbnQ6IDAuMDEsXHJcbiAgICAgICAgICAgICAgICAgIG5vZGVEaXN0YW5jZTogMTIwLFxyXG4gICAgICAgICAgICAgICAgICBkYW1waW5nOiAwLjA5XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLy9tYXhWZWxvY2l0eTogNTAwLCAvLzUwXHJcbiAgICAgICAgICAgICAgICAvL21pblZlbG9jaXR5OiAxLCAvLzAuMVxyXG4gICAgICAgICAgICAgICAgc29sdmVyOiAncmVwdWxzaW9uJyxcclxuICAgICAgICAgICAgICAgIC8qc3RhYmlsaXphdGlvbjoge1xyXG4gICAgICAgICAgICAgICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVJbnRlcnZhbDogMTAwLFxyXG4gICAgICAgICAgICAgICAgb25seUR5bmFtaWNFZGdlczogZmFsc2UvLyxcclxuICAgICAgICAgICAgICAgIC8vICBmaXQ6IHRydWVcclxuICAgICAgICAgICAgICB9LCovXHJcbiAgICAgICAgICAgICAgLy90aW1lc3RlcDogMC41LFxyXG4gICAgICAgICAgICAgIC8vYWRhcHRpdmVUaW1lc3RlcDogdHJ1ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBtYW5pcHVsYXRpb246IHtcclxuICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYWxtZW5kZS92aXMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvbmV0d29yay9vdGhlci9tYW5pcHVsYXRpb25FZGl0RWRnZU5vRHJhZy5odG1sXHJcbiAgICAgICAgICAgICAgYWRkTm9kZTogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBhcHAuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbm9kZS1vcGVyYXRpb24nKS5pbm5lckhUTUwgPSBcIkFkZCBOb2RlXCI7XHJcbiAgICAgICAgICAgICAgICBkYXRhLmxhYmVsID0gXCJcIlxyXG4gICAgICAgICAgICAgICAgLy8gIGFwcC5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLWxhYmVsJykudmFsdWUgPSBkYXRhLmxhYmVsO1xyXG5cclxuICAgICAgICAgICAgICAgIGFwcC5lZGl0Tm9kZShkYXRhLCBhcHAuY2xlYXJOb2RlUG9wVXAsIGNhbGxiYWNrKTtcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGVkaXROb2RlOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGFwcC5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLW9wZXJhdGlvbicpLmlubmVySFRNTCA9IFwiRWRpdCBOb2RlXCI7XHJcbiAgICAgICAgICAgICAgICBhcHAuZWRpdE5vZGUoZGF0YSwgYXBwLmNhbmNlbE5vZGVFZGl0LCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBhZGRFZGdlOiBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgIGlmIChkYXRhLmZyb20gPT0gZGF0YS50bykge1xyXG4gICAgICAgICAgICAgICAgICB2YXIgciA9IGNvbmZpcm0oXCJEbyB5b3Ugd2FudCB0byBjb25uZWN0IHRoZSBub2RlIHRvIGl0c2VsZj9cIik7XHJcbiAgICAgICAgICAgICAgICAgIGlmIChyICE9IHRydWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGFwcC5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGdlLW9wZXJhdGlvbicpLmlubmVySFRNTCA9IFwiQWRkIEVkZ2VcIjtcclxuICAgICAgICAgICAgICAgIGRhdGEubGFiZWwgPSBcIlwiXHJcbiAgICAgICAgICAgICAgICAvLyAgYXBwLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtbGFiZWwnKS52YWx1ZSA9IGRhdGEubGFiZWxcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgICAgICAgICAgICBhcHAuZWRpdEVkZ2VXaXRob3V0RHJhZyhkYXRhLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBlZGl0RWRnZTogZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBhcHAuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1vcGVyYXRpb24nKS5pbm5lckhUTUwgPSBcIkVkaXQgRWRnZVwiO1xyXG4gICAgICAgICAgICAgICAgYXBwLmVkaXRFZGdlV2l0aG91dERyYWcoZGF0YSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICB0aGlzLm5ldHdvcmsgPSBuZXcgdmlzLk5ldHdvcmsoY29udGFpbmVyLCB0aGlzLmRhdGEsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAgIHRoaXMubmV0d29yay5vbihcInNlbGVjdE5vZGVcIiwgZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgICAgICBwYXJhbXMuc2hvdyA9IHRydWVcclxuICAgICAgICAgICAgYXBwLnNlbmRTZWxlY3RlZChwYXJhbXMpXHJcbiAgICAgICAgICB9KVxyXG5cclxuICAgICAgICAgIHRoaXMubmV0d29yay5vbihcInNlbGVjdEVkZ2VcIiwgZnVuY3Rpb24gKHBhcmFtcykge1xyXG4gICAgICAgICAgICBwYXJhbXMuc2hvdyA9IHRydWVcclxuICAgICAgICAgICAgYXBwLnNlbmRTZWxlY3RlZChwYXJhbXMpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICAgdGhpcy5uZXR3b3JrLm9uKFwiZGVzZWxlY3ROb2RlXCIsIGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICAgICAgcGFyYW1zLnNob3cgPSB0cnVlXHJcbiAgICAgICAgICAgIGFwcC5zZW5kU2VsZWN0ZWQocGFyYW1zKVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIHRoaXMubmV0d29yay5vbihcImRlc2VsZWN0RWRnZVwiLCBmdW5jdGlvbiAocGFyYW1zKSB7XHJcbiAgICAgICAgICAgIHBhcmFtcy5zaG93ID0gZmFsc2VcclxuICAgICAgICAgICAgYXBwLnNlbmRTZWxlY3RlZChwYXJhbXMpXHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cclxuXHJcbiAgICAgICAgc2VuZFNlbGVjdGVkKHBhcmFtcyl7XHJcbiAgICAgICAgICB0aGlzLmFnZW50LnNlbmQoXCJTZWxlY3RlZFwiLCB7YWN0aW9uIDogXCJzZWxlY3RlZENoYW5nZWRcIixcclxuICAgICAgICAgIG5vZGVzIDogdGhpcy5uZXR3b3JrLmJvZHkuZGF0YS5ub2Rlcy5nZXQocGFyYW1zLm5vZGVzKSxcclxuICAgICAgICAgIGVkZ2VzOiB0aGlzLm5ldHdvcmsuYm9keS5kYXRhLmVkZ2VzLmdldChwYXJhbXMuZWRnZXMpIH0pXHJcbiAgICAgICAgICBwYXJhbXMuc2hvdyA9PSB0cnVlID8gdGhpcy5hZ2VudC5zZW5kKFwiQXBwXCIsIHthY3Rpb246XCJsZXZlbENoYW5nZWRcIiwgbGV2ZWw6IFwiTm9kZVwifSkgOiBcIlwiXHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlZGl0Tm9kZShkYXRhLCBjYW5jZWxBY3Rpb24sIGNhbGxiYWNrKXtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25vZGUtbGFiZWwnKS52YWx1ZSA9IGRhdGEubGFiZWw7XHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25vZGUtc2F2ZUJ1dHRvbicpLm9uY2xpY2sgPSB0aGlzLnNhdmVOb2RlRGF0YS5iaW5kKHRoaXMsIGRhdGEsIGNhbGxiYWNrKTtcclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbm9kZS1jYW5jZWxCdXR0b24nKS5vbmNsaWNrID0gY2FuY2VsQWN0aW9uLmJpbmQodGhpcywgY2FsbGJhY2spO1xyXG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLWNsb3NlJykub25jbGljayA9IGNhbmNlbEFjdGlvbi5iaW5kKHRoaXMsIGNhbGxiYWNrKTtcclxuXHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25vZGUtbGFiZWwnKS5vbmtleWRvd24gPSB0aGlzLmtleWRvd25Ob2RlLmJpbmQodGhpcywgZGF0YSwgY2FsbGJhY2spO1xyXG4gICAgICAgICAgLy9cclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbm9kZS1wb3BVcCcpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgLy8gIGFwcC5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLWxhYmVsJykuZm9jdXMoe3ByZXZlbnRTY3JvbGw6ZmFsc2V9KTtcclxuICAgICAgICAgIC8vICB0aGlzLmFnZW50LnNlbmQoXCJWaXNUb29sXCIsIHthY3Rpb246IFwiY2hhbmdlVG9vbFwiLCBwYXJhbXM6IHtkYXRhOiBkYXRhLCB0b29sOiBcImVkaXROb2RlXCIsIGNhbGxiYWNrOiBjYn19KVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gQ2FsbGJhY2sgcGFzc2VkIGFzIHBhcmFtZXRlciBpcyBpZ25vcmVkXHJcbiAgICAgICAgY2xlYXJOb2RlUG9wVXAoKSB7XHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ25vZGUtc2F2ZUJ1dHRvbicpLm9uY2xpY2sgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLWNhbmNlbEJ1dHRvbicpLm9uY2xpY2sgPSBudWxsO1xyXG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdub2RlLXBvcFVwJykuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNhbmNlbE5vZGVFZGl0KGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICB0aGlzLmNsZWFyTm9kZVBvcFVwKCk7XHJcbiAgICAgICAgICBjYWxsYmFjayhudWxsKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHNhdmVOb2RlRGF0YShkYXRhLCBjYWxsYmFjaykge1xyXG4gICAgICAgICAgZGF0YS5sYWJlbCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnbm9kZS1sYWJlbCcpLnZhbHVlO1xyXG4gICAgICAgICAgZGF0YS5pZCA9IHRoaXMuY3VycmVudEZpbGUrXCIjXCIrZGF0YS5sYWJlbFxyXG4gICAgICAgICAgdGhpcy5jbGVhck5vZGVQb3BVcCgpO1xyXG4gICAgICAgICAgY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBlZGl0RWRnZVdpdGhvdXREcmFnKGRhdGEsIGNhbGxiYWNrKXtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtbGFiZWwnKS52YWx1ZSA9IGRhdGEubGFiZWw7XHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2Utc2F2ZUJ1dHRvbicpLm9uY2xpY2sgPSB0aGlzLnNhdmVFZGdlRGF0YS5iaW5kKHRoaXMsIGRhdGEsIGNhbGxiYWNrKTtcclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1jYW5jZWxCdXR0b24nKS5vbmNsaWNrID0gdGhpcy5jYW5jZWxFZGdlRWRpdC5iaW5kKHRoaXMsY2FsbGJhY2spO1xyXG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGdlLWNsb3NlJykub25jbGljayA9IHRoaXMuY2FuY2VsRWRnZUVkaXQuYmluZCh0aGlzLGNhbGxiYWNrKTtcclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1sYWJlbCcpLm9ua2V5ZG93biA9IHRoaXMua2V5ZG93bkVkZ2UuYmluZCh0aGlzLCBkYXRhLCBjYWxsYmFjayk7XHJcbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2VkZ2UtcG9wVXAnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNsZWFyRWRnZVBvcFVwKCkge1xyXG4gICAgICAgICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCdlZGdlLXNhdmVCdXR0b24nKS5vbmNsaWNrID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1jYW5jZWxCdXR0b24nKS5vbmNsaWNrID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1wb3BVcCcpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjYW5jZWxFZGdlRWRpdChjYWxsYmFjaykge1xyXG4gICAgICAgICAgdGhpcy5jbGVhckVkZ2VQb3BVcCgpO1xyXG4gICAgICAgICAgY2FsbGJhY2sobnVsbCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBzYXZlRWRnZURhdGEoZGF0YSwgY2FsbGJhY2spIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpXHJcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEudG8gPT09ICdvYmplY3QnKVxyXG4gICAgICAgICAgZGF0YS50byA9IGRhdGEudG8uaWRcclxuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS5mcm9tID09PSAnb2JqZWN0JylcclxuICAgICAgICAgIGRhdGEuZnJvbSA9IGRhdGEuZnJvbS5pZFxyXG4gICAgICAgICAgZGF0YS5sYWJlbCA9IHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgnZWRnZS1sYWJlbCcpLnZhbHVlO1xyXG4gICAgICAgICAgbGV0IHN1YmplY3QgPSAgdGhpcy5uZXR3b3JrLmJvZHkuZGF0YS5ub2Rlcy5nZXQoZGF0YS5mcm9tKS5sYWJlbFxyXG4gICAgICAgICAgbGV0IG9iamVjdCA9IHRoaXMubmV0d29yay5ib2R5LmRhdGEubm9kZXMuZ2V0KGRhdGEudG8pLmxhYmVsXHJcbiAgICAgICAgICBsZXQgdHJpcGxlID0ge3N1YmplY3Q6IHN1YmplY3QgLCBwcmVkaWNhdGU6IGRhdGEubGFiZWwsIG9iamVjdDogb2JqZWN0fVxyXG4gICAgICAgICAgY29uc29sZS5sb2codHJpcGxlKVxyXG4gICAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiQnJvd3NlclwiLCB7YWN0aW9uOiBcImFkZFRyaXBsZVwiLCB0cmlwbGU6IHRyaXBsZX0pXHJcbiAgICAgICAgICB0aGlzLmNsZWFyRWRnZVBvcFVwKCk7XHJcbiAgICAgICAgICAvLyBub24gbmVjZXNzYWlyZSBjYXIgZ2VuZXLDqSBwYXIgYnJvd3NlciAgY2FsbGJhY2soZGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBrZXlkb3duTm9kZShkYXRhLCBjYWxsYmFjaywgZSl7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhlLGRhdGEsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgaWYgKCBlLndoaWNoID09PSAxMyApIHtcclxuICAgICAgICAgICAgLy8gIHRoaXMuYWRkX3RyaXBsZSgpXHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZU5vZGVEYXRhKGRhdGEsIGNhbGxiYWNrKVxyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGtleWRvd25FZGdlKGRhdGEsIGNhbGxiYWNrLCBlKXtcclxuICAgICAgICAgIGlmICggZS53aGljaCA9PT0gMTMgKSB7XHJcbiAgICAgICAgICAgIC8vdGhpcy5hZGRfdHJpcGxlKClcclxuICAgICAgICAgICAgdGhpcy5zYXZlRWRnZURhdGEoZGF0YSwgY2FsbGJhY2spXHJcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uZmlnQ2hhbmdlZChjb25maWcpe1xyXG4gICAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWdcclxuICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuY29uZmlnKVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgndmlzLXZpZXcnLCBWaXNWaWV3KTtcclxuIiwiLy8gTjMuanMgaW1wbGVtZW50YXRpb25zIG9mIHRoZSBSREYvSlMgY29yZSBkYXRhIHR5cGVzXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3JkZmpzL3JlcHJlc2VudGF0aW9uLXRhc2stZm9yY2UvYmxvYi9tYXN0ZXIvaW50ZXJmYWNlLXNwZWMubWRcblxuaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSAnLi9JUklzJztcbmNvbnN0IHsgcmRmLCB4c2QgfSA9IG5hbWVzcGFjZXM7XG5cbnZhciBEYXRhRmFjdG9yeSwgREVGQVVMVEdSQVBIO1xuXG52YXIgX2JsYW5rTm9kZUNvdW50ZXIgPSAwO1xuXG4vLyAjIyBUZXJtIGNvbnN0cnVjdG9yXG5jbGFzcyBUZXJtIHtcbiAgY29uc3RydWN0b3IoaWQpIHtcbiAgICB0aGlzLmlkID0gaWQ7XG4gIH1cblxuICAvLyAjIyMgVGhlIHZhbHVlIG9mIHRoaXMgdGVybVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQ7XG4gIH1cblxuICAvLyAjIyMgUmV0dXJucyB3aGV0aGVyIHRoaXMgb2JqZWN0IHJlcHJlc2VudHMgdGhlIHNhbWUgdGVybSBhcyB0aGUgb3RoZXJcbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgLy8gSWYgYm90aCB0ZXJtcyB3ZXJlIGNyZWF0ZWQgYnkgdGhpcyBsaWJyYXJ5LFxuICAgIC8vIGVxdWFsaXR5IGNhbiBiZSBjb21wdXRlZCB0aHJvdWdoIGlkc1xuICAgIGlmIChvdGhlciBpbnN0YW5jZW9mIFRlcm0pXG4gICAgICByZXR1cm4gdGhpcy5pZCA9PT0gb3RoZXIuaWQ7XG4gICAgLy8gT3RoZXJ3aXNlLCBjb21wYXJlIHRlcm0gdHlwZSBhbmQgdmFsdWVcbiAgICByZXR1cm4gISFvdGhlciAmJiB0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgICAgPT09IG90aGVyLnZhbHVlO1xuICB9XG5cbiAgLy8gIyMjIFJldHVybnMgYSBwbGFpbiBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhpcyB0ZXJtXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6IHRoaXMudGVybVR5cGUsXG4gICAgICB2YWx1ZTogICAgdGhpcy52YWx1ZSxcbiAgICB9O1xuICB9XG59XG5cblxuLy8gIyMgTmFtZWROb2RlIGNvbnN0cnVjdG9yXG5jbGFzcyBOYW1lZE5vZGUgZXh0ZW5kcyBUZXJtIHtcbiAgLy8gIyMjIFRoZSB0ZXJtIHR5cGUgb2YgdGhpcyB0ZXJtXG4gIGdldCB0ZXJtVHlwZSgpIHtcbiAgICByZXR1cm4gJ05hbWVkTm9kZSc7XG4gIH1cbn1cblxuLy8gIyMgTGl0ZXJhbCBjb25zdHJ1Y3RvclxuY2xhc3MgTGl0ZXJhbCBleHRlbmRzIFRlcm0ge1xuICAvLyAjIyMgVGhlIHRlcm0gdHlwZSBvZiB0aGlzIHRlcm1cbiAgZ2V0IHRlcm1UeXBlKCkge1xuICAgIHJldHVybiAnTGl0ZXJhbCc7XG4gIH1cblxuICAvLyAjIyMgVGhlIHRleHQgdmFsdWUgb2YgdGhpcyBsaXRlcmFsXG4gIGdldCB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcoMSwgdGhpcy5pZC5sYXN0SW5kZXhPZignXCInKSk7XG4gIH1cblxuICAvLyAjIyMgVGhlIGxhbmd1YWdlIG9mIHRoaXMgbGl0ZXJhbFxuICBnZXQgbGFuZ3VhZ2UoKSB7XG4gICAgLy8gRmluZCB0aGUgbGFzdCBxdW90YXRpb24gbWFyayAoZS5nLiwgJ1wiYWJjXCJAZW4tdXMnKVxuICAgIHZhciBpZCA9IHRoaXMuaWQsIGF0UG9zID0gaWQubGFzdEluZGV4T2YoJ1wiJykgKyAxO1xuICAgIC8vIElmIFwiQFwiIGl0IGZvbGxvd3MsIHJldHVybiB0aGUgcmVtYWluaW5nIHN1YnN0cmluZzsgZW1wdHkgb3RoZXJ3aXNlXG4gICAgcmV0dXJuIGF0UG9zIDwgaWQubGVuZ3RoICYmIGlkW2F0UG9zKytdID09PSAnQCcgPyBpZC5zdWJzdHIoYXRQb3MpLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgfVxuXG4gIC8vICMjIyBUaGUgZGF0YXR5cGUgSVJJIG9mIHRoaXMgbGl0ZXJhbFxuICBnZXQgZGF0YXR5cGUoKSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lZE5vZGUodGhpcy5kYXRhdHlwZVN0cmluZyk7XG4gIH1cblxuICAvLyAjIyMgVGhlIGRhdGF0eXBlIHN0cmluZyBvZiB0aGlzIGxpdGVyYWxcbiAgZ2V0IGRhdGF0eXBlU3RyaW5nKCkge1xuICAgIC8vIEZpbmQgdGhlIGxhc3QgcXVvdGF0aW9uIG1hcmsgKGUuZy4sICdcImFiY1wiXl5odHRwOi8vZXgub3JnL3R5cGVzI3QnKVxuICAgIHZhciBpZCA9IHRoaXMuaWQsIGR0UG9zID0gaWQubGFzdEluZGV4T2YoJ1wiJykgKyAxLCBjaDtcbiAgICAvLyBJZiBcIl5cIiBpdCBmb2xsb3dzLCByZXR1cm4gdGhlIHJlbWFpbmluZyBzdWJzdHJpbmdcbiAgICByZXR1cm4gZHRQb3MgPCBpZC5sZW5ndGggJiYgKGNoID0gaWRbZHRQb3NdKSA9PT0gJ14nID8gaWQuc3Vic3RyKGR0UG9zICsgMikgOlxuICAgICAgICAgICAvLyBJZiBcIkBcIiBmb2xsb3dzLCByZXR1cm4gcmRmOmxhbmdTdHJpbmc7IHhzZDpzdHJpbmcgb3RoZXJ3aXNlXG4gICAgICAgICAgIChjaCAhPT0gJ0AnID8geHNkLnN0cmluZyA6IHJkZi5sYW5nU3RyaW5nKTtcbiAgfVxuXG4gIC8vICMjIyBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgcmVwcmVzZW50cyB0aGUgc2FtZSB0ZXJtIGFzIHRoZSBvdGhlclxuICBlcXVhbHMob3RoZXIpIHtcbiAgICAvLyBJZiBib3RoIGxpdGVyYWxzIHdlcmUgY3JlYXRlZCBieSB0aGlzIGxpYnJhcnksXG4gICAgLy8gZXF1YWxpdHkgY2FuIGJlIGNvbXB1dGVkIHRocm91Z2ggaWRzXG4gICAgaWYgKG90aGVyIGluc3RhbmNlb2YgTGl0ZXJhbClcbiAgICAgIHJldHVybiB0aGlzLmlkID09PSBvdGhlci5pZDtcbiAgICAvLyBPdGhlcndpc2UsIGNvbXBhcmUgdGVybSB0eXBlLCB2YWx1ZSwgbGFuZ3VhZ2UsIGFuZCBkYXRhdHlwZVxuICAgIHJldHVybiAhIW90aGVyICYmICEhb3RoZXIuZGF0YXR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgICAgPT09IG90aGVyLnZhbHVlICAgICYmXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYW5ndWFnZSA9PT0gb3RoZXIubGFuZ3VhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGF0eXBlLnZhbHVlID09PSBvdGhlci5kYXRhdHlwZS52YWx1ZTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGVybVR5cGU6IHRoaXMudGVybVR5cGUsXG4gICAgICB2YWx1ZTogICAgdGhpcy52YWx1ZSxcbiAgICAgIGxhbmd1YWdlOiB0aGlzLmxhbmd1YWdlLFxuICAgICAgZGF0YXR5cGU6IHsgdGVybVR5cGU6ICdOYW1lZE5vZGUnLCB2YWx1ZTogdGhpcy5kYXRhdHlwZVN0cmluZyB9LFxuICAgIH07XG4gIH1cbn1cblxuLy8gIyMgQmxhbmtOb2RlIGNvbnN0cnVjdG9yXG5jbGFzcyBCbGFua05vZGUgZXh0ZW5kcyBUZXJtIHtcbiAgY29uc3RydWN0b3IobmFtZSkge1xuICAgIHN1cGVyKCdfOicgKyBuYW1lKTtcbiAgfVxuXG4gIC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdCbGFua05vZGUnO1xuICB9XG5cbiAgLy8gIyMjIFRoZSBuYW1lIG9mIHRoaXMgYmxhbmsgbm9kZVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyKDIpO1xuICB9XG59XG5cbmNsYXNzIFZhcmlhYmxlIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcignPycgKyBuYW1lKTtcbiAgfVxuXG4gIC8vICMjIyBUaGUgdGVybSB0eXBlIG9mIHRoaXMgdGVybVxuICBnZXQgdGVybVR5cGUoKSB7XG4gICAgcmV0dXJuICdWYXJpYWJsZSc7XG4gIH1cblxuICAvLyAjIyMgVGhlIG5hbWUgb2YgdGhpcyB2YXJpYWJsZVxuICBnZXQgdmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaWQuc3Vic3RyKDEpO1xuICB9XG59XG5cbi8vICMjIERlZmF1bHRHcmFwaCBjb25zdHJ1Y3RvclxuY2xhc3MgRGVmYXVsdEdyYXBoIGV4dGVuZHMgVGVybSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCcnKTtcbiAgICByZXR1cm4gREVGQVVMVEdSQVBIIHx8IHRoaXM7XG4gIH1cblxuICAvLyAjIyMgVGhlIHRlcm0gdHlwZSBvZiB0aGlzIHRlcm1cbiAgZ2V0IHRlcm1UeXBlKCkge1xuICAgIHJldHVybiAnRGVmYXVsdEdyYXBoJztcbiAgfVxuXG4gIC8vICMjIyBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgcmVwcmVzZW50cyB0aGUgc2FtZSB0ZXJtIGFzIHRoZSBvdGhlclxuICBlcXVhbHMob3RoZXIpIHtcbiAgICAvLyBJZiBib3RoIHRlcm1zIHdlcmUgY3JlYXRlZCBieSB0aGlzIGxpYnJhcnksXG4gICAgLy8gZXF1YWxpdHkgY2FuIGJlIGNvbXB1dGVkIHRocm91Z2ggc3RyaWN0IGVxdWFsaXR5O1xuICAgIC8vIG90aGVyd2lzZSwgY29tcGFyZSB0ZXJtIHR5cGVzLlxuICAgIHJldHVybiAodGhpcyA9PT0gb3RoZXIpIHx8ICghIW90aGVyICYmICh0aGlzLnRlcm1UeXBlID09PSBvdGhlci50ZXJtVHlwZSkpO1xuICB9XG59XG5cbi8vICMjIERlZmF1bHRHcmFwaCBzaW5nbGV0b25cbkRFRkFVTFRHUkFQSCA9IG5ldyBEZWZhdWx0R3JhcGgoKTtcblxuXG4vLyAjIyMgQ29uc3RydWN0cyBhIHRlcm0gZnJvbSB0aGUgZ2l2ZW4gaW50ZXJuYWwgc3RyaW5nIElEXG5mdW5jdGlvbiBmcm9tSWQoaWQsIGZhY3RvcnkpIHtcbiAgZmFjdG9yeSA9IGZhY3RvcnkgfHwgRGF0YUZhY3Rvcnk7XG5cbiAgLy8gRmFsc3kgdmFsdWUgb3IgZW1wdHkgc3RyaW5nIGluZGljYXRlIHRoZSBkZWZhdWx0IGdyYXBoXG4gIGlmICghaWQpXG4gICAgcmV0dXJuIGZhY3RvcnkuZGVmYXVsdEdyYXBoKCk7XG5cbiAgLy8gSWRlbnRpZnkgdGhlIHRlcm0gdHlwZSBiYXNlZCBvbiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gIHN3aXRjaCAoaWRbMF0pIHtcbiAgY2FzZSAnXyc6IHJldHVybiBmYWN0b3J5LmJsYW5rTm9kZShpZC5zdWJzdHIoMikpO1xuICBjYXNlICc/JzogcmV0dXJuIGZhY3RvcnkudmFyaWFibGUoaWQuc3Vic3RyKDEpKTtcbiAgY2FzZSAnXCInOlxuICAgIC8vIFNob3J0Y3V0IGZvciBpbnRlcm5hbCBsaXRlcmFsc1xuICAgIGlmIChmYWN0b3J5ID09PSBEYXRhRmFjdG9yeSlcbiAgICAgIHJldHVybiBuZXcgTGl0ZXJhbChpZCk7XG4gICAgLy8gTGl0ZXJhbCB3aXRob3V0IGRhdGF0eXBlIG9yIGxhbmd1YWdlXG4gICAgaWYgKGlkW2lkLmxlbmd0aCAtIDFdID09PSAnXCInKVxuICAgICAgcmV0dXJuIGZhY3RvcnkubGl0ZXJhbChpZC5zdWJzdHIoMSwgaWQubGVuZ3RoIC0gMikpO1xuICAgIC8vIExpdGVyYWwgd2l0aCBkYXRhdHlwZSBvciBsYW5ndWFnZVxuICAgIHZhciBlbmRQb3MgPSBpZC5sYXN0SW5kZXhPZignXCInLCBpZC5sZW5ndGggLSAxKTtcbiAgICByZXR1cm4gZmFjdG9yeS5saXRlcmFsKGlkLnN1YnN0cigxLCBlbmRQb3MgLSAxKSxcbiAgICAgICAgICAgIGlkW2VuZFBvcyArIDFdID09PSAnQCcgPyBpZC5zdWJzdHIoZW5kUG9zICsgMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBmYWN0b3J5Lm5hbWVkTm9kZShpZC5zdWJzdHIoZW5kUG9zICsgMykpKTtcbiAgZGVmYXVsdDogIHJldHVybiBmYWN0b3J5Lm5hbWVkTm9kZShpZCk7XG4gIH1cbn1cblxuLy8gIyMjIENvbnN0cnVjdHMgYW4gaW50ZXJuYWwgc3RyaW5nIElEIGZyb20gdGhlIGdpdmVuIHRlcm0gb3IgSUQgc3RyaW5nXG5mdW5jdGlvbiB0b0lkKHRlcm0pIHtcbiAgaWYgKHR5cGVvZiB0ZXJtID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gdGVybTtcbiAgaWYgKHRlcm0gaW5zdGFuY2VvZiBUZXJtKVxuICAgIHJldHVybiB0ZXJtLmlkO1xuICBpZiAoIXRlcm0pXG4gICAgcmV0dXJuIERFRkFVTFRHUkFQSC5pZDtcblxuICAvLyBUZXJtIGluc3RhbnRpYXRlZCB3aXRoIGFub3RoZXIgbGlicmFyeVxuICBzd2l0Y2ggKHRlcm0udGVybVR5cGUpIHtcbiAgY2FzZSAnTmFtZWROb2RlJzogICAgcmV0dXJuIHRlcm0udmFsdWU7XG4gIGNhc2UgJ0JsYW5rTm9kZSc6ICAgIHJldHVybiAnXzonICsgdGVybS52YWx1ZTtcbiAgY2FzZSAnVmFyaWFibGUnOiAgICAgcmV0dXJuICc/JyArIHRlcm0udmFsdWU7XG4gIGNhc2UgJ0RlZmF1bHRHcmFwaCc6IHJldHVybiAnJztcbiAgY2FzZSAnTGl0ZXJhbCc6ICAgICAgcmV0dXJuICdcIicgKyB0ZXJtLnZhbHVlICsgJ1wiJyArXG4gICAgKHRlcm0ubGFuZ3VhZ2UgPyAnQCcgKyB0ZXJtLmxhbmd1YWdlIDpcbiAgICAgICh0ZXJtLmRhdGF0eXBlICYmIHRlcm0uZGF0YXR5cGUudmFsdWUgIT09IHhzZC5zdHJpbmcgPyAnXl4nICsgdGVybS5kYXRhdHlwZS52YWx1ZSA6ICcnKSk7XG4gIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCB0ZXJtVHlwZTogJyArIHRlcm0udGVybVR5cGUpO1xuICB9XG59XG5cblxuLy8gIyMgUXVhZCBjb25zdHJ1Y3RvclxuY2xhc3MgUXVhZCB7XG4gIGNvbnN0cnVjdG9yKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHRoaXMuc3ViamVjdCAgID0gc3ViamVjdDtcbiAgICB0aGlzLnByZWRpY2F0ZSA9IHByZWRpY2F0ZTtcbiAgICB0aGlzLm9iamVjdCAgICA9IG9iamVjdDtcbiAgICB0aGlzLmdyYXBoICAgICA9IGdyYXBoIHx8IERFRkFVTFRHUkFQSDtcbiAgfVxuXG4gIC8vICMjIyBSZXR1cm5zIGEgcGxhaW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVhZFxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1YmplY3Q6ICAgdGhpcy5zdWJqZWN0LnRvSlNPTigpLFxuICAgICAgcHJlZGljYXRlOiB0aGlzLnByZWRpY2F0ZS50b0pTT04oKSxcbiAgICAgIG9iamVjdDogICAgdGhpcy5vYmplY3QudG9KU09OKCksXG4gICAgICBncmFwaDogICAgIHRoaXMuZ3JhcGgudG9KU09OKCksXG4gICAgfTtcbiAgfVxuXG4gIC8vICMjIyBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvYmplY3QgcmVwcmVzZW50cyB0aGUgc2FtZSBxdWFkIGFzIHRoZSBvdGhlclxuICBlcXVhbHMob3RoZXIpIHtcbiAgICByZXR1cm4gISFvdGhlciAmJiB0aGlzLnN1YmplY3QuZXF1YWxzKG90aGVyLnN1YmplY3QpICAgICAmJlxuICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlZGljYXRlLmVxdWFscyhvdGhlci5wcmVkaWNhdGUpICYmXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5vYmplY3QuZXF1YWxzKG90aGVyLm9iamVjdCkgICAgICAgJiZcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdyYXBoLmVxdWFscyhvdGhlci5ncmFwaCk7XG4gIH1cbn1cblxuXG4vLyAjIyBEYXRhRmFjdG9yeSBzaW5nbGV0b25cbkRhdGFGYWN0b3J5ID0ge1xuICAvLyAjIyMgUHVibGljIGZhY3RvcnkgZnVuY3Rpb25zXG4gIG5hbWVkTm9kZSxcbiAgYmxhbmtOb2RlLFxuICB2YXJpYWJsZSxcbiAgbGl0ZXJhbCxcbiAgZGVmYXVsdEdyYXBoLFxuICBxdWFkLFxuICB0cmlwbGU6IHF1YWQsXG5cbiAgLy8gIyMjIEludGVybmFsIGRhdGF0eXBlIGNvbnN0cnVjdG9yc1xuICBpbnRlcm5hbDoge1xuICAgIFRlcm0sXG4gICAgTmFtZWROb2RlLFxuICAgIEJsYW5rTm9kZSxcbiAgICBWYXJpYWJsZSxcbiAgICBMaXRlcmFsLFxuICAgIERlZmF1bHRHcmFwaCxcbiAgICBRdWFkLFxuICAgIFRyaXBsZTogUXVhZCxcbiAgICBmcm9tSWQsXG4gICAgdG9JZCxcbiAgfSxcbn07XG5leHBvcnQgZGVmYXVsdCBEYXRhRmFjdG9yeTtcblxuLy8gIyMjIENyZWF0ZXMgYW4gSVJJXG5mdW5jdGlvbiBuYW1lZE5vZGUoaXJpKSB7XG4gIHJldHVybiBuZXcgTmFtZWROb2RlKGlyaSk7XG59XG5cbi8vICMjIyBDcmVhdGVzIGEgYmxhbmsgbm9kZVxuZnVuY3Rpb24gYmxhbmtOb2RlKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBCbGFua05vZGUobmFtZSB8fCBgbjMtJHtfYmxhbmtOb2RlQ291bnRlcisrfWApO1xufVxuXG4vLyAjIyMgQ3JlYXRlcyBhIGxpdGVyYWxcbmZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIGxhbmd1YWdlT3JEYXRhVHlwZSkge1xuICAvLyBDcmVhdGUgYSBsYW5ndWFnZS10YWdnZWQgc3RyaW5nXG4gIGlmICh0eXBlb2YgbGFuZ3VhZ2VPckRhdGFUeXBlID09PSAnc3RyaW5nJylcbiAgICByZXR1cm4gbmV3IExpdGVyYWwoJ1wiJyArIHZhbHVlICsgJ1wiQCcgKyBsYW5ndWFnZU9yRGF0YVR5cGUudG9Mb3dlckNhc2UoKSk7XG5cbiAgLy8gQXV0b21hdGljYWxseSBkZXRlcm1pbmUgZGF0YXR5cGUgZm9yIGJvb2xlYW5zIGFuZCBudW1iZXJzXG4gIGxldCBkYXRhdHlwZSA9IGxhbmd1YWdlT3JEYXRhVHlwZSA/IGxhbmd1YWdlT3JEYXRhVHlwZS52YWx1ZSA6ICcnO1xuICBpZiAoZGF0YXR5cGUgPT09ICcnKSB7XG4gICAgLy8gQ29udmVydCBhIGJvb2xlYW5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpXG4gICAgICBkYXRhdHlwZSA9IHhzZC5ib29sZWFuO1xuICAgIC8vIENvbnZlcnQgYW4gaW50ZWdlciBvciBkb3VibGVcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSlcbiAgICAgICAgZGF0YXR5cGUgPSBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSA/IHhzZC5pbnRlZ2VyIDogeHNkLmRvdWJsZTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBkYXRhdHlwZSA9IHhzZC5kb3VibGU7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHZhbHVlKSlcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlID4gMCA/ICdJTkYnIDogJy1JTkYnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGRhdGF0eXBlZCBsaXRlcmFsXG4gIHJldHVybiAoZGF0YXR5cGUgPT09ICcnIHx8IGRhdGF0eXBlID09PSB4c2Quc3RyaW5nKSA/XG4gICAgbmV3IExpdGVyYWwoJ1wiJyArIHZhbHVlICsgJ1wiJykgOlxuICAgIG5ldyBMaXRlcmFsKCdcIicgKyB2YWx1ZSArICdcIl5eJyArIGRhdGF0eXBlKTtcbn1cblxuLy8gIyMjIENyZWF0ZXMgYSB2YXJpYWJsZVxuZnVuY3Rpb24gdmFyaWFibGUobmFtZSkge1xuICByZXR1cm4gbmV3IFZhcmlhYmxlKG5hbWUpO1xufVxuXG4vLyAjIyMgUmV0dXJucyB0aGUgZGVmYXVsdCBncmFwaFxuZnVuY3Rpb24gZGVmYXVsdEdyYXBoKCkge1xuICByZXR1cm4gREVGQVVMVEdSQVBIO1xufVxuXG4vLyAjIyMgQ3JlYXRlcyBhIHF1YWRcbmZ1bmN0aW9uIHF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gIHJldHVybiBuZXcgUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpO1xufVxuIiwiLy8gKipOM1dyaXRlcioqIHdyaXRlcyBOMyBkb2N1bWVudHMuXG5pbXBvcnQgbmFtZXNwYWNlcyBmcm9tICcuL0lSSXMnO1xuaW1wb3J0IE4zRGF0YUZhY3RvcnkgZnJvbSAnLi9OM0RhdGFGYWN0b3J5JztcblxuY29uc3QgREVGQVVMVEdSQVBIID0gTjNEYXRhRmFjdG9yeS5kZWZhdWx0R3JhcGgoKTtcblxuY29uc3QgeyByZGYsIHhzZCB9ID0gbmFtZXNwYWNlcztcblxuLy8gQ2hhcmFjdGVycyBpbiBsaXRlcmFscyB0aGF0IHJlcXVpcmUgZXNjYXBpbmdcbnZhciBlc2NhcGUgICAgPSAvW1wiXFxcXFxcdFxcblxcclxcYlxcZlxcdTAwMDAtXFx1MDAxOVxcdWQ4MDAtXFx1ZGJmZl0vLFxuICAgIGVzY2FwZUFsbCA9IC9bXCJcXFxcXFx0XFxuXFxyXFxiXFxmXFx1MDAwMC1cXHUwMDE5XXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdL2csXG4gICAgZXNjYXBlZENoYXJhY3RlcnMgPSB7XG4gICAgICAnXFxcXCc6ICdcXFxcXFxcXCcsICdcIic6ICdcXFxcXCInLCAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICdcXG4nOiAnXFxcXG4nLCAnXFxyJzogJ1xcXFxyJywgJ1xcYic6ICdcXFxcYicsICdcXGYnOiAnXFxcXGYnLFxuICAgIH07XG5cbi8vICMjIFBsYWNlaG9sZGVyIGNsYXNzIHRvIHJlcHJlc2VudCBhbHJlYWR5IHByZXR0eS1wcmludGVkIHRlcm1zXG5jbGFzcyBTZXJpYWxpemVkVGVybSBleHRlbmRzIE4zRGF0YUZhY3RvcnkuaW50ZXJuYWwuVGVybSB7XG4gIC8vIFByZXR0eS1wcmludGVkIG5vZGVzIGFyZSBub3QgZXF1YWwgdG8gYW55IG90aGVyIG5vZGVcbiAgLy8gKGUuZy4sIFtdIGRvZXMgbm90IGVxdWFsIFtdKVxuICBlcXVhbHMoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vICMjIENvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOM1dyaXRlciB7XG4gIGNvbnN0cnVjdG9yKG91dHB1dFN0cmVhbSwgb3B0aW9ucykge1xuICAgIC8vICMjIyBgX3ByZWZpeFJlZ2V4YCBtYXRjaGVzIGEgcHJlZml4ZWQgbmFtZSBvciBJUkkgdGhhdCBiZWdpbnMgd2l0aCBvbmUgb2YgdGhlIGFkZGVkIHByZWZpeGVzXG4gICAgdGhpcy5fcHJlZml4UmVnZXggPSAvJDBeLztcblxuICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgc3RyZWFtXG4gICAgaWYgKG91dHB1dFN0cmVhbSAmJiB0eXBlb2Ygb3V0cHV0U3RyZWFtLndyaXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgb3B0aW9ucyA9IG91dHB1dFN0cmVhbSwgb3V0cHV0U3RyZWFtID0gbnVsbDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9saXN0cyA9IG9wdGlvbnMubGlzdHM7XG5cbiAgICAvLyBJZiBubyBvdXRwdXQgc3RyZWFtIGdpdmVuLCBzZW5kIHRoZSBvdXRwdXQgYXMgc3RyaW5nIHRocm91Z2ggdGhlIGVuZCBjYWxsYmFja1xuICAgIGlmICghb3V0cHV0U3RyZWFtKSB7XG4gICAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSB7XG4gICAgICAgIHdyaXRlKGNodW5rLCBlbmNvZGluZywgZG9uZSkgeyBvdXRwdXQgKz0gY2h1bms7IGRvbmUgJiYgZG9uZSgpOyB9LFxuICAgICAgICBlbmQ6ICAgZnVuY3Rpb24gKGRvbmUpIHsgZG9uZSAmJiBkb25lKG51bGwsIG91dHB1dCk7IH0sXG4gICAgICB9O1xuICAgICAgdGhpcy5fZW5kU3RyZWFtID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9vdXRwdXRTdHJlYW0gPSBvdXRwdXRTdHJlYW07XG4gICAgICB0aGlzLl9lbmRTdHJlYW0gPSBvcHRpb25zLmVuZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6ICEhb3B0aW9ucy5lbmQ7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSB3cml0ZXIsIGRlcGVuZGluZyBvbiB0aGUgZm9ybWF0XG4gICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgaWYgKCEoL3RyaXBsZXxxdWFkL2kpLnRlc3Qob3B0aW9ucy5mb3JtYXQpKSB7XG4gICAgICB0aGlzLl9ncmFwaCA9IERFRkFVTFRHUkFQSDtcbiAgICAgIHRoaXMuX3ByZWZpeElSSXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgb3B0aW9ucy5wcmVmaXhlcyAmJiB0aGlzLmFkZFByZWZpeGVzKG9wdGlvbnMucHJlZml4ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3dyaXRlUXVhZCA9IHRoaXMuX3dyaXRlUXVhZExpbmU7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMgUHJpdmF0ZSBtZXRob2RzXG5cbiAgLy8gIyMjIFdoZXRoZXIgdGhlIGN1cnJlbnQgZ3JhcGggaXMgdGhlIGRlZmF1bHQgZ3JhcGhcbiAgZ2V0IF9pbkRlZmF1bHRHcmFwaCgpIHtcbiAgICByZXR1cm4gREVGQVVMVEdSQVBILmVxdWFscyh0aGlzLl9ncmFwaCk7XG4gIH1cblxuICAvLyAjIyMgYF93cml0ZWAgd3JpdGVzIHRoZSBhcmd1bWVudCB0byB0aGUgb3V0cHV0IHN0cmVhbVxuICBfd3JpdGUoc3RyaW5nLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX291dHB1dFN0cmVhbS53cml0ZShzdHJpbmcsICd1dGY4JywgY2FsbGJhY2spO1xuICB9XG5cbiAgLy8gIyMjIGBfd3JpdGVRdWFkYCB3cml0ZXMgdGhlIHF1YWQgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgX3dyaXRlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgsIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gV3JpdGUgdGhlIGdyYXBoJ3MgbGFiZWwgaWYgaXQgaGFzIGNoYW5nZWRcbiAgICAgIGlmICghZ3JhcGguZXF1YWxzKHRoaXMuX2dyYXBoKSkge1xuICAgICAgICAvLyBDbG9zZSB0aGUgcHJldmlvdXMgZ3JhcGggYW5kIHN0YXJ0IHRoZSBuZXcgb25lXG4gICAgICAgIHRoaXMuX3dyaXRlKCh0aGlzLl9zdWJqZWN0ID09PSBudWxsID8gJycgOiAodGhpcy5faW5EZWZhdWx0R3JhcGggPyAnLlxcbicgOiAnXFxufVxcbicpKSArXG4gICAgICAgICAgICAgICAgICAgIChERUZBVUxUR1JBUEguZXF1YWxzKGdyYXBoKSA/ICcnIDogdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhncmFwaCkgKyAnIHtcXG4nKSk7XG4gICAgICAgIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gRG9uJ3QgcmVwZWF0IHRoZSBzdWJqZWN0IGlmIGl0J3MgdGhlIHNhbWVcbiAgICAgIGlmIChzdWJqZWN0LmVxdWFscyh0aGlzLl9zdWJqZWN0KSkge1xuICAgICAgICAvLyBEb24ndCByZXBlYXQgdGhlIHByZWRpY2F0ZSBpZiBpdCdzIHRoZSBzYW1lXG4gICAgICAgIGlmIChwcmVkaWNhdGUuZXF1YWxzKHRoaXMuX3ByZWRpY2F0ZSkpXG4gICAgICAgICAgdGhpcy5fd3JpdGUoJywgJyArIHRoaXMuX2VuY29kZU9iamVjdChvYmplY3QpLCBkb25lKTtcbiAgICAgICAgLy8gU2FtZSBzdWJqZWN0LCBkaWZmZXJlbnQgcHJlZGljYXRlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLl93cml0ZSgnO1xcbiAgICAnICtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVQcmVkaWNhdGUodGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlT2JqZWN0KG9iamVjdCksIGRvbmUpO1xuICAgICAgfVxuICAgICAgLy8gRGlmZmVyZW50IHN1YmplY3Q7IHdyaXRlIHRoZSB3aG9sZSBxdWFkXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX3dyaXRlKCh0aGlzLl9zdWJqZWN0ID09PSBudWxsID8gJycgOiAnLlxcbicpICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlSXJpT3JCbGFuayh0aGlzLl9zdWJqZWN0ID0gc3ViamVjdCkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVQcmVkaWNhdGUodGhpcy5fcHJlZGljYXRlID0gcHJlZGljYXRlKSArICcgJyArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZU9iamVjdChvYmplY3QpLCBkb25lKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGRvbmUgJiYgZG9uZShlcnJvcik7IH1cbiAgfVxuXG4gIC8vICMjIyBgX3dyaXRlUXVhZExpbmVgIHdyaXRlcyB0aGUgcXVhZCB0byB0aGUgb3V0cHV0IHN0cmVhbSBhcyBhIHNpbmdsZSBsaW5lXG4gIF93cml0ZVF1YWRMaW5lKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCwgZG9uZSkge1xuICAgIC8vIFdyaXRlIHRoZSBxdWFkIHdpdGhvdXQgcHJlZml4ZXNcbiAgICBkZWxldGUgdGhpcy5fcHJlZml4TWF0Y2g7XG4gICAgdGhpcy5fd3JpdGUodGhpcy5xdWFkVG9TdHJpbmcoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSwgZG9uZSk7XG4gIH1cblxuICAvLyAjIyMgYHF1YWRUb1N0cmluZ2Agc2VyaWFsaXplcyBhIHF1YWQgYXMgYSBzdHJpbmdcbiAgcXVhZFRvU3RyaW5nKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHJldHVybiAgdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhzdWJqZWN0KSAgICsgJyAnICtcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZUlyaU9yQmxhbmsocHJlZGljYXRlKSArICcgJyArXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVPYmplY3Qob2JqZWN0KSArXG4gICAgICAgICAgICAoZ3JhcGggJiYgZ3JhcGgudmFsdWUgPyAnICcgKyB0aGlzLl9lbmNvZGVJcmlPckJsYW5rKGdyYXBoKSArICcgLlxcbicgOiAnIC5cXG4nKTtcbiAgfVxuXG4gIC8vICMjIyBgcXVhZHNUb1N0cmluZ2Agc2VyaWFsaXplcyBhbiBhcnJheSBvZiBxdWFkcyBhcyBhIHN0cmluZ1xuICBxdWFkc1RvU3RyaW5nKHF1YWRzKSB7XG4gICAgcmV0dXJuIHF1YWRzLm1hcChmdW5jdGlvbiAodCkge1xuICAgICAgcmV0dXJuIHRoaXMucXVhZFRvU3RyaW5nKHQuc3ViamVjdCwgdC5wcmVkaWNhdGUsIHQub2JqZWN0LCB0LmdyYXBoKTtcbiAgICB9LCB0aGlzKS5qb2luKCcnKTtcbiAgfVxuXG4gIC8vICMjIyBgX2VuY29kZUlyaU9yQmxhbmtgIHJlcHJlc2VudHMgYW4gSVJJIG9yIGJsYW5rIG5vZGVcbiAgX2VuY29kZUlyaU9yQmxhbmsoZW50aXR5KSB7XG4gICAgLy8gQSBibGFuayBub2RlIG9yIGxpc3QgaXMgcmVwcmVzZW50ZWQgYXMtaXNcbiAgICBpZiAoZW50aXR5LnRlcm1UeXBlICE9PSAnTmFtZWROb2RlJykge1xuICAgICAgLy8gSWYgaXQgaXMgYSBsaXN0IGhlYWQsIHByZXR0eS1wcmludCBpdFxuICAgICAgaWYgKHRoaXMuX2xpc3RzICYmIChlbnRpdHkudmFsdWUgaW4gdGhpcy5fbGlzdHMpKVxuICAgICAgICBlbnRpdHkgPSB0aGlzLmxpc3QodGhpcy5fbGlzdHNbZW50aXR5LnZhbHVlXSk7XG4gICAgICByZXR1cm4gJ2lkJyBpbiBlbnRpdHkgPyBlbnRpdHkuaWQgOiAnXzonICsgZW50aXR5LnZhbHVlO1xuICAgIH1cbiAgICAvLyBFc2NhcGUgc3BlY2lhbCBjaGFyYWN0ZXJzXG4gICAgdmFyIGlyaSA9IGVudGl0eS52YWx1ZTtcbiAgICBpZiAoZXNjYXBlLnRlc3QoaXJpKSlcbiAgICAgIGlyaSA9IGlyaS5yZXBsYWNlKGVzY2FwZUFsbCwgY2hhcmFjdGVyUmVwbGFjZXIpO1xuICAgIC8vIFRyeSB0byByZXByZXNlbnQgdGhlIElSSSBhcyBwcmVmaXhlZCBuYW1lXG4gICAgdmFyIHByZWZpeE1hdGNoID0gdGhpcy5fcHJlZml4UmVnZXguZXhlYyhpcmkpO1xuICAgIHJldHVybiAhcHJlZml4TWF0Y2ggPyAnPCcgKyBpcmkgKyAnPicgOlxuICAgICAgICAgICAoIXByZWZpeE1hdGNoWzFdID8gaXJpIDogdGhpcy5fcHJlZml4SVJJc1twcmVmaXhNYXRjaFsxXV0gKyBwcmVmaXhNYXRjaFsyXSk7XG4gIH1cblxuICAvLyAjIyMgYF9lbmNvZGVMaXRlcmFsYCByZXByZXNlbnRzIGEgbGl0ZXJhbFxuICBfZW5jb2RlTGl0ZXJhbChsaXRlcmFsKSB7XG4gICAgLy8gRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVyc1xuICAgIHZhciB2YWx1ZSA9IGxpdGVyYWwudmFsdWU7XG4gICAgaWYgKGVzY2FwZS50ZXN0KHZhbHVlKSlcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShlc2NhcGVBbGwsIGNoYXJhY3RlclJlcGxhY2VyKTtcbiAgICAvLyBXcml0ZSB0aGUgbGl0ZXJhbCwgcG9zc2libHkgd2l0aCB0eXBlIG9yIGxhbmd1YWdlXG4gICAgaWYgKGxpdGVyYWwubGFuZ3VhZ2UpXG4gICAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiQCcgKyBsaXRlcmFsLmxhbmd1YWdlO1xuICAgIGVsc2UgaWYgKGxpdGVyYWwuZGF0YXR5cGUudmFsdWUgIT09IHhzZC5zdHJpbmcpXG4gICAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiXl4nICsgdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhsaXRlcmFsLmRhdGF0eXBlKTtcbiAgICBlbHNlXG4gICAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgfVxuXG4gIC8vICMjIyBgX2VuY29kZVByZWRpY2F0ZWAgcmVwcmVzZW50cyBhIHByZWRpY2F0ZVxuICBfZW5jb2RlUHJlZGljYXRlKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBwcmVkaWNhdGUudmFsdWUgPT09IHJkZi50eXBlID8gJ2EnIDogdGhpcy5fZW5jb2RlSXJpT3JCbGFuayhwcmVkaWNhdGUpO1xuICB9XG5cbiAgLy8gIyMjIGBfZW5jb2RlT2JqZWN0YCByZXByZXNlbnRzIGFuIG9iamVjdFxuICBfZW5jb2RlT2JqZWN0KG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QudGVybVR5cGUgPT09ICdMaXRlcmFsJyA/IHRoaXMuX2VuY29kZUxpdGVyYWwob2JqZWN0KSA6IHRoaXMuX2VuY29kZUlyaU9yQmxhbmsob2JqZWN0KTtcbiAgfVxuXG4gIC8vICMjIyBgX2Jsb2NrZWRXcml0ZWAgcmVwbGFjZXMgYF93cml0ZWAgYWZ0ZXIgdGhlIHdyaXRlciBoYXMgYmVlbiBjbG9zZWRcbiAgX2Jsb2NrZWRXcml0ZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB3cml0ZSBiZWNhdXNlIHRoZSB3cml0ZXIgaGFzIGJlZW4gY2xvc2VkLicpO1xuICB9XG5cbiAgLy8gIyMjIGBhZGRRdWFkYCBhZGRzIHRoZSBxdWFkIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gIGFkZFF1YWQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoLCBkb25lKSB7XG4gICAgLy8gVGhlIHF1YWQgd2FzIGdpdmVuIGFzIGFuIG9iamVjdCwgc28gc2hpZnQgcGFyYW1ldGVyc1xuICAgIGlmIChvYmplY3QgPT09IHVuZGVmaW5lZClcbiAgICAgIHRoaXMuX3dyaXRlUXVhZChzdWJqZWN0LnN1YmplY3QsIHN1YmplY3QucHJlZGljYXRlLCBzdWJqZWN0Lm9iamVjdCwgc3ViamVjdC5ncmFwaCwgcHJlZGljYXRlKTtcbiAgICAvLyBUaGUgb3B0aW9uYWwgYGdyYXBoYCBwYXJhbWV0ZXIgd2FzIG5vdCBwcm92aWRlZFxuICAgIGVsc2UgaWYgKHR5cGVvZiBncmFwaCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRoaXMuX3dyaXRlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgREVGQVVMVEdSQVBILCBncmFwaCk7XG4gICAgLy8gVGhlIGBncmFwaGAgcGFyYW1ldGVyIHdhcyBwcm92aWRlZFxuICAgIGVsc2VcbiAgICAgIHRoaXMuX3dyaXRlUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGggfHwgREVGQVVMVEdSQVBILCBkb25lKTtcbiAgfVxuXG4gIC8vICMjIyBgYWRkUXVhZHNgIGFkZHMgdGhlIHF1YWRzIHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gIGFkZFF1YWRzKHF1YWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYWRkUXVhZChxdWFkc1tpXSk7XG4gIH1cblxuICAvLyAjIyMgYGFkZFByZWZpeGAgYWRkcyB0aGUgcHJlZml4IHRvIHRoZSBvdXRwdXQgc3RyZWFtXG4gIGFkZFByZWZpeChwcmVmaXgsIGlyaSwgZG9uZSkge1xuICAgIHZhciBwcmVmaXhlcyA9IHt9O1xuICAgIHByZWZpeGVzW3ByZWZpeF0gPSBpcmk7XG4gICAgdGhpcy5hZGRQcmVmaXhlcyhwcmVmaXhlcywgZG9uZSk7XG4gIH1cblxuICAvLyAjIyMgYGFkZFByZWZpeGVzYCBhZGRzIHRoZSBwcmVmaXhlcyB0byB0aGUgb3V0cHV0IHN0cmVhbVxuICBhZGRQcmVmaXhlcyhwcmVmaXhlcywgZG9uZSkge1xuICAgIHZhciBwcmVmaXhJUklzID0gdGhpcy5fcHJlZml4SVJJcywgaGFzUHJlZml4ZXMgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBwcmVmaXggaW4gcHJlZml4ZXMpIHtcbiAgICAgIHZhciBpcmkgPSBwcmVmaXhlc1twcmVmaXhdO1xuICAgICAgaWYgKHR5cGVvZiBpcmkgIT09ICdzdHJpbmcnKVxuICAgICAgICBpcmkgPSBpcmkudmFsdWU7XG4gICAgICBoYXNQcmVmaXhlcyA9IHRydWU7XG4gICAgICAvLyBGaW5pc2ggYSBwb3NzaWJsZSBwZW5kaW5nIHF1YWRcbiAgICAgIGlmICh0aGlzLl9zdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuX3dyaXRlKHRoaXMuX2luRGVmYXVsdEdyYXBoID8gJy5cXG4nIDogJ1xcbn1cXG4nKTtcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGwsIHRoaXMuX2dyYXBoID0gJyc7XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgd3JpdGUgdGhlIHByZWZpeFxuICAgICAgcHJlZml4SVJJc1tpcmldID0gKHByZWZpeCArPSAnOicpO1xuICAgICAgdGhpcy5fd3JpdGUoJ0BwcmVmaXggJyArIHByZWZpeCArICcgPCcgKyBpcmkgKyAnPi5cXG4nKTtcbiAgICB9XG4gICAgLy8gUmVjcmVhdGUgdGhlIHByZWZpeCBtYXRjaGVyXG4gICAgaWYgKGhhc1ByZWZpeGVzKSB7XG4gICAgICB2YXIgSVJJbGlzdCA9ICcnLCBwcmVmaXhMaXN0ID0gJyc7XG4gICAgICBmb3IgKHZhciBwcmVmaXhJUkkgaW4gcHJlZml4SVJJcykge1xuICAgICAgICBJUklsaXN0ICs9IElSSWxpc3QgPyAnfCcgKyBwcmVmaXhJUkkgOiBwcmVmaXhJUkk7XG4gICAgICAgIHByZWZpeExpc3QgKz0gKHByZWZpeExpc3QgPyAnfCcgOiAnJykgKyBwcmVmaXhJUklzW3ByZWZpeElSSV07XG4gICAgICB9XG4gICAgICBJUklsaXN0ID0gSVJJbGlzdC5yZXBsYWNlKC9bXFxdXFwvXFwoXFwpXFwqXFwrXFw/XFwuXFxcXFxcJF0vZywgJ1xcXFwkJicpO1xuICAgICAgdGhpcy5fcHJlZml4UmVnZXggPSBuZXcgUmVnRXhwKCdeKD86JyArIHByZWZpeExpc3QgKyAnKVteXFwvXSokfCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdeKCcgKyBJUklsaXN0ICsgJykoW2EtekEtWl1bXFxcXC1fYS16QS1aMC05XSopJCcpO1xuICAgIH1cbiAgICAvLyBFbmQgYSBwcmVmaXggYmxvY2sgd2l0aCBhIG5ld2xpbmVcbiAgICB0aGlzLl93cml0ZShoYXNQcmVmaXhlcyA/ICdcXG4nIDogJycsIGRvbmUpO1xuICB9XG5cbiAgLy8gIyMjIGBibGFua2AgY3JlYXRlcyBhIGJsYW5rIG5vZGUgd2l0aCB0aGUgZ2l2ZW4gY29udGVudFxuICBibGFuayhwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIHZhciBjaGlsZHJlbiA9IHByZWRpY2F0ZSwgY2hpbGQsIGxlbmd0aDtcbiAgICAvLyBFbXB0eSBibGFuayBub2RlXG4gICAgaWYgKHByZWRpY2F0ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgY2hpbGRyZW4gPSBbXTtcbiAgICAvLyBCbGFuayBub2RlIHBhc3NlZCBhcyBibGFuayhUZXJtKFwicHJlZGljYXRlXCIpLCBUZXJtKFwib2JqZWN0XCIpKVxuICAgIGVsc2UgaWYgKHByZWRpY2F0ZS50ZXJtVHlwZSlcbiAgICAgIGNoaWxkcmVuID0gW3sgcHJlZGljYXRlOiBwcmVkaWNhdGUsIG9iamVjdDogb2JqZWN0IH1dO1xuICAgIC8vIEJsYW5rIG5vZGUgcGFzc2VkIGFzIGJsYW5rKHsgcHJlZGljYXRlOiBwcmVkaWNhdGUsIG9iamVjdDogb2JqZWN0IH0pXG4gICAgZWxzZSBpZiAoISgnbGVuZ3RoJyBpbiBwcmVkaWNhdGUpKVxuICAgICAgY2hpbGRyZW4gPSBbcHJlZGljYXRlXTtcblxuICAgIHN3aXRjaCAobGVuZ3RoID0gY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgLy8gR2VuZXJhdGUgYW4gZW1wdHkgYmxhbmsgbm9kZVxuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oJ1tdJyk7XG4gICAgLy8gR2VuZXJhdGUgYSBub24tbmVzdGVkIG9uZS10cmlwbGUgYmxhbmsgbm9kZVxuICAgIGNhc2UgMTpcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5bMF07XG4gICAgICBpZiAoIShjaGlsZC5vYmplY3QgaW5zdGFuY2VvZiBTZXJpYWxpemVkVGVybSkpXG4gICAgICAgIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oJ1sgJyArIHRoaXMuX2VuY29kZVByZWRpY2F0ZShjaGlsZC5wcmVkaWNhdGUpICsgJyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmNvZGVPYmplY3QoY2hpbGQub2JqZWN0KSArICcgXScpO1xuICAgIC8vIEdlbmVyYXRlIGEgbXVsdGktdHJpcGxlIG9yIG5lc3RlZCBibGFuayBub2RlXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBjb250ZW50cyA9ICdbJztcbiAgICAgIC8vIFdyaXRlIGFsbCB0cmlwbGVzIGluIG9yZGVyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICAgIC8vIFdyaXRlIG9ubHkgdGhlIG9iamVjdCBpcyB0aGUgcHJlZGljYXRlIGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91c1xuICAgICAgICBpZiAoY2hpbGQucHJlZGljYXRlLmVxdWFscyhwcmVkaWNhdGUpKVxuICAgICAgICAgIGNvbnRlbnRzICs9ICcsICcgKyB0aGlzLl9lbmNvZGVPYmplY3QoY2hpbGQub2JqZWN0KTtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3cml0ZSB0aGUgcHJlZGljYXRlIGFuZCB0aGUgb2JqZWN0XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnRzICs9IChpID8gJztcXG4gICcgOiAnXFxuICAnKSArXG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW5jb2RlUHJlZGljYXRlKGNoaWxkLnByZWRpY2F0ZSkgKyAnICcgK1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuY29kZU9iamVjdChjaGlsZC5vYmplY3QpO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGNoaWxkLnByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBTZXJpYWxpemVkVGVybShjb250ZW50cyArICdcXG5dJyk7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBsaXN0YCBjcmVhdGVzIGEgbGlzdCBub2RlIHdpdGggdGhlIGdpdmVuIGNvbnRlbnRcbiAgbGlzdChlbGVtZW50cykge1xuICAgIHZhciBsZW5ndGggPSBlbGVtZW50cyAmJiBlbGVtZW50cy5sZW5ndGggfHwgMCwgY29udGVudHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgY29udGVudHNbaV0gPSB0aGlzLl9lbmNvZGVPYmplY3QoZWxlbWVudHNbaV0pO1xuICAgIHJldHVybiBuZXcgU2VyaWFsaXplZFRlcm0oJygnICsgY29udGVudHMuam9pbignICcpICsgJyknKTtcbiAgfVxuXG4gIC8vICMjIyBgZW5kYCBzaWduYWxzIHRoZSBlbmQgb2YgdGhlIG91dHB1dCBzdHJlYW1cbiAgZW5kKGRvbmUpIHtcbiAgICAvLyBGaW5pc2ggYSBwb3NzaWJsZSBwZW5kaW5nIHF1YWRcbiAgICBpZiAodGhpcy5fc3ViamVjdCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5fd3JpdGUodGhpcy5faW5EZWZhdWx0R3JhcGggPyAnLlxcbicgOiAnXFxufVxcbicpO1xuICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgfVxuICAgIC8vIERpc2FsbG93IGZ1cnRoZXIgd3JpdGluZ1xuICAgIHRoaXMuX3dyaXRlID0gdGhpcy5fYmxvY2tlZFdyaXRlO1xuXG4gICAgLy8gVHJ5IHRvIGVuZCB0aGUgdW5kZXJseWluZyBzdHJlYW0sIGVuc3VyaW5nIGRvbmUgaXMgY2FsbGVkIGV4YWN0bHkgb25lIHRpbWVcbiAgICB2YXIgc2luZ2xlRG9uZSA9IGRvbmUgJiYgZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHsgc2luZ2xlRG9uZSA9IG51bGwsIGRvbmUoZXJyb3IsIHJlc3VsdCk7IH07XG4gICAgaWYgKHRoaXMuX2VuZFN0cmVhbSkge1xuICAgICAgdHJ5IHsgcmV0dXJuIHRoaXMuX291dHB1dFN0cmVhbS5lbmQoc2luZ2xlRG9uZSk7IH1cbiAgICAgIGNhdGNoIChlcnJvcikgeyAvKiBlcnJvciBjbG9zaW5nIHN0cmVhbSAqLyB9XG4gICAgfVxuICAgIHNpbmdsZURvbmUgJiYgc2luZ2xlRG9uZSgpO1xuICB9XG59XG5cbi8vIFJlcGxhY2VzIGEgY2hhcmFjdGVyIGJ5IGl0cyBlc2NhcGVkIHZlcnNpb25cbmZ1bmN0aW9uIGNoYXJhY3RlclJlcGxhY2VyKGNoYXJhY3Rlcikge1xuICAvLyBSZXBsYWNlIGEgc2luZ2xlIGNoYXJhY3RlciBieSBpdHMgZXNjYXBlZCB2ZXJzaW9uXG4gIHZhciByZXN1bHQgPSBlc2NhcGVkQ2hhcmFjdGVyc1tjaGFyYWN0ZXJdO1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBSZXBsYWNlIGEgc2luZ2xlIGNoYXJhY3RlciB3aXRoIGl0cyA0LWJpdCB1bmljb2RlIGVzY2FwZSBzZXF1ZW5jZVxuICAgIGlmIChjaGFyYWN0ZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXN1bHQgPSBjaGFyYWN0ZXIuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNik7XG4gICAgICByZXN1bHQgPSAnXFxcXHUwMDAwJy5zdWJzdHIoMCwgNiAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXBsYWNlIGEgc3Vycm9nYXRlIHBhaXIgd2l0aCBpdHMgOC1iaXQgdW5pY29kZSBlc2NhcGUgc2VxdWVuY2VcbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdCA9ICgoY2hhcmFjdGVyLmNoYXJDb2RlQXQoMCkgLSAweEQ4MDApICogMHg0MDAgK1xuICAgICAgICAgICAgICAgICBjaGFyYWN0ZXIuY2hhckNvZGVBdCgxKSArIDB4MjQwMCkudG9TdHJpbmcoMTYpO1xuICAgICAgcmVzdWx0ID0gJ1xcXFxVMDAwMDAwMDAnLnN1YnN0cigwLCAxMCAtIHJlc3VsdC5sZW5ndGgpICsgcmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLy8gKipOM1BhcnNlcioqIHBhcnNlcyBOMyBkb2N1bWVudHMuXG5pbXBvcnQgTjNMZXhlciBmcm9tICcuL04zTGV4ZXInO1xuaW1wb3J0IE4zRGF0YUZhY3RvcnkgZnJvbSAnLi9OM0RhdGFGYWN0b3J5JztcbmltcG9ydCBuYW1lc3BhY2VzIGZyb20gJy4vSVJJcyc7XG5cbmxldCBibGFua05vZGVQcmVmaXggPSAwO1xuXG4vLyAjIyBDb25zdHJ1Y3RvclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTjNQYXJzZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5fY29udGV4dFN0YWNrID0gW107XG4gICAgdGhpcy5fZ3JhcGggPSBudWxsO1xuXG4gICAgLy8gU2V0IHRoZSBkb2N1bWVudCBJUklcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zZXRCYXNlKG9wdGlvbnMuYmFzZUlSSSk7XG4gICAgb3B0aW9ucy5mYWN0b3J5ICYmIGluaXREYXRhRmFjdG9yeSh0aGlzLCBvcHRpb25zLmZhY3RvcnkpO1xuXG4gICAgLy8gU2V0IHN1cHBvcnRlZCBmZWF0dXJlcyBkZXBlbmRpbmcgb24gdGhlIGZvcm1hdFxuICAgIHZhciBmb3JtYXQgPSAodHlwZW9mIG9wdGlvbnMuZm9ybWF0ID09PSAnc3RyaW5nJykgP1xuICAgICAgICAgICAgICAgICBvcHRpb25zLmZvcm1hdC5tYXRjaCgvXFx3KiQvKVswXS50b0xvd2VyQ2FzZSgpIDogJycsXG4gICAgICAgIGlzVHVydGxlID0gZm9ybWF0ID09PSAndHVydGxlJywgaXNUcmlHID0gZm9ybWF0ID09PSAndHJpZycsXG4gICAgICAgIGlzTlRyaXBsZXMgPSAvdHJpcGxlLy50ZXN0KGZvcm1hdCksIGlzTlF1YWRzID0gL3F1YWQvLnRlc3QoZm9ybWF0KSxcbiAgICAgICAgaXNOMyA9IHRoaXMuX24zTW9kZSA9IC9uMy8udGVzdChmb3JtYXQpLFxuICAgICAgICBpc0xpbmVNb2RlID0gaXNOVHJpcGxlcyB8fCBpc05RdWFkcztcbiAgICBpZiAoISh0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzID0gIShpc1R1cnRsZSB8fCBpc04zKSkpXG4gICAgICB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoID0gdGhpcy5fcmVhZFByZWRpY2F0ZTtcbiAgICB0aGlzLl9zdXBwb3J0c1F1YWRzID0gIShpc1R1cnRsZSB8fCBpc1RyaUcgfHwgaXNOVHJpcGxlcyB8fCBpc04zKTtcbiAgICAvLyBEaXNhYmxlIHJlbGF0aXZlIElSSXMgaW4gTi1UcmlwbGVzIG9yIE4tUXVhZHMgbW9kZVxuICAgIGlmIChpc0xpbmVNb2RlKVxuICAgICAgdGhpcy5fcmVzb2x2ZVJlbGF0aXZlSVJJID0gZnVuY3Rpb24gKGlyaSkgeyByZXR1cm4gbnVsbDsgfTtcbiAgICB0aGlzLl9ibGFua05vZGVQcmVmaXggPSB0eXBlb2Ygb3B0aW9ucy5ibGFua05vZGVQcmVmaXggIT09ICdzdHJpbmcnID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5ibGFua05vZGVQcmVmaXgucmVwbGFjZSgvXig/IV86KS8sICdfOicpO1xuICAgIHRoaXMuX2xleGVyID0gb3B0aW9ucy5sZXhlciB8fCBuZXcgTjNMZXhlcih7IGxpbmVNb2RlOiBpc0xpbmVNb2RlLCBuMzogaXNOMyB9KTtcbiAgICAvLyBEaXNhYmxlIGV4cGxpY2l0IHF1YW50aWZpZXJzIGJ5IGRlZmF1bHRcbiAgICB0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzID0gISFvcHRpb25zLmV4cGxpY2l0UXVhbnRpZmllcnM7XG4gIH1cblxuICAvLyAjIyBTdGF0aWMgY2xhc3MgbWV0aG9kc1xuXG4gIC8vICMjIyBgX3Jlc2V0QmxhbmtOb2RlUHJlZml4YCByZXN0YXJ0cyBibGFuayBub2RlIHByZWZpeCBpZGVudGlmaWNhdGlvblxuICBzdGF0aWMgX3Jlc2V0QmxhbmtOb2RlUHJlZml4KCkge1xuICAgIGJsYW5rTm9kZVByZWZpeCA9IDA7XG4gIH1cblxuICAvLyAjIyBQcml2YXRlIG1ldGhvZHNcblxuICAvLyAjIyMgYF9zZXRCYXNlYCBzZXRzIHRoZSBiYXNlIElSSSB0byByZXNvbHZlIHJlbGF0aXZlIElSSXNcbiAgX3NldEJhc2UoYmFzZUlSSSkge1xuICAgIGlmICghYmFzZUlSSSkge1xuICAgICAgdGhpcy5fYmFzZSA9ICcnO1xuICAgICAgdGhpcy5fYmFzZVBhdGggPSAnJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgZnJhZ21lbnQgaWYgcHJlc2VudFxuICAgICAgdmFyIGZyYWdtZW50UG9zID0gYmFzZUlSSS5pbmRleE9mKCcjJyk7XG4gICAgICBpZiAoZnJhZ21lbnRQb3MgPj0gMClcbiAgICAgICAgYmFzZUlSSSA9IGJhc2VJUkkuc3Vic3RyKDAsIGZyYWdtZW50UG9zKTtcbiAgICAgIC8vIFNldCBiYXNlIElSSSBhbmQgaXRzIGNvbXBvbmVudHNcbiAgICAgIHRoaXMuX2Jhc2UgPSBiYXNlSVJJO1xuICAgICAgdGhpcy5fYmFzZVBhdGggICA9IGJhc2VJUkkuaW5kZXhPZignLycpIDwgMCA/IGJhc2VJUkkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2VJUkkucmVwbGFjZSgvW15cXC8/XSooPzpcXD8uKik/JC8sICcnKTtcbiAgICAgIGJhc2VJUkkgPSBiYXNlSVJJLm1hdGNoKC9eKD86KFthLXpdW2EtejAtOSsuLV0qOikpPyg/OlxcL1xcL1teXFwvXSopPy9pKTtcbiAgICAgIHRoaXMuX2Jhc2VSb290ICAgPSBiYXNlSVJJWzBdO1xuICAgICAgdGhpcy5fYmFzZVNjaGVtZSA9IGJhc2VJUklbMV07XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfc2F2ZUNvbnRleHRgIHN0b3JlcyB0aGUgY3VycmVudCBwYXJzaW5nIGNvbnRleHRcbiAgLy8gd2hlbiBlbnRlcmluZyBhIG5ldyBzY29wZSAobGlzdCwgYmxhbmsgbm9kZSwgZm9ybXVsYSlcbiAgX3NhdmVDb250ZXh0KHR5cGUsIGdyYXBoLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIHZhciBuM01vZGUgPSB0aGlzLl9uM01vZGU7XG4gICAgdGhpcy5fY29udGV4dFN0YWNrLnB1c2goe1xuICAgICAgc3ViamVjdDogc3ViamVjdCwgcHJlZGljYXRlOiBwcmVkaWNhdGUsIG9iamVjdDogb2JqZWN0LFxuICAgICAgZ3JhcGg6IGdyYXBoLCB0eXBlOiB0eXBlLFxuICAgICAgaW52ZXJzZTogbjNNb2RlID8gdGhpcy5faW52ZXJzZVByZWRpY2F0ZSA6IGZhbHNlLFxuICAgICAgYmxhbmtQcmVmaXg6IG4zTW9kZSA/IHRoaXMuX3ByZWZpeGVzLl8gOiAnJyxcbiAgICAgIHF1YW50aWZpZWQ6IG4zTW9kZSA/IHRoaXMuX3F1YW50aWZpZWQgOiBudWxsLFxuICAgIH0pO1xuICAgIC8vIFRoZSBzZXR0aW5ncyBiZWxvdyBvbmx5IGFwcGx5IHRvIE4zIHN0cmVhbXNcbiAgICBpZiAobjNNb2RlKSB7XG4gICAgICAvLyBFdmVyeSBuZXcgc2NvcGUgcmVzZXRzIHRoZSBwcmVkaWNhdGUgZGlyZWN0aW9uXG4gICAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gZmFsc2U7XG4gICAgICAvLyBJbiBOMywgYmxhbmsgbm9kZXMgYXJlIHNjb3BlZCB0byBhIGZvcm11bGFcbiAgICAgIC8vICh1c2luZyBhIGRvdCBhcyBzZXBhcmF0b3IsIGFzIGEgYmxhbmsgbm9kZSBsYWJlbCBjYW5ub3Qgc3RhcnQgd2l0aCBpdClcbiAgICAgIHRoaXMuX3ByZWZpeGVzLl8gPSAodGhpcy5fZ3JhcGggPyB0aGlzLl9ncmFwaC5pZC5zdWJzdHIoMikgKyAnLicgOiAnLicpO1xuICAgICAgLy8gUXVhbnRpZmllcnMgYXJlIHNjb3BlZCB0byBhIGZvcm11bGFcbiAgICAgIHRoaXMuX3F1YW50aWZpZWQgPSBPYmplY3QuY3JlYXRlKHRoaXMuX3F1YW50aWZpZWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgX3Jlc3RvcmVDb250ZXh0YCByZXN0b3JlcyB0aGUgcGFyZW50IGNvbnRleHRcbiAgLy8gd2hlbiBsZWF2aW5nIGEgc2NvcGUgKGxpc3QsIGJsYW5rIG5vZGUsIGZvcm11bGEpXG4gIF9yZXN0b3JlQ29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHRoaXMuX2NvbnRleHRTdGFjay5wb3AoKSwgbjNNb2RlID0gdGhpcy5fbjNNb2RlO1xuICAgIHRoaXMuX3N1YmplY3QgICA9IGNvbnRleHQuc3ViamVjdDtcbiAgICB0aGlzLl9wcmVkaWNhdGUgPSBjb250ZXh0LnByZWRpY2F0ZTtcbiAgICB0aGlzLl9vYmplY3QgICAgPSBjb250ZXh0Lm9iamVjdDtcbiAgICB0aGlzLl9ncmFwaCAgICAgPSBjb250ZXh0LmdyYXBoO1xuICAgIC8vIFRoZSBzZXR0aW5ncyBiZWxvdyBvbmx5IGFwcGx5IHRvIE4zIHN0cmVhbXNcbiAgICBpZiAobjNNb2RlKSB7XG4gICAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gY29udGV4dC5pbnZlcnNlO1xuICAgICAgdGhpcy5fcHJlZml4ZXMuXyA9IGNvbnRleHQuYmxhbmtQcmVmaXg7XG4gICAgICB0aGlzLl9xdWFudGlmaWVkID0gY29udGV4dC5xdWFudGlmaWVkO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRJblRvcENvbnRleHRgIHJlYWRzIGEgdG9rZW4gd2hlbiBpbiB0aGUgdG9wIGNvbnRleHRcbiAgX3JlYWRJblRvcENvbnRleHQodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvLyBJZiBhbiBFT0YgdG9rZW4gYXJyaXZlcyBpbiB0aGUgdG9wIGNvbnRleHQsIHNpZ25hbCB0aGF0IHdlJ3JlIGRvbmVcbiAgICBjYXNlICdlb2YnOlxuICAgICAgaWYgKHRoaXMuX2dyYXBoICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuY2xvc2VkIGdyYXBoJywgdG9rZW4pO1xuICAgICAgZGVsZXRlIHRoaXMuX3ByZWZpeGVzLl87XG4gICAgICByZXR1cm4gdGhpcy5fY2FsbGJhY2sobnVsbCwgbnVsbCwgdGhpcy5fcHJlZml4ZXMpO1xuICAgIC8vIEl0IGNvdWxkIGJlIGEgcHJlZml4IGRlY2xhcmF0aW9uXG4gICAgY2FzZSAnUFJFRklYJzpcbiAgICAgIHRoaXMuX3NwYXJxbFN0eWxlID0gdHJ1ZTtcbiAgICBjYXNlICdAcHJlZml4JzpcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkUHJlZml4O1xuICAgIC8vIEl0IGNvdWxkIGJlIGEgYmFzZSBkZWNsYXJhdGlvblxuICAgIGNhc2UgJ0JBU0UnOlxuICAgICAgdGhpcy5fc3BhcnFsU3R5bGUgPSB0cnVlO1xuICAgIGNhc2UgJ0BiYXNlJzpcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkQmFzZUlSSTtcbiAgICAvLyBJdCBjb3VsZCBiZSBhIGdyYXBoXG4gICAgY2FzZSAneyc6XG4gICAgICBpZiAodGhpcy5fc3VwcG9ydHNOYW1lZEdyYXBocykge1xuICAgICAgICB0aGlzLl9ncmFwaCA9ICcnO1xuICAgICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRTdWJqZWN0O1xuICAgICAgfVxuICAgIGNhc2UgJ0dSQVBIJzpcbiAgICAgIGlmICh0aGlzLl9zdXBwb3J0c05hbWVkR3JhcGhzKVxuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZE5hbWVkR3JhcGhMYWJlbDtcbiAgICAvLyBPdGhlcndpc2UsIHRoZSBuZXh0IHRva2VuIG11c3QgYmUgYSBzdWJqZWN0XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkU3ViamVjdCh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfcmVhZEVudGl0eWAgcmVhZHMgYW4gSVJJLCBwcmVmaXhlZCBuYW1lLCBibGFuayBub2RlLCBvciB2YXJpYWJsZVxuICBfcmVhZEVudGl0eSh0b2tlbiwgcXVhbnRpZmllcikge1xuICAgIHZhciB2YWx1ZTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvLyBSZWFkIGEgcmVsYXRpdmUgb3IgYWJzb2x1dGUgSVJJXG4gICAgY2FzZSAnSVJJJzpcbiAgICBjYXNlICd0eXBlSVJJJzpcbiAgICAgIHZhciBpcmkgPSB0aGlzLl9yZXNvbHZlSVJJKHRva2VuLnZhbHVlKTtcbiAgICAgIGlmIChpcmkgPT09IG51bGwpXG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcignSW52YWxpZCBJUkknLCB0b2tlbik7XG4gICAgICB2YWx1ZSA9IHRoaXMuX25hbWVkTm9kZShpcmkpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gUmVhZCBhIHByZWZpeGVkIG5hbWVcbiAgICBjYXNlICd0eXBlJzpcbiAgICBjYXNlICdwcmVmaXhlZCc6XG4gICAgICB2YXIgcHJlZml4ID0gdGhpcy5fcHJlZml4ZXNbdG9rZW4ucHJlZml4XTtcbiAgICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmRlZmluZWQgcHJlZml4IFwiJyArIHRva2VuLnByZWZpeCArICc6XCInLCB0b2tlbik7XG4gICAgICB2YWx1ZSA9IHRoaXMuX25hbWVkTm9kZShwcmVmaXggKyB0b2tlbi52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICAvLyBSZWFkIGEgYmxhbmsgbm9kZVxuICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgIHZhbHVlID0gdGhpcy5fYmxhbmtOb2RlKHRoaXMuX3ByZWZpeGVzW3Rva2VuLnByZWZpeF0gKyB0b2tlbi52YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICAvLyBSZWFkIGEgdmFyaWFibGVcbiAgICBjYXNlICd2YXInOlxuICAgICAgdmFsdWUgPSB0aGlzLl92YXJpYWJsZSh0b2tlbi52YWx1ZS5zdWJzdHIoMSkpO1xuICAgICAgYnJlYWs7XG4gICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIG5vdCBhbiBlbnRpdHlcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBlbnRpdHkgYnV0IGdvdCAnICsgdG9rZW4udHlwZSwgdG9rZW4pO1xuICAgIH1cbiAgICAvLyBJbiBOMyBtb2RlLCByZXBsYWNlIHRoZSBlbnRpdHkgaWYgaXQgaXMgcXVhbnRpZmllZFxuICAgIGlmICghcXVhbnRpZmllciAmJiB0aGlzLl9uM01vZGUgJiYgKHZhbHVlLmlkIGluIHRoaXMuX3F1YW50aWZpZWQpKVxuICAgICAgdmFsdWUgPSB0aGlzLl9xdWFudGlmaWVkW3ZhbHVlLmlkXTtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkU3ViamVjdGAgcmVhZHMgYSBxdWFkJ3Mgc3ViamVjdFxuICBfcmVhZFN1YmplY3QodG9rZW4pIHtcbiAgICB0aGlzLl9wcmVkaWNhdGUgPSBudWxsO1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ1snOlxuICAgICAgLy8gU3RhcnQgYSBuZXcgcXVhZCB3aXRoIGEgbmV3IGJsYW5rIG5vZGUgYXMgc3ViamVjdFxuICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2JsYW5rJywgdGhpcy5fZ3JhcGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCksIG51bGwsIG51bGwpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVIZWFkO1xuICAgIGNhc2UgJygnOlxuICAgICAgLy8gU3RhcnQgYSBuZXcgbGlzdFxuICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2xpc3QnLCB0aGlzLl9ncmFwaCwgdGhpcy5SREZfTklMLCBudWxsLCBudWxsKTtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRMaXN0SXRlbTtcbiAgICBjYXNlICd7JzpcbiAgICAgIC8vIFN0YXJ0IGEgbmV3IGZvcm11bGFcbiAgICAgIGlmICghdGhpcy5fbjNNb2RlKVxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ1VuZXhwZWN0ZWQgZ3JhcGgnLCB0b2tlbik7XG4gICAgICB0aGlzLl9zYXZlQ29udGV4dCgnZm9ybXVsYScsIHRoaXMuX2dyYXBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9ibGFua05vZGUoKSwgbnVsbCwgbnVsbCk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG4gICAgY2FzZSAnfSc6XG4gICAgICAgLy8gTm8gc3ViamVjdDsgdGhlIGdyYXBoIGluIHdoaWNoIHdlIGFyZSByZWFkaW5nIGlzIGNsb3NlZCBpbnN0ZWFkXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uKHRva2VuKTtcbiAgICBjYXNlICdAZm9yU29tZSc6XG4gICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIFwiQGZvclNvbWVcIicsIHRva2VuKTtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgdGhpcy5fcHJlZGljYXRlID0gdGhpcy5OM19GT1JTT01FO1xuICAgICAgdGhpcy5fcXVhbnRpZmllciA9IHRoaXMuX2JsYW5rTm9kZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkUXVhbnRpZmllckxpc3Q7XG4gICAgY2FzZSAnQGZvckFsbCc6XG4gICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIFwiQGZvckFsbFwiJywgdG9rZW4pO1xuICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl9wcmVkaWNhdGUgPSB0aGlzLk4zX0ZPUkFMTDtcbiAgICAgIHRoaXMuX3F1YW50aWZpZXIgPSB0aGlzLl92YXJpYWJsZTtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkUXVhbnRpZmllckxpc3Q7XG4gICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGxpdGVyYWwnLCB0b2tlbik7XG5cbiAgICAgIGlmICh0b2tlbi5wcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGxldGVTdWJqZWN0TGl0ZXJhbDtcbiAgICAgIH1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2xpdGVyYWwodG9rZW4udmFsdWUsIHRoaXMuX25hbWVkTm9kZSh0b2tlbi5wcmVmaXgpKTtcblxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFJlYWQgdGhlIHN1YmplY3QgZW50aXR5XG4gICAgICBpZiAoKHRoaXMuX3N1YmplY3QgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKSkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgLy8gSW4gTjMgbW9kZSwgdGhlIHN1YmplY3QgbWlnaHQgYmUgYSBwYXRoXG4gICAgICBpZiAodGhpcy5fbjNNb2RlKVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aFJlYWRlcih0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoKTtcbiAgICB9XG5cbiAgICAvLyBUaGUgbmV4dCB0b2tlbiBtdXN0IGJlIGEgcHJlZGljYXRlLFxuICAgIC8vIG9yLCBpZiB0aGUgc3ViamVjdCB3YXMgYWN0dWFsbHkgYSBncmFwaCBJUkksIGEgbmFtZWQgZ3JhcGhcbiAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaDtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRQcmVkaWNhdGVgIHJlYWRzIGEgcXVhZCdzIHByZWRpY2F0ZVxuICBfcmVhZFByZWRpY2F0ZSh0b2tlbikge1xuICAgIHZhciB0eXBlID0gdG9rZW4udHlwZTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdpbnZlcnNlJzpcbiAgICAgIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSB0cnVlO1xuICAgIGNhc2UgJ2FiYnJldmlhdGlvbic6XG4gICAgICB0aGlzLl9wcmVkaWNhdGUgPSB0aGlzLkFCQlJFVklBVElPTlNbdG9rZW4udmFsdWVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnLic6XG4gICAgY2FzZSAnXSc6XG4gICAgY2FzZSAnfSc6XG4gICAgICAvLyBFeHBlY3RlZCBwcmVkaWNhdGUgZGlkbid0IGNvbWUsIG11c3QgaGF2ZSBiZWVuIHRyYWlsaW5nIHNlbWljb2xvblxuICAgICAgaWYgKHRoaXMuX3ByZWRpY2F0ZSA9PT0gbnVsbClcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkICcgKyB0eXBlLCB0b2tlbik7XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0eXBlID09PSAnXScgPyB0aGlzLl9yZWFkQmxhbmtOb2RlVGFpbCh0b2tlbikgOiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pO1xuICAgIGNhc2UgJzsnOlxuICAgICAgLy8gQWRkaXRpb25hbCBzZW1pY29sb25zIGNhbiBiZSBzYWZlbHkgaWdub3JlZFxuICAgICAgcmV0dXJuIHRoaXMuX3ByZWRpY2F0ZSAhPT0gbnVsbCA/IHRoaXMuX3JlYWRQcmVkaWNhdGUgOlxuICAgICAgICAgICAgIHRoaXMuX2Vycm9yKCdFeHBlY3RlZCBwcmVkaWNhdGUgYnV0IGdvdCA7JywgdG9rZW4pO1xuICAgIGNhc2UgJ2JsYW5rJzpcbiAgICAgIGlmICghdGhpcy5fbjNNb2RlKVxuICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0Rpc2FsbG93ZWQgYmxhbmsgbm9kZSBhcyBwcmVkaWNhdGUnLCB0b2tlbik7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgodGhpcy5fcHJlZGljYXRlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVGhlIG5leHQgdG9rZW4gbXVzdCBiZSBhbiBvYmplY3RcbiAgICByZXR1cm4gdGhpcy5fcmVhZE9iamVjdDtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRPYmplY3RgIHJlYWRzIGEgcXVhZCdzIG9iamVjdFxuICBfcmVhZE9iamVjdCh0b2tlbikge1xuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgLy8gUmVndWxhciBsaXRlcmFsLCBjYW4gc3RpbGwgZ2V0IGEgZGF0YXR5cGUgb3IgbGFuZ3VhZ2VcbiAgICAgIGlmICh0b2tlbi5wcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZERhdGFUeXBlT3JMYW5nO1xuICAgICAgfVxuICAgICAgLy8gUHJlLWRhdGF0eXBlZCBzdHJpbmcgbGl0ZXJhbCAocHJlZml4IHN0b3JlcyB0aGUgZGF0YXR5cGUpXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX29iamVjdCA9IHRoaXMuX2xpdGVyYWwodG9rZW4udmFsdWUsIHRoaXMuX25hbWVkTm9kZSh0b2tlbi5wcmVmaXgpKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1snOlxuICAgICAgLy8gU3RhcnQgYSBuZXcgcXVhZCB3aXRoIGEgbmV3IGJsYW5rIG5vZGUgYXMgc3ViamVjdFxuICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2JsYW5rJywgdGhpcy5fZ3JhcGgsIHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZUhlYWQ7XG4gICAgY2FzZSAnKCc6XG4gICAgICAvLyBTdGFydCBhIG5ldyBsaXN0XG4gICAgICB0aGlzLl9zYXZlQ29udGV4dCgnbGlzdCcsIHRoaXMuX2dyYXBoLCB0aGlzLl9zdWJqZWN0LCB0aGlzLl9wcmVkaWNhdGUsIHRoaXMuUkRGX05JTCk7XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkTGlzdEl0ZW07XG4gICAgY2FzZSAneyc6XG4gICAgICAvLyBTdGFydCBhIG5ldyBmb3JtdWxhXG4gICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGdyYXBoJywgdG9rZW4pO1xuICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2Zvcm11bGEnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9ibGFua05vZGUoKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFJlYWQgdGhlIG9iamVjdCBlbnRpdHlcbiAgICAgIGlmICgodGhpcy5fb2JqZWN0ID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybjtcbiAgICAgIC8vIEluIE4zIG1vZGUsIHRoZSBvYmplY3QgbWlnaHQgYmUgYSBwYXRoXG4gICAgICBpZiAodGhpcy5fbjNNb2RlKVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aFJlYWRlcih0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICB9XG5cbiAgLy8gIyMjIGBfcmVhZFByZWRpY2F0ZU9yTmFtZWRHcmFwaGAgcmVhZHMgYSBxdWFkJ3MgcHJlZGljYXRlLCBvciBhIG5hbWVkIGdyYXBoXG4gIF9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoKHRva2VuKSB7XG4gICAgcmV0dXJuIHRva2VuLnR5cGUgPT09ICd7JyA/IHRoaXMuX3JlYWRHcmFwaCh0b2tlbikgOiB0aGlzLl9yZWFkUHJlZGljYXRlKHRva2VuKTtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRHcmFwaGAgcmVhZHMgYSBncmFwaFxuICBfcmVhZEdyYXBoKHRva2VuKSB7XG4gICAgaWYgKHRva2VuLnR5cGUgIT09ICd7JylcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgZ3JhcGggYnV0IGdvdCAnICsgdG9rZW4udHlwZSwgdG9rZW4pO1xuICAgIC8vIFRoZSBcInN1YmplY3RcIiB3ZSByZWFkIGlzIGFjdHVhbGx5IHRoZSBHUkFQSCdzIGxhYmVsXG4gICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9zdWJqZWN0LCB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkQmxhbmtOb2RlSGVhZGAgcmVhZHMgdGhlIGhlYWQgb2YgYSBibGFuayBub2RlXG4gIF9yZWFkQmxhbmtOb2RlSGVhZCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnXScpIHtcbiAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVUYWlsKHRva2VuKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9wcmVkaWNhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGUodG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRCbGFua05vZGVUYWlsYCByZWFkcyB0aGUgZW5kIG9mIGEgYmxhbmsgbm9kZVxuICBfcmVhZEJsYW5rTm9kZVRhaWwodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ10nKVxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRCbGFua05vZGVQdW5jdHVhdGlvbih0b2tlbik7XG5cbiAgICAvLyBTdG9yZSBibGFuayBub2RlIHF1YWRcbiAgICBpZiAodGhpcy5fc3ViamVjdCAhPT0gbnVsbClcbiAgICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTtcblxuICAgIC8vIFJlc3RvcmUgdGhlIHBhcmVudCBjb250ZXh0IGNvbnRhaW5pbmcgdGhpcyBibGFuayBub2RlXG4gICAgdmFyIGVtcHR5ID0gdGhpcy5fcHJlZGljYXRlID09PSBudWxsO1xuICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7XG4gICAgLy8gSWYgdGhlIGJsYW5rIG5vZGUgd2FzIHRoZSBzdWJqZWN0LCBjb250aW51ZSByZWFkaW5nIHRoZSBwcmVkaWNhdGVcbiAgICBpZiAodGhpcy5fb2JqZWN0ID09PSBudWxsKVxuICAgICAgLy8gSWYgdGhlIGJsYW5rIG5vZGUgd2FzIGVtcHR5LCBpdCBjb3VsZCBiZSBhIG5hbWVkIGdyYXBoIGxhYmVsXG4gICAgICByZXR1cm4gZW1wdHkgPyB0aGlzLl9yZWFkUHJlZGljYXRlT3JOYW1lZEdyYXBoIDogdGhpcy5fcmVhZFByZWRpY2F0ZUFmdGVyQmxhbms7XG4gICAgLy8gSWYgdGhlIGJsYW5rIG5vZGUgd2FzIHRoZSBvYmplY3QsIHJlc3RvcmUgcHJldmlvdXMgY29udGV4dCBhbmQgcmVhZCBwdW5jdHVhdGlvblxuICAgIGVsc2VcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkUHJlZGljYXRlQWZ0ZXJCbGFua2AgcmVhZHMgYSBwcmVkaWNhdGUgYWZ0ZXIgYW4gYW5vbnltb3VzIGJsYW5rIG5vZGVcbiAgX3JlYWRQcmVkaWNhdGVBZnRlckJsYW5rKHRva2VuKSB7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnLic6XG4gICAgY2FzZSAnfSc6XG4gICAgICAvLyBObyBwcmVkaWNhdGUgaXMgY29taW5nIGlmIHRoZSB0cmlwbGUgaXMgdGVybWluYXRlZCBoZXJlXG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkUHVuY3R1YXRpb24odG9rZW4pO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFByZWRpY2F0ZSh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfcmVhZExpc3RJdGVtYCByZWFkcyBpdGVtcyBmcm9tIGEgbGlzdFxuICBfcmVhZExpc3RJdGVtKHRva2VuKSB7XG4gICAgdmFyIGl0ZW0gPSBudWxsLCAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaXRlbSBvZiB0aGUgbGlzdFxuICAgICAgICBsaXN0ID0gbnVsbCwgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGxpc3QgaXRzZWxmXG4gICAgICAgIHByZXZpb3VzTGlzdCA9IHRoaXMuX3N1YmplY3QsICAgICAvLyBUaGUgcHJldmlvdXMgbGlzdCB0aGF0IGNvbnRhaW5zIHRoaXMgbGlzdFxuICAgICAgICBzdGFjayA9IHRoaXMuX2NvbnRleHRTdGFjaywgICAgICAgLy8gVGhlIHN0YWNrIG9mIHBhcmVudCBjb250ZXh0c1xuICAgICAgICBwYXJlbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXSwgLy8gVGhlIHBhcmVudCBjb250YWluaW5nIHRoZSBjdXJyZW50IGxpc3RcbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRMaXN0SXRlbTsgICAgICAgIC8vIFRoZSBuZXh0IGZ1bmN0aW9uIHRvIGV4ZWN1dGVcblxuICAgIHN3aXRjaCAodG9rZW4udHlwZSkge1xuICAgIGNhc2UgJ1snOlxuICAgICAgLy8gU3RhY2sgdGhlIGN1cnJlbnQgbGlzdCBxdWFkIGFuZCBzdGFydCBhIG5ldyBxdWFkIHdpdGggYSBibGFuayBub2RlIGFzIHN1YmplY3RcbiAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdibGFuaycsIHRoaXMuX2dyYXBoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGlzdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlJERl9GSVJTVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3N1YmplY3QgPSBpdGVtID0gdGhpcy5fYmxhbmtOb2RlKCkpO1xuICAgICAgbmV4dCA9IHRoaXMuX3JlYWRCbGFua05vZGVIZWFkO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnKCc6XG4gICAgICAvLyBTdGFjayB0aGUgY3VycmVudCBsaXN0IHF1YWQgYW5kIHN0YXJ0IGEgbmV3IGxpc3RcbiAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdsaXN0JywgdGhpcy5fZ3JhcGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaXN0ID0gdGhpcy5fYmxhbmtOb2RlKCksIHRoaXMuUkRGX0ZJUlNULCB0aGlzLlJERl9OSUwpO1xuICAgICAgdGhpcy5fc3ViamVjdCA9IG51bGw7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcpJzpcbiAgICAgIC8vIENsb3NpbmcgdGhlIGxpc3Q7IHJlc3RvcmUgdGhlIHBhcmVudCBjb250ZXh0XG4gICAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgLy8gSWYgdGhpcyBsaXN0IGlzIGNvbnRhaW5lZCB3aXRoaW4gYSBwYXJlbnQgbGlzdCwgcmV0dXJuIHRoZSBtZW1iZXJzaGlwIHF1YWQgaGVyZS5cbiAgICAgIC8vIFRoaXMgd2lsbCBiZSBgPHBhcmVudCBsaXN0IGVsZW1lbnQ+IHJkZjpmaXJzdCA8dGhpcyBsaXN0Pi5gLlxuICAgICAgaWYgKHN0YWNrLmxlbmd0aCAhPT0gMCAmJiBzdGFja1tzdGFjay5sZW5ndGggLSAxXS50eXBlID09PSAnbGlzdCcpXG4gICAgICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTtcbiAgICAgIC8vIFdhcyB0aGlzIGxpc3QgdGhlIHBhcmVudCdzIHN1YmplY3Q/XG4gICAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBuZXh0IHRva2VuIGlzIHRoZSBwcmVkaWNhdGVcbiAgICAgICAgbmV4dCA9IHRoaXMuX3JlYWRQcmVkaWNhdGU7XG4gICAgICAgIC8vIE5vIGxpc3QgdGFpbCBpZiB0aGlzIHdhcyBhbiBlbXB0eSBsaXN0XG4gICAgICAgIGlmICh0aGlzLl9zdWJqZWN0ID09PSB0aGlzLlJERl9OSUwpXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG4gICAgICAvLyBUaGUgbGlzdCB3YXMgaW4gdGhlIHBhcmVudCBjb250ZXh0J3Mgb2JqZWN0XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV4dCA9IHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTtcbiAgICAgICAgLy8gTm8gbGlzdCB0YWlsIGlmIHRoaXMgd2FzIGFuIGVtcHR5IGxpc3RcbiAgICAgICAgaWYgKHRoaXMuX29iamVjdCA9PT0gdGhpcy5SREZfTklMKVxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuICAgICAgLy8gQ2xvc2UgdGhlIGxpc3QgYnkgbWFraW5nIHRoZSBoZWFkIG5pbFxuICAgICAgbGlzdCA9IHRoaXMuUkRGX05JTDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2xpdGVyYWwnOlxuICAgICAgLy8gUmVndWxhciBsaXRlcmFsLCBjYW4gc3RpbGwgZ2V0IGEgZGF0YXR5cGUgb3IgbGFuZ3VhZ2VcbiAgICAgIGlmICh0b2tlbi5wcmVmaXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX2xpdGVyYWxWYWx1ZSA9IHRva2VuLnZhbHVlO1xuICAgICAgICBuZXh0ID0gdGhpcy5fcmVhZExpc3RJdGVtRGF0YVR5cGVPckxhbmc7XG4gICAgICB9XG4gICAgICAvLyBQcmUtZGF0YXR5cGVkIHN0cmluZyBsaXRlcmFsIChwcmVmaXggc3RvcmVzIHRoZSBkYXRhdHlwZSlcbiAgICAgIGVsc2Uge1xuICAgICAgICBpdGVtID0gdGhpcy5fbGl0ZXJhbCh0b2tlbi52YWx1ZSwgdGhpcy5fbmFtZWROb2RlKHRva2VuLnByZWZpeCkpO1xuICAgICAgICBuZXh0ID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAneyc6XG4gICAgICAvLyBTdGFydCBhIG5ldyBmb3JtdWxhXG4gICAgICBpZiAoIXRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkIGdyYXBoJywgdG9rZW4pO1xuICAgICAgdGhpcy5fc2F2ZUNvbnRleHQoJ2Zvcm11bGEnLCB0aGlzLl9ncmFwaCwgdGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JhcGggPSB0aGlzLl9ibGFua05vZGUoKSk7XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgoaXRlbSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgIC8vIENyZWF0ZSBhIG5ldyBibGFuayBub2RlIGlmIG5vIGl0ZW0gaGVhZCB3YXMgYXNzaWduZWQgeWV0XG4gICAgaWYgKGxpc3QgPT09IG51bGwpXG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbGlzdCA9IHRoaXMuX2JsYW5rTm9kZSgpO1xuXG4gICAgLy8gSXMgdGhpcyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgbGlzdD9cbiAgICBpZiAocHJldmlvdXNMaXN0ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGxpc3QgaXMgZWl0aGVyIHRoZSBzdWJqZWN0IG9yIHRoZSBvYmplY3Qgb2YgaXRzIHBhcmVudFxuICAgICAgaWYgKHBhcmVudC5wcmVkaWNhdGUgPT09IG51bGwpXG4gICAgICAgIHBhcmVudC5zdWJqZWN0ID0gbGlzdDtcbiAgICAgIGVsc2VcbiAgICAgICAgcGFyZW50Lm9iamVjdCA9IGxpc3Q7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgLy8gQ29udGludWUgdGhlIHByZXZpb3VzIGxpc3Qgd2l0aCB0aGUgY3VycmVudCBsaXN0XG4gICAgICB0aGlzLl9lbWl0KHByZXZpb3VzTGlzdCwgdGhpcy5SREZfUkVTVCwgbGlzdCwgdGhpcy5fZ3JhcGgpO1xuICAgIH1cbiAgICAvLyBJZiBhbiBpdGVtIHdhcyByZWFkLCBhZGQgaXQgdG8gdGhlIGxpc3RcbiAgICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgLy8gSW4gTjMgbW9kZSwgdGhlIGl0ZW0gbWlnaHQgYmUgYSBwYXRoXG4gICAgICBpZiAodGhpcy5fbjNNb2RlICYmICh0b2tlbi50eXBlID09PSAnSVJJJyB8fCB0b2tlbi50eXBlID09PSAncHJlZml4ZWQnKSkge1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY29udGV4dCB0byBhZGQgdGhlIGl0ZW0ncyBwYXRoXG4gICAgICAgIHRoaXMuX3NhdmVDb250ZXh0KCdpdGVtJywgdGhpcy5fZ3JhcGgsIGxpc3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtKTtcbiAgICAgICAgdGhpcy5fc3ViamVjdCA9IGl0ZW0sIHRoaXMuX3ByZWRpY2F0ZSA9IG51bGw7XG4gICAgICAgIC8vIF9yZWFkUGF0aCB3aWxsIHJlc3RvcmUgdGhlIGNvbnRleHQgYW5kIG91dHB1dCB0aGUgaXRlbVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UGF0aFJlYWRlcih0aGlzLl9yZWFkTGlzdEl0ZW0pO1xuICAgICAgfVxuICAgICAgLy8gT3V0cHV0IHRoZSBpdGVtXG4gICAgICB0aGlzLl9lbWl0KGxpc3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtLCB0aGlzLl9ncmFwaCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gIyMjIGBfcmVhZERhdGFUeXBlT3JMYW5nYCByZWFkcyBhbiBfb3B0aW9uYWxfIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG4gIF9yZWFkRGF0YVR5cGVPckxhbmcodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGxldGVPYmplY3RMaXRlcmFsKHRva2VuLCBmYWxzZSk7XG4gIH1cblxuXG4gIC8vICMjIyBgX3JlYWRMaXN0SXRlbURhdGFUeXBlT3JMYW5nYCByZWFkcyBhbiBfb3B0aW9uYWxfIGRhdGF0eXBlIG9yIGxhbmd1YWdlIGluIGEgbGlzdFxuICBfcmVhZExpc3RJdGVtRGF0YVR5cGVPckxhbmcodG9rZW4pIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGxldGVPYmplY3RMaXRlcmFsKHRva2VuLCB0cnVlKTtcbiAgfVxuXG4gIC8vICMjIyBgX2NvbXBsZXRlTGl0ZXJhbGAgY29tcGxldGVzIGEgbGl0ZXJhbCB3aXRoIGFuIG9wdGlvbmFsIGRhdGF0eXBlIG9yIGxhbmd1YWdlXG4gIF9jb21wbGV0ZUxpdGVyYWwodG9rZW4pIHtcbiAgICAvLyBDcmVhdGUgYSBzaW1wbGUgc3RyaW5nIGxpdGVyYWwgYnkgZGVmYXVsdFxuICAgIGxldCBsaXRlcmFsID0gdGhpcy5fbGl0ZXJhbCh0aGlzLl9saXRlcmFsVmFsdWUpO1xuXG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgLy8gQ3JlYXRlIGEgZGF0YXR5cGVkIGxpdGVyYWxcbiAgICBjYXNlICd0eXBlJzpcbiAgICBjYXNlICd0eXBlSVJJJzpcbiAgICAgIHZhciBkYXRhdHlwZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pO1xuICAgICAgaWYgKGRhdGF0eXBlID09PSB1bmRlZmluZWQpIHJldHVybjsgLy8gTm8gZGF0YXR5cGUgbWVhbnMgYW4gZXJyb3Igb2NjdXJyZWRcbiAgICAgIGxpdGVyYWwgPSB0aGlzLl9saXRlcmFsKHRoaXMuX2xpdGVyYWxWYWx1ZSwgZGF0YXR5cGUpO1xuICAgICAgdG9rZW4gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ3JlYXRlIGEgbGFuZ3VhZ2UtdGFnZ2VkIHN0cmluZ1xuICAgIGNhc2UgJ2xhbmdjb2RlJzpcbiAgICAgIGxpdGVyYWwgPSB0aGlzLl9saXRlcmFsKHRoaXMuX2xpdGVyYWxWYWx1ZSwgdG9rZW4udmFsdWUpO1xuICAgICAgdG9rZW4gPSBudWxsO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgdG9rZW4sIGxpdGVyYWwgfTtcbiAgfVxuXG4gIC8vIENvbXBsZXRlcyBhIGxpdGVyYWwgaW4gc3ViamVjdCBwb3NpdGlvblxuICBfY29tcGxldGVTdWJqZWN0TGl0ZXJhbCh0b2tlbikge1xuICAgIHRoaXMuX3N1YmplY3QgPSB0aGlzLl9jb21wbGV0ZUxpdGVyYWwodG9rZW4pLmxpdGVyYWw7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQcmVkaWNhdGVPck5hbWVkR3JhcGg7XG4gIH1cblxuICAvLyBDb21wbGV0ZXMgYSBsaXRlcmFsIGluIG9iamVjdCBwb3NpdGlvblxuICBfY29tcGxldGVPYmplY3RMaXRlcmFsKHRva2VuLCBsaXN0SXRlbSkge1xuICAgIGNvbnN0IGNvbXBsZXRlZCA9IHRoaXMuX2NvbXBsZXRlTGl0ZXJhbCh0b2tlbik7XG4gICAgaWYgKCFjb21wbGV0ZWQpXG4gICAgICByZXR1cm47XG4gICAgdGhpcy5fb2JqZWN0ID0gY29tcGxldGVkLmxpdGVyYWw7XG5cbiAgICAvLyBJZiB0aGlzIGxpdGVyYWwgd2FzIHBhcnQgb2YgYSBsaXN0LCB3cml0ZSB0aGUgaXRlbVxuICAgIC8vICh3ZSBjb3VsZCBhbHNvIGNoZWNrIHRoZSBjb250ZXh0IHN0YWNrLCBidXQgcGFzc2luZyBpbiBhIGZsYWcgaXMgZmFzdGVyKVxuICAgIGlmIChsaXN0SXRlbSlcbiAgICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5SREZfRklSU1QsIHRoaXMuX29iamVjdCwgdGhpcy5fZ3JhcGgpO1xuICAgIC8vIElmIHRoZSB0b2tlbiB3YXMgY29uc3VtZWQsIGNvbnRpbnVlIHdpdGggdGhlIHJlc3Qgb2YgdGhlIGlucHV0XG4gICAgaWYgKGNvbXBsZXRlZC50b2tlbiA9PT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBjb25zdW1lIHRoZSB0b2tlbiBub3dcbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX3JlYWRDYWxsYmFjayA9IHRoaXMuX2dldENvbnRleHRFbmRSZWFkZXIoKTtcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkQ2FsbGJhY2soY29tcGxldGVkLnRva2VuKTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkRm9ybXVsYVRhaWxgIHJlYWRzIHRoZSBlbmQgb2YgYSBmb3JtdWxhXG4gIF9yZWFkRm9ybXVsYVRhaWwodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ30nKVxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRQdW5jdHVhdGlvbih0b2tlbik7XG5cbiAgICAvLyBTdG9yZSB0aGUgbGFzdCBxdWFkIG9mIHRoZSBmb3JtdWxhXG4gICAgaWYgKHRoaXMuX3N1YmplY3QgIT09IG51bGwpXG4gICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuX3ByZWRpY2F0ZSwgdGhpcy5fb2JqZWN0LCB0aGlzLl9ncmFwaCk7XG5cbiAgICAvLyBSZXN0b3JlIHRoZSBwYXJlbnQgY29udGV4dCBjb250YWluaW5nIHRoaXMgZm9ybXVsYVxuICAgIHRoaXMuX3Jlc3RvcmVDb250ZXh0KCk7XG4gICAgLy8gSWYgdGhlIGZvcm11bGEgd2FzIHRoZSBzdWJqZWN0LCBjb250aW51ZSByZWFkaW5nIHRoZSBwcmVkaWNhdGUuXG4gICAgLy8gSWYgdGhlIGZvcm11bGEgd2FzIHRoZSBvYmplY3QsIHJlYWQgcHVuY3R1YXRpb24uXG4gICAgcmV0dXJuIHRoaXMuX29iamVjdCA9PT0gbnVsbCA/IHRoaXMuX3JlYWRQcmVkaWNhdGUgOiB0aGlzLl9nZXRDb250ZXh0RW5kUmVhZGVyKCk7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkUHVuY3R1YXRpb25gIHJlYWRzIHB1bmN0dWF0aW9uIGJldHdlZW4gcXVhZHMgb3IgcXVhZCBwYXJ0c1xuICBfcmVhZFB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgdmFyIG5leHQsIHN1YmplY3QgPSB0aGlzLl9zdWJqZWN0LCBncmFwaCA9IHRoaXMuX2dyYXBoLFxuICAgICAgICBpbnZlcnNlUHJlZGljYXRlID0gdGhpcy5faW52ZXJzZVByZWRpY2F0ZTtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvLyBBIGNsb3NpbmcgYnJhY2UgZW5kcyBhIGdyYXBoXG4gICAgY2FzZSAnfSc6XG4gICAgICBpZiAodGhpcy5fZ3JhcGggPT09IG51bGwpXG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcignVW5leHBlY3RlZCBncmFwaCBjbG9zaW5nJywgdG9rZW4pO1xuICAgICAgaWYgKHRoaXMuX24zTW9kZSlcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWRGb3JtdWxhVGFpbCh0b2tlbik7XG4gICAgICB0aGlzLl9ncmFwaCA9IG51bGw7XG4gICAgLy8gQSBkb3QganVzdCBlbmRzIHRoZSBzdGF0ZW1lbnQsIHdpdGhvdXQgc2hhcmluZyBhbnl0aGluZyB3aXRoIHRoZSBuZXh0XG4gICAgY2FzZSAnLic6XG4gICAgICB0aGlzLl9zdWJqZWN0ID0gbnVsbDtcbiAgICAgIG5leHQgPSB0aGlzLl9jb250ZXh0U3RhY2subGVuZ3RoID8gdGhpcy5fcmVhZFN1YmplY3QgOiB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0O1xuICAgICAgaWYgKGludmVyc2VQcmVkaWNhdGUpIHRoaXMuX2ludmVyc2VQcmVkaWNhdGUgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIC8vIFNlbWljb2xvbiBtZWFucyB0aGUgc3ViamVjdCBpcyBzaGFyZWQ7IHByZWRpY2F0ZSBhbmQgb2JqZWN0IGFyZSBkaWZmZXJlbnRcbiAgICBjYXNlICc7JzpcbiAgICAgIG5leHQgPSB0aGlzLl9yZWFkUHJlZGljYXRlO1xuICAgICAgYnJlYWs7XG4gICAgLy8gQ29tbWEgbWVhbnMgYm90aCB0aGUgc3ViamVjdCBhbmQgcHJlZGljYXRlIGFyZSBzaGFyZWQ7IHRoZSBvYmplY3QgaXMgZGlmZmVyZW50XG4gICAgY2FzZSAnLCc6XG4gICAgICBuZXh0ID0gdGhpcy5fcmVhZE9iamVjdDtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBBbiBlbnRpdHkgbWVhbnMgdGhpcyBpcyBhIHF1YWQgKG9ubHkgYWxsb3dlZCBpZiBub3QgYWxyZWFkeSBpbnNpZGUgYSBncmFwaClcbiAgICAgIGlmICh0aGlzLl9zdXBwb3J0c1F1YWRzICYmIHRoaXMuX2dyYXBoID09PSBudWxsICYmIChncmFwaCA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5leHQgPSB0aGlzLl9yZWFkUXVhZFB1bmN0dWF0aW9uO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHVuY3R1YXRpb24gdG8gZm9sbG93IFwiJyArIHRoaXMuX29iamVjdC5pZCArICdcIicsIHRva2VuKTtcbiAgICB9XG4gICAgLy8gQSBxdWFkIGhhcyBiZWVuIGNvbXBsZXRlZCBub3csIHNvIHJldHVybiBpdFxuICAgIGlmIChzdWJqZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJlZGljYXRlID0gdGhpcy5fcHJlZGljYXRlLCBvYmplY3QgPSB0aGlzLl9vYmplY3Q7XG4gICAgICBpZiAoIWludmVyc2VQcmVkaWNhdGUpXG4gICAgICAgIHRoaXMuX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsICBncmFwaCk7XG4gICAgICBlbHNlXG4gICAgICAgIHRoaXMuX2VtaXQob2JqZWN0LCAgcHJlZGljYXRlLCBzdWJqZWN0LCBncmFwaCk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgICAvLyAjIyMgYF9yZWFkQmxhbmtOb2RlUHVuY3R1YXRpb25gIHJlYWRzIHB1bmN0dWF0aW9uIGluIGEgYmxhbmsgbm9kZVxuICBfcmVhZEJsYW5rTm9kZVB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgdmFyIG5leHQ7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgLy8gU2VtaWNvbG9uIG1lYW5zIHRoZSBzdWJqZWN0IGlzIHNoYXJlZDsgcHJlZGljYXRlIGFuZCBvYmplY3QgYXJlIGRpZmZlcmVudFxuICAgIGNhc2UgJzsnOlxuICAgICAgbmV4dCA9IHRoaXMuX3JlYWRQcmVkaWNhdGU7XG4gICAgICBicmVhaztcbiAgICAvLyBDb21tYSBtZWFucyBib3RoIHRoZSBzdWJqZWN0IGFuZCBwcmVkaWNhdGUgYXJlIHNoYXJlZDsgdGhlIG9iamVjdCBpcyBkaWZmZXJlbnRcbiAgICBjYXNlICcsJzpcbiAgICAgIG5leHQgPSB0aGlzLl9yZWFkT2JqZWN0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0aGlzLl9lcnJvcignRXhwZWN0ZWQgcHVuY3R1YXRpb24gdG8gZm9sbG93IFwiJyArIHRoaXMuX29iamVjdC5pZCArICdcIicsIHRva2VuKTtcbiAgICB9XG4gICAgLy8gQSBxdWFkIGhhcyBiZWVuIGNvbXBsZXRlZCBub3csIHNvIHJldHVybiBpdFxuICAgIHRoaXMuX2VtaXQodGhpcy5fc3ViamVjdCwgdGhpcy5fcHJlZGljYXRlLCB0aGlzLl9vYmplY3QsIHRoaXMuX2dyYXBoKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRRdWFkUHVuY3R1YXRpb25gIHJlYWRzIHB1bmN0dWF0aW9uIGFmdGVyIGEgcXVhZFxuICBfcmVhZFF1YWRQdW5jdHVhdGlvbih0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSAnLicpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGRvdCB0byBmb2xsb3cgcXVhZCcsIHRva2VuKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZEluVG9wQ29udGV4dDtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRQcmVmaXhgIHJlYWRzIHRoZSBwcmVmaXggb2YgYSBwcmVmaXggZGVjbGFyYXRpb25cbiAgX3JlYWRQcmVmaXgodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ3ByZWZpeCcpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIHByZWZpeCB0byBmb2xsb3cgQHByZWZpeCcsIHRva2VuKTtcbiAgICB0aGlzLl9wcmVmaXggPSB0b2tlbi52YWx1ZTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFByZWZpeElSSTtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRQcmVmaXhJUklgIHJlYWRzIHRoZSBJUkkgb2YgYSBwcmVmaXggZGVjbGFyYXRpb25cbiAgX3JlYWRQcmVmaXhJUkkodG9rZW4pIHtcbiAgICBpZiAodG9rZW4udHlwZSAhPT0gJ0lSSScpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIElSSSB0byBmb2xsb3cgcHJlZml4IFwiJyArIHRoaXMuX3ByZWZpeCArICc6XCInLCB0b2tlbik7XG4gICAgdmFyIHByZWZpeE5vZGUgPSB0aGlzLl9yZWFkRW50aXR5KHRva2VuKTtcbiAgICB0aGlzLl9wcmVmaXhlc1t0aGlzLl9wcmVmaXhdID0gcHJlZml4Tm9kZS52YWx1ZTtcbiAgICB0aGlzLl9wcmVmaXhDYWxsYmFjayh0aGlzLl9wcmVmaXgsIHByZWZpeE5vZGUpO1xuICAgIHJldHVybiB0aGlzLl9yZWFkRGVjbGFyYXRpb25QdW5jdHVhdGlvbjtcbiAgfVxuXG4gIC8vICMjIyBgX3JlYWRCYXNlSVJJYCByZWFkcyB0aGUgSVJJIG9mIGEgYmFzZSBkZWNsYXJhdGlvblxuICBfcmVhZEJhc2VJUkkodG9rZW4pIHtcbiAgICB2YXIgaXJpID0gdG9rZW4udHlwZSA9PT0gJ0lSSScgJiYgdGhpcy5fcmVzb2x2ZUlSSSh0b2tlbi52YWx1ZSk7XG4gICAgaWYgKCFpcmkpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIHZhbGlkIElSSSB0byBmb2xsb3cgYmFzZSBkZWNsYXJhdGlvbicsIHRva2VuKTtcbiAgICB0aGlzLl9zZXRCYXNlKGlyaSk7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uO1xuICB9XG5cbiAgLy8gIyMjIGBfcmVhZE5hbWVkR3JhcGhMYWJlbGAgcmVhZHMgdGhlIGxhYmVsIG9mIGEgbmFtZWQgZ3JhcGhcbiAgX3JlYWROYW1lZEdyYXBoTGFiZWwodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICBjYXNlICdJUkknOlxuICAgIGNhc2UgJ2JsYW5rJzpcbiAgICBjYXNlICdwcmVmaXhlZCc6XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFN1YmplY3QodG9rZW4pLCB0aGlzLl9yZWFkR3JhcGg7XG4gICAgY2FzZSAnWyc6XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZE5hbWVkR3JhcGhCbGFua0xhYmVsO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0ludmFsaWQgZ3JhcGggbGFiZWwnLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfcmVhZE5hbWVkR3JhcGhMYWJlbGAgcmVhZHMgYSBibGFuayBub2RlIGxhYmVsIG9mIGEgbmFtZWQgZ3JhcGhcbiAgX3JlYWROYW1lZEdyYXBoQmxhbmtMYWJlbCh0b2tlbikge1xuICAgIGlmICh0b2tlbi50eXBlICE9PSAnXScpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0ludmFsaWQgZ3JhcGggbGFiZWwnLCB0b2tlbik7XG4gICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpO1xuICAgIHJldHVybiB0aGlzLl9yZWFkR3JhcGg7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkRGVjbGFyYXRpb25QdW5jdHVhdGlvbmAgcmVhZHMgdGhlIHB1bmN0dWF0aW9uIG9mIGEgZGVjbGFyYXRpb25cbiAgX3JlYWREZWNsYXJhdGlvblB1bmN0dWF0aW9uKHRva2VuKSB7XG4gICAgLy8gU1BBUlFMLXN0eWxlIGRlY2xhcmF0aW9ucyBkb24ndCBoYXZlIHB1bmN0dWF0aW9uXG4gICAgaWYgKHRoaXMuX3NwYXJxbFN0eWxlKSB7XG4gICAgICB0aGlzLl9zcGFycWxTdHlsZSA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRJblRvcENvbnRleHQodG9rZW4pO1xuICAgIH1cblxuICAgIGlmICh0b2tlbi50eXBlICE9PSAnLicpXG4gICAgICByZXR1cm4gdGhpcy5fZXJyb3IoJ0V4cGVjdGVkIGRlY2xhcmF0aW9uIHRvIGVuZCB3aXRoIGEgZG90JywgdG9rZW4pO1xuICAgIHJldHVybiB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0O1xuICB9XG5cbiAgLy8gUmVhZHMgYSBsaXN0IG9mIHF1YW50aWZpZWQgc3ltYm9scyBmcm9tIGEgQGZvclNvbWUgb3IgQGZvckFsbCBzdGF0ZW1lbnRcbiAgX3JlYWRRdWFudGlmaWVyTGlzdCh0b2tlbikge1xuICAgIHZhciBlbnRpdHk7XG4gICAgc3dpdGNoICh0b2tlbi50eXBlKSB7XG4gICAgY2FzZSAnSVJJJzpcbiAgICBjYXNlICdwcmVmaXhlZCc6XG4gICAgICBpZiAoKGVudGl0eSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4sIHRydWUpKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yKCdVbmV4cGVjdGVkICcgKyB0b2tlbi50eXBlLCB0b2tlbik7XG4gICAgfVxuICAgIC8vIFdpdGhvdXQgZXhwbGljaXQgcXVhbnRpZmllcnMsIG1hcCBlbnRpdGllcyB0byBhIHF1YW50aWZpZWQgZW50aXR5XG4gICAgaWYgKCF0aGlzLl9leHBsaWNpdFF1YW50aWZpZXJzKVxuICAgICAgdGhpcy5fcXVhbnRpZmllZFtlbnRpdHkuaWRdID0gdGhpcy5fcXVhbnRpZmllcih0aGlzLl9ibGFua05vZGUoKS52YWx1ZSk7XG4gICAgLy8gV2l0aCBleHBsaWNpdCBxdWFudGlmaWVycywgb3V0cHV0IHRoZSByZWlmaWVkIHF1YW50aWZpZXJcbiAgICBlbHNlIHtcbiAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IGl0ZW0sIHN0YXJ0IGEgbmV3IHF1YW50aWZpZXIgbGlzdFxuICAgICAgaWYgKHRoaXMuX3N1YmplY3QgPT09IG51bGwpXG4gICAgICAgIHRoaXMuX2VtaXQodGhpcy5fZ3JhcGggfHwgdGhpcy5ERUZBVUxUR1JBUEgsIHRoaXMuX3ByZWRpY2F0ZSxcbiAgICAgICAgICAgICAgICAgICB0aGlzLl9zdWJqZWN0ID0gdGhpcy5fYmxhbmtOb2RlKCksIHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpO1xuICAgICAgLy8gT3RoZXJ3aXNlLCBjb250aW51ZSB0aGUgcHJldmlvdXMgbGlzdFxuICAgICAgZWxzZVxuICAgICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX1JFU1QsXG4gICAgICAgICAgICAgICAgICAgdGhpcy5fc3ViamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpLCB0aGlzLlFVQU5USUZJRVJTX0dSQVBIKTtcbiAgICAgIC8vIE91dHB1dCB0aGUgbGlzdCBpdGVtXG4gICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX0ZJUlNULCBlbnRpdHksIHRoaXMuUVVBTlRJRklFUlNfR1JBUEgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZFF1YW50aWZpZXJQdW5jdHVhdGlvbjtcbiAgfVxuXG4gIC8vIFJlYWRzIHB1bmN0dWF0aW9uIGZyb20gYSBAZm9yU29tZSBvciBAZm9yQWxsIHN0YXRlbWVudFxuICBfcmVhZFF1YW50aWZpZXJQdW5jdHVhdGlvbih0b2tlbikge1xuICAgIC8vIFJlYWQgbW9yZSBxdWFudGlmaWVyc1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnLCcpXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFF1YW50aWZpZXJMaXN0O1xuICAgIC8vIEVuZCBvZiB0aGUgcXVhbnRpZmllciBsaXN0XG4gICAgZWxzZSB7XG4gICAgICAvLyBXaXRoIGV4cGxpY2l0IHF1YW50aWZpZXJzLCBjbG9zZSB0aGUgcXVhbnRpZmllciBsaXN0XG4gICAgICBpZiAodGhpcy5fZXhwbGljaXRRdWFudGlmaWVycykge1xuICAgICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX1JFU1QsIHRoaXMuUkRGX05JTCwgdGhpcy5RVUFOVElGSUVSU19HUkFQSCk7XG4gICAgICAgIHRoaXMuX3N1YmplY3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gUmVhZCBhIGRvdFxuICAgICAgdGhpcy5fcmVhZENhbGxiYWNrID0gdGhpcy5fZ2V0Q29udGV4dEVuZFJlYWRlcigpO1xuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRDYWxsYmFjayh0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfZ2V0UGF0aFJlYWRlcmAgcmVhZHMgYSBwb3RlbnRpYWwgcGF0aCBhbmQgdGhlbiByZXN1bWVzIHdpdGggdGhlIGdpdmVuIGZ1bmN0aW9uXG4gIF9nZXRQYXRoUmVhZGVyKGFmdGVyUGF0aCkge1xuICAgIHRoaXMuX2FmdGVyUGF0aCA9IGFmdGVyUGF0aDtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhdGg7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkUGF0aGAgcmVhZHMgYSBwb3RlbnRpYWwgcGF0aFxuICBfcmVhZFBhdGgodG9rZW4pIHtcbiAgICBzd2l0Y2ggKHRva2VuLnR5cGUpIHtcbiAgICAvLyBGb3J3YXJkIHBhdGhcbiAgICBjYXNlICchJzogcmV0dXJuIHRoaXMuX3JlYWRGb3J3YXJkUGF0aDtcbiAgICAvLyBCYWNrd2FyZCBwYXRoXG4gICAgY2FzZSAnXic6IHJldHVybiB0aGlzLl9yZWFkQmFja3dhcmRQYXRoO1xuICAgIC8vIE5vdCBhIHBhdGg7IHJlc3VtZSByZWFkaW5nIHdoZXJlIHdlIGxlZnQgb2ZmXG4gICAgZGVmYXVsdDpcbiAgICAgIHZhciBzdGFjayA9IHRoaXMuX2NvbnRleHRTdGFjaywgcGFyZW50ID0gc3RhY2subGVuZ3RoICYmIHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGEgbGlzdCBpdGVtLCB3ZSBzdGlsbCBuZWVkIHRvIG91dHB1dCBpdFxuICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQudHlwZSA9PT0gJ2l0ZW0nKSB7XG4gICAgICAgIC8vIFRoZSBsaXN0IGl0ZW0gaXMgdGhlIHJlbWFpbmluZyBzdWJlamN0IGFmdGVyIHJlYWRpbmcgdGhlIHBhdGhcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9zdWJqZWN0O1xuICAgICAgICAvLyBTd2l0Y2ggYmFjayB0byB0aGUgY29udGV4dCBvZiB0aGUgbGlzdFxuICAgICAgICB0aGlzLl9yZXN0b3JlQ29udGV4dCgpO1xuICAgICAgICAvLyBPdXRwdXQgdGhlIGxpc3QgaXRlbVxuICAgICAgICB0aGlzLl9lbWl0KHRoaXMuX3N1YmplY3QsIHRoaXMuUkRGX0ZJUlNULCBpdGVtLCB0aGlzLl9ncmFwaCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYWZ0ZXJQYXRoKHRva2VuKTtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkRm9yd2FyZFBhdGhgIHJlYWRzIGEgJyEnIHBhdGhcbiAgX3JlYWRGb3J3YXJkUGF0aCh0b2tlbikge1xuICAgIHZhciBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCA9IHRoaXMuX2JsYW5rTm9kZSgpO1xuICAgIC8vIFRoZSBuZXh0IHRva2VuIGlzIHRoZSBwcmVkaWNhdGVcbiAgICBpZiAoKHByZWRpY2F0ZSA9IHRoaXMuX3JlYWRFbnRpdHkodG9rZW4pKSA9PT0gdW5kZWZpbmVkKVxuICAgICAgcmV0dXJuO1xuICAgIC8vIElmIHdlIHdlcmUgcmVhZGluZyBhIHN1YmplY3QsIHJlcGxhY2UgdGhlIHN1YmplY3QgYnkgdGhlIHBhdGgncyBvYmplY3RcbiAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKVxuICAgICAgc3ViamVjdCA9IHRoaXMuX3N1YmplY3QsIHRoaXMuX3N1YmplY3QgPSBvYmplY3Q7XG4gICAgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGFuIG9iamVjdCwgcmVwbGFjZSB0aGUgc3ViamVjdCBieSB0aGUgcGF0aCdzIG9iamVjdFxuICAgIGVsc2VcbiAgICAgIHN1YmplY3QgPSB0aGlzLl9vYmplY3QsICB0aGlzLl9vYmplY3QgID0gb2JqZWN0O1xuICAgIC8vIEVtaXQgdGhlIHBhdGgncyBjdXJyZW50IHF1YWQgYW5kIHJlYWQgaXRzIG5leHQgc2VjdGlvblxuICAgIHRoaXMuX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIHRoaXMuX2dyYXBoKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZFBhdGg7XG4gIH1cblxuICAvLyAjIyMgYF9yZWFkQmFja3dhcmRQYXRoYCByZWFkcyBhICdeJyBwYXRoXG4gIF9yZWFkQmFja3dhcmRQYXRoKHRva2VuKSB7XG4gICAgdmFyIHN1YmplY3QgPSB0aGlzLl9ibGFua05vZGUoKSwgcHJlZGljYXRlLCBvYmplY3Q7XG4gICAgLy8gVGhlIG5leHQgdG9rZW4gaXMgdGhlIHByZWRpY2F0ZVxuICAgIGlmICgocHJlZGljYXRlID0gdGhpcy5fcmVhZEVudGl0eSh0b2tlbikpID09PSB1bmRlZmluZWQpXG4gICAgICByZXR1cm47XG4gICAgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGEgc3ViamVjdCwgcmVwbGFjZSB0aGUgc3ViamVjdCBieSB0aGUgcGF0aCdzIHN1YmplY3RcbiAgICBpZiAodGhpcy5fcHJlZGljYXRlID09PSBudWxsKVxuICAgICAgb2JqZWN0ID0gdGhpcy5fc3ViamVjdCwgdGhpcy5fc3ViamVjdCA9IHN1YmplY3Q7XG4gICAgLy8gSWYgd2Ugd2VyZSByZWFkaW5nIGFuIG9iamVjdCwgcmVwbGFjZSB0aGUgc3ViamVjdCBieSB0aGUgcGF0aCdzIHN1YmplY3RcbiAgICBlbHNlXG4gICAgICBvYmplY3QgPSB0aGlzLl9vYmplY3QsICB0aGlzLl9vYmplY3QgID0gc3ViamVjdDtcbiAgICAvLyBFbWl0IHRoZSBwYXRoJ3MgY3VycmVudCBxdWFkIGFuZCByZWFkIGl0cyBuZXh0IHNlY3Rpb25cbiAgICB0aGlzLl9lbWl0KHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCB0aGlzLl9ncmFwaCk7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRQYXRoO1xuICB9XG5cbiAgLy8gIyMjIGBfZ2V0Q29udGV4dEVuZFJlYWRlcmAgZ2V0cyB0aGUgbmV4dCByZWFkZXIgZnVuY3Rpb24gYXQgdGhlIGVuZCBvZiBhIGNvbnRleHRcbiAgX2dldENvbnRleHRFbmRSZWFkZXIoKSB7XG4gICAgdmFyIGNvbnRleHRTdGFjayA9IHRoaXMuX2NvbnRleHRTdGFjaztcbiAgICBpZiAoIWNvbnRleHRTdGFjay5sZW5ndGgpXG4gICAgICByZXR1cm4gdGhpcy5fcmVhZFB1bmN0dWF0aW9uO1xuXG4gICAgc3dpdGNoIChjb250ZXh0U3RhY2tbY29udGV4dFN0YWNrLmxlbmd0aCAtIDFdLnR5cGUpIHtcbiAgICBjYXNlICdibGFuayc6XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZEJsYW5rTm9kZVRhaWw7XG4gICAgY2FzZSAnbGlzdCc6XG4gICAgICByZXR1cm4gdGhpcy5fcmVhZExpc3RJdGVtO1xuICAgIGNhc2UgJ2Zvcm11bGEnOlxuICAgICAgcmV0dXJuIHRoaXMuX3JlYWRGb3JtdWxhVGFpbDtcbiAgICB9XG4gIH1cblxuICAvLyAjIyMgYF9lbWl0YCBzZW5kcyBhIHF1YWQgdGhyb3VnaCB0aGUgY2FsbGJhY2tcbiAgX2VtaXQoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2sobnVsbCwgdGhpcy5fcXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGggfHwgdGhpcy5ERUZBVUxUR1JBUEgpKTtcbiAgfVxuXG4gIC8vICMjIyBgX2Vycm9yYCBlbWl0cyBhbiBlcnJvciBtZXNzYWdlIHRocm91Z2ggdGhlIGNhbGxiYWNrXG4gIF9lcnJvcihtZXNzYWdlLCB0b2tlbikge1xuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSArICcgb24gbGluZSAnICsgdG9rZW4ubGluZSArICcuJyk7XG4gICAgZXJyLmNvbnRleHQgPSB7XG4gICAgICB0b2tlbjogdG9rZW4sXG4gICAgICBsaW5lOiB0b2tlbi5saW5lLFxuICAgICAgcHJldmlvdXNUb2tlbjogdGhpcy5fbGV4ZXIucHJldmlvdXNUb2tlbixcbiAgICB9O1xuICAgIHRoaXMuX2NhbGxiYWNrKGVycik7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBub29wO1xuICB9XG5cbiAgLy8gIyMjIGBfcmVzb2x2ZUlSSWAgcmVzb2x2ZXMgYW4gSVJJIGFnYWluc3QgdGhlIGJhc2UgcGF0aFxuICBfcmVzb2x2ZUlSSShpcmkpIHtcbiAgICByZXR1cm4gL15bYS16XVthLXowLTkrLi1dKjovaS50ZXN0KGlyaSkgPyBpcmkgOiB0aGlzLl9yZXNvbHZlUmVsYXRpdmVJUkkoaXJpKTtcbiAgfVxuXG4gIC8vICMjIyBgX3Jlc29sdmVSZWxhdGl2ZUlSSWAgcmVzb2x2ZXMgYW4gSVJJIGFnYWluc3QgdGhlIGJhc2UgcGF0aCxcbiAgLy8gYXNzdW1pbmcgdGhhdCBhIGJhc2UgcGF0aCBoYXMgYmVlbiBzZXQgYW5kIHRoYXQgdGhlIElSSSBpcyBpbmRlZWQgcmVsYXRpdmVcbiAgX3Jlc29sdmVSZWxhdGl2ZUlSSShpcmkpIHtcbiAgICAvLyBBbiBlbXB0eSByZWxhdGl2ZSBJUkkgaW5kaWNhdGVzIHRoZSBiYXNlIElSSVxuICAgIGlmICghaXJpLmxlbmd0aClcbiAgICAgIHJldHVybiB0aGlzLl9iYXNlO1xuICAgIC8vIERlY2lkZSByZXNvbHZpbmcgc3RyYXRlZ3kgYmFzZWQgaW4gdGhlIGZpcnN0IGNoYXJhY3RlclxuICAgIHN3aXRjaCAoaXJpWzBdKSB7XG4gICAgLy8gUmVzb2x2ZSByZWxhdGl2ZSBmcmFnbWVudCBJUklzIGFnYWluc3QgdGhlIGJhc2UgSVJJXG4gICAgY2FzZSAnIyc6IHJldHVybiB0aGlzLl9iYXNlICsgaXJpO1xuICAgIC8vIFJlc29sdmUgcmVsYXRpdmUgcXVlcnkgc3RyaW5nIElSSXMgYnkgcmVwbGFjaW5nIHRoZSBxdWVyeSBzdHJpbmdcbiAgICBjYXNlICc/JzogcmV0dXJuIHRoaXMuX2Jhc2UucmVwbGFjZSgvKD86XFw/LiopPyQvLCBpcmkpO1xuICAgIC8vIFJlc29sdmUgcm9vdC1yZWxhdGl2ZSBJUklzIGF0IHRoZSByb290IG9mIHRoZSBiYXNlIElSSVxuICAgIGNhc2UgJy8nOlxuICAgICAgLy8gUmVzb2x2ZSBzY2hlbWUtcmVsYXRpdmUgSVJJcyB0byB0aGUgc2NoZW1lXG4gICAgICByZXR1cm4gKGlyaVsxXSA9PT0gJy8nID8gdGhpcy5fYmFzZVNjaGVtZSA6IHRoaXMuX2Jhc2VSb290KSArIHRoaXMuX3JlbW92ZURvdFNlZ21lbnRzKGlyaSk7XG4gICAgLy8gUmVzb2x2ZSBhbGwgb3RoZXIgSVJJcyBhdCB0aGUgYmFzZSBJUkkncyBwYXRoXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFJlbGF0aXZlIElSSXMgY2Fubm90IGNvbnRhaW4gYSBjb2xvbiBpbiB0aGUgZmlyc3QgcGF0aCBzZWdtZW50XG4gICAgICByZXR1cm4gKC9eW14vOl0qOi8udGVzdChpcmkpKSA/IG51bGwgOiB0aGlzLl9yZW1vdmVEb3RTZWdtZW50cyh0aGlzLl9iYXNlUGF0aCArIGlyaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfcmVtb3ZlRG90U2VnbWVudHNgIHJlc29sdmVzICcuLycgYW5kICcuLi8nIHBhdGggc2VnbWVudHMgaW4gYW4gSVJJIGFzIHBlciBSRkMzOTg2XG4gIF9yZW1vdmVEb3RTZWdtZW50cyhpcmkpIHtcbiAgICAvLyBEb24ndCBtb2RpZnkgdGhlIElSSSBpZiBpdCBkb2VzIG5vdCBjb250YWluIGFueSBkb3Qgc2VnbWVudHNcbiAgICBpZiAoIS8oXnxcXC8pXFwuXFwuPygkfFsvIz9dKS8udGVzdChpcmkpKVxuICAgICAgcmV0dXJuIGlyaTtcblxuICAgIC8vIFN0YXJ0IHdpdGggYW4gaW1hZ2luYXJ5IHNsYXNoIGJlZm9yZSB0aGUgSVJJIGluIG9yZGVyIHRvIHJlc29sdmUgdHJhaWxpbmcgJy4vJyBhbmQgJy4uLydcbiAgICB2YXIgcmVzdWx0ID0gJycsIGxlbmd0aCA9IGlyaS5sZW5ndGgsIGkgPSAtMSwgcGF0aFN0YXJ0ID0gLTEsIHNlZ21lbnRTdGFydCA9IDAsIG5leHQgPSAnLyc7XG5cbiAgICB3aGlsZSAoaSA8IGxlbmd0aCkge1xuICAgICAgc3dpdGNoIChuZXh0KSB7XG4gICAgICAvLyBUaGUgcGF0aCBzdGFydHMgd2l0aCB0aGUgZmlyc3Qgc2xhc2ggYWZ0ZXIgdGhlIGF1dGhvcml0eVxuICAgICAgY2FzZSAnOic6XG4gICAgICAgIGlmIChwYXRoU3RhcnQgPCAwKSB7XG4gICAgICAgICAgLy8gU2tpcCB0d28gc2xhc2hlcyBiZWZvcmUgdGhlIGF1dGhvcml0eVxuICAgICAgICAgIGlmIChpcmlbKytpXSA9PT0gJy8nICYmIGlyaVsrK2ldID09PSAnLycpXG4gICAgICAgICAgICAvLyBTa2lwIHRvIHNsYXNoIGFmdGVyIHRoZSBhdXRob3JpdHlcbiAgICAgICAgICAgIHdoaWxlICgocGF0aFN0YXJ0ID0gaSArIDEpIDwgbGVuZ3RoICYmIGlyaVtwYXRoU3RhcnRdICE9PSAnLycpXG4gICAgICAgICAgICAgIGkgPSBwYXRoU3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBtb2RpZnkgYSBxdWVyeSBzdHJpbmcgb3IgZnJhZ21lbnRcbiAgICAgIGNhc2UgJz8nOlxuICAgICAgY2FzZSAnIyc6XG4gICAgICAgIGkgPSBsZW5ndGg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gSGFuZGxlICcvLicgb3IgJy8uLicgcGF0aCBzZWdtZW50c1xuICAgICAgY2FzZSAnLyc6XG4gICAgICAgIGlmIChpcmlbaSArIDFdID09PSAnLicpIHtcbiAgICAgICAgICBuZXh0ID0gaXJpWysraSArIDFdO1xuICAgICAgICAgIHN3aXRjaCAobmV4dCkge1xuICAgICAgICAgIC8vIFJlbW92ZSBhICcvLicgc2VnbWVudFxuICAgICAgICAgIGNhc2UgJy8nOlxuICAgICAgICAgICAgcmVzdWx0ICs9IGlyaS5zdWJzdHJpbmcoc2VnbWVudFN0YXJ0LCBpIC0gMSk7XG4gICAgICAgICAgICBzZWdtZW50U3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vIFJlbW92ZSBhIHRyYWlsaW5nICcvLicgc2VnbWVudFxuICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgIGNhc2UgJz8nOlxuICAgICAgICAgIGNhc2UgJyMnOlxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIGlyaS5zdWJzdHJpbmcoc2VnbWVudFN0YXJ0LCBpKSArIGlyaS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgIC8vIFJlbW92ZSBhICcvLi4nIHNlZ21lbnRcbiAgICAgICAgICBjYXNlICcuJzpcbiAgICAgICAgICAgIG5leHQgPSBpcmlbKytpICsgMV07XG4gICAgICAgICAgICBpZiAobmV4dCA9PT0gdW5kZWZpbmVkIHx8IG5leHQgPT09ICcvJyB8fCBuZXh0ID09PSAnPycgfHwgbmV4dCA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBpcmkuc3Vic3RyaW5nKHNlZ21lbnRTdGFydCwgaSAtIDIpO1xuICAgICAgICAgICAgICAvLyBUcnkgdG8gcmVtb3ZlIHRoZSBwYXJlbnQgcGF0aCBmcm9tIHJlc3VsdFxuICAgICAgICAgICAgICBpZiAoKHNlZ21lbnRTdGFydCA9IHJlc3VsdC5sYXN0SW5kZXhPZignLycpKSA+PSBwYXRoU3RhcnQpXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnN1YnN0cigwLCBzZWdtZW50U3RhcnQpO1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgYSB0cmFpbGluZyAnLy4uJyBzZWdtZW50XG4gICAgICAgICAgICAgIGlmIChuZXh0ICE9PSAnLycpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArICcvJyArIGlyaS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgICAgICBzZWdtZW50U3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHQgPSBpcmlbKytpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdCArIGlyaS5zdWJzdHJpbmcoc2VnbWVudFN0YXJ0KTtcbiAgfVxuXG4gIC8vICMjIFB1YmxpYyBtZXRob2RzXG5cbiAgLy8gIyMjIGBwYXJzZWAgcGFyc2VzIHRoZSBOMyBpbnB1dCBhbmQgZW1pdHMgZWFjaCBwYXJzZWQgcXVhZCB0aHJvdWdoIHRoZSBjYWxsYmFja1xuICBwYXJzZShpbnB1dCwgcXVhZENhbGxiYWNrLCBwcmVmaXhDYWxsYmFjaykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAvLyBUaGUgcmVhZCBjYWxsYmFjayBpcyB0aGUgbmV4dCBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGEgdG9rZW4gYXJyaXZlcy5cbiAgICAvLyBXZSBzdGFydCByZWFkaW5nIGluIHRoZSB0b3AgY29udGV4dC5cbiAgICB0aGlzLl9yZWFkQ2FsbGJhY2sgPSB0aGlzLl9yZWFkSW5Ub3BDb250ZXh0O1xuICAgIHRoaXMuX3NwYXJxbFN0eWxlID0gZmFsc2U7XG4gICAgdGhpcy5fcHJlZml4ZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3ByZWZpeGVzLl8gPSB0aGlzLl9ibGFua05vZGVQcmVmaXggPyB0aGlzLl9ibGFua05vZGVQcmVmaXguc3Vic3RyKDIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICdiJyArIGJsYW5rTm9kZVByZWZpeCsrICsgJ18nO1xuICAgIHRoaXMuX3ByZWZpeENhbGxiYWNrID0gcHJlZml4Q2FsbGJhY2sgfHwgbm9vcDtcbiAgICB0aGlzLl9pbnZlcnNlUHJlZGljYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcXVhbnRpZmllZCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgICAvLyBQYXJzZSBzeW5jaHJvbm91c2x5IGlmIG5vIHF1YWQgY2FsbGJhY2sgaXMgZ2l2ZW5cbiAgICBpZiAoIXF1YWRDYWxsYmFjaykge1xuICAgICAgdmFyIHF1YWRzID0gW10sIGVycm9yO1xuICAgICAgdGhpcy5fY2FsbGJhY2sgPSBmdW5jdGlvbiAoZSwgdCkgeyBlID8gKGVycm9yID0gZSkgOiB0ICYmIHF1YWRzLnB1c2godCk7IH07XG4gICAgICB0aGlzLl9sZXhlci50b2tlbml6ZShpbnB1dCkuZXZlcnkoZnVuY3Rpb24gKHRva2VuKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9yZWFkQ2FsbGJhY2sgPSBzZWxmLl9yZWFkQ2FsbGJhY2sodG9rZW4pO1xuICAgICAgfSk7XG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yO1xuICAgICAgcmV0dXJuIHF1YWRzO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGFzeW5jaHJvbm91c2x5IG90aGVyd2lzZSwgZXhlY3V0aW5nIHRoZSByZWFkIGNhbGxiYWNrIHdoZW4gYSB0b2tlbiBhcnJpdmVzXG4gICAgdGhpcy5fY2FsbGJhY2sgPSBxdWFkQ2FsbGJhY2s7XG4gICAgdGhpcy5fbGV4ZXIudG9rZW5pemUoaW5wdXQsIGZ1bmN0aW9uIChlcnJvciwgdG9rZW4pIHtcbiAgICAgIGlmIChlcnJvciAhPT0gbnVsbClcbiAgICAgICAgc2VsZi5fY2FsbGJhY2soZXJyb3IpLCBzZWxmLl9jYWxsYmFjayA9IG5vb3A7XG4gICAgICBlbHNlIGlmIChzZWxmLl9yZWFkQ2FsbGJhY2spXG4gICAgICAgIHNlbGYuX3JlYWRDYWxsYmFjayA9IHNlbGYuX3JlYWRDYWxsYmFjayh0b2tlbik7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gVGhlIGVtcHR5IGZ1bmN0aW9uXG5mdW5jdGlvbiBub29wKCkge31cblxuLy8gSW5pdGlhbGl6ZXMgdGhlIHBhcnNlciB3aXRoIHRoZSBnaXZlbiBkYXRhIGZhY3RvcnlcbmZ1bmN0aW9uIGluaXREYXRhRmFjdG9yeShwYXJzZXIsIGZhY3RvcnkpIHtcbiAgLy8gU2V0IGZhY3RvcnkgbWV0aG9kc1xuICB2YXIgbmFtZWROb2RlID0gZmFjdG9yeS5uYW1lZE5vZGU7XG4gIHBhcnNlci5fbmFtZWROb2RlICAgPSBuYW1lZE5vZGU7XG4gIHBhcnNlci5fYmxhbmtOb2RlICAgPSBmYWN0b3J5LmJsYW5rTm9kZTtcbiAgcGFyc2VyLl9saXRlcmFsICAgICA9IGZhY3RvcnkubGl0ZXJhbDtcbiAgcGFyc2VyLl92YXJpYWJsZSAgICA9IGZhY3RvcnkudmFyaWFibGU7XG4gIHBhcnNlci5fcXVhZCAgICAgICAgPSBmYWN0b3J5LnF1YWQ7XG4gIHBhcnNlci5ERUZBVUxUR1JBUEggPSBmYWN0b3J5LmRlZmF1bHRHcmFwaCgpO1xuXG4gIC8vIFNldCBjb21tb24gbmFtZWQgbm9kZXNcbiAgcGFyc2VyLlJERl9GSVJTVCAgPSBuYW1lZE5vZGUobmFtZXNwYWNlcy5yZGYuZmlyc3QpO1xuICBwYXJzZXIuUkRGX1JFU1QgICA9IG5hbWVkTm9kZShuYW1lc3BhY2VzLnJkZi5yZXN0KTtcbiAgcGFyc2VyLlJERl9OSUwgICAgPSBuYW1lZE5vZGUobmFtZXNwYWNlcy5yZGYubmlsKTtcbiAgcGFyc2VyLk4zX0ZPUkFMTCAgPSBuYW1lZE5vZGUobmFtZXNwYWNlcy5yLmZvckFsbCk7XG4gIHBhcnNlci5OM19GT1JTT01FID0gbmFtZWROb2RlKG5hbWVzcGFjZXMuci5mb3JTb21lKTtcbiAgcGFyc2VyLkFCQlJFVklBVElPTlMgPSB7XG4gICAgJ2EnOiBuYW1lZE5vZGUobmFtZXNwYWNlcy5yZGYudHlwZSksXG4gICAgJz0nOiBuYW1lZE5vZGUobmFtZXNwYWNlcy5vd2wuc2FtZUFzKSxcbiAgICAnPic6IG5hbWVkTm9kZShuYW1lc3BhY2VzLmxvZy5pbXBsaWVzKSxcbiAgfTtcbiAgcGFyc2VyLlFVQU5USUZJRVJTX0dSQVBIID0gbmFtZWROb2RlKCd1cm46bjM6cXVhbnRpZmllcnMnKTtcbn1cbmluaXREYXRhRmFjdG9yeShOM1BhcnNlci5wcm90b3R5cGUsIE4zRGF0YUZhY3RvcnkpO1xuIiwiLy8gKipOM1N0b3JlKiogb2JqZWN0cyBzdG9yZSBOMyBxdWFkcyBieSBncmFwaCBpbiBtZW1vcnkuXG5pbXBvcnQgTjNEYXRhRmFjdG9yeSBmcm9tICcuL04zRGF0YUZhY3RvcnknO1xuaW1wb3J0IHsgUmVhZGFibGUgfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IG5hbWVzcGFjZXMgZnJvbSAnLi9JUklzJztcblxuY29uc3QgeyB0b0lkLCBmcm9tSWQgfSA9IE4zRGF0YUZhY3RvcnkuaW50ZXJuYWw7XG5cbi8vICMjIENvbnN0cnVjdG9yXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBOM1N0b3JlIHtcbiAgY29uc3RydWN0b3IocXVhZHMsIG9wdGlvbnMpIHtcbiAgICAvLyBUaGUgbnVtYmVyIG9mIHF1YWRzIGlzIGluaXRpYWxseSB6ZXJvXG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgLy8gYF9ncmFwaHNgIGNvbnRhaW5zIHN1YmplY3QsIHByZWRpY2F0ZSwgYW5kIG9iamVjdCBpbmRleGVzIHBlciBncmFwaFxuICAgIHRoaXMuX2dyYXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgLy8gYF9pZHNgIG1hcHMgZW50aXRpZXMgc3VjaCBhcyBgaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lYCB0byBudW1iZXJzLFxuICAgIC8vIHNhdmluZyBtZW1vcnkgYnkgdXNpbmcgb25seSBudW1iZXJzIGFzIGtleXMgaW4gYF9ncmFwaHNgXG4gICAgdGhpcy5faWQgPSAwO1xuICAgIHRoaXMuX2lkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5faWRzWyc+PCddID0gMDsgLy8gZHVtbXkgZW50cnksIHNvIHRoZSBmaXJzdCBhY3R1YWwga2V5IGlzIG5vbi16ZXJvXG4gICAgdGhpcy5fZW50aXRpZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBpbnZlcnNlIG9mIGBfaWRzYFxuICAgIC8vIGBfYmxhbmtOb2RlSW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbGFzdCBhdXRvbWF0aWNhbGx5IG5hbWVkIGJsYW5rIG5vZGVcbiAgICB0aGlzLl9ibGFua05vZGVJbmRleCA9IDA7XG5cbiAgICAvLyBTaGlmdCBwYXJhbWV0ZXJzIGlmIGBxdWFkc2AgaXMgbm90IGdpdmVuXG4gICAgaWYgKCFvcHRpb25zICYmIHF1YWRzICYmICFxdWFkc1swXSlcbiAgICAgIG9wdGlvbnMgPSBxdWFkcywgcXVhZHMgPSBudWxsO1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX2ZhY3RvcnkgPSBvcHRpb25zLmZhY3RvcnkgfHwgTjNEYXRhRmFjdG9yeTtcblxuICAgIC8vIEFkZCBxdWFkcyBpZiBwYXNzZWRcbiAgICBpZiAocXVhZHMpXG4gICAgICB0aGlzLmFkZFF1YWRzKHF1YWRzKTtcbiAgfVxuXG4gIC8vICMjIFB1YmxpYyBwcm9wZXJ0aWVzXG5cbiAgLy8gIyMjIGBzaXplYCByZXR1cm5zIHRoZSBudW1iZXIgb2YgcXVhZHMgaW4gdGhlIHN0b3JlXG4gIGdldCBzaXplKCkge1xuICAgIC8vIFJldHVybiB0aGUgcXVhZCBjb3VudCBpZiBpZiB3YXMgY2FjaGVkXG4gICAgdmFyIHNpemUgPSB0aGlzLl9zaXplO1xuICAgIGlmIChzaXplICE9PSBudWxsKVxuICAgICAgcmV0dXJuIHNpemU7XG5cbiAgICAvLyBDYWxjdWxhdGUgdGhlIG51bWJlciBvZiBxdWFkcyBieSBjb3VudGluZyB0byB0aGUgZGVlcGVzdCBsZXZlbFxuICAgIHNpemUgPSAwO1xuICAgIHZhciBncmFwaHMgPSB0aGlzLl9ncmFwaHMsIHN1YmplY3RzLCBzdWJqZWN0O1xuICAgIGZvciAodmFyIGdyYXBoS2V5IGluIGdyYXBocylcbiAgICAgIGZvciAodmFyIHN1YmplY3RLZXkgaW4gKHN1YmplY3RzID0gZ3JhcGhzW2dyYXBoS2V5XS5zdWJqZWN0cykpXG4gICAgICAgIGZvciAodmFyIHByZWRpY2F0ZUtleSBpbiAoc3ViamVjdCA9IHN1YmplY3RzW3N1YmplY3RLZXldKSlcbiAgICAgICAgICBzaXplICs9IE9iamVjdC5rZXlzKHN1YmplY3RbcHJlZGljYXRlS2V5XSkubGVuZ3RoO1xuICAgIHJldHVybiB0aGlzLl9zaXplID0gc2l6ZTtcbiAgfVxuXG4gIC8vICMjIFByaXZhdGUgbWV0aG9kc1xuXG4gIC8vICMjIyBgX2FkZFRvSW5kZXhgIGFkZHMgYSBxdWFkIHRvIGEgdGhyZWUtbGF5ZXJlZCBpbmRleC5cbiAgLy8gUmV0dXJucyBpZiB0aGUgaW5kZXggaGFzIGNoYW5nZWQsIGlmIHRoZSBlbnRyeSBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4gIF9hZGRUb0luZGV4KGluZGV4MCwga2V5MCwga2V5MSwga2V5Mikge1xuICAgIC8vIENyZWF0ZSBsYXllcnMgYXMgbmVjZXNzYXJ5XG4gICAgdmFyIGluZGV4MSA9IGluZGV4MFtrZXkwXSB8fCAoaW5kZXgwW2tleTBdID0ge30pO1xuICAgIHZhciBpbmRleDIgPSBpbmRleDFba2V5MV0gfHwgKGluZGV4MVtrZXkxXSA9IHt9KTtcbiAgICAvLyBTZXR0aW5nIHRoZSBrZXkgdG8gX2FueV8gdmFsdWUgc2lnbmFscyB0aGUgcHJlc2VuY2Ugb2YgdGhlIHF1YWRcbiAgICB2YXIgZXhpc3RlZCA9IGtleTIgaW4gaW5kZXgyO1xuICAgIGlmICghZXhpc3RlZClcbiAgICAgIGluZGV4MltrZXkyXSA9IG51bGw7XG4gICAgcmV0dXJuICFleGlzdGVkO1xuICB9XG5cbiAgLy8gIyMjIGBfcmVtb3ZlRnJvbUluZGV4YCByZW1vdmVzIGEgcXVhZCBmcm9tIGEgdGhyZWUtbGF5ZXJlZCBpbmRleFxuICBfcmVtb3ZlRnJvbUluZGV4KGluZGV4MCwga2V5MCwga2V5MSwga2V5Mikge1xuICAgIC8vIFJlbW92ZSB0aGUgcXVhZCBmcm9tIHRoZSBpbmRleFxuICAgIHZhciBpbmRleDEgPSBpbmRleDBba2V5MF0sIGluZGV4MiA9IGluZGV4MVtrZXkxXSwga2V5O1xuICAgIGRlbGV0ZSBpbmRleDJba2V5Ml07XG5cbiAgICAvLyBSZW1vdmUgaW50ZXJtZWRpYXJ5IGluZGV4IGxheWVycyBpZiB0aGV5IGFyZSBlbXB0eVxuICAgIGZvciAoa2V5IGluIGluZGV4MikgcmV0dXJuO1xuICAgIGRlbGV0ZSBpbmRleDFba2V5MV07XG4gICAgZm9yIChrZXkgaW4gaW5kZXgxKSByZXR1cm47XG4gICAgZGVsZXRlIGluZGV4MFtrZXkwXTtcbiAgfVxuXG4gIC8vICMjIyBgX2ZpbmRJbkluZGV4YCBmaW5kcyBhIHNldCBvZiBxdWFkcyBpbiBhIHRocmVlLWxheWVyZWQgaW5kZXguXG4gIC8vIFRoZSBpbmRleCBiYXNlIGlzIGBpbmRleDBgIGFuZCB0aGUga2V5cyBhdCBlYWNoIGxldmVsIGFyZSBga2V5MGAsIGBrZXkxYCwgYW5kIGBrZXkyYC5cbiAgLy8gQW55IG9mIHRoZXNlIGtleXMgY2FuIGJlIHVuZGVmaW5lZCwgd2hpY2ggaXMgaW50ZXJwcmV0ZWQgYXMgYSB3aWxkY2FyZC5cbiAgLy8gYG5hbWUwYCwgYG5hbWUxYCwgYW5kIGBuYW1lMmAgYXJlIHRoZSBuYW1lcyBvZiB0aGUga2V5cyBhdCBlYWNoIGxldmVsLFxuICAvLyB1c2VkIHdoZW4gcmVjb25zdHJ1Y3RpbmcgdGhlIHJlc3VsdGluZyBxdWFkXG4gIC8vIChmb3IgaW5zdGFuY2U6IF9zdWJqZWN0XywgX3ByZWRpY2F0ZV8sIGFuZCBfb2JqZWN0XykuXG4gIC8vIEZpbmFsbHksIGBncmFwaGAgd2lsbCBiZSB0aGUgZ3JhcGggb2YgdGhlIGNyZWF0ZWQgcXVhZHMuXG4gIC8vIElmIGBjYWxsYmFja2AgaXMgZ2l2ZW4sIGVhY2ggcmVzdWx0IGlzIHBhc3NlZCB0aHJvdWdoIGl0XG4gIC8vIGFuZCBpdGVyYXRpb24gaGFsdHMgd2hlbiBpdCByZXR1cm5zIHRydXRoeSBmb3IgYW55IHF1YWQuXG4gIC8vIElmIGluc3RlYWQgYGFycmF5YCBpcyBnaXZlbiwgZWFjaCByZXN1bHQgaXMgYWRkZWQgdG8gdGhlIGFycmF5LlxuICBfZmluZEluSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyLCBuYW1lMCwgbmFtZTEsIG5hbWUyLCBncmFwaCwgY2FsbGJhY2ssIGFycmF5KSB7XG4gICAgdmFyIHRtcCwgaW5kZXgxLCBpbmRleDIsIHZhckNvdW50ID0gIWtleTAgKyAha2V5MSArICFrZXkyLFxuICAgICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIG51bWJlciBvZiB2YXJpYWJsZXMsIGtleXMgb3IgcmV2ZXJzZSBpbmRleCBhcmUgZmFzdGVyXG4gICAgICAgIGVudGl0eUtleXMgPSB2YXJDb3VudCA+IDEgPyBPYmplY3Qua2V5cyh0aGlzLl9pZHMpIDogdGhpcy5fZW50aXRpZXM7XG5cbiAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHVzZSBvbmx5IHRoYXQgcGFydCBvZiBpbmRleCAwLlxuICAgIGlmIChrZXkwKSAodG1wID0gaW5kZXgwLCBpbmRleDAgPSB7fSlba2V5MF0gPSB0bXBba2V5MF07XG4gICAgZm9yICh2YXIgdmFsdWUwIGluIGluZGV4MCkge1xuICAgICAgdmFyIGVudGl0eTAgPSBlbnRpdHlLZXlzW3ZhbHVlMF07XG5cbiAgICAgIGlmIChpbmRleDEgPSBpbmRleDBbdmFsdWUwXSkge1xuICAgICAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIHVzZSBvbmx5IHRoYXQgcGFydCBvZiBpbmRleCAxLlxuICAgICAgICBpZiAoa2V5MSkgKHRtcCA9IGluZGV4MSwgaW5kZXgxID0ge30pW2tleTFdID0gdG1wW2tleTFdO1xuICAgICAgICBmb3IgKHZhciB2YWx1ZTEgaW4gaW5kZXgxKSB7XG4gICAgICAgICAgdmFyIGVudGl0eTEgPSBlbnRpdHlLZXlzW3ZhbHVlMV07XG5cbiAgICAgICAgICBpZiAoaW5kZXgyID0gaW5kZXgxW3ZhbHVlMV0pIHtcbiAgICAgICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgdXNlIG9ubHkgdGhhdCBwYXJ0IG9mIGluZGV4IDIsIGlmIGl0IGV4aXN0cy5cbiAgICAgICAgICAgIHZhciB2YWx1ZXMgPSBrZXkyID8gKGtleTIgaW4gaW5kZXgyID8gW2tleTJdIDogW10pIDogT2JqZWN0LmtleXMoaW5kZXgyKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBxdWFkcyBmb3IgYWxsIGl0ZW1zIGZvdW5kIGluIGluZGV4IDIuXG4gICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHZhbHVlcy5sZW5ndGg7IGwrKykge1xuICAgICAgICAgICAgICB2YXIgcGFydHMgPSB7IHN1YmplY3Q6IG51bGwsIHByZWRpY2F0ZTogbnVsbCwgb2JqZWN0OiBudWxsIH07XG4gICAgICAgICAgICAgIHBhcnRzW25hbWUwXSA9IGZyb21JZChlbnRpdHkwLCB0aGlzLl9mYWN0b3J5KTtcbiAgICAgICAgICAgICAgcGFydHNbbmFtZTFdID0gZnJvbUlkKGVudGl0eTEsIHRoaXMuX2ZhY3RvcnkpO1xuICAgICAgICAgICAgICBwYXJ0c1tuYW1lMl0gPSBmcm9tSWQoZW50aXR5S2V5c1t2YWx1ZXNbbF1dLCB0aGlzLl9mYWN0b3J5KTtcbiAgICAgICAgICAgICAgdmFyIHF1YWQgPSB0aGlzLl9mYWN0b3J5LnF1YWQoXG4gICAgICAgICAgICAgICAgcGFydHMuc3ViamVjdCwgcGFydHMucHJlZGljYXRlLCBwYXJ0cy5vYmplY3QsIGZyb21JZChncmFwaCwgdGhpcy5fZmFjdG9yeSkpO1xuICAgICAgICAgICAgICBpZiAoYXJyYXkpXG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaChxdWFkKTtcbiAgICAgICAgICAgICAgZWxzZSBpZiAoY2FsbGJhY2socXVhZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8vICMjIyBgX2xvb3BgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwga2V5cyBvZiBpbmRleCAwXG4gIF9sb29wKGluZGV4MCwgY2FsbGJhY2spIHtcbiAgICBmb3IgKHZhciBrZXkwIGluIGluZGV4MClcbiAgICAgIGNhbGxiYWNrKGtleTApO1xuICB9XG5cbiAgLy8gIyMjIGBfbG9vcEJ5S2V5MGAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBrZXlzIG9mIGEgY2VydGFpbiBlbnRyeSBpbiBpbmRleCAwXG4gIF9sb29wQnlLZXkwKGluZGV4MCwga2V5MCwgY2FsbGJhY2spIHtcbiAgICB2YXIgaW5kZXgxLCBrZXkxO1xuICAgIGlmIChpbmRleDEgPSBpbmRleDBba2V5MF0pIHtcbiAgICAgIGZvciAoa2V5MSBpbiBpbmRleDEpXG4gICAgICAgIGNhbGxiYWNrKGtleTEpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgX2xvb3BCeUtleTFgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBnaXZlbiBrZXlzIG9mIGFsbCBlbnRyaWVzIGluIGluZGV4IDBcbiAgX2xvb3BCeUtleTEoaW5kZXgwLCBrZXkxLCBjYWxsYmFjaykge1xuICAgIHZhciBrZXkwLCBpbmRleDE7XG4gICAgZm9yIChrZXkwIGluIGluZGV4MCkge1xuICAgICAgaW5kZXgxID0gaW5kZXgwW2tleTBdO1xuICAgICAgaWYgKGluZGV4MVtrZXkxXSlcbiAgICAgICAgY2FsbGJhY2soa2V5MCk7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfbG9vcEJ5MktleXNgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBnaXZlbiBrZXlzIG9mIGNlcnRhaW4gZW50cmllcyBpbiBpbmRleCAyXG4gIF9sb29wQnkyS2V5cyhpbmRleDAsIGtleTAsIGtleTEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGluZGV4MSwgaW5kZXgyLCBrZXkyO1xuICAgIGlmICgoaW5kZXgxID0gaW5kZXgwW2tleTBdKSAmJiAoaW5kZXgyID0gaW5kZXgxW2tleTFdKSkge1xuICAgICAgZm9yIChrZXkyIGluIGluZGV4MilcbiAgICAgICAgY2FsbGJhY2soa2V5Mik7XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBfY291bnRJbkluZGV4YCBjb3VudHMgbWF0Y2hpbmcgcXVhZHMgaW4gYSB0aHJlZS1sYXllcmVkIGluZGV4LlxuICAvLyBUaGUgaW5kZXggYmFzZSBpcyBgaW5kZXgwYCBhbmQgdGhlIGtleXMgYXQgZWFjaCBsZXZlbCBhcmUgYGtleTBgLCBga2V5MWAsIGFuZCBga2V5MmAuXG4gIC8vIEFueSBvZiB0aGVzZSBrZXlzIGNhbiBiZSB1bmRlZmluZWQsIHdoaWNoIGlzIGludGVycHJldGVkIGFzIGEgd2lsZGNhcmQuXG4gIF9jb3VudEluSW5kZXgoaW5kZXgwLCBrZXkwLCBrZXkxLCBrZXkyKSB7XG4gICAgdmFyIGNvdW50ID0gMCwgdG1wLCBpbmRleDEsIGluZGV4MjtcblxuICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgY291bnQgb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMFxuICAgIGlmIChrZXkwKSAodG1wID0gaW5kZXgwLCBpbmRleDAgPSB7fSlba2V5MF0gPSB0bXBba2V5MF07XG4gICAgZm9yICh2YXIgdmFsdWUwIGluIGluZGV4MCkge1xuICAgICAgaWYgKGluZGV4MSA9IGluZGV4MFt2YWx1ZTBdKSB7XG4gICAgICAgIC8vIElmIGEga2V5IGlzIHNwZWNpZmllZCwgY291bnQgb25seSB0aGF0IHBhcnQgb2YgaW5kZXggMVxuICAgICAgICBpZiAoa2V5MSkgKHRtcCA9IGluZGV4MSwgaW5kZXgxID0ge30pW2tleTFdID0gdG1wW2tleTFdO1xuICAgICAgICBmb3IgKHZhciB2YWx1ZTEgaW4gaW5kZXgxKSB7XG4gICAgICAgICAgaWYgKGluZGV4MiA9IGluZGV4MVt2YWx1ZTFdKSB7XG4gICAgICAgICAgICAvLyBJZiBhIGtleSBpcyBzcGVjaWZpZWQsIGNvdW50IHRoZSBxdWFkIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgaWYgKGtleTIpIChrZXkyIGluIGluZGV4MikgJiYgY291bnQrKztcbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgY291bnQgYWxsIHF1YWRzXG4gICAgICAgICAgICBlbHNlIGNvdW50ICs9IE9iamVjdC5rZXlzKGluZGV4MikubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvLyAjIyMgYF9nZXRHcmFwaHNgIHJldHVybnMgYW4gYXJyYXkgd2l0aCB0aGUgZ2l2ZW4gZ3JhcGgsXG4gIC8vIG9yIGFsbCBncmFwaHMgaWYgdGhlIGFyZ3VtZW50IGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICBfZ2V0R3JhcGhzKGdyYXBoKSB7XG4gICAgaWYgKCFpc1N0cmluZyhncmFwaCkpXG4gICAgICByZXR1cm4gdGhpcy5fZ3JhcGhzO1xuICAgIHZhciBncmFwaHMgPSB7fTtcbiAgICBncmFwaHNbZ3JhcGhdID0gdGhpcy5fZ3JhcGhzW2dyYXBoXTtcbiAgICByZXR1cm4gZ3JhcGhzO1xuICB9XG5cbiAgLy8gIyMjIGBfdW5pcXVlRW50aXRpZXNgIHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYW4gZW50aXR5IElEXG4gIC8vIGFuZCBwYXNzZXMgdGhlIGNvcnJlc3BvbmRpbmcgZW50aXR5IHRvIGNhbGxiYWNrIGlmIGl0IGhhc24ndCBvY2N1cnJlZCBiZWZvcmUuXG4gIF91bmlxdWVFbnRpdGllcyhjYWxsYmFjaykge1xuICAgIHZhciB1bmlxdWVJZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpLCBlbnRpdGllcyA9IHRoaXMuX2VudGl0aWVzO1xuICAgIHJldHVybiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmICghKGlkIGluIHVuaXF1ZUlkcykpIHtcbiAgICAgICAgdW5pcXVlSWRzW2lkXSA9IHRydWU7XG4gICAgICAgIGNhbGxiYWNrKGZyb21JZChlbnRpdGllc1tpZF0pKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gIyMgUHVibGljIG1ldGhvZHNcblxuICAvLyAjIyMgYGFkZFF1YWRgIGFkZHMgYSBuZXcgcXVhZCB0byB0aGUgc3RvcmUuXG4gIC8vIFJldHVybnMgaWYgdGhlIHF1YWQgaW5kZXggaGFzIGNoYW5nZWQsIGlmIHRoZSBxdWFkIGRpZCBub3QgYWxyZWFkeSBleGlzdC5cbiAgYWRkUXVhZChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBTaGlmdCBhcmd1bWVudHMgaWYgYSBxdWFkIG9iamVjdCBpcyBnaXZlbiBpbnN0ZWFkIG9mIGNvbXBvbmVudHNcbiAgICBpZiAoIXByZWRpY2F0ZSlcbiAgICAgIGdyYXBoID0gc3ViamVjdC5ncmFwaCwgb2JqZWN0ID0gc3ViamVjdC5vYmplY3QsXG4gICAgICAgIHByZWRpY2F0ZSA9IHN1YmplY3QucHJlZGljYXRlLCBzdWJqZWN0ID0gc3ViamVjdC5zdWJqZWN0O1xuXG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBzdWJqZWN0ID0gdG9JZChzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSB0b0lkKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gdG9JZChvYmplY3QpO1xuICAgIGdyYXBoID0gdG9JZChncmFwaCk7XG5cbiAgICAvLyBGaW5kIHRoZSBncmFwaCB0aGF0IHdpbGwgY29udGFpbiB0aGUgdHJpcGxlXG4gICAgdmFyIGdyYXBoSXRlbSA9IHRoaXMuX2dyYXBoc1tncmFwaF07XG4gICAgLy8gQ3JlYXRlIHRoZSBncmFwaCBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldFxuICAgIGlmICghZ3JhcGhJdGVtKSB7XG4gICAgICBncmFwaEl0ZW0gPSB0aGlzLl9ncmFwaHNbZ3JhcGhdID0geyBzdWJqZWN0czoge30sIHByZWRpY2F0ZXM6IHt9LCBvYmplY3RzOiB7fSB9O1xuICAgICAgLy8gRnJlZXppbmcgYSBncmFwaCBoZWxwcyBzdWJzZXF1ZW50IGBhZGRgIHBlcmZvcm1hbmNlLFxuICAgICAgLy8gYW5kIHByb3BlcnRpZXMgd2lsbCBuZXZlciBiZSBtb2RpZmllZCBhbnl3YXlcbiAgICAgIE9iamVjdC5mcmVlemUoZ3JhcGhJdGVtKTtcbiAgICB9XG5cbiAgICAvLyBTaW5jZSBlbnRpdGllcyBjYW4gb2Z0ZW4gYmUgbG9uZyBJUklzLCB3ZSBhdm9pZCBzdG9yaW5nIHRoZW0gaW4gZXZlcnkgaW5kZXguXG4gICAgLy8gSW5zdGVhZCwgd2UgaGF2ZSBhIHNlcGFyYXRlIGluZGV4IHRoYXQgbWFwcyBlbnRpdGllcyB0byBudW1iZXJzLFxuICAgIC8vIHdoaWNoIGFyZSB0aGVuIHVzZWQgYXMga2V5cyBpbiB0aGUgb3RoZXIgaW5kZXhlcy5cbiAgICB2YXIgaWRzID0gdGhpcy5faWRzO1xuICAgIHZhciBlbnRpdGllcyA9IHRoaXMuX2VudGl0aWVzO1xuICAgIHN1YmplY3QgICA9IGlkc1tzdWJqZWN0XSAgIHx8IChpZHNbZW50aXRpZXNbKyt0aGlzLl9pZF0gPSBzdWJqZWN0XSAgID0gdGhpcy5faWQpO1xuICAgIHByZWRpY2F0ZSA9IGlkc1twcmVkaWNhdGVdIHx8IChpZHNbZW50aXRpZXNbKyt0aGlzLl9pZF0gPSBwcmVkaWNhdGVdID0gdGhpcy5faWQpO1xuICAgIG9iamVjdCAgICA9IGlkc1tvYmplY3RdICAgIHx8IChpZHNbZW50aXRpZXNbKyt0aGlzLl9pZF0gPSBvYmplY3RdICAgID0gdGhpcy5faWQpO1xuXG4gICAgdmFyIGNoYW5nZWQgPSB0aGlzLl9hZGRUb0luZGV4KGdyYXBoSXRlbS5zdWJqZWN0cywgICBzdWJqZWN0LCAgIHByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICB0aGlzLl9hZGRUb0luZGV4KGdyYXBoSXRlbS5wcmVkaWNhdGVzLCBwcmVkaWNhdGUsIG9iamVjdCwgICAgc3ViamVjdCk7XG4gICAgdGhpcy5fYWRkVG9JbmRleChncmFwaEl0ZW0ub2JqZWN0cywgICAgb2JqZWN0LCAgICBzdWJqZWN0LCAgIHByZWRpY2F0ZSk7XG5cbiAgICAvLyBUaGUgY2FjaGVkIHF1YWQgY291bnQgaXMgbm93IGludmFsaWRcbiAgICB0aGlzLl9zaXplID0gbnVsbDtcbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuXG4gIC8vICMjIyBgYWRkUXVhZHNgIGFkZHMgbXVsdGlwbGUgcXVhZHMgdG8gdGhlIHN0b3JlXG4gIGFkZFF1YWRzKHF1YWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMuYWRkUXVhZChxdWFkc1tpXSk7XG4gIH1cblxuICAvLyAjIyMgYGltcG9ydGAgYWRkcyBhIHN0cmVhbSBvZiBxdWFkcyB0byB0aGUgc3RvcmVcbiAgaW1wb3J0KHN0cmVhbSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAocXVhZCkgeyBzZWxmLmFkZFF1YWQocXVhZCk7IH0pO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvLyAjIyMgYHJlbW92ZVF1YWRgIHJlbW92ZXMgYSBxdWFkIGZyb20gdGhlIHN0b3JlIGlmIGl0IGV4aXN0c1xuICByZW1vdmVRdWFkKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBhIHF1YWQgb2JqZWN0IGlzIGdpdmVuIGluc3RlYWQgb2YgY29tcG9uZW50c1xuICAgIGlmICghcHJlZGljYXRlKVxuICAgICAgZ3JhcGggPSBzdWJqZWN0LmdyYXBoLCBvYmplY3QgPSBzdWJqZWN0Lm9iamVjdCxcbiAgICAgICAgcHJlZGljYXRlID0gc3ViamVjdC5wcmVkaWNhdGUsIHN1YmplY3QgPSBzdWJqZWN0LnN1YmplY3Q7XG5cbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSB0b0lkKHN1YmplY3QpO1xuICAgIHByZWRpY2F0ZSA9IHRvSWQocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSB0b0lkKG9iamVjdCk7XG4gICAgZ3JhcGggPSB0b0lkKGdyYXBoKTtcblxuICAgIC8vIEZpbmQgaW50ZXJuYWwgaWRlbnRpZmllcnMgZm9yIGFsbCBjb21wb25lbnRzXG4gICAgLy8gYW5kIHZlcmlmeSB0aGUgcXVhZCBleGlzdHMuXG4gICAgdmFyIGdyYXBoSXRlbSwgaWRzID0gdGhpcy5faWRzLCBncmFwaHMgPSB0aGlzLl9ncmFwaHMsIHN1YmplY3RzLCBwcmVkaWNhdGVzO1xuICAgIGlmICghKHN1YmplY3QgICAgPSBpZHNbc3ViamVjdF0pIHx8ICEocHJlZGljYXRlID0gaWRzW3ByZWRpY2F0ZV0pIHx8XG4gICAgICAgICEob2JqZWN0ICAgICA9IGlkc1tvYmplY3RdKSAgfHwgIShncmFwaEl0ZW0gPSBncmFwaHNbZ3JhcGhdKSAgfHxcbiAgICAgICAgIShzdWJqZWN0cyAgID0gZ3JhcGhJdGVtLnN1YmplY3RzW3N1YmplY3RdKSB8fFxuICAgICAgICAhKHByZWRpY2F0ZXMgPSBzdWJqZWN0c1twcmVkaWNhdGVdKSB8fFxuICAgICAgICAhKG9iamVjdCBpbiBwcmVkaWNhdGVzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIC8vIFJlbW92ZSBpdCBmcm9tIGFsbCBpbmRleGVzXG4gICAgdGhpcy5fcmVtb3ZlRnJvbUluZGV4KGdyYXBoSXRlbS5zdWJqZWN0cywgICBzdWJqZWN0LCAgIHByZWRpY2F0ZSwgb2JqZWN0KTtcbiAgICB0aGlzLl9yZW1vdmVGcm9tSW5kZXgoZ3JhcGhJdGVtLnByZWRpY2F0ZXMsIHByZWRpY2F0ZSwgb2JqZWN0LCAgICBzdWJqZWN0KTtcbiAgICB0aGlzLl9yZW1vdmVGcm9tSW5kZXgoZ3JhcGhJdGVtLm9iamVjdHMsICAgIG9iamVjdCwgICAgc3ViamVjdCwgICBwcmVkaWNhdGUpO1xuICAgIGlmICh0aGlzLl9zaXplICE9PSBudWxsKSB0aGlzLl9zaXplLS07XG5cbiAgICAvLyBSZW1vdmUgdGhlIGdyYXBoIGlmIGl0IGlzIGVtcHR5XG4gICAgZm9yIChzdWJqZWN0IGluIGdyYXBoSXRlbS5zdWJqZWN0cykgcmV0dXJuIHRydWU7XG4gICAgZGVsZXRlIGdyYXBoc1tncmFwaF07XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyAjIyMgYHJlbW92ZVF1YWRzYCByZW1vdmVzIG11bHRpcGxlIHF1YWRzIGZyb20gdGhlIHN0b3JlXG4gIHJlbW92ZVF1YWRzKHF1YWRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWFkcy5sZW5ndGg7IGkrKylcbiAgICAgIHRoaXMucmVtb3ZlUXVhZChxdWFkc1tpXSk7XG4gIH1cblxuICAvLyAjIyMgYHJlbW92ZWAgcmVtb3ZlcyBhIHN0cmVhbSBvZiBxdWFkcyBmcm9tIHRoZSBzdG9yZVxuICByZW1vdmUoc3RyZWFtKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChxdWFkKSB7IHNlbGYucmVtb3ZlUXVhZChxdWFkKTsgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8vICMjIyBgcmVtb3ZlTWF0Y2hlc2AgcmVtb3ZlcyBhbGwgbWF0Y2hpbmcgcXVhZHMgZnJvbSB0aGUgc3RvcmVcbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuICByZW1vdmVNYXRjaGVzKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZSh0aGlzLm1hdGNoKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkpO1xuICB9XG5cbiAgLy8gIyMjIGBkZWxldGVHcmFwaGAgcmVtb3ZlcyBhbGwgdHJpcGxlcyB3aXRoIHRoZSBnaXZlbiBncmFwaCBmcm9tIHRoZSBzdG9yZVxuICBkZWxldGVHcmFwaChncmFwaCkge1xuICAgIHJldHVybiB0aGlzLnJlbW92ZU1hdGNoZXMobnVsbCwgbnVsbCwgbnVsbCwgZ3JhcGgpO1xuICB9XG5cbiAgLy8gIyMjIGBnZXRRdWFkc2AgcmV0dXJucyBhbiBhcnJheSBvZiBxdWFkcyBtYXRjaGluZyBhIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZ2V0UXVhZHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgLy8gQ29udmVydCB0ZXJtcyB0byBpbnRlcm5hbCBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICBzdWJqZWN0ID0gc3ViamVjdCAmJiB0b0lkKHN1YmplY3QpO1xuICAgIHByZWRpY2F0ZSA9IHByZWRpY2F0ZSAmJiB0b0lkKHByZWRpY2F0ZSk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmIHRvSWQob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmIHRvSWQoZ3JhcGgpO1xuXG4gICAgdmFyIHF1YWRzID0gW10sIGdyYXBocyA9IHRoaXMuX2dldEdyYXBocyhncmFwaCksIGNvbnRlbnQsXG4gICAgICAgIGlkcyA9IHRoaXMuX2lkcywgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQ7XG5cbiAgICAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuICAgIGlmIChpc1N0cmluZyhzdWJqZWN0KSAgICYmICEoc3ViamVjdElkICAgPSBpZHNbc3ViamVjdF0pICAgfHxcbiAgICAgICAgaXNTdHJpbmcocHJlZGljYXRlKSAmJiAhKHByZWRpY2F0ZUlkID0gaWRzW3ByZWRpY2F0ZV0pIHx8XG4gICAgICAgIGlzU3RyaW5nKG9iamVjdCkgICAgJiYgIShvYmplY3RJZCAgICA9IGlkc1tvYmplY3RdKSlcbiAgICAgIHJldHVybiBxdWFkcztcblxuICAgIGZvciAodmFyIGdyYXBoSWQgaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoSWRdKSB7XG4gICAgICAgIC8vIENob29zZSB0aGUgb3B0aW1hbCBpbmRleCwgYmFzZWQgb24gd2hhdCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICAgICAgaWYgKHN1YmplY3RJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZClcbiAgICAgICAgICAgIC8vIElmIHN1YmplY3QgYW5kIG9iamVjdCBhcmUgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgICAgdGhpcy5fZmluZEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBwcmVkaWNhdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdvYmplY3QnLCAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gSWYgb25seSBzdWJqZWN0IGFuZCBwb3NzaWJseSBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgc3ViamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnN1YmplY3RzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgJ29iamVjdCcsIGdyYXBoSWQsIG51bGwsIHF1YWRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVJZClcbiAgICAgICAgICAvLyBJZiBvbmx5IHByZWRpY2F0ZSBhbmQgcG9zc2libHkgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIHByZWRpY2F0ZSBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgdGhpcy5fZmluZEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCAnc3ViamVjdCcsIGdyYXBoSWQsIG51bGwsIHF1YWRzKTtcbiAgICAgICAgZWxzZSBpZiAob2JqZWN0SWQpXG4gICAgICAgICAgLy8gSWYgb25seSBvYmplY3QgaXMgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIHRoaXMuX2ZpbmRJbkluZGV4KGNvbnRlbnQub2JqZWN0cywgb2JqZWN0SWQsIG51bGwsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsIGdyYXBoSWQsIG51bGwsIHF1YWRzKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIC8vIElmIG5vdGhpbmcgaXMgZ2l2ZW4sIGl0ZXJhdGUgc3ViamVjdHMgYW5kIHByZWRpY2F0ZXMgZmlyc3RcbiAgICAgICAgICB0aGlzLl9maW5kSW5JbmRleChjb250ZW50LnN1YmplY3RzLCBudWxsLCBudWxsLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBudWxsLCBxdWFkcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBxdWFkcztcbiAgfVxuXG4gIC8vICMjIyBgbWF0Y2hgIHJldHVybnMgYSBzdHJlYW0gb2YgcXVhZHMgbWF0Y2hpbmcgYSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG4gIG1hdGNoKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciBzdHJlYW0gPSBuZXcgUmVhZGFibGUoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgLy8gSW5pdGlhbGl6ZSBzdHJlYW0gb25jZSBpdCBpcyBiZWluZyByZWFkXG4gICAgc3RyZWFtLl9yZWFkID0gKCkgPT4ge1xuICAgICAgZm9yICh2YXIgcXVhZCBvZiB0aGlzLmdldFF1YWRzKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkpXG4gICAgICAgIHN0cmVhbS5wdXNoKHF1YWQpO1xuICAgICAgc3RyZWFtLnB1c2gobnVsbCk7XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvLyAjIyMgYGNvdW50UXVhZHNgIHJldHVybnMgdGhlIG51bWJlciBvZiBxdWFkcyBtYXRjaGluZyBhIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgY291bnRRdWFkcyhzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmIHRvSWQoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmIHRvSWQocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSBvYmplY3QgJiYgdG9JZChvYmplY3QpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgdG9JZChncmFwaCk7XG5cbiAgICB2YXIgY291bnQgPSAwLCBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLCBjb250ZW50LFxuICAgICAgICBpZHMgPSB0aGlzLl9pZHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIG9iamVjdElkO1xuXG4gICAgLy8gVHJhbnNsYXRlIElSSXMgdG8gaW50ZXJuYWwgaW5kZXgga2V5cy5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgICAmJiAhKHN1YmplY3RJZCAgID0gaWRzW3N1YmplY3RdKSAgIHx8XG4gICAgICAgIGlzU3RyaW5nKHByZWRpY2F0ZSkgJiYgIShwcmVkaWNhdGVJZCA9IGlkc1twcmVkaWNhdGVdKSB8fFxuICAgICAgICBpc1N0cmluZyhvYmplY3QpICAgICYmICEob2JqZWN0SWQgICAgPSBpZHNbb2JqZWN0XSkpXG4gICAgICByZXR1cm4gMDtcblxuICAgIGZvciAodmFyIGdyYXBoSWQgaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoSWRdKSB7XG4gICAgICAgIC8vIENob29zZSB0aGUgb3B0aW1hbCBpbmRleCwgYmFzZWQgb24gd2hhdCBmaWVsZHMgYXJlIHByZXNlbnRcbiAgICAgICAgaWYgKHN1YmplY3QpIHtcbiAgICAgICAgICBpZiAob2JqZWN0KVxuICAgICAgICAgICAgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIG9iamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBwcmVkaWNhdGVJZCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gSWYgb25seSBzdWJqZWN0IGFuZCBwb3NzaWJseSBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgc3ViamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5zdWJqZWN0cywgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZWRpY2F0ZSkge1xuICAgICAgICAgIC8vIElmIG9ubHkgcHJlZGljYXRlIGFuZCBwb3NzaWJseSBvYmplY3QgYXJlIGdpdmVuLCB0aGUgcHJlZGljYXRlIGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBjb3VudCArPSB0aGlzLl9jb3VudEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIHN1YmplY3RJZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgLy8gSWYgb25seSBvYmplY3QgaXMgcG9zc2libHkgZ2l2ZW4sIHRoZSBvYmplY3QgaW5kZXggd2lsbCBiZSB0aGUgZmFzdGVzdFxuICAgICAgICAgIGNvdW50ICs9IHRoaXMuX2NvdW50SW5JbmRleChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnQ7XG4gIH1cblxuICAvLyAjIyMgYGZvckVhY2hgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgcXVhZHMuXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZm9yRWFjaChjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdGhpcy5zb21lKGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICBjYWxsYmFjayhxdWFkKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpO1xuICB9XG5cbiAgLy8gIyMjIGBldmVyeWAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBxdWFkcyxcbiAgLy8gYW5kIHJldHVybnMgYHRydWVgIGlmIGl0IHJldHVybnMgdHJ1dGh5IGZvciBhbGwgdGhlbS5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuICBldmVyeShjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKSB7XG4gICAgdmFyIHNvbWUgPSBmYWxzZTtcbiAgICB2YXIgZXZlcnkgPSAhdGhpcy5zb21lKGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICBzb21lID0gdHJ1ZTtcbiAgICAgIHJldHVybiAhY2FsbGJhY2socXVhZCk7XG4gICAgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QsIGdyYXBoKTtcbiAgICByZXR1cm4gc29tZSAmJiBldmVyeTtcbiAgfVxuXG4gIC8vICMjIyBgc29tZWAgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBxdWFkcyxcbiAgLy8gYW5kIHJldHVybnMgYHRydWVgIGlmIGl0IHJldHVybnMgdHJ1dGh5IGZvciBhbnkgb2YgdGhlbS5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuICBzb21lKGNhbGxiYWNrLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmIHRvSWQoc3ViamVjdCk7XG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmIHRvSWQocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSBvYmplY3QgJiYgdG9JZChvYmplY3QpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgdG9JZChncmFwaCk7XG5cbiAgICB2YXIgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSwgY29udGVudCxcbiAgICAgICAgaWRzID0gdGhpcy5faWRzLCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkLCBvYmplY3RJZDtcblxuICAgIC8vIFRyYW5zbGF0ZSBJUklzIHRvIGludGVybmFsIGluZGV4IGtleXMuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICAgJiYgIShzdWJqZWN0SWQgICA9IGlkc1tzdWJqZWN0XSkgICB8fFxuICAgICAgICBpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkgfHxcbiAgICAgICAgaXNTdHJpbmcob2JqZWN0KSAgICAmJiAhKG9iamVjdElkICAgID0gaWRzW29iamVjdF0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yICh2YXIgZ3JhcGhJZCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhJZF0pIHtcbiAgICAgICAgLy8gQ2hvb3NlIHRoZSBvcHRpbWFsIGluZGV4LCBiYXNlZCBvbiB3aGF0IGZpZWxkcyBhcmUgcHJlc2VudFxuICAgICAgICBpZiAoc3ViamVjdElkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdElkKSB7XG4gICAgICAgICAgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIG9iamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBwcmVkaWNhdGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnb2JqZWN0JywgJ3N1YmplY3QnLCAncHJlZGljYXRlJywgZ3JhcGhJZCwgY2FsbGJhY2ssIG51bGwpKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gSWYgb25seSBzdWJqZWN0IGFuZCBwb3NzaWJseSBwcmVkaWNhdGUgYXJlIGdpdmVuLCB0aGUgc3ViamVjdCBpbmRleCB3aWxsIGJlIHRoZSBmYXN0ZXN0XG4gICAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5zdWJqZWN0cywgc3ViamVjdElkLCBwcmVkaWNhdGVJZCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3ViamVjdCcsICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgZ3JhcGhJZCwgY2FsbGJhY2ssIG51bGwpKVxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVJZCkge1xuICAgICAgICAgIC8vIElmIG9ubHkgcHJlZGljYXRlIGFuZCBwb3NzaWJseSBvYmplY3QgYXJlIGdpdmVuLCB0aGUgcHJlZGljYXRlIGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwcmVkaWNhdGUnLCAnb2JqZWN0JywgJ3N1YmplY3QnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvYmplY3RJZCkge1xuICAgICAgICAgIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgb2JqZWN0IGluZGV4IHdpbGwgYmUgdGhlIGZhc3Rlc3RcbiAgICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29iamVjdCcsICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsIGdyYXBoSWQsIGNhbGxiYWNrLCBudWxsKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgLy8gSWYgbm90aGluZyBpcyBnaXZlbiwgaXRlcmF0ZSBzdWJqZWN0cyBhbmQgcHJlZGljYXRlcyBmaXJzdFxuICAgICAgICBpZiAodGhpcy5fZmluZEluSW5kZXgoY29udGVudC5zdWJqZWN0cywgbnVsbCwgbnVsbCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdWJqZWN0JywgJ3ByZWRpY2F0ZScsICdvYmplY3QnLCBncmFwaElkLCBjYWxsYmFjaywgbnVsbCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyAjIyMgYGdldFN1YmplY3RzYCByZXR1cm5zIGFsbCBzdWJqZWN0cyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG4gIGdldFN1YmplY3RzKHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdGhpcy5mb3JTdWJqZWN0cyhmdW5jdGlvbiAocykgeyByZXN1bHRzLnB1c2gocyk7IH0sIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyAjIyMgYGZvclN1YmplY3RzYCBleGVjdXRlcyB0aGUgY2FsbGJhY2sgb24gYWxsIHN1YmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZm9yU3ViamVjdHMoY2FsbGJhY2ssIHByZWRpY2F0ZSwgb2JqZWN0LCBncmFwaCkge1xuICAgIC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgcHJlZGljYXRlID0gcHJlZGljYXRlICYmIHRvSWQocHJlZGljYXRlKTtcbiAgICBvYmplY3QgPSBvYmplY3QgJiYgdG9JZChvYmplY3QpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgdG9JZChncmFwaCk7XG5cbiAgICB2YXIgaWRzID0gdGhpcy5faWRzLCBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLCBjb250ZW50LCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQ7XG4gICAgY2FsbGJhY2sgPSB0aGlzLl91bmlxdWVFbnRpdGllcyhjYWxsYmFjayk7XG5cbiAgICAvLyBUcmFuc2xhdGUgSVJJcyB0byBpbnRlcm5hbCBpbmRleCBrZXlzLlxuICAgIGlmIChpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkgfHxcbiAgICAgICAgaXNTdHJpbmcob2JqZWN0KSAgICAmJiAhKG9iamVjdElkICAgID0gaWRzW29iamVjdF0pKVxuICAgICAgcmV0dXJuO1xuXG4gICAgZm9yIChncmFwaCBpbiBncmFwaHMpIHtcbiAgICAgIC8vIE9ubHkgaWYgdGhlIHNwZWNpZmllZCBncmFwaCBjb250YWlucyB0cmlwbGVzLCB0aGVyZSBjYW4gYmUgcmVzdWx0c1xuICAgICAgaWYgKGNvbnRlbnQgPSBncmFwaHNbZ3JhcGhdKSB7XG4gICAgICAgIC8vIENob29zZSBvcHRpbWFsIGluZGV4IGJhc2VkIG9uIHdoaWNoIGZpZWxkcyBhcmUgd2lsZGNhcmRzXG4gICAgICAgIGlmIChwcmVkaWNhdGVJZCkge1xuICAgICAgICAgIGlmIChvYmplY3RJZClcbiAgICAgICAgICAgIC8vIElmIHByZWRpY2F0ZSBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIFBPUyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5MktleXMoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgb2JqZWN0SWQsIGNhbGxiYWNrKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAvLyBJZiBvbmx5IHByZWRpY2F0ZSBpcyBnaXZlbiwgdGhlIFNQTyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MShjb250ZW50LnN1YmplY3RzLCBwcmVkaWNhdGVJZCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iamVjdElkKVxuICAgICAgICAgIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgT1NQIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MChjb250ZW50Lm9iamVjdHMsIG9iamVjdElkLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAvLyBJZiBubyBwYXJhbXMgZ2l2ZW4sIGl0ZXJhdGUgYWxsIHRoZSBzdWJqZWN0c1xuICAgICAgICAgIHRoaXMuX2xvb3AoY29udGVudC5zdWJqZWN0cywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgZ2V0UHJlZGljYXRlc2AgcmV0dXJucyBhbGwgcHJlZGljYXRlcyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG4gIGdldFByZWRpY2F0ZXMoc3ViamVjdCwgb2JqZWN0LCBncmFwaCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdGhpcy5mb3JQcmVkaWNhdGVzKGZ1bmN0aW9uIChwKSB7IHJlc3VsdHMucHVzaChwKTsgfSwgc3ViamVjdCwgb2JqZWN0LCBncmFwaCk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxuICAvLyAjIyMgYGZvclByZWRpY2F0ZXNgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgcHJlZGljYXRlcyB0aGF0IG1hdGNoIHRoZSBwYXR0ZXJuLlxuICAvLyBTZXR0aW5nIGFueSBmaWVsZCB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW5kaWNhdGVzIGEgd2lsZGNhcmQuXG4gIGZvclByZWRpY2F0ZXMoY2FsbGJhY2ssIHN1YmplY3QsIG9iamVjdCwgZ3JhcGgpIHtcbiAgICAvLyBDb252ZXJ0IHRlcm1zIHRvIGludGVybmFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgIHN1YmplY3QgPSBzdWJqZWN0ICYmIHRvSWQoc3ViamVjdCk7XG4gICAgb2JqZWN0ID0gb2JqZWN0ICYmIHRvSWQob2JqZWN0KTtcbiAgICBncmFwaCA9IGdyYXBoICYmIHRvSWQoZ3JhcGgpO1xuXG4gICAgdmFyIGlkcyA9IHRoaXMuX2lkcywgZ3JhcGhzID0gdGhpcy5fZ2V0R3JhcGhzKGdyYXBoKSwgY29udGVudCwgc3ViamVjdElkLCBvYmplY3RJZDtcbiAgICBjYWxsYmFjayA9IHRoaXMuX3VuaXF1ZUVudGl0aWVzKGNhbGxiYWNrKTtcblxuICAgIC8vIFRyYW5zbGF0ZSBJUklzIHRvIGludGVybmFsIGluZGV4IGtleXMuXG4gICAgaWYgKGlzU3RyaW5nKHN1YmplY3QpICYmICEoc3ViamVjdElkID0gaWRzW3N1YmplY3RdKSB8fFxuICAgICAgICBpc1N0cmluZyhvYmplY3QpICAmJiAhKG9iamVjdElkICA9IGlkc1tvYmplY3RdKSlcbiAgICAgIHJldHVybjtcblxuICAgIGZvciAoZ3JhcGggaW4gZ3JhcGhzKSB7XG4gICAgICAvLyBPbmx5IGlmIHRoZSBzcGVjaWZpZWQgZ3JhcGggY29udGFpbnMgdHJpcGxlcywgdGhlcmUgY2FuIGJlIHJlc3VsdHNcbiAgICAgIGlmIChjb250ZW50ID0gZ3JhcGhzW2dyYXBoXSkge1xuICAgICAgICAvLyBDaG9vc2Ugb3B0aW1hbCBpbmRleCBiYXNlZCBvbiB3aGljaCBmaWVsZHMgYXJlIHdpbGRjYXJkc1xuICAgICAgICBpZiAoc3ViamVjdElkKSB7XG4gICAgICAgICAgaWYgKG9iamVjdElkKVxuICAgICAgICAgICAgLy8gSWYgc3ViamVjdCBhbmQgb2JqZWN0IGFyZSBnaXZlbiwgdGhlIE9TUCBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgICAgdGhpcy5fbG9vcEJ5MktleXMoY29udGVudC5vYmplY3RzLCBvYmplY3RJZCwgc3ViamVjdElkLCBjYWxsYmFjayk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gSWYgb25seSBzdWJqZWN0IGlzIGdpdmVuLCB0aGUgU1BPIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgICB0aGlzLl9sb29wQnlLZXkwKGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9iamVjdElkKVxuICAgICAgICAgIC8vIElmIG9ubHkgb2JqZWN0IGlzIGdpdmVuLCB0aGUgUE9TIGluZGV4IGlzIGJlc3QuXG4gICAgICAgICAgdGhpcy5fbG9vcEJ5S2V5MShjb250ZW50LnByZWRpY2F0ZXMsIG9iamVjdElkLCBjYWxsYmFjayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAvLyBJZiBubyBwYXJhbXMgZ2l2ZW4sIGl0ZXJhdGUgYWxsIHRoZSBwcmVkaWNhdGVzLlxuICAgICAgICAgIHRoaXMuX2xvb3AoY29udGVudC5wcmVkaWNhdGVzLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gIyMjIGBnZXRPYmplY3RzYCByZXR1cm5zIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZ2V0T2JqZWN0cyhzdWJqZWN0LCBwcmVkaWNhdGUsIGdyYXBoKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB0aGlzLmZvck9iamVjdHMoZnVuY3Rpb24gKG8pIHsgcmVzdWx0cy5wdXNoKG8pOyB9LCBzdWJqZWN0LCBwcmVkaWNhdGUsIGdyYXBoKTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8vICMjIyBgZm9yT2JqZWN0c2AgZXhlY3V0ZXMgdGhlIGNhbGxiYWNrIG9uIGFsbCBvYmplY3RzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZm9yT2JqZWN0cyhjYWxsYmFjaywgc3ViamVjdCwgcHJlZGljYXRlLCBncmFwaCkge1xuICAgIC8vIENvbnZlcnQgdGVybXMgdG8gaW50ZXJuYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgc3ViamVjdCA9IHN1YmplY3QgJiYgdG9JZChzdWJqZWN0KTtcbiAgICBwcmVkaWNhdGUgPSBwcmVkaWNhdGUgJiYgdG9JZChwcmVkaWNhdGUpO1xuICAgIGdyYXBoID0gZ3JhcGggJiYgdG9JZChncmFwaCk7XG5cbiAgICB2YXIgaWRzID0gdGhpcy5faWRzLCBncmFwaHMgPSB0aGlzLl9nZXRHcmFwaHMoZ3JhcGgpLCBjb250ZW50LCBzdWJqZWN0SWQsIHByZWRpY2F0ZUlkO1xuICAgIGNhbGxiYWNrID0gdGhpcy5fdW5pcXVlRW50aXRpZXMoY2FsbGJhY2spO1xuXG4gICAgLy8gVHJhbnNsYXRlIElSSXMgdG8gaW50ZXJuYWwgaW5kZXgga2V5cy5cbiAgICBpZiAoaXNTdHJpbmcoc3ViamVjdCkgICAmJiAhKHN1YmplY3RJZCAgID0gaWRzW3N1YmplY3RdKSB8fFxuICAgICAgICBpc1N0cmluZyhwcmVkaWNhdGUpICYmICEocHJlZGljYXRlSWQgPSBpZHNbcHJlZGljYXRlXSkpXG4gICAgICByZXR1cm47XG5cbiAgICBmb3IgKGdyYXBoIGluIGdyYXBocykge1xuICAgICAgLy8gT25seSBpZiB0aGUgc3BlY2lmaWVkIGdyYXBoIGNvbnRhaW5zIHRyaXBsZXMsIHRoZXJlIGNhbiBiZSByZXN1bHRzXG4gICAgICBpZiAoY29udGVudCA9IGdyYXBoc1tncmFwaF0pIHtcbiAgICAgICAgLy8gQ2hvb3NlIG9wdGltYWwgaW5kZXggYmFzZWQgb24gd2hpY2ggZmllbGRzIGFyZSB3aWxkY2FyZHNcbiAgICAgICAgaWYgKHN1YmplY3RJZCkge1xuICAgICAgICAgIGlmIChwcmVkaWNhdGVJZClcbiAgICAgICAgICAgIC8vIElmIHN1YmplY3QgYW5kIHByZWRpY2F0ZSBhcmUgZ2l2ZW4sIHRoZSBTUE8gaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeTJLZXlzKGNvbnRlbnQuc3ViamVjdHMsIHN1YmplY3RJZCwgcHJlZGljYXRlSWQsIGNhbGxiYWNrKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAvLyBJZiBvbmx5IHN1YmplY3QgaXMgZ2l2ZW4sIHRoZSBPU1AgaW5kZXggaXMgYmVzdC5cbiAgICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTEoY29udGVudC5vYmplY3RzLCBzdWJqZWN0SWQsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmVkaWNhdGVJZClcbiAgICAgICAgICAvLyBJZiBvbmx5IHByZWRpY2F0ZSBpcyBnaXZlbiwgdGhlIFBPUyBpbmRleCBpcyBiZXN0LlxuICAgICAgICAgIHRoaXMuX2xvb3BCeUtleTAoY29udGVudC5wcmVkaWNhdGVzLCBwcmVkaWNhdGVJZCwgY2FsbGJhY2spO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgLy8gSWYgbm8gcGFyYW1zIGdpdmVuLCBpdGVyYXRlIGFsbCB0aGUgb2JqZWN0cy5cbiAgICAgICAgICB0aGlzLl9sb29wKGNvbnRlbnQub2JqZWN0cywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgZ2V0R3JhcGhzYCByZXR1cm5zIGFsbCBncmFwaHMgdGhhdCBtYXRjaCB0aGUgcGF0dGVybi5cbiAgLy8gU2V0dGluZyBhbnkgZmllbGQgdG8gYHVuZGVmaW5lZGAgb3IgYG51bGxgIGluZGljYXRlcyBhIHdpbGRjYXJkLlxuICBnZXRHcmFwaHMoc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHRoaXMuZm9yR3JhcGhzKGZ1bmN0aW9uIChnKSB7IHJlc3VsdHMucHVzaChnKTsgfSwgc3ViamVjdCwgcHJlZGljYXRlLCBvYmplY3QpO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgLy8gIyMjIGBmb3JHcmFwaHNgIGV4ZWN1dGVzIHRoZSBjYWxsYmFjayBvbiBhbGwgZ3JhcGhzIHRoYXQgbWF0Y2ggdGhlIHBhdHRlcm4uXG4gIC8vIFNldHRpbmcgYW55IGZpZWxkIHRvIGB1bmRlZmluZWRgIG9yIGBudWxsYCBpbmRpY2F0ZXMgYSB3aWxkY2FyZC5cbiAgZm9yR3JhcGhzKGNhbGxiYWNrLCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIGZvciAodmFyIGdyYXBoIGluIHRoaXMuX2dyYXBocykge1xuICAgICAgdGhpcy5zb21lKGZ1bmN0aW9uIChxdWFkKSB7XG4gICAgICAgIGNhbGxiYWNrKHF1YWQuZ3JhcGgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gSGFsdCBpdGVyYXRpb24gb2Ygc29tZSgpXG4gICAgICB9LCBzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpO1xuICAgIH1cbiAgfVxuXG4gIC8vICMjIyBgY3JlYXRlQmxhbmtOb2RlYCBjcmVhdGVzIGEgbmV3IGJsYW5rIG5vZGUsIHJldHVybmluZyBpdHMgbmFtZVxuICBjcmVhdGVCbGFua05vZGUoc3VnZ2VzdGVkTmFtZSkge1xuICAgIHZhciBuYW1lLCBpbmRleDtcbiAgICAvLyBHZW5lcmF0ZSBhIG5hbWUgYmFzZWQgb24gdGhlIHN1Z2dlc3RlZCBuYW1lXG4gICAgaWYgKHN1Z2dlc3RlZE5hbWUpIHtcbiAgICAgIG5hbWUgPSBzdWdnZXN0ZWROYW1lID0gJ186JyArIHN1Z2dlc3RlZE5hbWUsIGluZGV4ID0gMTtcbiAgICAgIHdoaWxlICh0aGlzLl9pZHNbbmFtZV0pXG4gICAgICAgIG5hbWUgPSBzdWdnZXN0ZWROYW1lICsgaW5kZXgrKztcbiAgICB9XG4gICAgLy8gR2VuZXJhdGUgYSBnZW5lcmljIGJsYW5rIG5vZGUgbmFtZVxuICAgIGVsc2Uge1xuICAgICAgZG8geyBuYW1lID0gJ186YicgKyB0aGlzLl9ibGFua05vZGVJbmRleCsrOyB9XG4gICAgICB3aGlsZSAodGhpcy5faWRzW25hbWVdKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBibGFuayBub2RlIHRvIHRoZSBlbnRpdGllcywgYXZvaWRpbmcgdGhlIGdlbmVyYXRpb24gb2YgZHVwbGljYXRlc1xuICAgIHRoaXMuX2lkc1tuYW1lXSA9ICsrdGhpcy5faWQ7XG4gICAgdGhpcy5fZW50aXRpZXNbdGhpcy5faWRdID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZmFjdG9yeS5ibGFua05vZGUobmFtZS5zdWJzdHIoMikpO1xuICB9XG5cbiAgLy8gIyMjIGBleHRyYWN0TGlzdHNgIGZpbmRzIGFuZCByZW1vdmVzIGFsbCBsaXN0IHRyaXBsZXNcbiAgLy8gYW5kIHJldHVybnMgdGhlIGl0ZW1zIHBlciBsaXN0LlxuICBleHRyYWN0TGlzdHMoeyByZW1vdmUgPSBmYWxzZSwgaWdub3JlRXJyb3JzID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgdmFyIGxpc3RzID0ge307IC8vIGhhcyBzY2FsYXIga2V5cyBzbyBjb3VsZCBiZSBhIHNpbXBsZSBPYmplY3RcbiAgICB2YXIgb25FcnJvciA9IGlnbm9yZUVycm9ycyA/ICgoKSA9PiB0cnVlKSA6XG4gICAgICAgICAgICAgICAgICAoKG5vZGUsIG1lc3NhZ2UpID0+IHsgdGhyb3cgbmV3IEVycm9yKGAke25vZGUudmFsdWV9ICR7bWVzc2FnZX1gKTsgfSk7XG5cbiAgICAvLyBUcmF2ZXJzZSBlYWNoIGxpc3QgZnJvbSBpdHMgdGFpbFxuICAgIHZhciB0YWlscyA9IHRoaXMuZ2V0UXVhZHMobnVsbCwgbmFtZXNwYWNlcy5yZGYucmVzdCwgbmFtZXNwYWNlcy5yZGYubmlsLCBudWxsKTtcbiAgICB2YXIgdG9SZW1vdmUgPSByZW1vdmUgPyBbLi4udGFpbHNdIDogW107XG4gICAgdGFpbHMuZm9yRWFjaCh0YWlsUXVhZCA9PiB7XG4gICAgICB2YXIgaXRlbXMgPSBbXTsgICAgICAgICAgICAgLy8gdGhlIG1lbWJlcnMgZm91bmQgYXMgb2JqZWN0cyBvZiByZGY6Zmlyc3QgcXVhZHNcbiAgICAgIHZhciBtYWxmb3JtZWQgPSBmYWxzZTsgICAgICAvLyBzaWduYWxzIHdoZXRoZXIgdGhlIGN1cnJlbnQgbGlzdCBpcyBtYWxmb3JtZWRcbiAgICAgIHZhciBoZWFkOyAgICAgICAgICAgICAgICAgICAvLyB0aGUgaGVhZCBvZiB0aGUgbGlzdCAoXzpiMSBpbiBhYm92ZSBleGFtcGxlKVxuICAgICAgdmFyIGhlYWRQb3M7ICAgICAgICAgICAgICAgIC8vIHNldCB0byBzdWJqZWN0IG9yIG9iamVjdCB3aGVuIGhlYWQgaXMgc2V0XG4gICAgICB2YXIgZ3JhcGggPSB0YWlsUXVhZC5ncmFwaDsgLy8gbWFrZSBzdXJlIGxpc3QgaXMgaW4gZXhhY3RseSBvbmUgZ3JhcGhcblxuICAgICAgLy8gVHJhdmVyc2UgdGhlIGxpc3QgZnJvbSB0YWlsIHRvIGVuZFxuICAgICAgdmFyIGN1cnJlbnQgPSB0YWlsUXVhZC5zdWJqZWN0O1xuICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgIW1hbGZvcm1lZCkge1xuICAgICAgICB2YXIgb2JqZWN0UXVhZHMgPSB0aGlzLmdldFF1YWRzKG51bGwsIG51bGwsIGN1cnJlbnQsIG51bGwpO1xuICAgICAgICB2YXIgc3ViamVjdFF1YWRzID0gdGhpcy5nZXRRdWFkcyhjdXJyZW50LCBudWxsLCBudWxsLCBudWxsKTtcbiAgICAgICAgdmFyIGksIHF1YWQsIGZpcnN0ID0gbnVsbCwgcmVzdCA9IG51bGwsIHBhcmVudCA9IG51bGw7XG5cbiAgICAgICAgLy8gRmluZCB0aGUgZmlyc3QgYW5kIHJlc3Qgb2YgdGhpcyBsaXN0IG5vZGVcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHN1YmplY3RRdWFkcy5sZW5ndGggJiYgIW1hbGZvcm1lZDsgaSsrKSB7XG4gICAgICAgICAgcXVhZCA9IHN1YmplY3RRdWFkc1tpXTtcbiAgICAgICAgICBpZiAoIXF1YWQuZ3JhcGguZXF1YWxzKGdyYXBoKSlcbiAgICAgICAgICAgIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ25vdCBjb25maW5lZCB0byBzaW5nbGUgZ3JhcGgnKTtcbiAgICAgICAgICBlbHNlIGlmIChoZWFkKVxuICAgICAgICAgICAgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIG5vbi1saXN0IGFyY3Mgb3V0Jyk7XG5cbiAgICAgICAgICAvLyBvbmUgcmRmOmZpcnN0XG4gICAgICAgICAgZWxzZSBpZiAocXVhZC5wcmVkaWNhdGUudmFsdWUgPT09IG5hbWVzcGFjZXMucmRmLmZpcnN0KSB7XG4gICAgICAgICAgICBpZiAoZmlyc3QpXG4gICAgICAgICAgICAgIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2hhcyBtdWx0aXBsZSByZGY6Zmlyc3QgYXJjcycpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKGZpcnN0ID0gcXVhZCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gb25lIHJkZjpyZXN0XG4gICAgICAgICAgZWxzZSBpZiAocXVhZC5wcmVkaWNhdGUudmFsdWUgPT09IG5hbWVzcGFjZXMucmRmLnJlc3QpIHtcbiAgICAgICAgICAgIGlmIChyZXN0KVxuICAgICAgICAgICAgICBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdoYXMgbXVsdGlwbGUgcmRmOnJlc3QgYXJjcycpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB0b1JlbW92ZS5wdXNoKHJlc3QgPSBxdWFkKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBhbGllbiB0cmlwbGVcbiAgICAgICAgICBlbHNlIGlmIChvYmplY3RRdWFkcy5sZW5ndGgpXG4gICAgICAgICAgICBtYWxmb3JtZWQgPSBvbkVycm9yKGN1cnJlbnQsICdjYW5cXCd0IGJlIHN1YmplY3QgYW5kIG9iamVjdCcpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZCA9IHF1YWQ7IC8vIGUuZy4geyAoMSAyIDMpIDpwIDpvIH1cbiAgICAgICAgICAgIGhlYWRQb3MgPSAnc3ViamVjdCc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8geyA6cyA6cCAoMSAyKSB9IGFycml2ZXMgaGVyZSB3aXRoIG5vIGhlYWRcbiAgICAgICAgLy8geyAoMSAyKSA6cCA6byB9IGFycml2ZXMgaGVyZSB3aXRoIGhlYWQgc2V0IHRvIHRoZSBsaXN0LlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgb2JqZWN0UXVhZHMubGVuZ3RoICYmICFtYWxmb3JtZWQ7ICsraSkge1xuICAgICAgICAgIHF1YWQgPSBvYmplY3RRdWFkc1tpXTtcbiAgICAgICAgICBpZiAoaGVhZClcbiAgICAgICAgICAgIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2NhblxcJ3QgaGF2ZSBjb3JlZmVyZW5jZXMnKTtcbiAgICAgICAgICAvLyBvbmUgcmRmOnJlc3RcbiAgICAgICAgICBlbHNlIGlmIChxdWFkLnByZWRpY2F0ZS52YWx1ZSA9PT0gbmFtZXNwYWNlcy5yZGYucmVzdCkge1xuICAgICAgICAgICAgaWYgKHBhcmVudClcbiAgICAgICAgICAgICAgbWFsZm9ybWVkID0gb25FcnJvcihjdXJyZW50LCAnaGFzIGluY29taW5nIHJkZjpyZXN0IGFyY3MnKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgcGFyZW50ID0gcXVhZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoZWFkID0gcXVhZDsgLy8gZS5nLiB7IDpzIDpwICgxIDIpIH1cbiAgICAgICAgICAgIGhlYWRQb3MgPSAnb2JqZWN0JztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSB0aGUgbGlzdCBpdGVtIGFuZCBjb250aW51ZSB3aXRoIHBhcmVudFxuICAgICAgICBpZiAoIWZpcnN0KVxuICAgICAgICAgIG1hbGZvcm1lZCA9IG9uRXJyb3IoY3VycmVudCwgJ2hhcyBubyBsaXN0IGhlYWQnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGl0ZW1zLnVuc2hpZnQoZmlyc3Qub2JqZWN0KTtcbiAgICAgICAgY3VycmVudCA9IHBhcmVudCAmJiBwYXJlbnQuc3ViamVjdDtcbiAgICAgIH1cblxuICAgICAgLy8gRG9uJ3QgcmVtb3ZlIGFueSBxdWFkcyBpZiB0aGUgbGlzdCBpcyBtYWxmb3JtZWRcbiAgICAgIGlmIChtYWxmb3JtZWQpXG4gICAgICAgIHJlbW92ZSA9IGZhbHNlO1xuICAgICAgLy8gU3RvcmUgdGhlIGxpc3QgdW5kZXIgdGhlIHZhbHVlIG9mIGl0cyBoZWFkXG4gICAgICBlbHNlIGlmIChoZWFkKVxuICAgICAgICBsaXN0c1toZWFkW2hlYWRQb3NdLnZhbHVlXSA9IGl0ZW1zO1xuICAgIH0pO1xuXG4gICAgLy8gUmVtb3ZlIGxpc3QgcXVhZHMgaWYgcmVxdWVzdGVkXG4gICAgaWYgKHJlbW92ZSlcbiAgICAgIHRoaXMucmVtb3ZlUXVhZHModG9SZW1vdmUpO1xuICAgIHJldHVybiBsaXN0cztcbiAgfVxufVxuXG4vLyBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGFyZ3VtZW50IGlzIGEgc3RyaW5nXG5mdW5jdGlvbiBpc1N0cmluZyhzKSB7XG4gIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgcyBpbnN0YW5jZW9mIFN0cmluZztcbn1cbiIsImltcG9ydCBMaW5rSGVhZGVyIGZyb20gJ2h0dHAtbGluay1oZWFkZXInO1xuaW1wb3J0IFNvbGlkQXV0aENsaWVudCBmcm9tICdzb2xpZC1hdXRoLWNsaWVudCc7XG5pbXBvcnQgeyBXcml0ZXIsIERhdGFGYWN0b3J5IGFzIERhdGFGYWN0b3J5JDEsIFBhcnNlciwgU3RvcmUgfSBmcm9tICduMyc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gcXVhZHMgVHJpcGxlcyB0aGF0IHNob3VsZCBiZSBzZXJpYWxpc2VkIHRvIFR1cnRsZVxyXG4gKiBAaW50ZXJuYWwgVXRpbGl0eSBtZXRob2QgZm9yIGludGVybmFsIHVzZSBieSBUcmlwbGVkb2M7IG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLlxyXG4gKi9cclxuZnVuY3Rpb24gdHJpcGxlc1RvVHVydGxlKHF1YWRzKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdCwgd3JpdGVyLCB0cmlwbGVzLCB3cml0ZVByb21pc2UsIHJhd1R1cnRsZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQgPSAndGV4dC90dXJ0bGUnO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlciA9IG5ldyBXcml0ZXIoeyBmb3JtYXQ6IGZvcm1hdCB9KTtcclxuICAgICAgICAgICAgICAgICAgICB0cmlwbGVzID0gcXVhZHMubWFwKGZ1bmN0aW9uIChxdWFkKSB7IHJldHVybiBEYXRhRmFjdG9yeSQxLnRyaXBsZShxdWFkLnN1YmplY3QsIHF1YWQucHJlZGljYXRlLCBxdWFkLm9iamVjdCk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlci5hZGRRdWFkcyh0cmlwbGVzKTtcclxuICAgICAgICAgICAgICAgICAgICB3cml0ZVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci5lbmQoZnVuY3Rpb24gKGVycm9yLCByZXN1bHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiBbbjMuanMgZG9lc24ndCBhY3R1YWxseSBwYXNzIGFuIGVycm9yIG5vciBhIHJlc3VsdCwgYXBwYXJlbnRseTogaHR0cHM6Ly9naXRodWIuY29tL3JkZmpzL04zLmpzL2Jsb2IvNjI2ODJlNDhjMDJkODk2NWI0ZDcyOGNiNWYyY2JlYzZiNWQxYjFiOC9zcmMvTjNXcml0ZXIuanMjTDI5MF0gKi9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB3cml0ZVByb21pc2VdO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJhd1R1cnRsZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmF3VHVydGxlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSByYXcgVHVydGxlIHRoYXQgc2hvdWxkIGJlIHBhcnNlZCBpbnRvIFRyaXBsZXNcclxuICogQGludGVybmFsIFV0aWxpdHkgbWV0aG9kIGZvciBpbnRlcm5hbCB1c2UgYnkgVHJpcGxlZG9jOyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIHR1cnRsZVRvVHJpcGxlcyhyYXcsIGRvY3VtZW50UmVmKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGZvcm1hdCwgcGFyc2VyLCBwYXJzaW5nUHJvbWlzZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIGZvcm1hdCA9ICd0ZXh0L3R1cnRsZSc7XHJcbiAgICAgICAgICAgIHBhcnNlciA9IG5ldyBQYXJzZXIoeyBmb3JtYXQ6IGZvcm1hdCwgYmFzZUlSSTogZG9jdW1lbnRSZWYgfSk7XHJcbiAgICAgICAgICAgIHBhcnNpbmdQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBhcnNlZFRyaXBsZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgIHBhcnNlci5wYXJzZShyYXcsIGZ1bmN0aW9uIChlcnJvciwgdHJpcGxlLCBfcHJlZml4ZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmlwbGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkVHJpcGxlcy5wdXNoKHRyaXBsZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBhcnNlZFRyaXBsZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHBhcnNpbmdQcm9taXNlXTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbi8qKlxyXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIHRoYXQgZ2V0cyBUcmlwbGVzIGxvY2F0ZWQgYXQgYSBVUkxcclxuICpcclxuICogQHBhcmFtIHVybCBMb2NhdGlvbiBvZiB0aGUgRG9jdW1lbnQgY29udGFpbnMgdGhlIFRyaXBsZXMuXHJcbiAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBUcmlwbGVzXHJcbiAqIEBpbnRlcm5hbCBTaG91bGQgbm90IGJlIHVzZWQgYnkgbGlicmFyeSBjb25zdW1lcnMgZGlyZWN0bHkuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBKdXN0IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBzb2xpZC1hdXRoLWNsaWVudCwgeWV0IGN1bWJlcnNvbWUgdG8gdGVzdCBkdWUgdG8gc2lkZSBlZmZlY3RzICovXHJcbmZ1bmN0aW9uIGdldCh1cmwpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmVzcG9uc2U7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIFNvbGlkQXV0aENsaWVudC5mZXRjaCh1cmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQWNjZXB0OiAndGV4dC90dXJ0bGUnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgcmVzcG9uc2VdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogVXRpbGl0eSBmdW5jdGlvbiB0aGF0IGdldHMgYSBVUkwncyBtZXRhZGF0YVxyXG4gKlxyXG4gKiBAcGFyYW0gdXJsIExvY2F0aW9uIG9mIHRoZSBEb2N1bWVudCB0byBnZXQgdGhlIG1ldGFkYXRhIG9mXHJcbiAqIEByZXR1cm5zIFByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBSZXNwb25zZVxyXG4gKiBAaW50ZXJuYWwgU2hvdWxkIG5vdCBiZSB1c2VkIGJ5IGxpYnJhcnkgY29uc3VtZXJzIGRpcmVjdGx5LlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgSnVzdCBhIHRoaW4gd3JhcHBlciBhcm91bmQgc29saWQtYXV0aC1jbGllbnQsIHlldCBjdW1iZXJzb21lIHRvIHRlc3QgZHVlIHRvIHNpZGUgZWZmZWN0cyAqL1xyXG5mdW5jdGlvbiBoZWFkKHVybCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgU29saWRBdXRoQ2xpZW50LmZldGNoKHVybCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdIRUFEJyxcclxuICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBzZW5kcyBhIFBBVENIIHJlcXVlc3QgdG8gdGhlIFBvZCB0byB1cGRhdGUgYSBEb2N1bWVudFxyXG4gKlxyXG4gKiBAcGFyYW0gdXJsIExvY2F0aW9uIG9mIHRoZSBEb2N1bWVudCB0aGF0IGNvbnRhaW5zIHRoZSBUcmlwbGVzIHRvIGRlbGV0ZSwgYW5kIHNob3VsZCBoYXZlIHRoZSBUcmlwbGVzIHRvIGFkZC5cclxuICogQHBhcmFtIHRyaXBsZXNUb0RlbGV0ZSBUcmlwbGVzIGN1cnJlbnRseSBwcmVzZW50IG9uIHRoZSBQb2QgdGhhdCBzaG91bGQgYmUgZGVsZXRlZC5cclxuICogQHBhcmFtIHRyaXBsZXNUb0FkZCBUcmlwbGVzIG5vdCBjdXJyZW50bHkgcHJlc2VudCBvbiB0aGUgUG9kIHRoYXQgc2hvdWxkIGJlIGFkZGVkLlxyXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgdXBkYXRlIHdhcyBleGVjdXRlZCBzdWNjZXNzZnVsbHksIGFuZCByZWplY3RzIGlmIG5vdC5cclxuICogQGludGVybmFsIFNob3VsZCBub3QgYmUgdXNlZCBieSBsaWJyYXJ5IGNvbnN1bWVycyBkaXJlY3RseS5cclxuICovXHJcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IEp1c3QgYSB0aGluIHdyYXBwZXIgYXJvdW5kIHNvbGlkLWF1dGgtY2xpZW50LCB5ZXQgY3VtYmVyc29tZSB0byB0ZXN0IGR1ZSB0byBzaWRlIGVmZmVjdHMgKi9cclxuZnVuY3Rpb24gdXBkYXRlKHVybCwgdHJpcGxlc1RvRGVsZXRlLCB0cmlwbGVzVG9BZGQpIHtcclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmF3VHJpcGxlc1RvRGVsZXRlLCByYXdUcmlwbGVzVG9BZGQsIGRlbGV0ZVN0YXRlbWVudCwgaW5zZXJ0U3RhdGVtZW50LCByZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdHJpcGxlc1RvVHVydGxlKHRyaXBsZXNUb0RlbGV0ZSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJhd1RyaXBsZXNUb0RlbGV0ZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmlwbGVzVG9UdXJ0bGUodHJpcGxlc1RvQWRkKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3VHJpcGxlc1RvQWRkID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVN0YXRlbWVudCA9ICh0cmlwbGVzVG9EZWxldGUubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIkRFTEVURSBEQVRBIHtcIiArIHJhd1RyaXBsZXNUb0RlbGV0ZSArIFwifTtcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIGluc2VydFN0YXRlbWVudCA9ICh0cmlwbGVzVG9BZGQubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBcIklOU0VSVCBEQVRBIHtcIiArIHJhd1RyaXBsZXNUb0FkZCArIFwifTtcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFNvbGlkQXV0aENsaWVudC5mZXRjaCh1cmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRlbGV0ZVN0YXRlbWVudCArIFwiIFwiICsgaW5zZXJ0U3RhdGVtZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vc3BhcnFsLXVwZGF0ZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBzZW5kcyBhIFBVVCByZXF1ZXN0IHRvIHRoZSBQb2QgdG8gY3JlYXRlIGEgbmV3IERvY3VtZW50XHJcbiAqXHJcbiAqIEBwYXJhbSB1cmwgVVJMIG9mIHRoZSBEb2N1bWVudCB0aGF0IHNob3VsZCBiZSBjcmVhdGVkLlxyXG4gKiBAcGFyYW0gdHJpcGxlc1RvQWRkIFRyaXBsZXMgdGhhdCBzaG91bGQgYmUgYWRkZWQgdG8gdGhlIERvY3VtZW50LlxyXG4gKiBAcmV0dXJucyBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2Ugd2hlbiB0aGUgRG9jdW1lbnQgd2FzIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBhbmQgcmVqZWN0cyBpZiBub3QuXHJcbiAqIEBpbnRlcm5hbCBTaG91bGQgbm90IGJlIHVzZWQgYnkgbGlicmFyeSBjb25zdW1lcnMgZGlyZWN0bHkuXHJcbiAqL1xyXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCBKdXN0IGEgdGhpbiB3cmFwcGVyIGFyb3VuZCBzb2xpZC1hdXRoLWNsaWVudCwgeWV0IGN1bWJlcnNvbWUgdG8gdGVzdCBkdWUgdG8gc2lkZSBlZmZlY3RzICovXHJcbmZ1bmN0aW9uIGNyZWF0ZSh1cmwsIHRyaXBsZXNUb0FkZCkge1xyXG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByYXdUdXJ0bGUsIHJlc3BvbnNlO1xyXG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0cmlwbGVzVG9UdXJ0bGUodHJpcGxlc1RvQWRkKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmF3VHVydGxlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFNvbGlkQXV0aENsaWVudC5mZXRjaCh1cmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BVVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiByYXdUdXJ0bGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICd0ZXh0L3R1cnRsZScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ0lmLU5vbmUtTWF0Y2gnOiAnKicsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdGhhdCBzZW5kcyBhIFBPU1QgcmVxdWVzdCB0byBhIENvbnRhaW5lciBpbiB0aGUgUG9kIHRvIGNyZWF0ZSBhIG5ldyBEb2N1bWVudFxyXG4gKlxyXG4gKiBAcGFyYW0gY29udGFpbmVyVXJsIFVSTCBvZiB0aGUgQ29udGFpbmVyIGluIHdoaWNoIHRoZSBEb2N1bWVudCBzaG91bGQgYmUgY3JlYXRlZC5cclxuICogQHBhcmFtIHRyaXBsZXNUb0FkZCBUcmlwbGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBEb2N1bWVudC5cclxuICogQHJldHVybnMgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHJlc3BvbnNlIHdoZW4gdGhlIERvY3VtZW50IHdhcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseSwgYW5kIHJlamVjdHMgaWYgbm90LlxyXG4gKiBAaW50ZXJuYWwgU2hvdWxkIG5vdCBiZSB1c2VkIGJ5IGxpYnJhcnkgY29uc3VtZXJzIGRpcmVjdGx5LlxyXG4gKi9cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgSnVzdCBhIHRoaW4gd3JhcHBlciBhcm91bmQgc29saWQtYXV0aC1jbGllbnQsIHlldCBjdW1iZXJzb21lIHRvIHRlc3QgZHVlIHRvIHNpZGUgZWZmZWN0cyAqL1xyXG5mdW5jdGlvbiBjcmVhdGVJbkNvbnRhaW5lcihjb250YWluZXJVcmwsIHRyaXBsZXNUb0FkZCwgb3B0aW9ucykge1xyXG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cclxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgcmF3VHVydGxlLCBoZWFkZXJzLCByZXNwb25zZTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdHJpcGxlc1RvVHVydGxlKHRyaXBsZXNUb0FkZCldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHJhd1R1cnRsZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ3RleHQvdHVydGxlJyxcclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLnNsdWdTdWdnZXN0aW9uKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMuc2x1ZyA9IG9wdGlvbnMuc2x1Z1N1Z2dlc3Rpb247XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIFNvbGlkQXV0aENsaWVudC5mZXRjaChjb250YWluZXJVcmwsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogcmF3VHVydGxlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNwb25zZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBBIHNpbXBsZSB3cmFwcGVyIHRvIG1ha2UgTjMgY29uZm9ybSB3aXRoIGEgc3Vic2V0IG9mIHRoZSBSREYvSlMgRGF0YXNldFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJmYWNlOyBzaG91bGQgY29udGFpbiBubyBidXNpbmVzcyBsb2dpYy4gKi9cclxuZnVuY3Rpb24gdG9SZGZqc0RhdGFzZXQoc3RvcmUpIHtcclxuICAgIHZhciBhZGRBbGwgPSBmdW5jdGlvbiAocXVhZHMpIHtcclxuICAgICAgICB2YXIgcXVhZHNBc0FycmF5ID0gQXJyYXkuaXNBcnJheShxdWFkcykgPyBxdWFkcyA6IHF1YWRzLnRvQXJyYXkoKTtcclxuICAgICAgICBzdG9yZS5hZGRRdWFkcyhxdWFkc0FzQXJyYXkpO1xyXG4gICAgICAgIHJldHVybiBkYXRhc2V0O1xyXG4gICAgfTtcclxuICAgIHZhciBtYXRjaCA9IGZ1bmN0aW9uIChzdWJqZWN0LCBwcmVkaWNhdGUsIG9iamVjdCwgZ3JhcGgpIHtcclxuICAgICAgICB2YXIgbm90VW5kZWZpbmVkU3ViamVjdCA9ICh0eXBlb2Ygc3ViamVjdCA9PT0gJ3VuZGVmaW5lZCcpID8gbnVsbCA6IHN1YmplY3Q7XHJcbiAgICAgICAgdmFyIG5vdFVuZGVmaW5lZFByZWRpY2F0ZSA9ICh0eXBlb2YgcHJlZGljYXRlID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogcHJlZGljYXRlO1xyXG4gICAgICAgIHZhciBub3RVbmRlZmluZWRPYmplY3QgPSAodHlwZW9mIG9iamVjdCA9PT0gJ3VuZGVmaW5lZCcpID8gbnVsbCA6IG9iamVjdDtcclxuICAgICAgICB2YXIgbm90VW5kZWZpbmVkR3JhcGggPSAodHlwZW9mIGdyYXBoID09PSAndW5kZWZpbmVkJykgPyBudWxsIDogZ3JhcGg7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgdG9BcnJheTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0UXVhZHMobm90VW5kZWZpbmVkU3ViamVjdCwgbm90VW5kZWZpbmVkUHJlZGljYXRlLCBub3RVbmRlZmluZWRPYmplY3QsIG5vdFVuZGVmaW5lZEdyYXBoKTsgfSxcclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIHZhciB0b0FycmF5ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gc3RvcmUuZ2V0UXVhZHMobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCk7IH07XHJcbiAgICB2YXIgZGF0YXNldCA9IHtcclxuICAgICAgICBhZGRBbGw6IGFkZEFsbCxcclxuICAgICAgICBtYXRjaDogbWF0Y2gsXHJcbiAgICAgICAgdG9BcnJheTogdG9BcnJheSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gZGF0YXNldDtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpbml0aWFsaXNlRGF0YXNldCgpIHtcclxuICAgIHJldHVybiB0b1JkZmpzRGF0YXNldChuZXcgU3RvcmUoKSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxudmFyIERhdGFGYWN0b3J5ID0gRGF0YUZhY3RvcnkkMTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIGEgdXRpbGl0eSBtZXRob2QgZm9yIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLCBhbmQgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuXHJcbiAqL1xyXG52YXIgZmluZFN1YmplY3RJbkRhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YXNldCwgcHJlZGljYXRlUmVmLCBvYmplY3RSZWYpIHtcclxuICAgIHJldHVybiBmaW5kRW50aXR5SW5EYXRhc2V0KGRhdGFzZXQsICdzdWJqZWN0JywgbnVsbCwgcHJlZGljYXRlUmVmLCBvYmplY3RSZWYpO1xyXG59O1xyXG4vKipcclxuICogQGludGVybmFsIFRoaXMgaXMgYSB1dGlsaXR5IG1ldGhvZCBmb3Igb3RoZXIgcGFydHMgb2YgdGhlIGNvZGUsIGFuZCBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSS5cclxuICovXHJcbnZhciBmaW5kU3ViamVjdHNJbkRhdGFzZXQgPSBmdW5jdGlvbiAoZGF0YXNldCwgcHJlZGljYXRlUmVmLCBvYmplY3RSZWYpIHtcclxuICAgIHJldHVybiBmaW5kRW50aXRpZXNJbkRhdGFzZXQoZGF0YXNldCwgJ3N1YmplY3QnLCBudWxsLCBwcmVkaWNhdGVSZWYsIG9iamVjdFJlZik7XHJcbn07XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgVGhpcyBpcyBhIHV0aWxpdHkgbWV0aG9kIGZvciBvdGhlciBwYXJ0cyBvZiB0aGUgY29kZSwgYW5kIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLlxyXG4gKi9cclxudmFyIGZpbmRPYmplY3RzSW5EYXRhc2V0ID0gZnVuY3Rpb24gKGRhdGFzZXQsIHN1YmplY3RSZWYsIHByZWRpY2F0ZVJlZikge1xyXG4gICAgcmV0dXJuIGZpbmRFbnRpdGllc0luRGF0YXNldChkYXRhc2V0LCAnb2JqZWN0Jywgc3ViamVjdFJlZiwgcHJlZGljYXRlUmVmLCBudWxsKTtcclxufTtcclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIGEgdXRpbGl0eSBtZXRob2QgZm9yIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLCBhbmQgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kRW50aXR5SW5EYXRhc2V0KGRhdGFzZXQsIHR5cGUsIHN1YmplY3RSZWYsIHByZWRpY2F0ZVJlZiwgb2JqZWN0UmVmKSB7XHJcbiAgICB2YXIgdGFyZ2V0U3ViamVjdCA9IHN1YmplY3RSZWYgPyB0b05vZGUoc3ViamVjdFJlZikgOiBudWxsO1xyXG4gICAgdmFyIHRhcmdldFByZWRpY2F0ZSA9IHByZWRpY2F0ZVJlZiA/IHRvTm9kZShwcmVkaWNhdGVSZWYpIDogbnVsbDtcclxuICAgIHZhciB0YXJnZXRPYmplY3QgPSBvYmplY3RSZWYgPyB0b05vZGUob2JqZWN0UmVmKSA6IG51bGw7XHJcbiAgICB2YXIgbWF0Y2hpbmdUcmlwbGVzID0gZGF0YXNldC5tYXRjaCh0YXJnZXRTdWJqZWN0LCB0YXJnZXRQcmVkaWNhdGUsIHRhcmdldE9iamVjdCwgbnVsbCkudG9BcnJheSgpO1xyXG4gICAgdmFyIGZvdW5kVHJpcGxlID0gbWF0Y2hpbmdUcmlwbGVzLmZpbmQoZnVuY3Rpb24gKHRyaXBsZSkgeyByZXR1cm4gKHR5cGVvZiB0cmlwbGVbdHlwZV0gIT09ICd1bmRlZmluZWQnKTsgfSk7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBmb3VuZFRyaXBsZSAhPT0gJ3VuZGVmaW5lZCcpID8gbm9ybWFsaXNlRW50aXR5KGZvdW5kVHJpcGxlW3R5cGVdKSA6IG51bGw7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUaGlzIGlzIGEgdXRpbGl0eSBtZXRob2QgZm9yIG90aGVyIHBhcnRzIG9mIHRoZSBjb2RlLCBhbmQgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEkuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kRW50aXRpZXNJbkRhdGFzZXQoZGF0YXNldCwgdHlwZSwgc3ViamVjdFJlZiwgcHJlZGljYXRlUmVmLCBvYmplY3RSZWYpIHtcclxuICAgIHZhciB0YXJnZXRTdWJqZWN0ID0gc3ViamVjdFJlZiA/IHRvTm9kZShzdWJqZWN0UmVmKSA6IG51bGw7XHJcbiAgICB2YXIgdGFyZ2V0UHJlZGljYXRlID0gcHJlZGljYXRlUmVmID8gdG9Ob2RlKHByZWRpY2F0ZVJlZikgOiBudWxsO1xyXG4gICAgdmFyIHRhcmdldE9iamVjdCA9IG9iamVjdFJlZiA/IHRvTm9kZShvYmplY3RSZWYpIDogbnVsbDtcclxuICAgIHZhciBtYXRjaGluZ1RyaXBsZXMgPSBkYXRhc2V0Lm1hdGNoKHRhcmdldFN1YmplY3QsIHRhcmdldFByZWRpY2F0ZSwgdGFyZ2V0T2JqZWN0LCBudWxsKS50b0FycmF5KCk7XHJcbiAgICB2YXIgZm91bmRUcmlwbGVzID0gbWF0Y2hpbmdUcmlwbGVzLmZpbHRlcihmdW5jdGlvbiAodHJpcGxlKSB7IHJldHVybiAodHlwZW9mIHRyaXBsZVt0eXBlXSAhPT0gJ3VuZGVmaW5lZCcpOyB9KTtcclxuICAgIHJldHVybiBmb3VuZFRyaXBsZXMubWFwKGZ1bmN0aW9uICh0cmlwbGUpIHsgcmV0dXJuIG5vcm1hbGlzZUVudGl0eSh0cmlwbGVbdHlwZV0pOyB9KS5maWx0ZXIoaXNFbnRpdHkpO1xyXG59XHJcbmZ1bmN0aW9uIHRvTm9kZShyZWZlcmVuY2VPckJsYW5rTm9kZSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcmVmZXJlbmNlT3JCbGFua05vZGUgPT09ICdzdHJpbmcnKSA/IERhdGFGYWN0b3J5Lm5hbWVkTm9kZShyZWZlcmVuY2VPckJsYW5rTm9kZSkgOiByZWZlcmVuY2VPckJsYW5rTm9kZTtcclxufVxyXG5mdW5jdGlvbiBub3JtYWxpc2VFbnRpdHkoZW50aXR5KSB7XHJcbiAgICBpZiAoaXNCbGFua05vZGUoZW50aXR5KSkge1xyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNOYW1lZE5vZGUoZW50aXR5KSkge1xyXG4gICAgICAgIHJldHVybiBlbnRpdHkudmFsdWU7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZTogQWxsIGNvZGUgcGF0aHMgdG8gaGVyZSByZXN1bHQgaW4gZWl0aGVyIGEgTm9kZSBvciBhIExpdGVyYWwsIHNvIHdlIGNhbid0IHRlc3QgaXQgKi9cclxuICAgIGlmIChpc0xpdGVyYWwoZW50aXR5KSkge1xyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogQWxsIGNvZGUgcGF0aHMgdG8gaGVyZSByZXN1bHQgaW4gZWl0aGVyIGEgTm9kZSBvciBhIExpdGVyYWwsIHNvIHdlIGNhbid0IHRlc3QgaXQgKi9cclxuICAgIHJldHVybiBudWxsO1xyXG59XHJcbmZ1bmN0aW9uIGlzRW50aXR5KG5vZGUpIHtcclxuICAgIHJldHVybiAobm9kZSAhPT0gbnVsbCk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBVdGlsaXR5IGZ1bmN0aW9uIGZvciB3b3JraW5nIHdpdGggTjMsIHdoaWNoIHRoZSBsaWJyYXJ5IGNvbnN1bWVyIHNob3VsZCBub3QgbmVlZCB0b1xyXG4gKiAgICAgICAgICAgYmUgZXhwb3NlZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIGlzTmFtZWROb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnRlcm1UeXBlID09PSAnTmFtZWROb2RlJztcclxufVxyXG4vKipcclxuICogQGludGVybmFsIFV0aWxpdHkgZnVuY3Rpb24gZm9yIHdvcmtpbmcgd2l0aCByZGZsaWIsIHdoaWNoIHRoZSBsaWJyYXJ5IGNvbnN1bWVyIHNob3VsZCBub3QgbmVlZCB0b1xyXG4gKiAgICAgICAgICAgYmUgZXhwb3NlZCB0by5cclxuICovXHJcbmZ1bmN0aW9uIGlzQmxhbmtOb2RlKG5vZGUpIHtcclxuICAgIHJldHVybiBub2RlLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJztcclxufVxuXG4vKipcclxuICogQGludGVybmFsIE9ubHkgdG8gYmUgY2FsbGVkIGJ5IHRoZSBEb2N1bWVudCBjb250YWluaW5nIHRoaXMgc3ViamVjdDsgbm90IGEgcHVibGljIEFQSS5cclxuICogQHBhcmFtIGRvY3VtZW50IFRoZSBEb2N1bWVudCB0aGlzIFN1YmplY3QgaXMgZGVmaW5lZCBpbi5cclxuICogQHBhcmFtIHN1YmplY3RSZWYgVGhlIFVSTCB0aGF0IGlkZW50aWZpZXMgdGhpcyBzdWJqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gaW5pdGlhbGlzZVN1YmplY3QoZG9jdW1lbnQsIHN1YmplY3RSZWYpIHtcclxuICAgIHZhciBzdWJqZWN0Tm9kZSA9IGlzQmxhbmtOb2RlJDEoc3ViamVjdFJlZikgPyBzdWJqZWN0UmVmIDogRGF0YUZhY3RvcnkubmFtZWROb2RlKHN1YmplY3RSZWYpO1xyXG4gICAgdmFyIHRyaXBsZXMgPSAoaXNTYXZlZFRvUG9kKGRvY3VtZW50KSlcclxuICAgICAgICA/IGRvY3VtZW50LmdldFN0b3JlKCkubWF0Y2goc3ViamVjdE5vZGUsIG51bGwsIG51bGwsIG51bGwpLnRvQXJyYXkoKVxyXG4gICAgICAgIDogW107XHJcbiAgICB2YXIgZGF0YXNldCA9IGluaXRpYWxpc2VEYXRhc2V0KCk7XHJcbiAgICBkYXRhc2V0LmFkZEFsbCh0cmlwbGVzKTtcclxuICAgIHZhciBwZW5kaW5nQWRkaXRpb25zID0gW107XHJcbiAgICB2YXIgcGVuZGluZ0RlbGV0aW9ucyA9IFtdO1xyXG4gICAgdmFyIGdldCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVOb2RlKSB7IHJldHVybiBmaW5kT2JqZWN0c0luRGF0YXNldChkYXRhc2V0LCBzdWJqZWN0UmVmLCBwcmVkaWNhdGVOb2RlKTsgfTtcclxuICAgIHZhciBnZXRTdHJpbmcgPSBmdW5jdGlvbiAocHJlZGljYXRlTm9kZSkge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZU5vZGUpO1xyXG4gICAgICAgIHZhciBmaXJzdFN0cmluZ0xpdGVyYWwgPSBvYmplY3RzLmZpbmQoaXNTdHJpbmdMaXRlcmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0U3RyaW5nTGl0ZXJhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmaXJzdFN0cmluZ0xpdGVyYWwudmFsdWU7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldExvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVOb2RlLCBsb2NhbGUpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVOb2RlKTtcclxuICAgICAgICB2YXIgZmlyc3RTdHJpbmdMaXRlcmFsID0gb2JqZWN0cy5maW5kKGdlbmVyYXRlTG9jYWxlVHlwZUd1YXJkKGxvY2FsZSkpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RTdHJpbmdMaXRlcmFsID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpcnN0U3RyaW5nTGl0ZXJhbC52YWx1ZTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0SW50ZWdlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIHZhciBmaXJzdEludGVnZXJMaXRlcmFsID0gb2JqZWN0cy5maW5kKGlzSW50ZWdlckxpdGVyYWwpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RJbnRlZ2VyTGl0ZXJhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmcm9tSW50ZWdlckxpdGVyYWwoZmlyc3RJbnRlZ2VyTGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldERlY2ltYWwgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBnZXQocHJlZGljYXRlUmVmKTtcclxuICAgICAgICB2YXIgZmlyc3REZWNpbWFsTGl0ZXJhbCA9IG9iamVjdHMuZmluZChpc0RlY2ltYWxMaXRlcmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0RGVjaW1hbExpdGVyYWwgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnJvbURlY2ltYWxMaXRlcmFsKGZpcnN0RGVjaW1hbExpdGVyYWwpO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXREYXRlVGltZSA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIHZhciBmaXJzdERhdGVUaW1lTGl0ZXJhbCA9IG9iamVjdHMuZmluZChpc0RhdGVUaW1lTGl0ZXJhbCk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdERhdGVUaW1lTGl0ZXJhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmcm9tRGF0ZVRpbWVMaXRlcmFsKGZpcnN0RGF0ZVRpbWVMaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0TGl0ZXJhbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIHZhciBmaXJzdExpdGVyYWwgPSBvYmplY3RzLmZpbmQoaXNMaXRlcmFsKTtcclxuICAgICAgICBpZiAodHlwZW9mIGZpcnN0TGl0ZXJhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmcm9tTGl0ZXJhbChmaXJzdExpdGVyYWwpO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRBbGxTdHJpbmdzID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZikge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGxpdGVyYWxzID0gb2JqZWN0cy5maWx0ZXIoaXNTdHJpbmdMaXRlcmFsKTtcclxuICAgICAgICByZXR1cm4gbGl0ZXJhbHMubWFwKGZyb21TdHJpbmdMaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0QWxsTG9jYWxlU3RyaW5ncyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxvY2FsZSkge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGxpdGVyYWxzID0gb2JqZWN0cy5maWx0ZXIoZ2VuZXJhdGVMb2NhbGVUeXBlR3VhcmQobG9jYWxlKSk7XHJcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxzLm1hcChmcm9tU3RyaW5nTGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldEFsbEludGVnZXJzID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZikge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGxpdGVyYWxzID0gb2JqZWN0cy5maWx0ZXIoaXNJbnRlZ2VyTGl0ZXJhbCk7XHJcbiAgICAgICAgcmV0dXJuIGxpdGVyYWxzLm1hcChmcm9tSW50ZWdlckxpdGVyYWwpO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRBbGxEZWNpbWFscyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIHZhciBsaXRlcmFscyA9IG9iamVjdHMuZmlsdGVyKGlzRGVjaW1hbExpdGVyYWwpO1xyXG4gICAgICAgIHJldHVybiBsaXRlcmFscy5tYXAoZnJvbURlY2ltYWxMaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0QWxsRGF0ZVRpbWVzID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZikge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGxpdGVyYWxzID0gb2JqZWN0cy5maWx0ZXIoaXNEYXRlVGltZUxpdGVyYWwpO1xyXG4gICAgICAgIHJldHVybiBsaXRlcmFscy5tYXAoZnJvbURhdGVUaW1lTGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldEFsbExpdGVyYWxzID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZikge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGxpdGVyYWxzID0gb2JqZWN0cy5maWx0ZXIoaXNMaXRlcmFsKTtcclxuICAgICAgICByZXR1cm4gbGl0ZXJhbHMubWFwKGZyb21MaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0TG9jYWxTdWJqZWN0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZikge1xyXG4gICAgICAgIHZhciBvYmplY3RzID0gZ2V0KHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgdmFyIGZpcnN0UmVmID0gb2JqZWN0cy5maW5kKGlzQmxhbmtOb2RlJDEpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RSZWYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW5pdGlhbGlzZVN1YmplY3QoZG9jdW1lbnQsIGZpcnN0UmVmKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0QWxsTG9jYWxTdWJqZWN0cyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICB2YXIgb2JqZWN0cyA9IGdldChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIHZhciBub2RlUmVmcyA9IG9iamVjdHMuZmlsdGVyKGlzQmxhbmtOb2RlJDEpO1xyXG4gICAgICAgIHJldHVybiBub2RlUmVmcy5tYXAoZnVuY3Rpb24gKGxvY2FsU3ViamVjdCkgeyByZXR1cm4gaW5pdGlhbGlzZVN1YmplY3QoZG9jdW1lbnQsIGxvY2FsU3ViamVjdCk7IH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRSZWYgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBnZXQocHJlZGljYXRlUmVmKTtcclxuICAgICAgICB2YXIgZmlyc3RSZWYgPSBvYmplY3RzLmZpbmQoaXNSZWZlcmVuY2UpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgZmlyc3RSZWYgPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmlyc3RSZWY7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldEFsbFJlZnMgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmKSB7XHJcbiAgICAgICAgdmFyIG9iamVjdHMgPSBnZXQocHJlZGljYXRlUmVmKTtcclxuICAgICAgICB2YXIgbm9kZVJlZnMgPSBvYmplY3RzLmZpbHRlcihpc1JlZmVyZW5jZSk7XHJcbiAgICAgICAgcmV0dXJuIG5vZGVSZWZzO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRUeXBlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBnZXRSZWYoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyN0eXBlJyk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGFkZExpdGVyYWwgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcGVuZGluZ0FkZGl0aW9ucy5wdXNoKERhdGFGYWN0b3J5LnRyaXBsZShzdWJqZWN0Tm9kZSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKHByZWRpY2F0ZVJlZiksIGFzTGl0ZXJhbChsaXRlcmFsKSkpO1xyXG4gICAgfTtcclxuICAgIHZhciBhZGRTdHJpbmcgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXRlcmFsICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRMaXRlcmFsKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGFkZExvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxpdGVyYWwsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGl0ZXJhbCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwZW5kaW5nQWRkaXRpb25zLnB1c2goRGF0YUZhY3RvcnkudHJpcGxlKHN1YmplY3ROb2RlLCBEYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJlZGljYXRlUmVmKSwgRGF0YUZhY3RvcnkubGl0ZXJhbChsaXRlcmFsLCBsb2NhbGUpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGFkZEludGVnZXIgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXRlcmFsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihsaXRlcmFsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFkZExpdGVyYWwocHJlZGljYXRlUmVmLCBsaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgYWRkRGVjaW1hbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxpdGVyYWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxpdGVyYWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIGRlY2ltYWwuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHBlbmRpbmdBZGRpdGlvbnMucHVzaChEYXRhRmFjdG9yeS50cmlwbGUoc3ViamVjdE5vZGUsIERhdGFGYWN0b3J5Lm5hbWVkTm9kZShwcmVkaWNhdGVSZWYpLCBEYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwudG9TdHJpbmcoKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNkZWNpbWFsJykpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGFkZERhdGVUaW1lID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCkge1xyXG4gICAgICAgIGlmIChsaXRlcmFsIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgRGF0ZVRpbWUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRMaXRlcmFsKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGFkZFJlZiA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIG5vZGVSZWYpIHtcclxuICAgICAgICBwZW5kaW5nQWRkaXRpb25zLnB1c2goRGF0YUZhY3RvcnkudHJpcGxlKHN1YmplY3ROb2RlLCBEYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJlZGljYXRlUmVmKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKG5vZGVSZWYpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZVJlZiA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIG5vZGVSZWYpIHtcclxuICAgICAgICBwZW5kaW5nRGVsZXRpb25zLnB1c2goRGF0YUZhY3RvcnkudHJpcGxlKHN1YmplY3ROb2RlLCBEYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJlZGljYXRlUmVmKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKG5vZGVSZWYpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZUxpdGVyYWwgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcGVuZGluZ0RlbGV0aW9ucy5wdXNoKERhdGFGYWN0b3J5LnRyaXBsZShzdWJqZWN0Tm9kZSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKHByZWRpY2F0ZVJlZiksIGFzTGl0ZXJhbChsaXRlcmFsKSkpO1xyXG4gICAgfTtcclxuICAgIHZhciByZW1vdmVTdHJpbmcgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXRlcmFsICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBzdHJpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdmVMaXRlcmFsKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZUxvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxpdGVyYWwsIGxvY2FsZSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgbGl0ZXJhbCAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgc3RyaW5nLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBwZW5kaW5nRGVsZXRpb25zLnB1c2goRGF0YUZhY3RvcnkudHJpcGxlKHN1YmplY3ROb2RlLCBEYXRhRmFjdG9yeS5uYW1lZE5vZGUocHJlZGljYXRlUmVmKSwgRGF0YUZhY3RvcnkubGl0ZXJhbChsaXRlcmFsLCBsb2NhbGUpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZUludGVnZXIgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBsaXRlcmFsICE9PSAnbnVtYmVyJyB8fCAhTnVtYmVyLmlzSW50ZWdlcihsaXRlcmFsKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYW4gaW50ZWdlci4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlbW92ZUxpdGVyYWwocHJlZGljYXRlUmVmLCBsaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgcmVtb3ZlRGVjaW1hbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxpdGVyYWwpIHtcclxuICAgICAgICBpZiAodHlwZW9mIGxpdGVyYWwgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIGRlY2ltYWwuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFdlIGNhbm5vdCByZS11c2UgYHJlbW92ZUxpdGVyYWxgIGhlcmUgYmVjYXVzZSBpdCB3aWxsIHBhcnNlIGA0Mi4wYCBhcyBhbiBpbnRlZ2VyOlxyXG4gICAgICAgIHBlbmRpbmdEZWxldGlvbnMucHVzaChEYXRhRmFjdG9yeS50cmlwbGUoc3ViamVjdE5vZGUsIERhdGFGYWN0b3J5Lm5hbWVkTm9kZShwcmVkaWNhdGVSZWYpLCBEYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwudG9TdHJpbmcoKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNkZWNpbWFsJykpKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZURhdGVUaW1lID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCkge1xyXG4gICAgICAgIGlmIChsaXRlcmFsIGluc3RhbmNlb2YgRGF0ZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgRGF0ZVRpbWUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW1vdmVMaXRlcmFsKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHJlbW92ZUFsbCA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYpIHtcclxuICAgICAgICBwZW5kaW5nRGVsZXRpb25zLnB1c2guYXBwbHkocGVuZGluZ0RlbGV0aW9ucywgZGF0YXNldC5tYXRjaChzdWJqZWN0Tm9kZSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKHByZWRpY2F0ZVJlZiksIG51bGwsIG51bGwpLnRvQXJyYXkoKSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGNsZWFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHBlbmRpbmdEZWxldGlvbnMucHVzaC5hcHBseShwZW5kaW5nRGVsZXRpb25zLCBnZXRUcmlwbGVzKCkpO1xyXG4gICAgfTtcclxuICAgIHZhciBzZXRSZWYgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBub2RlUmVmKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsKHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgYWRkUmVmKHByZWRpY2F0ZVJlZiwgbm9kZVJlZik7XHJcbiAgICB9O1xyXG4gICAgdmFyIHNldExpdGVyYWwgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsKHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgYWRkTGl0ZXJhbChwcmVkaWNhdGVSZWYsIGxpdGVyYWwpO1xyXG4gICAgfTtcclxuICAgIHZhciBzZXRTdHJpbmcgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsKHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgYWRkU3RyaW5nKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHNldExvY2FsZVN0cmluZyA9IGZ1bmN0aW9uIChwcmVkaWNhdGVSZWYsIGxpdGVyYWwsIGxvY2FsZSkge1xyXG4gICAgICAgIHJlbW92ZUFsbChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIGFkZExvY2FsZVN0cmluZyhwcmVkaWNhdGVSZWYsIGxpdGVyYWwsIGxvY2FsZSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIHNldEludGVnZXIgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsKHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgYWRkSW50ZWdlcihwcmVkaWNhdGVSZWYsIGxpdGVyYWwpO1xyXG4gICAgfTtcclxuICAgIHZhciBzZXREZWNpbWFsID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZiwgbGl0ZXJhbCkge1xyXG4gICAgICAgIHJlbW92ZUFsbChwcmVkaWNhdGVSZWYpO1xyXG4gICAgICAgIGFkZERlY2ltYWwocHJlZGljYXRlUmVmLCBsaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgc2V0RGF0ZVRpbWUgPSBmdW5jdGlvbiAocHJlZGljYXRlUmVmLCBsaXRlcmFsKSB7XHJcbiAgICAgICAgcmVtb3ZlQWxsKHByZWRpY2F0ZVJlZik7XHJcbiAgICAgICAgYWRkRGF0ZVRpbWUocHJlZGljYXRlUmVmLCBsaXRlcmFsKTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0VHJpcGxlcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFzZXQubWF0Y2goc3ViamVjdE5vZGUsIG51bGwsIG51bGwsIG51bGwpLnRvQXJyYXkoKTsgfTtcclxuICAgIHZhciBhc1JlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlzQmxhbmtOb2RlJDEoc3ViamVjdFJlZikgPyBzdWJqZWN0UmVmLnZhbHVlIDogc3ViamVjdFJlZjsgfTtcclxuICAgIHZhciBzdWJqZWN0ID0ge1xyXG4gICAgICAgIGdldERvY3VtZW50OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkb2N1bWVudDsgfSxcclxuICAgICAgICBnZXRUcmlwbGVzOiBnZXRUcmlwbGVzLFxyXG4gICAgICAgIGdldFN0cmluZzogZ2V0U3RyaW5nLFxyXG4gICAgICAgIGdldExvY2FsZVN0cmluZzogZ2V0TG9jYWxlU3RyaW5nLFxyXG4gICAgICAgIGdldEludGVnZXI6IGdldEludGVnZXIsXHJcbiAgICAgICAgZ2V0RGVjaW1hbDogZ2V0RGVjaW1hbCxcclxuICAgICAgICBnZXREYXRlVGltZTogZ2V0RGF0ZVRpbWUsXHJcbiAgICAgICAgZ2V0TGl0ZXJhbDogZ2V0TGl0ZXJhbCxcclxuICAgICAgICBnZXRBbGxTdHJpbmdzOiBnZXRBbGxTdHJpbmdzLFxyXG4gICAgICAgIGdldEFsbExvY2FsZVN0cmluZ3M6IGdldEFsbExvY2FsZVN0cmluZ3MsXHJcbiAgICAgICAgZ2V0QWxsSW50ZWdlcnM6IGdldEFsbEludGVnZXJzLFxyXG4gICAgICAgIGdldEFsbERlY2ltYWxzOiBnZXRBbGxEZWNpbWFscyxcclxuICAgICAgICBnZXRBbGxEYXRlVGltZXM6IGdldEFsbERhdGVUaW1lcyxcclxuICAgICAgICBnZXRBbGxMaXRlcmFsczogZ2V0QWxsTGl0ZXJhbHMsXHJcbiAgICAgICAgZ2V0TG9jYWxTdWJqZWN0OiBnZXRMb2NhbFN1YmplY3QsXHJcbiAgICAgICAgZ2V0QWxsTG9jYWxTdWJqZWN0czogZ2V0QWxsTG9jYWxTdWJqZWN0cyxcclxuICAgICAgICBnZXRSZWY6IGdldFJlZixcclxuICAgICAgICBnZXRBbGxSZWZzOiBnZXRBbGxSZWZzLFxyXG4gICAgICAgIGdldFR5cGU6IGdldFR5cGUsXHJcbiAgICAgICAgYWRkU3RyaW5nOiBhZGRTdHJpbmcsXHJcbiAgICAgICAgYWRkTG9jYWxlU3RyaW5nOiBhZGRMb2NhbGVTdHJpbmcsXHJcbiAgICAgICAgYWRkSW50ZWdlcjogYWRkSW50ZWdlcixcclxuICAgICAgICBhZGREZWNpbWFsOiBhZGREZWNpbWFsLFxyXG4gICAgICAgIGFkZERhdGVUaW1lOiBhZGREYXRlVGltZSxcclxuICAgICAgICBhZGRSZWY6IGFkZFJlZixcclxuICAgICAgICByZW1vdmVBbGw6IHJlbW92ZUFsbCxcclxuICAgICAgICByZW1vdmVTdHJpbmc6IHJlbW92ZVN0cmluZyxcclxuICAgICAgICByZW1vdmVMb2NhbGVTdHJpbmc6IHJlbW92ZUxvY2FsZVN0cmluZyxcclxuICAgICAgICByZW1vdmVJbnRlZ2VyOiByZW1vdmVJbnRlZ2VyLFxyXG4gICAgICAgIHJlbW92ZURlY2ltYWw6IHJlbW92ZURlY2ltYWwsXHJcbiAgICAgICAgcmVtb3ZlRGF0ZVRpbWU6IHJlbW92ZURhdGVUaW1lLFxyXG4gICAgICAgIHJlbW92ZVJlZjogcmVtb3ZlUmVmLFxyXG4gICAgICAgIHNldFJlZjogc2V0UmVmLFxyXG4gICAgICAgIHNldFN0cmluZzogc2V0U3RyaW5nLFxyXG4gICAgICAgIHNldExvY2FsZVN0cmluZzogc2V0TG9jYWxlU3RyaW5nLFxyXG4gICAgICAgIHNldEludGVnZXI6IHNldEludGVnZXIsXHJcbiAgICAgICAgc2V0RGVjaW1hbDogc2V0RGVjaW1hbCxcclxuICAgICAgICBzZXREYXRlVGltZTogc2V0RGF0ZVRpbWUsXHJcbiAgICAgICAgY2xlYXI6IGNsZWFyLFxyXG4gICAgICAgIGdldFBlbmRpbmdUcmlwbGVzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBbcGVuZGluZ0RlbGV0aW9ucywgcGVuZGluZ0FkZGl0aW9uc107IH0sXHJcbiAgICAgICAgYXNSZWY6IGFzUmVmLFxyXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgYWxpYXNlcywgaW5jbHVkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxyXG4gICAgICAgIGdldE5vZGVSZWY6IGdldFJlZixcclxuICAgICAgICBnZXRBbGxOb2RlUmVmczogZ2V0QWxsUmVmcyxcclxuICAgICAgICBhZGROb2RlUmVmOiBhZGRSZWYsXHJcbiAgICAgICAgYWRkTGl0ZXJhbDogYWRkTGl0ZXJhbCxcclxuICAgICAgICByZW1vdmVOb2RlUmVmOiByZW1vdmVSZWYsXHJcbiAgICAgICAgcmVtb3ZlTGl0ZXJhbDogcmVtb3ZlTGl0ZXJhbCxcclxuICAgICAgICBzZXROb2RlUmVmOiBzZXRSZWYsXHJcbiAgICAgICAgc2V0TGl0ZXJhbDogc2V0TGl0ZXJhbCxcclxuICAgICAgICBhc05vZGVSZWY6IGFzUmVmLFxyXG4gICAgfTtcclxuICAgIHJldHVybiBzdWJqZWN0O1xyXG59XHJcbmZ1bmN0aW9uIGZyb21EYXRlVGltZUxpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saW5rZWRkYXRhL3JkZmxpYi5qcy9ibG9iL2Q4NGFmODhmMzY3YjhiNWY2MTdjNzUzZDgyNDFjNWEyMDM1NDU4ZTgvc3JjL2xpdGVyYWwuanMjTDg3XHJcbiAgICB2YXIgdXRjRnVsbFllYXIgPSBwYXJzZUludChsaXRlcmFsLnZhbHVlLnN1YnN0cmluZygwLCA0KSwgMTApO1xyXG4gICAgdmFyIHV0Y01vbnRoID0gcGFyc2VJbnQobGl0ZXJhbC52YWx1ZS5zdWJzdHJpbmcoNSwgNyksIDEwKSAtIDE7XHJcbiAgICB2YXIgdXRjRGF0ZSA9IHBhcnNlSW50KGxpdGVyYWwudmFsdWUuc3Vic3RyaW5nKDgsIDEwKSwgMTApO1xyXG4gICAgdmFyIHV0Y0hvdXJzID0gcGFyc2VJbnQobGl0ZXJhbC52YWx1ZS5zdWJzdHJpbmcoMTEsIDEzKSwgMTApO1xyXG4gICAgdmFyIHV0Y01pbnV0ZXMgPSBwYXJzZUludChsaXRlcmFsLnZhbHVlLnN1YnN0cmluZygxNCwgMTYpLCAxMCk7XHJcbiAgICB2YXIgdXRjU2Vjb25kcyA9IHBhcnNlSW50KGxpdGVyYWwudmFsdWUuc3Vic3RyaW5nKDE3LCBsaXRlcmFsLnZhbHVlLmluZGV4T2YoJ1onKSksIDEwKTtcclxuICAgIHZhciBkYXRlID0gbmV3IERhdGUoMCk7XHJcbiAgICBkYXRlLnNldFVUQ0Z1bGxZZWFyKHV0Y0Z1bGxZZWFyKTtcclxuICAgIGRhdGUuc2V0VVRDTW9udGgodXRjTW9udGgpO1xyXG4gICAgZGF0ZS5zZXRVVENEYXRlKHV0Y0RhdGUpO1xyXG4gICAgZGF0ZS5zZXRVVENIb3Vycyh1dGNIb3Vycyk7XHJcbiAgICBkYXRlLnNldFVUQ01pbnV0ZXModXRjTWludXRlcyk7XHJcbiAgICBkYXRlLnNldFVUQ1NlY29uZHModXRjU2Vjb25kcyk7XHJcbiAgICByZXR1cm4gZGF0ZTtcclxufVxyXG5mdW5jdGlvbiBmcm9tSW50ZWdlckxpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgcmV0dXJuIHBhcnNlSW50KGxpdGVyYWwudmFsdWUsIDEwKTtcclxufVxyXG5mdW5jdGlvbiBmcm9tRGVjaW1hbExpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgcmV0dXJuIHBhcnNlRmxvYXQobGl0ZXJhbC52YWx1ZSk7XHJcbn1cclxuZnVuY3Rpb24gZnJvbVN0cmluZ0xpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgcmV0dXJuIGxpdGVyYWwudmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gZnJvbUxpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgaWYgKGlzRGF0ZVRpbWVMaXRlcmFsKGxpdGVyYWwpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZyb21EYXRlVGltZUxpdGVyYWwobGl0ZXJhbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNJbnRlZ2VyTGl0ZXJhbChsaXRlcmFsKSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tSW50ZWdlckxpdGVyYWwobGl0ZXJhbCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEZWNpbWFsTGl0ZXJhbChsaXRlcmFsKSkge1xyXG4gICAgICAgIHJldHVybiBmcm9tRGVjaW1hbExpdGVyYWwobGl0ZXJhbCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGl0ZXJhbC52YWx1ZTtcclxufVxyXG5mdW5jdGlvbiBhc0xpdGVyYWwobGl0ZXJhbCkge1xyXG4gICAgaWYgKGxpdGVyYWwgaW5zdGFuY2VvZiBEYXRlKSB7XHJcbiAgICAgICAgLy8gVG8gYWxpZ24gd2l0aCByZGZsaWIsIHdlIGlnbm9yZSBtaWxpc2Vjb25kczpcclxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbGlua2VkZGF0YS9yZGZsaWIuanMvYmxvYi9kODRhZjg4ZjM2N2I4YjVmNjE3Yzc1M2Q4MjQxYzVhMjAzNTQ1OGU4L3NyYy9saXRlcmFsLmpzI0w3NFxyXG4gICAgICAgIHZhciByb3VuZGVkRGF0ZSA9IG5ldyBEYXRlKERhdGUuVVRDKGxpdGVyYWwuZ2V0VVRDRnVsbFllYXIoKSwgbGl0ZXJhbC5nZXRVVENNb250aCgpLCBsaXRlcmFsLmdldFVUQ0RhdGUoKSwgbGl0ZXJhbC5nZXRVVENIb3VycygpLCBsaXRlcmFsLmdldFVUQ01pbnV0ZXMoKSwgbGl0ZXJhbC5nZXRVVENTZWNvbmRzKCksIDApKTtcclxuICAgICAgICAvLyBUcnVuY2F0ZSB0aGUgYC4wMDBaYCBhdCB0aGUgZW5kIChpLmUuIHRoZSBtaWxpc2Vjb25kcyksIHRvIHBsYWluIGBaYDpcclxuICAgICAgICB2YXIgcmRmbGliU3R5bGVTdHJpbmcgPSByb3VuZGVkRGF0ZS50b0lTT1N0cmluZygpLnJlcGxhY2UoL1xcLjAwMFokLywgJ1onKTtcclxuICAgICAgICByZXR1cm4gRGF0YUZhY3RvcnkubGl0ZXJhbChyZGZsaWJTdHlsZVN0cmluZywgRGF0YUZhY3RvcnkubmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNkYXRlVGltZScpKTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgbGl0ZXJhbCA9PT0gJ251bWJlcicgJiYgTnVtYmVyLmlzSW50ZWdlcihsaXRlcmFsKSkge1xyXG4gICAgICAgIHJldHVybiBEYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwudG9TdHJpbmcoKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNpbnRlZ2VyJykpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBsaXRlcmFsID09PSAnbnVtYmVyJyAmJiAhTnVtYmVyLmlzSW50ZWdlcihsaXRlcmFsKSkge1xyXG4gICAgICAgIHJldHVybiBEYXRhRmFjdG9yeS5saXRlcmFsKGxpdGVyYWwudG9TdHJpbmcoKSwgRGF0YUZhY3RvcnkubmFtZWROb2RlKCdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSNkZWNpbWFsJykpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIERhdGFGYWN0b3J5LmxpdGVyYWwobGl0ZXJhbC50b1N0cmluZygpKTtcclxufVxuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUxvY2FsVHJpcGxlRG9jdW1lbnQoZGF0YXNldCwgc3ViamVjdENhY2hlLCBtZXRhZGF0YSkge1xyXG4gICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgIHZhciBiYXJlVHJpcGxlRG9jdW1lbnQgPSBpbnN0YW50aWF0ZUJhcmVUcmlwbGVEb2N1bWVudChzdWJqZWN0Q2FjaGUsIG1ldGFkYXRhKTtcclxuICAgIHZhciBhc1JlZiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1ldGFkYXRhLmRvY3VtZW50UmVmOyB9O1xyXG4gICAgdmFyIHNhdmUgPSBmdW5jdGlvbiAoc3ViamVjdHMpIHtcclxuICAgICAgICBpZiAoc3ViamVjdHMgPT09IHZvaWQgMCkgeyBzdWJqZWN0cyA9IE9iamVjdC52YWx1ZXMoc3ViamVjdENhY2hlLmdldEFjY2Vzc2VkU3ViamVjdHMoKSk7IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGVuZGluZ0NoYW5nZXMsIHVwZGF0ZWRNZXRhZGF0YSwgcmVzcG9uc2UsIG1lc3NhZ2UsIGFjbFJlZiwgd2ViU29ja2V0UmVmO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQ2hhbmdlcyA9IGdldFBlbmRpbmdDaGFuZ2VzKHN1YmplY3RzLCB0cmlwbGVEb2N1bWVudFdpdGhSZWYsIGRhdGFzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjcmVhdGUobWV0YWRhdGEuZG9jdW1lbnRSZWYsIHBlbmRpbmdDaGFuZ2VzLmFsbEFkZGl0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXJlc3BvbnNlLm9rKSByZXR1cm4gWzMgLypicmVhayovLCAzXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRNZXRhZGF0YSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBtZXRhZGF0YSksIHsgZXhpc3RzT25Qb2Q6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjbFJlZiA9IGV4dHJhY3RBY2xSZWYocmVzcG9uc2UsIG1ldGFkYXRhLmRvY3VtZW50UmVmKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFjbFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE1ldGFkYXRhLmFjbFJlZiA9IGFjbFJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB3ZWJTb2NrZXRSZWYgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnVXBkYXRlcy1WaWEnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlYlNvY2tldFJlZikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE1ldGFkYXRhLndlYlNvY2tldFJlZiA9IHdlYlNvY2tldFJlZjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBhIG5ldyBUcmlwbGVEb2N1bWVudCB0aGF0IGluY2x1ZGVzIHRoZSB1cGRhdGVkIFRyaXBsZXM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBpbnN0YW50aWF0ZURvY3VtZW50KHBlbmRpbmdDaGFuZ2VzLm5ld1RyaXBsZXMsIHVwZGF0ZWRNZXRhZGF0YSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICB2YXIgdHJpcGxlRG9jdW1lbnRXaXRoUmVmID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGJhcmVUcmlwbGVEb2N1bWVudCksIHsgc2F2ZTogc2F2ZSwgYXNSZWY6IGFzUmVmLCBcclxuICAgICAgICAvLyBEZXByZWNhdGVkIGFsaWFzOlxyXG4gICAgICAgIGFzTm9kZVJlZjogYXNSZWYgfSk7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3aGVuIFRyaXBsZVN1YmplY3RzIGdldCBpbml0aWFsaXNlZCBmb3IgdGhpcyBEb2N1bWVudCxcclxuICAgIC8vIHRoZXkncmUgYXR0YWNoZWQgdG8gdGhlIERvY3VtZW50IGluc3RhbmNlIHRoYXQgaW5jbHVkZXMgaXRzIFJlZmVyZW5jZTpcclxuICAgIHN1YmplY3RDYWNoZS5zZXREb2N1bWVudCh0cmlwbGVEb2N1bWVudFdpdGhSZWYpO1xyXG4gICAgcmV0dXJuIHRyaXBsZURvY3VtZW50V2l0aFJlZjtcclxufVxuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZUZ1bGxUcmlwbGVEb2N1bWVudChkYXRhc2V0LCBzdWJqZWN0Q2FjaGUsIG1ldGFkYXRhKSB7XHJcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgdmFyIHRyaXBsZURvY3VtZW50V2l0aFJlZiA9IGluc3RhbnRpYXRlTG9jYWxUcmlwbGVEb2N1bWVudChkYXRhc2V0LCBzdWJqZWN0Q2FjaGUsIG1ldGFkYXRhKTtcclxuICAgIHZhciBnZXRBY2xSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLmFjbFJlZiB8fCBudWxsO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRXZWJTb2NrZXRSZWYgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG1ldGFkYXRhLndlYlNvY2tldFJlZiB8fCBudWxsO1xyXG4gICAgfTtcclxuICAgIHZhciByZW1vdmVTdWJqZWN0ID0gZnVuY3Rpb24gKHN1YmplY3RSZWYpIHtcclxuICAgICAgICB2YXIgc3ViamVjdCA9IHN1YmplY3RDYWNoZS5nZXRTdWJqZWN0KHN1YmplY3RSZWYpO1xyXG4gICAgICAgIHJldHVybiBzdWJqZWN0LmNsZWFyKCk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGZpbmRTdWJqZWN0ID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZiwgb2JqZWN0UmVmKSB7XHJcbiAgICAgICAgdmFyIGZpbmRTdWJqZWN0UmVmID0gd2l0aERvY3VtZW50U2luZ3VsYXIoZmluZFN1YmplY3RJbkRhdGFzZXQsIGRhdGFzZXQpO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVmID0gZmluZFN1YmplY3RSZWYocHJlZGljYXRlUmVmLCBvYmplY3RSZWYpO1xyXG4gICAgICAgIGlmICghc3ViamVjdFJlZiB8fCAhaXNSZWZlcmVuY2Uoc3ViamVjdFJlZikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJqZWN0Q2FjaGUuZ2V0U3ViamVjdChzdWJqZWN0UmVmKTtcclxuICAgIH07XHJcbiAgICB2YXIgZmluZFN1YmplY3RzID0gZnVuY3Rpb24gKHByZWRpY2F0ZVJlZiwgb2JqZWN0UmVmKSB7XHJcbiAgICAgICAgdmFyIGZpbmRTdWJqZWN0UmVmcyA9IHdpdGhEb2N1bWVudFBsdXJhbChmaW5kU3ViamVjdHNJbkRhdGFzZXQsIGRhdGFzZXQpO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVmcyA9IGZpbmRTdWJqZWN0UmVmcyhwcmVkaWNhdGVSZWYsIG9iamVjdFJlZik7XHJcbiAgICAgICAgcmV0dXJuIHN1YmplY3RSZWZzLmZpbHRlcihpc1JlZmVyZW5jZSkubWFwKHN1YmplY3RDYWNoZS5nZXRTdWJqZWN0KTtcclxuICAgIH07XHJcbiAgICB2YXIgZ2V0QWxsU3ViamVjdHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFsbFN1YmplY3RSZWZzSW5UcmlwbGVzID0gZmluZEVudGl0aWVzSW5EYXRhc2V0KGRhdGFzZXQsICdzdWJqZWN0JywgbnVsbCwgbnVsbCwgbnVsbClcclxuICAgICAgICAgICAgLmZpbHRlcihpc1JlZmVyZW5jZSk7XHJcbiAgICAgICAgdmFyIHVuaXF1ZVN1YmplY3RSZWZzID0gQXJyYXkuZnJvbShuZXcgU2V0KGFsbFN1YmplY3RSZWZzSW5UcmlwbGVzKSk7XHJcbiAgICAgICAgcmV0dXJuIHVuaXF1ZVN1YmplY3RSZWZzLm1hcChmdW5jdGlvbiAoc3ViamVjdFJlZikgeyByZXR1cm4gc3ViamVjdENhY2hlLmdldFN1YmplY3Qoc3ViamVjdFJlZik7IH0pO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRBbGxTdWJqZWN0c09mVHlwZSA9IGZ1bmN0aW9uICh0eXBlUmVmKSB7XHJcbiAgICAgICAgcmV0dXJuIGZpbmRTdWJqZWN0cygnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zI3R5cGUnLCB0eXBlUmVmKTtcclxuICAgIH07XHJcbiAgICB2YXIgc2F2ZSA9IGZ1bmN0aW9uIChzdWJqZWN0cykge1xyXG4gICAgICAgIGlmIChzdWJqZWN0cyA9PT0gdm9pZCAwKSB7IHN1YmplY3RzID0gT2JqZWN0LnZhbHVlcyhzdWJqZWN0Q2FjaGUuZ2V0QWNjZXNzZWRTdWJqZWN0cygpKTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwZW5kaW5nQ2hhbmdlcywgdXBkYXRlZE1ldGFkYXRhLCByZXNwb25zZSwgbWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoYW5nZXMgPSBnZXRQZW5kaW5nQ2hhbmdlcyhzdWJqZWN0cywgdHJpcGxlRG9jdW1lbnQsIGRhdGFzZXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB1cGRhdGUobWV0YWRhdGEuZG9jdW1lbnRSZWYsIHBlbmRpbmdDaGFuZ2VzLmFsbERlbGV0aW9ucywgcGVuZGluZ0NoYW5nZXMuYWxsQWRkaXRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEhcmVzcG9uc2Uub2spIHJldHVybiBbMyAvKmJyZWFrKi8sIDNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS50ZXh0KCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZE1ldGFkYXRhID0gX19hc3NpZ24oX19hc3NpZ24oe30sIG1ldGFkYXRhKSwgeyBleGlzdHNPblBvZDogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgYSBuZXcgVHJpcGxlRG9jdW1lbnQgdGhhdCBpbmNsdWRlcyB0aGUgdXBkYXRlZCBUcmlwbGVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW5zdGFudGlhdGVEb2N1bWVudChwZW5kaW5nQ2hhbmdlcy5uZXdUcmlwbGVzLCB1cGRhdGVkTWV0YWRhdGEpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGdldFN0b3JlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YXNldDsgfTtcclxuICAgIHZhciBnZXRUcmlwbGVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZGF0YXNldC50b0FycmF5KCk7IH07XHJcbiAgICB2YXIgdHJpcGxlRG9jdW1lbnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdHJpcGxlRG9jdW1lbnRXaXRoUmVmKSwgeyBzYXZlOiBzYXZlLCByZW1vdmVTdWJqZWN0OiByZW1vdmVTdWJqZWN0LCBnZXRTdWJqZWN0OiBzdWJqZWN0Q2FjaGUuZ2V0U3ViamVjdCwgZ2V0QWxsU3ViamVjdHNPZlR5cGU6IGdldEFsbFN1YmplY3RzT2ZUeXBlLCBmaW5kU3ViamVjdDogZmluZFN1YmplY3QsIGZpbmRTdWJqZWN0czogZmluZFN1YmplY3RzLCBnZXRBY2xSZWY6IGdldEFjbFJlZiwgZ2V0V2ViU29ja2V0UmVmOiBnZXRXZWJTb2NrZXRSZWYsIFxyXG4gICAgICAgIC8vIEV4cGVyaW1lbnRhbCBtZXRob2RzOlxyXG4gICAgICAgIGV4cGVyaW1lbnRhbF9nZXRBbGxTdWJqZWN0czogZ2V0QWxsU3ViamVjdHMsIFxyXG4gICAgICAgIC8vIEVzY2FwZSBoYXRjaGVzLCBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeTpcclxuICAgICAgICBnZXRTdG9yZTogZ2V0U3RvcmUsIGdldFRyaXBsZXM6IGdldFRyaXBsZXMsIFxyXG4gICAgICAgIC8vIERlcHJlY2F0ZWQgYWxpYXNlcywgaW5jbHVkZWQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OlxyXG4gICAgICAgIGdldEFjbDogZ2V0QWNsUmVmLCBnZXRTdGF0ZW1lbnRzOiBnZXRUcmlwbGVzLCBnZXRTdWJqZWN0c09mVHlwZTogZ2V0QWxsU3ViamVjdHNPZlR5cGUgfSk7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhhdCB3aGVuIFRyaXBsZVN1YmplY3RzIGdldCBpbml0aWFsaXNlZCBmb3IgdGhpcyBEb2N1bWVudCxcclxuICAgIC8vIHRoZXkncmUgYXR0YWNoZWQgdG8gdGhlIGZ1bGx5IGluaXRpYWxpc2VkIERvY3VtZW50IGluc3RhbmNlOlxyXG4gICAgc3ViamVjdENhY2hlLnNldERvY3VtZW50KHRyaXBsZURvY3VtZW50KTtcclxuICAgIHJldHVybiB0cmlwbGVEb2N1bWVudDtcclxufVxyXG52YXIgd2l0aERvY3VtZW50U2luZ3VsYXIgPSBmdW5jdGlvbiAoZ2V0RW50aXR5RnJvbVRyaXBsZXMsIGRhdGFzZXQpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAoa25vd25FbnRpdHkxLCBrbm93bkVudGl0eTIpIHtcclxuICAgICAgICByZXR1cm4gZ2V0RW50aXR5RnJvbVRyaXBsZXMoZGF0YXNldCwga25vd25FbnRpdHkxLCBrbm93bkVudGl0eTIpO1xyXG4gICAgfTtcclxufTtcclxudmFyIHdpdGhEb2N1bWVudFBsdXJhbCA9IGZ1bmN0aW9uIChnZXRFbnRpdGllc0Zyb21UcmlwbGVzLCBkYXRhc2V0KSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtub3duRW50aXR5MSwga25vd25FbnRpdHkyKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldEVudGl0aWVzRnJvbVRyaXBsZXMoZGF0YXNldCwga25vd25FbnRpdHkxLCBrbm93bkVudGl0eTIpO1xyXG4gICAgfTtcclxufTtcblxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFudGlhdGVMb2NhbFRyaXBsZURvY3VtZW50Rm9yQ29udGFpbmVyKGRhdGFzZXQsIHN1YmplY3RDYWNoZSwgbWV0YWRhdGEpIHtcclxuICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICB2YXIgYmFyZVRyaXBsZURvY3VtZW50ID0gaW5zdGFudGlhdGVCYXJlVHJpcGxlRG9jdW1lbnQoc3ViamVjdENhY2hlLCBtZXRhZGF0YSk7XHJcbiAgICB2YXIgc2F2ZSA9IGZ1bmN0aW9uIChzdWJqZWN0cykge1xyXG4gICAgICAgIGlmIChzdWJqZWN0cyA9PT0gdm9pZCAwKSB7IHN1YmplY3RzID0gT2JqZWN0LnZhbHVlcyhzdWJqZWN0Q2FjaGUuZ2V0QWNjZXNzZWRTdWJqZWN0cygpKTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIoX3RoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBwZW5kaW5nQ2hhbmdlcywgdXBkYXRlZE1ldGFkYXRhLCBjb250YWluZXJSZXNwb25zZSwgbG9jYXRpb25IZWFkZXIsIG1lc3NhZ2UsIGRvY3VtZW50UmVmLCBkb2N1bWVudFJlc3BvbnNlLCBhY2xSZWYsIHdlYlNvY2tldFJlZjtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ0NoYW5nZXMgPSBnZXRQZW5kaW5nQ2hhbmdlcyhzdWJqZWN0cywgbG9jYWxUcmlwbGVEb2N1bWVudEZvckNvbnRhaW5lciwgZGF0YXNldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNyZWF0ZUluQ29udGFpbmVyKG1ldGFkYXRhLmNvbnRhaW5lclJlZiwgcGVuZGluZ0NoYW5nZXMuYWxsQWRkaXRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250YWluZXJSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYXRpb25IZWFkZXIgPSBjb250YWluZXJSZXNwb25zZS5oZWFkZXJzLmdldCgnTG9jYXRpb24nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoIWNvbnRhaW5lclJlc3BvbnNlLm9rIHx8IGxvY2F0aW9uSGVhZGVyID09PSBudWxsKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgM107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGNvbnRhaW5lclJlc3BvbnNlLnRleHQoKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFJlZiA9IG5ldyBVUkwobG9jYXRpb25IZWFkZXIsIG5ldyBVUkwobWV0YWRhdGEuY29udGFpbmVyUmVmKS5vcmlnaW4pLmhyZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRNZXRhZGF0YSA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBtZXRhZGF0YSksIHsgY29udGFpbmVyUmVmOiB1bmRlZmluZWQsIGRvY3VtZW50UmVmOiBkb2N1bWVudFJlZiwgZXhpc3RzT25Qb2Q6IHRydWUgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGhlYWQoZG9jdW1lbnRSZWYpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50UmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjbFJlZiA9IGV4dHJhY3RBY2xSZWYoZG9jdW1lbnRSZXNwb25zZSwgZG9jdW1lbnRSZWYpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYWNsUmVmKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVkTWV0YWRhdGEuYWNsUmVmID0gYWNsUmVmO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldFJlZiA9IGRvY3VtZW50UmVzcG9uc2UuaGVhZGVycy5nZXQoJ1VwZGF0ZXMtVmlhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3ZWJTb2NrZXRSZWYpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRNZXRhZGF0YS53ZWJTb2NrZXRSZWYgPSB3ZWJTb2NrZXRSZWY7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zdGFudGlhdGUgYSBuZXcgVHJpcGxlRG9jdW1lbnQgdGhhdCBpbmNsdWRlcyB0aGUgdXBkYXRlZCBUcmlwbGVzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgaW5zdGFudGlhdGVEb2N1bWVudChwZW5kaW5nQ2hhbmdlcy5uZXdUcmlwbGVzLCB1cGRhdGVkTWV0YWRhdGEpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgdmFyIGxvY2FsVHJpcGxlRG9jdW1lbnRGb3JDb250YWluZXIgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYmFyZVRyaXBsZURvY3VtZW50KSwgeyBzYXZlOiBzYXZlIH0pO1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgd2hlbiBUcmlwbGVTdWJqZWN0cyBnZXQgaW5pdGlhbGlzZWQgZm9yIHRoaXMgRG9jdW1lbnQsXHJcbiAgICAvLyB0aGV5J3JlIGF0dGFjaGVkIHRvIHRoaXMgRG9jdW1lbnQgaW5zdGFuY2U6XHJcbiAgICBzdWJqZWN0Q2FjaGUuc2V0RG9jdW1lbnQobG9jYWxUcmlwbGVEb2N1bWVudEZvckNvbnRhaW5lcik7XHJcbiAgICByZXR1cm4gbG9jYWxUcmlwbGVEb2N1bWVudEZvckNvbnRhaW5lcjtcclxufVxuXG4vKipcclxuICogQGlnbm9yZSBOb3QgeWV0IGEgc3VwcG9ydGVkIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIGhhc1JlZihkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudC5hc1JlZiA9PT0gJ2Z1bmN0aW9uJztcclxufVxyXG4vKipcclxuICogQGlnbm9yZSBOb3QgeWV0IGEgc3VwcG9ydGVkIEFQSS5cclxuICovXHJcbmZ1bmN0aW9uIGlzU2F2ZWRUb1BvZChkb2N1bWVudCkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkb2N1bWVudC5nZXRUcmlwbGVzID09PSAnZnVuY3Rpb24nO1xyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXNlIGEgbmV3IFR1cnRsZSBkb2N1bWVudFxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBEb2N1bWVudCB3aWxsIG5vdCBiZSBjcmVhdGVkIG9uIHRoZSBQb2QgdW50aWwgeW91IGNhbGwgW1tzYXZlXV0gb24gaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSByZWYgVVJMIHdoZXJlIHRoaXMgZG9jdW1lbnQgc2hvdWxkIGxpdmVcclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZURvY3VtZW50KHJlZikge1xyXG4gICAgcmV0dXJuIGluc3RhbnRpYXRlRG9jdW1lbnQoW10sIHsgZG9jdW1lbnRSZWY6IHJlZiwgZXhpc3RzT25Qb2Q6IGZhbHNlIH0pO1xyXG59XHJcbi8qKlxyXG4gKiBJbml0aWFsaXNlIGEgbmV3IFR1cnRsZSBEb2N1bWVudCBpbiBhIENvbnRhaW5lclxyXG4gKlxyXG4gKiBOb3RlIHRoYXQgdGhpcyBEb2N1bWVudCB3aWxsIG5vdCBiZSBjcmVhdGVkIG9uIHRoZSBQb2QgdW50aWwgeW91IGNhbGwgW1tzYXZlXV0gb24gaXQuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXJSZWYgVVJMIG9mIHRoZSBDb250YWluZXIgaW4gd2hpY2ggdGhpcyBkb2N1bWVudCBzaG91bGQgbGl2ZVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlRG9jdW1lbnRJbkNvbnRhaW5lcihjb250YWluZXJSZWYpIHtcclxuICAgIHJldHVybiBpbnN0YW50aWF0ZURvY3VtZW50KFtdLCB7IGNvbnRhaW5lclJlZjogY29udGFpbmVyUmVmLCBleGlzdHNPblBvZDogZmFsc2UgfSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHJpZXZlIGEgZG9jdW1lbnQgY29udGFpbmluZyBSREYgdHJpcGxlc1xyXG4gKlxyXG4gKiBAcGFyYW0gZG9jdW1lbnRSZWYgV2hlcmUgdGhlIGRvY3VtZW50IGxpdmVzLlxyXG4gKiBAcmV0dXJucyBSZXByZXNlbnRhdGlvbiBvZiB0cmlwbGVzIGluIHRoZSBkb2N1bWVudCBhdCBgdXJpYC5cclxuICovXHJcbmZ1bmN0aW9uIGZldGNoRG9jdW1lbnQodXJpKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRvY1VybCwgZG9jdW1lbnRSZWYsIHJlc3BvbnNlLCByYXdEb2N1bWVudCwgdHJpcGxlcywgYWNsUmVmLCB3ZWJTb2NrZXRSZWY7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZG9jVXJsID0gbmV3IFVSTCh1cmkpO1xyXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50UmVmID0gZG9jVXJsLm9yaWdpbiArIGRvY1VybC5wYXRobmFtZSArIGRvY1VybC5zZWFyY2g7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgZ2V0KGRvY3VtZW50UmVmKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLm9rID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZXRjaGluZyB0aGUgRG9jdW1lbnQgZmFpbGVkOiBcIiArIHJlc3BvbnNlLnN0YXR1cyArIFwiIFwiICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCArIFwiLlwiKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzcG9uc2UudGV4dCgpXTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICByYXdEb2N1bWVudCA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0dXJ0bGVUb1RyaXBsZXMocmF3RG9jdW1lbnQsIGRvY3VtZW50UmVmKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgdHJpcGxlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICBhY2xSZWYgPSBleHRyYWN0QWNsUmVmKHJlc3BvbnNlLCBkb2N1bWVudFJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgd2ViU29ja2V0UmVmID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ1VwZGF0ZXMtVmlhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGluc3RhbnRpYXRlRG9jdW1lbnQodHJpcGxlcywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNsUmVmOiBhY2xSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudFJlZjogZG9jdW1lbnRSZWYsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWJTb2NrZXRSZWY6IHdlYlNvY2tldFJlZiB8fCB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdHNPblBvZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufVxyXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xyXG5mdW5jdGlvbiBleHRyYWN0QWNsUmVmKHJlc3BvbnNlLCBkb2N1bWVudFJlZikge1xyXG4gICAgdmFyIGFjbFJlZjtcclxuICAgIHZhciBsaW5rSGVhZGVyID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ0xpbmsnKTtcclxuICAgIC8vIGBMaW5rSGVhZGVyYCBtaWdodCBub3QgYmUgcHJlc2VudCB3aGVuIHVzaW5nIHRoZSBVTUQgYnVpbGQgaW4gdGhlIGJyb3dzZXIsXHJcbiAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGp1c3QgZG9uJ3QgcGFyc2UgdGhlIEFDTCBoZWFkZXIuIEl0IGlzIHJlY29tbWVuZGVkIHRvIHVzZSBhIG5vbi1VTUQgYnVpbGRcclxuICAgIC8vIHRoYXQgc3VwcG9ydHMgY29kZSBzcGxpdHRpbmcgYW55d2F5LlxyXG4gICAgaWYgKGxpbmtIZWFkZXIgJiYgTGlua0hlYWRlcikge1xyXG4gICAgICAgIHZhciBwYXJzZWRMaW5rcyA9IExpbmtIZWFkZXIucGFyc2UobGlua0hlYWRlcik7XHJcbiAgICAgICAgdmFyIGFjbExpbmtzID0gcGFyc2VkTGlua3MuZ2V0KCdyZWwnLCAnYWNsJyk7XHJcbiAgICAgICAgaWYgKGFjbExpbmtzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICBhY2xSZWYgPSBuZXcgVVJMKGFjbExpbmtzWzBdLnVyaSwgZG9jdW1lbnRSZWYpLmhyZWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFjbFJlZjtcclxufVxyXG5mdW5jdGlvbiBoYXNLbm93blJlZihtZXRhZGF0YSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBtZXRhZGF0YS5kb2N1bWVudFJlZiA9PT0gJ3N0cmluZyc7XHJcbn1cclxuZnVuY3Rpb24gZXhpc3RzT25Qb2QobWV0YWRhdGEpIHtcclxuICAgIHJldHVybiBtZXRhZGF0YS5leGlzdHNPblBvZCA9PT0gdHJ1ZTtcclxufVxyXG5mdW5jdGlvbiBpbnN0YW50aWF0ZURvY3VtZW50KHRyaXBsZXMsIG1ldGFkYXRhKSB7XHJcbiAgICB2YXIgZGF0YXNldCA9IGluaXRpYWxpc2VEYXRhc2V0KCk7XHJcbiAgICBkYXRhc2V0LmFkZEFsbCh0cmlwbGVzKTtcclxuICAgIHZhciBzdWJqZWN0Q2FjaGUgPSBpbml0aWFsaXNlU3ViamVjdENhY2hlKCk7XHJcbiAgICBpZiAoIWhhc0tub3duUmVmKG1ldGFkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUxvY2FsVHJpcGxlRG9jdW1lbnRGb3JDb250YWluZXIoZGF0YXNldCwgc3ViamVjdENhY2hlLCBtZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICBpZiAoIWV4aXN0c09uUG9kKG1ldGFkYXRhKSkge1xyXG4gICAgICAgIHJldHVybiBpbnN0YW50aWF0ZUxvY2FsVHJpcGxlRG9jdW1lbnQoZGF0YXNldCwgc3ViamVjdENhY2hlLCBtZXRhZGF0YSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaW5zdGFudGlhdGVGdWxsVHJpcGxlRG9jdW1lbnQoZGF0YXNldCwgc3ViamVjdENhY2hlLCBtZXRhZGF0YSk7XHJcbn1cclxuZnVuY3Rpb24gaW5pdGlhbGlzZVN1YmplY3RDYWNoZSgpIHtcclxuICAgIHZhciBzb3VyY2VEb2N1bWVudDtcclxuICAgIHZhciBhY2Nlc3NlZFN1YmplY3RzID0ge307XHJcbiAgICB2YXIgc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiAobmV3RG9jdW1lbnQpIHtcclxuICAgICAgICBzb3VyY2VEb2N1bWVudCA9IG5ld0RvY3VtZW50O1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRTdWJqZWN0ID0gZnVuY3Rpb24gKHN1YmplY3RSZWYpIHtcclxuICAgICAgICAvLyBBbGxvdyByZWxhdGl2ZSBVUkxzIHRvIGFjY2VzcyBTdWJqZWN0cyBpZiB3ZSBrbm93IHdoZXJlIHRoZSBEb2N1bWVudCBpczpcclxuICAgICAgICBzdWJqZWN0UmVmID0gaGFzUmVmKHNvdXJjZURvY3VtZW50KVxyXG4gICAgICAgICAgICA/IG5ldyBVUkwoc3ViamVjdFJlZiwgc291cmNlRG9jdW1lbnQuYXNSZWYoKSkuaHJlZlxyXG4gICAgICAgICAgICA6IHN1YmplY3RSZWY7XHJcbiAgICAgICAgaWYgKCFhY2Nlc3NlZFN1YmplY3RzW3N1YmplY3RSZWZdKSB7XHJcbiAgICAgICAgICAgIGFjY2Vzc2VkU3ViamVjdHNbc3ViamVjdFJlZl0gPSBpbml0aWFsaXNlU3ViamVjdChzb3VyY2VEb2N1bWVudCwgc3ViamVjdFJlZik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhY2Nlc3NlZFN1YmplY3RzW3N1YmplY3RSZWZdO1xyXG4gICAgfTtcclxuICAgIHZhciBnZXRBY2Nlc3NlZFN1YmplY3RzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYWNjZXNzZWRTdWJqZWN0czsgfTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0U3ViamVjdDogZ2V0U3ViamVjdCxcclxuICAgICAgICBzZXREb2N1bWVudDogc2V0RG9jdW1lbnQsXHJcbiAgICAgICAgZ2V0QWNjZXNzZWRTdWJqZWN0czogZ2V0QWNjZXNzZWRTdWJqZWN0cyxcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cclxuZnVuY3Rpb24gaW5zdGFudGlhdGVCYXJlVHJpcGxlRG9jdW1lbnQoc3ViamVjdENhY2hlLCBtZXRhZGF0YSkge1xyXG4gICAgdmFyIGFkZFN1YmplY3QgPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5pZGVudGlmaWVyLCBpZGVudGlmaWVyID0gX2MgPT09IHZvaWQgMCA/IGdlbmVyYXRlSWRlbnRpZmllcigpIDogX2MsIF9kID0gX2IuaWRlbnRpZmllclByZWZpeCwgaWRlbnRpZmllclByZWZpeCA9IF9kID09PSB2b2lkIDAgPyAnJyA6IF9kO1xyXG4gICAgICAgIHZhciBzdWJqZWN0UmVmID0gKGhhc0tub3duUmVmKG1ldGFkYXRhKSA/IG1ldGFkYXRhLmRvY3VtZW50UmVmIDogJycpICsgJyMnICsgaWRlbnRpZmllclByZWZpeCArIGlkZW50aWZpZXI7XHJcbiAgICAgICAgcmV0dXJuIHN1YmplY3RDYWNoZS5nZXRTdWJqZWN0KHN1YmplY3RSZWYpO1xyXG4gICAgfTtcclxuICAgIHZhciBiYXJlVHJpcGxlRG9jdW1lbnQgPSB7XHJcbiAgICAgICAgYWRkU3ViamVjdDogYWRkU3ViamVjdCxcclxuICAgIH07XHJcbiAgICByZXR1cm4gYmFyZVRyaXBsZURvY3VtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXHJcbmZ1bmN0aW9uIGdldFBlbmRpbmdDaGFuZ2VzKHN1YmplY3RzLCBkb2N1bWVudCwgZGF0YXNldCkge1xyXG4gICAgdmFyIHJlbGV2YW50U3ViamVjdHMgPSBzdWJqZWN0cy5maWx0ZXIoZnVuY3Rpb24gKHN1YmplY3QpIHsgcmV0dXJuIHN1YmplY3QuZ2V0RG9jdW1lbnQoKSA9PT0gZG9jdW1lbnQ7IH0pO1xyXG4gICAgdmFyIF9hID0gcmVsZXZhbnRTdWJqZWN0cy5yZWR1Y2UoZnVuY3Rpb24gKF9hLCBzdWJqZWN0KSB7XHJcbiAgICAgICAgdmFyIGRlbGV0aW9uc1NvRmFyID0gX2FbMF0sIGFkZGl0aW9uc1NvRmFyID0gX2FbMV07XHJcbiAgICAgICAgdmFyIF9iID0gc3ViamVjdC5nZXRQZW5kaW5nVHJpcGxlcygpLCBkZWxldGlvbnMgPSBfYlswXSwgYWRkaXRpb25zID0gX2JbMV07XHJcbiAgICAgICAgcmV0dXJuIFtkZWxldGlvbnNTb0Zhci5jb25jYXQoZGVsZXRpb25zKSwgYWRkaXRpb25zU29GYXIuY29uY2F0KGFkZGl0aW9ucyldO1xyXG4gICAgfSwgW1tdLCBbXV0pLCBhbGxEZWxldGlvbnMgPSBfYVswXSwgYWxsQWRkaXRpb25zID0gX2FbMV07XHJcbiAgICB2YXIgbmV3VHJpcGxlcyA9IGRhdGFzZXQudG9BcnJheSgpXHJcbiAgICAgICAgLmNvbmNhdChhbGxBZGRpdGlvbnMpXHJcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAodHJpcGxlVG9EZWxldGUpIHsgcmV0dXJuIGFsbERlbGV0aW9ucy5maW5kSW5kZXgoZnVuY3Rpb24gKHRyaXBsZSkgeyByZXR1cm4gdHJpcGxlLmVxdWFscyh0cmlwbGVUb0RlbGV0ZSk7IH0pID09PSAtMTsgfSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFsbEFkZGl0aW9uczogYWxsQWRkaXRpb25zLFxyXG4gICAgICAgIGFsbERlbGV0aW9uczogYWxsRGVsZXRpb25zLFxyXG4gICAgICAgIG5ld1RyaXBsZXM6IG5ld1RyaXBsZXMsXHJcbiAgICB9O1xyXG59XHJcbi8qKlxyXG4gKiBHZW5lcmF0ZSBhIHN0cmluZyB0aGF0IGNhbiBiZSB1c2VkIGFzIHRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgYSBTdWJqZWN0XHJcbiAqXHJcbiAqIFRoaXMgZnVuY3Rpb24gd29ya3MgYnkgc3RhcnRpbmcgd2l0aCBhIGRhdGUgc3RyaW5nIChzbyB0aGF0IFN1YmplY3RzIGNhbiBiZVxyXG4gKiBzb3J0ZWQgY2hyb25vbG9naWNhbGx5KSwgZm9sbG93ZWQgYnkgYSByYW5kb20gbnVtYmVyIGdlbmVyYXRlZCBieSB0YWtpbmcgYVxyXG4gKiByYW5kb20gbnVtYmVyIGJldHdlZW4gMCBhbmQgMSwgYW5kIGN1dHRpbmcgb2ZmIHRoZSBgMC5gLlxyXG4gKlxyXG4gKiBAaW50ZXJuYWxcclxuICogQHJldHVybnMgQW4gc3RyaW5nIHRoYXQncyBsaWtlbHkgdG8gYmUgdW5pcXVlXHJcbiAqL1xyXG52YXIgZ2VuZXJhdGVJZGVudGlmaWVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIERhdGUubm93KCkudG9TdHJpbmcoKSArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoKS5zdWJzdHJpbmcoJzAuJy5sZW5ndGgpO1xyXG59O1xuXG4vKipcclxuICogQGlnbm9yZSBUcmlwbGVkb2MncyBtZXRob2RzIHNob3VsZCBiZSBleHBsaWNpdCBhYm91dCB3aGV0aGVyIHRoZXkgcmV0dXJuIG9yIGFjY2VwdCBhIExpdGVyYWwsIHNvXHJcbiAqICAgICAgICAgdGhpcyBpcyBtZXJlbHkgYW4gaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBwdWJsaWMgQVBJLlxyXG4gKiBAcGFyYW0gcGFyYW0gQSB2YWx1ZSB0aGF0IG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhbiBOMyBMaXRlcmFsLlxyXG4gKiBAcmV0dXJucyBXaGV0aGVyIGBwYXJhbWAgaXMgYW4gTjMgTGl0ZXJhbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzTGl0ZXJhbChwYXJhbSkge1xyXG4gICAgcmV0dXJuICh0eXBlb2YgcGFyYW0gPT09ICdvYmplY3QnKSAmJlxyXG4gICAgICAgIChwYXJhbSAhPT0gbnVsbCkgJiZcclxuICAgICAgICAodHlwZW9mIHBhcmFtLnRlcm1UeXBlID09PSAnc3RyaW5nJykgJiZcclxuICAgICAgICBwYXJhbS50ZXJtVHlwZSA9PT0gJ0xpdGVyYWwnO1xyXG59XHJcbi8qKlxyXG4gKiBAaW50ZXJuYWwgVHJpcGxlZG9jJ3MgbWV0aG9kcyBzaG91bGQgYmUgZXhwbGljaXQgYWJvdXQgd2hldGhlciB0aGV5IHJldHVybiBvciBhY2NlcHQgYSBzcGVjaWZpY1xyXG4gKiAgICAgICAgICAgdHlwZSwgc28gdGhpcyBpcyBtZXJlbHkgYW4gaW50ZXJuYWwgdXRpbGl0eSBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBwdWJsaWMgQVBJLlxyXG4gKiBAcGFyYW0gcGFyYW0gQSB2YWx1ZSB0aGF0IG1pZ2h0IG9yIG1pZ2h0IG5vdCBiZSBhbiBOMyBzdHJpbmcgTGl0ZXJhbC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGFuIE4zIHN0cmluZyBMaXRlcmFsLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNTdHJpbmdMaXRlcmFsKHBhcmFtKSB7XHJcbiAgICByZXR1cm4gaXNMaXRlcmFsKHBhcmFtKSAmJiBwYXJhbS5kYXRhdHlwZS52YWx1ZSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDEvWE1MU2NoZW1hI3N0cmluZyc7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUcmlwbGVkb2MncyBtZXRob2RzIHNob3VsZCBiZSBleHBsaWNpdCBhYm91dCB3aGV0aGVyIHRoZXkgcmV0dXJuIG9yIGFjY2VwdCBhIHNwZWNpZmljXHJcbiAqICAgICAgICAgICB0eXBlLCBzbyB0aGlzIGlzIG1lcmVseSBhbiBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIHB1YmxpYyBBUEkuXHJcbiAqIEBwYXJhbSBwYXJhbSBBIHZhbHVlIHRoYXQgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGFuIE4zIGxvY2FsZSBzdHJpbmcgTGl0ZXJhbC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGFuIE4zIGxvY2FsZSBzdHJpbmcgTGl0ZXJhbCB3aXRoIHRoZSBnaXZlbiBsb2NhbGUuXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0xvY2FsZVN0cmluZ0xpdGVyYWwocGFyYW0sIGxvY2FsZSkge1xyXG4gICAgcmV0dXJuIGlzTGl0ZXJhbChwYXJhbSkgJiZcclxuICAgICAgICBwYXJhbS5kYXRhdHlwZS52YWx1ZSA9PT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNsYW5nU3RyaW5nJyAmJlxyXG4gICAgICAgIHBhcmFtLmxhbmd1YWdlLnRvTG93ZXJDYXNlKCkgPT09IGxvY2FsZS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbi8qKlxyXG4gKiBQcmltYXJpbHkgdXNlZnVsIHRvIGNyZWF0ZSB0eXBlIGd1YXJzZCBmb3IgdXNlIGluIGUuZy4gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgLlxyXG4gKiBAaW50ZXJuYWwgVGhpcyBpcyBhbiBpbnRlcm5hbCBUcmlwbGVEb2MgZGF0YSB0eXBlIHRoYXQgc2hvdWxkIG5vdCBiZSBleHBvc2VkIHRvIGxpYnJhcnkgY29uc3VtZXJzLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VuZXJhdGVMb2NhbGVUeXBlR3VhcmQobG9jYWxlKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gdHlwZUd1YXJkKHBhcmFtKSB7XHJcbiAgICAgICAgcmV0dXJuIGlzTG9jYWxlU3RyaW5nTGl0ZXJhbChwYXJhbSwgbG9jYWxlKTtcclxuICAgIH07XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUcmlwbGVkb2MncyBtZXRob2RzIHNob3VsZCBiZSBleHBsaWNpdCBhYm91dCB3aGV0aGVyIHRoZXkgcmV0dXJuIG9yIGFjY2VwdCBhIHNwZWNpZmljXHJcbiAqICAgICAgICAgICB0eXBlLCBzbyB0aGlzIGlzIG1lcmVseSBhbiBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIHB1YmxpYyBBUEkuXHJcbiAqIEBwYXJhbSBwYXJhbSBBIHZhbHVlIHRoYXQgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGFuIE4zIGludGVnZXIgTGl0ZXJhbC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGFuIE4zIGludGVnZXIgTGl0ZXJhbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzSW50ZWdlckxpdGVyYWwocGFyYW0pIHtcclxuICAgIHJldHVybiBpc0xpdGVyYWwocGFyYW0pICYmIHBhcmFtLmRhdGF0eXBlLnZhbHVlID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjaW50ZWdlcic7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUcmlwbGVkb2MncyBtZXRob2RzIHNob3VsZCBiZSBleHBsaWNpdCBhYm91dCB3aGV0aGVyIHRoZXkgcmV0dXJuIG9yIGFjY2VwdCBhIHNwZWNpZmljXHJcbiAqICAgICAgICAgICB0eXBlLCBzbyB0aGlzIGlzIG1lcmVseSBhbiBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIHB1YmxpYyBBUEkuXHJcbiAqIEBwYXJhbSBwYXJhbSBBIHZhbHVlIHRoYXQgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGFuIE4zIGRlY2ltYWwgTGl0ZXJhbC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGFuIE4zIGRlY2ltYWwgTGl0ZXJhbC5cclxuICovXHJcbmZ1bmN0aW9uIGlzRGVjaW1hbExpdGVyYWwocGFyYW0pIHtcclxuICAgIHJldHVybiBpc0xpdGVyYWwocGFyYW0pICYmIHBhcmFtLmRhdGF0eXBlLnZhbHVlID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjZGVjaW1hbCc7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBUcmlwbGVkb2MncyBtZXRob2RzIHNob3VsZCBiZSBleHBsaWNpdCBhYm91dCB3aGV0aGVyIHRoZXkgcmV0dXJuIG9yIGFjY2VwdCBhIHNwZWNpZmljXHJcbiAqICAgICAgICAgICB0eXBlLCBzbyB0aGlzIGlzIG1lcmVseSBhbiBpbnRlcm5hbCB1dGlsaXR5IGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIHB1YmxpYyBBUEkuXHJcbiAqIEBwYXJhbSBwYXJhbSBBIHZhbHVlIHRoYXQgbWlnaHQgb3IgbWlnaHQgbm90IGJlIGFuIE4zIERhdGVUaW1lIExpdGVyYWwuXHJcbiAqIEByZXR1cm5zIFdoZXRoZXIgYHBhcmFtYCBpcyBhbiBOMyBEYXRlVGltZSBMaXRlcmFsLlxyXG4gKi9cclxuZnVuY3Rpb24gaXNEYXRlVGltZUxpdGVyYWwocGFyYW0pIHtcclxuICAgIHJldHVybiBpc0xpdGVyYWwocGFyYW0pICYmIHBhcmFtLmRhdGF0eXBlLnZhbHVlID09PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjZGF0ZVRpbWUnO1xyXG59XHJcbi8qKlxyXG4gKiBAaWdub3JlIERlcHJlY2F0ZWQgZnVuY3Rpb24uXHJcbiAqIEBkZXByZWNhdGVkIFJlcGxhY2VkIGJ5IFtbaXNSZWZlcmVuY2VdXS5cclxuICovXHJcbnZhciBpc05vZGVSZWYgPSBpc1JlZmVyZW5jZTtcclxuLyoqXHJcbiAqIEBpZ25vcmUgVHJpcGxlZG9jJ3MgbWV0aG9kcyBzaG91bGQgYmUgZXhwbGljaXQgYWJvdXQgd2hldGhlciB0aGV5IHJldHVybiBvciBhY2NlcHQgYSBbW1JlZmVyZW5jZV1dLFxyXG4gKiAgICAgICAgIHNvIHRoaXMgaXMgbWVyZWx5IGFuIGludGVybmFsIHV0aWxpdHkgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgcHVibGljIEFQSS5cclxuICogQHBhcmFtIHBhcmFtIEEgdmFsdWUgdGhhdCBtaWdodCBvciBtaWdodCBub3QgYmUgYSByZWZlcmVuY2UgdG8gYSBub2RlIGluIHRoZSBMaW5rZWQgRGF0YSBncmFwaC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGEgcmVmZXJlbmNlIHRvIGEgbm9kZSBpbiB0aGUgTGlua2VkIERhdGEgZ3JhcGguXHJcbiAqL1xyXG5mdW5jdGlvbiBpc1JlZmVyZW5jZSh2YWx1ZSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiYgIWlzTGl0ZXJhbCh2YWx1ZSk7XHJcbn1cclxuLyoqXHJcbiAqIEBpbnRlcm5hbCBCbGFuayBOb2RlcyB0aGVtc2VsdmVzIHNob3VsZCBub3QgYmUgZXhwb3NlZCB0byBsaWJyYXJ5IGNvbnN1bWVycywgc28gdGhpcyBpcyBtZXJlbHkgYW5cclxuICogICAgICAgICAgIGludGVybmFsIHV0aWxpdHkgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgcHVibGljIEFQSS5cclxuICogQHBhcmFtIHBhcmFtIEEgdmFsdWUgdGhhdCBtaWdodCBvciBtaWdodCBub3QgYmUgYSBibGFuayBub2RlIGluIHRoZSBMaW5rZWQgRGF0YSBncmFwaC5cclxuICogQHJldHVybnMgV2hldGhlciBgcGFyYW1gIGlzIGEgYmxhbmsgbm9kZSBpbiB0aGUgTGlua2VkIERhdGEgZ3JhcGguXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0JsYW5rTm9kZSQxKHBhcmFtKSB7XHJcbiAgICByZXR1cm4gKHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCcpICYmXHJcbiAgICAgICAgKHBhcmFtICE9PSBudWxsKSAmJlxyXG4gICAgICAgICh0eXBlb2YgcGFyYW0udGVybVR5cGUgPT09ICdzdHJpbmcnKSAmJlxyXG4gICAgICAgIHBhcmFtLnRlcm1UeXBlID09PSAnQmxhbmtOb2RlJztcclxufVxuXG5leHBvcnQgeyBjcmVhdGVEb2N1bWVudCwgY3JlYXRlRG9jdW1lbnRJbkNvbnRhaW5lciwgZmV0Y2hEb2N1bWVudCwgZ2VuZXJhdGVMb2NhbGVUeXBlR3VhcmQsIGhhc1JlZiwgaXNCbGFua05vZGUkMSBhcyBpc0JsYW5rTm9kZSwgaXNEYXRlVGltZUxpdGVyYWwsIGlzRGVjaW1hbExpdGVyYWwsIGlzSW50ZWdlckxpdGVyYWwsIGlzTGl0ZXJhbCwgaXNMb2NhbGVTdHJpbmdMaXRlcmFsLCBpc05vZGVSZWYsIGlzUmVmZXJlbmNlLCBpc1NhdmVkVG9Qb2QsIGlzU3RyaW5nTGl0ZXJhbCB9O1xuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcbmltcG9ydCAqIGFzIFNvbGlkRmlsZUNsaWVudCBmcm9tIFwic29saWQtZmlsZS1jbGllbnRcIlxyXG5pbXBvcnQgeyBmZXRjaERvY3VtZW50IH0gZnJvbSBcInRyaXBsZWRvY1wiO1xyXG5pbXBvcnQgeyBuYW1lZE5vZGUgfSBmcm9tICdAcmRmanMvZGF0YS1tb2RlbCc7XHJcblxyXG5jbGFzcyBCcm93c2VyVmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgd2ViSWQ6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBzdG9yYWdlOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgcGF0aDoge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGxhc3Q6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBmb2xkZXI6IHt0eXBlOiBPYmplY3R9LFxyXG4gICAgICBmb2xkZXJOYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZmlsZU5hbWU6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICBjcmVhdGVIaWRkZW46IHt0eXBlOiBCb29sZWFufSxcclxuICAgICAgY3VycmVudEZpbGU6IHt0eXBlOiBTdHJpbmd9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJCcm93c2VyXCJcclxuICAgIHRoaXMud2ViSWQgPSB7fVxyXG4gICAgdGhpcy5zdG9yYWdlID0gXCJcIlxyXG4gICAgdGhpcy5wYXRoID0gXCJcIlxyXG4gICAgdGhpcy5sYXN0ID0gXCJcIlxyXG4gICAgdGhpcy5mb2xkZXIgPSB7Zm9sZGVyczpbXSwgZmlsZXM6IFtdfVxyXG4gICAgdGhpcy5mb2xkZXJOYW1lID0gXCJcIlxyXG4gICAgdGhpcy5maWxlTmFtZSA9IFwiXCJcclxuICAgIHRoaXMuZmMgPSBuZXcgU29saWRGaWxlQ2xpZW50KHNvbGlkLmF1dGgpXHJcbiAgICB0aGlzLmNyZWF0ZUhpZGRlbiA9IHRydWVcclxuICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcbiAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuXHJcbiAgICBjdXJyZW50RmlsZSA6ICR7dGhpcy5jdXJyZW50RmlsZX1cclxuICAgIDxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWRcIiA/aGlkZGVuPVwiJHt0aGlzLnBhdGgubGVuZ3RoID09IDB9XCI+XHJcbiAgICA8ZGl2IGNsYXNzPVwiYnRuLWdyb3VwICBjb250YWluZXItZmx1aWRcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiQmFzaWMgZXhhbXBsZVwiPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIEBjbGljaz1cIiR7dGhpcy51cH1cIj48aSBjbGFzcz1cImZhcyBmYS1hcnJvdy11cFwiIEBjbGljaz1cIiR7dGhpcy51cH1cIj48L2k+IDwvYnV0dG9uPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeVwiIEBjbGljaz1cIiR7dGhpcy5wcmVjfVwiPjxpIGNsYXNzPVwiZmFzIGZhLWFycm93LWxlZnRcIiBAY2xpY2s9XCIke3RoaXMucHJlY31cIj48L2k+PC9idXR0b24+XHJcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgaW5wdXRfdHlwZT1cImZvbGRlcm5hbWVcIiBAY2xpY2s9XCIke3RoaXMubmV3fVwiPjxpIGNsYXNzPVwiZmFzIGZhLWZvbGRlci1wbHVzXCIgaW5wdXRfdHlwZT1cImZvbGRlcm5hbWVcIiAgQGNsaWNrPVwiJHt0aGlzLm5ld31cIj48L2k+PC9idXR0b24+XHJcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgaW5wdXRfdHlwZT1cImZpbGVuYW1lXCIgQGNsaWNrPVwiJHt0aGlzLm5ld31cIj48aSBjbGFzcz1cImZhcyBmYS1maWxlXCIgaW5wdXRfdHlwZT1cImZpbGVuYW1lXCIgQGNsaWNrPVwiJHt0aGlzLm5ld31cIj48L2k+PC9idXR0b24+XHJcbiAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5XCIgaW5wdXRfdHlwZT1cImZpbGVcIiBAY2xpY2s9XCIke3RoaXMubmV3fVwiPjxpIGNsYXNzPVwiZmFzIGZhLWZpbGUtdXBsb2FkXCIgaW5wdXRfdHlwZT1cImZpbGVcIiBAY2xpY2s9XCIke3RoaXMubmV3fVwiPjwvaT48L2J1dHRvbj5cclxuICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1zZWNvbmRhcnlcIiBkaXNhYmxlZCBAY2xpY2s9XCIke3RoaXMuc29saWR9XCI+PGkgY2xhc3M9XCJmYXMgZmEtdXNlci1mcmllbmRzXCIgQGNsaWNrPVwiJHt0aGlzLnNvbGlkfVwiPjwvaT4gc29saWQ8L2J1dHRvbj5cclxuICAgIDwvZGl2PlxyXG4gICAgPGJyPlxyXG4gICAgPGRpdiBjbGFzcz1cImJ0bi1ncm91cCBjb250YWluZXItZmx1aWRcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiQmFzaWMgZXhhbXBsZVwiPlxyXG4gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5XCIgZGlzYWJsZWQ+JHt0aGlzLnBhdGh9PC9idXR0b24+XHJcbiAgICA8L2Rpdj5cclxuXHJcblxyXG4gICAgPGRpdiAgP2hpZGRlbj1cIiR7dGhpcy5jcmVhdGVIaWRkZW59XCJcclxuICAgIGNsYXNzPVwiYnRuLWdyb3VwIGNvbnRhaW5lci1mbHVpZFwiIHJvbGU9XCJncm91cFwiIGFyaWEtbGFiZWw9XCJuZXdcIj5cclxuICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zXCI+XHJcbiAgICA8aW5wdXQgdHlwZT1cInRleHRcIlxyXG4gICAgaWQ9XCJjcmVhdGVfaW5wdXRcIiBjbGFzcz1cImZvcm0tY29udHJvbFwiXHJcbiAgICBwbGFjZWhvbGRlcj1cIkZvbGRlciBvciBGaWxlIG5hbWVcIlxyXG4gICAgYXJpYS1sYWJlbD1cIkZvbGRlciBvciBGaWxlIG5hbWVcIlxyXG4gICAgYXJpYS1kZXNjcmliZWRieT1cImJhc2ljLWFkZG9uMlwiPlxyXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LWdyb3VwLWFwcGVuZFwiPlxyXG4gICAgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiB0eXBlPVwiYnV0dG9uXCIgQGNsaWNrPVwiJHt0aGlzLmNyZWF0ZX1cIj5DcmVhdGU8L2J1dHRvbj5cclxuICAgIDxpIGNsYXNzPVwiZmFzIGZhLXRpbWVzIGJ0biBidG4tb3V0bGluZS1zZWNvbmRhcnlcIiBAY2xpY2s9XCIke3RoaXMuY2xvc2VDcmVhdGVJbnB1dH1cIj48L2k+XHJcbiAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICAgPC9kaXY+XHJcblxyXG5cclxuXHJcbiAgICA8ZGl2IHN0eWxlPVwiaGVpZ2h0OiAzMHZoOyB3aWR0aDoxMDAlOyBvdmVyZmxvdzogYXV0b1wiPlxyXG4gICAgPHVsIGNsYXNzPVwibGlzdC1ncm91cFwiPlxyXG4gICAgJHt0aGlzLmZvbGRlci5mb2xkZXJzLm1hcCgoZiwgaSkgPT5cclxuICAgICAgaHRtbGBcclxuICAgICAgPGxpIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCIgdXJsPVwiJHtmLnVybH1cIiB0eXBlPVwiJHtmLnR5cGV9XCIgQGNsaWNrPVwiJHt0aGlzLmNoYW5nZVBhdGh9XCI+XHJcbiAgICAgIDxpIGNsYXNzPVwiZmFzIGZhLWZvbGRlclwiPjwvaT5cclxuICAgICAgJHtmLm5hbWV9PC9saT5cclxuICAgICAgYFxyXG4gICAgKX1cclxuICAgIDwvdWw+XHJcbiAgICA8aHI+XHJcbiAgICA8dWwgY2xhc3M9XCJsaXN0LWdyb3VwXCI+XHJcbiAgICAke3RoaXMuZm9sZGVyLmZpbGVzLm1hcCgoZiwgaSkgPT5cclxuICAgICAgaHRtbGBcclxuICAgICAgPGxpIGNsYXNzPVwibGlzdC1ncm91cC1pdGVtXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidG4tdG9vbGJhciBqdXN0aWZ5LWNvbnRlbnQtYmV0d2VlblwiIHJvbGU9XCJ0b29sYmFyXCIgYXJpYS1sYWJlbD1cIlRvb2xiYXIgd2l0aCBidXR0b24gZ3JvdXBzXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiByb2xlPVwiZ3JvdXBcIiBhcmlhLWxhYmVsPVwiRmlyc3QgZ3JvdXBcIj5cclxuICAgICAgPGRpdiBjbGFzcz1cInRleHQtb3V0bGluZS1zZWNvbmRhcnlcIiB1cmw9XCIke2YudXJsfVwiIHR5cGU9XCIke2YudHlwZX1cIiBAY2xpY2s9XCIke3RoaXMuY2hhbmdlUGF0aH1cIj5cclxuICAgICAgPGkgY2xhc3M9XCJmYXMgZmEtZmlsZVwiIHVybD1cIiR7Zi51cmx9XCIgdHlwZT1cIiR7Zi50eXBlfVwiIEBjbGljaz1cIiR7dGhpcy5jaGFuZ2VQYXRofVwiPjwvaT5cclxuICAgICAgJHtmLm5hbWV9XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJidG4tZ3JvdXBcIiByb2xlPVwiZ3JvdXBcIj5cclxuICAgICAgPGEgaHJlZj1cIiR7Zi51cmx9XCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeSBidG4tc21cIiB0YXJnZXQ9XCJfYmxhbmtcIj48aSBjbGFzcz1cImZhcyBmYS1leHRlcm5hbC1saW5rLWFsdFwiPjwvaT48L2E+XHJcbiAgICAgIDwhLS0gICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeSBidG4tc21cIiBkaXNhYmxlZD48aSBjbGFzcz1cImZhcyBmYS1maWxlLWRvd25sb2FkXCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tc2Vjb25kYXJ5IGJ0bi1zbVwiZGlzYWJsZWQ+PGkgY2xhc3M9XCJmYXMgZmEtZmlsZS1leHBvcnRcIj48L2k+PC9idXR0b24+XHJcbiAgICAgIC0tPiAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXNlY29uZGFyeSBidG4tc21cIiB1cmw9JyR7Zi51cmx9JyBAY2xpY2s9XCIke3RoaXMuZGVsZXRlRmlsZX1cIj48aSBjbGFzcz1cImZhcyBmYS10cmFzaFwiIHVybD0nJHtmLnVybH0nIEBjbGljaz1cIiR7dGhpcy5kZWxldGV9XCI+PC9pPjwvYnV0dG9uPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvbGk+XHJcbiAgICAgIGBcclxuICAgICl9XHJcbiAgICA8L3VsPlxyXG4gICAgPC9kaXY+XHJcbiAgICA8L2Rpdj5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuXHJcbiAgbmV3KGUpe1xyXG4gICAgdGhpcy5jcmVhdGVIaWRkZW4gPSBmYWxzZVxyXG4gICAgbGV0IGlucHV0X3R5cGUgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJpbnB1dF90eXBlXCIpXHJcbiAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJjcmVhdGVfaW5wdXRcIikuc2V0QXR0cmlidXRlKFwiaW5wdXRfdHlwZVwiLCBpbnB1dF90eXBlKVxyXG4gICAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwiY3JlYXRlX2lucHV0XCIpLnNldEF0dHJpYnV0ZShcInR5cGVcIiwgaW5wdXRfdHlwZSA9PSBcImZpbGVcIiA/IFwiZmlsZVwiIDogXCJ0ZXh0XCIpXHJcbiAgICBpZiAoaW5wdXRfdHlwZSA9PSBcImZpbGVuYW1lXCIpe1xyXG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJjcmVhdGVfaW5wdXRcIikudmFsdWUgPSAobmV3IERhdGUpLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgvOi9naSwnLScpLnJlcGxhY2UoL3QvZ2ksJ18nKS5yZXBsYWNlKC96L2dpLCcnKS50cmltKCkrXCIudHRsXCJcclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiVmlzXCIsIHthY3Rpb246IFwiY2xlYXJcIn0pXHJcbiAgICB9XHJcblxyXG4gICAgLy8gIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcImNyZWF0ZV9pbnB1dFwiKS5wbGFjZWhvbGRlciggdHlwZSlcclxuICB9XHJcblxyXG4gIGFzeW5jIGNyZWF0ZSgpe1xyXG4gICAgbGV0IG5hbWUgPSAgdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKFwiY3JlYXRlX2lucHV0XCIpLnZhbHVlLnRyaW0oKVxyXG4gICAgaWYobmFtZS5sZW5ndGggPiAwKXtcclxuICAgICAgbGV0IGlucHV0X3R5cGUgPSAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcImNyZWF0ZV9pbnB1dFwiKS5nZXRBdHRyaWJ1dGUoXCJpbnB1dF90eXBlXCIpXHJcbiAgICAgIGNvbnNvbGUubG9nKG5hbWUsIGlucHV0X3R5cGUpXHJcbiAgICAgIGxldCBjcmVhdGVfcGF0aCA9IHRoaXMucGF0aCtuYW1lXHJcblxyXG4gICAgICBzd2l0Y2ggKGlucHV0X3R5cGUpIHtcclxuICAgICAgICBjYXNlIFwiZmlsZW5hbWVcIjpcclxuICAgICAgICBjcmVhdGVfcGF0aCA9ICFjcmVhdGVfcGF0aC5lbmRzV2l0aChcIi50dGxcIikgPyBjcmVhdGVfcGF0aCtcIi50dGxcIiA6IGNyZWF0ZV9wYXRoXHJcbiAgICAgICAgY29uc29sZS5sb2coY3JlYXRlX3BhdGgpXHJcbiAgICAgICAgdGhpcy5jdXJyZW50RmlsZSA9IGNyZWF0ZV9wYXRoXHJcbiAgICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiVmlzXCIsIHthY3Rpb246IFwiY3VycmVudEZpbGVDaGFuZ2VkXCIsIGN1cnJlbnRGaWxlOiB0aGlzLmN1cnJlbnRGaWxlfSlcclxuICAgICAgICBsZXQgZGVmYXVsdENvbnRlbnQgPSBcIiMgY3JlYXRlZCBieSBTcG9nZ3kgQXBwXCJcclxuICAgICAgICBhd2FpdCB0aGlzLmZjLmNyZWF0ZUZpbGUoY3JlYXRlX3BhdGgsZGVmYXVsdENvbnRlbnQsXCJ0ZXh0L3R1cnRsZVwiKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgRXJyb3I6ICR7ZXJyfWApKVxyXG5cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFwiZm9sZGVybmFtZVwiOlxyXG4gICAgICAgIGNvbnNvbGUubG9nKGNyZWF0ZV9wYXRoKVxyXG4gICAgICAgIGF3YWl0IHRoaXMuZmMuY3JlYXRlRm9sZGVyKGNyZWF0ZV9wYXRoKS5jYXRjaChlcnIgPT4gY29uc29sZS5lcnJvcihgRXJyb3I6ICR7ZXJyfWApKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgXCJmaWxlbmFtZVwiOlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVE9ETyA6IHVwbG9hZFwiKVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcblxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuY3JlYXRlSGlkZGVuID0gdHJ1ZVxyXG4gICAgICB0aGlzLnVwZGF0ZUZvbGRlcigpXHJcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZChcImNyZWF0ZV9pbnB1dFwiKS52YWx1ZSA9IFwiXCJcclxuICAgIH1lbHNle1xyXG4gICAgICBhbGVydCAoXCJJIGNhbid0IGNyZWF0ZSBhIGZvbGRlciBvciBhIGZpbGUgd2l0aCBhIGJsYW5rIG5hbWUgIVwiKVxyXG4gICAgfVxyXG5cclxuICB9XHJcblxyXG4gIGNsb3NlQ3JlYXRlSW5wdXQoKXtcclxuICAgIHRoaXMuY3JlYXRlSGlkZGVuID0gdHJ1ZVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZGVsZXRlRmlsZShlKXtcclxuICAgIGxldCB1cmwgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ1cmxcIilcclxuXHJcbiAgICB2YXIgZGVsID0gY29uZmlybShcIkRvIHlvdSB3YW50IHJlYWxseSB3YW50IHRvIGRlbGV0ZSBcIit1cmwrXCIgP1wiKTtcclxuICAgIGlmIChkZWwgPT0gdHJ1ZSl7XHJcbiAgICAgIGF3YWl0IHRoaXMuZmMuZGVsZXRlRmlsZSh1cmwpXHJcbiAgICAgIHRoaXMudXBkYXRlRm9sZGVyKClcclxuICAgIH1cclxuXHJcbiAgICAvKlxyXG4gICAgVE9ETyBBRlRFUiBDT05GSVJNXHJcbiAgICBodHRwczovL2dpdGh1Yi5jb20vamVmZi16dWNrZXIvc29saWQtZmlsZS1jbGllbnQjZGVsZXRlZmlsZS1maWxldXJsLW9wdGlvbnMtXHJcbiAgICBkZWxldGVGaWxlKCBmaWxlVVJMLCBvcHRpb25zIClcclxuICAgIGRlbGV0ZUZvbGRlciggZm9sZGVyVVJMIClcclxuICAgICovXHJcbiAgfVxyXG5cclxuXHJcbiAgY2hhbmdlUGF0aChlKXtcclxuICAgIC8vICAgIGNvbnNvbGUubG9nKGUpXHJcbiAgICBsZXQgdXJsID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwidXJsXCIpXHJcbiAgICBsZXQgdHlwZSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcInR5cGVcIilcclxuICAgIGlmICh0eXBlID09IFwiZm9sZGVyXCIpe1xyXG4gICAgICB0aGlzLmxhc3QgPSB0aGlzLnBhdGhcclxuICAgICAgdGhpcy5wYXRoID0gdXJsXHJcbiAgICAgIHRoaXMudXBkYXRlRm9sZGVyKClcclxuICAgIH1lbHNle1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkEgZmlsZSwgdG9kb1wiLHVybClcclxuICAgICAgdGhpcy5nZXRGaWxlKHVybClcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGFzeW5jIGdldEZpbGUodXJsKXtcclxuICAgIHRoaXMuY3JlYXRlSGlkZGVuID0gdHJ1ZVxyXG4gICAgdHJ5e1xyXG4gICAgICBjb25zdCBkb2MgPSBhd2FpdCBmZXRjaERvY3VtZW50KHVybCk7XHJcbiAgICAgIHRoaXMuY3VycmVudEZpbGUgPSB1cmxcclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiVmlzXCIsIHthY3Rpb246IFwiY3VycmVudEZpbGVDaGFuZ2VkXCIsIGN1cnJlbnRGaWxlOiB0aGlzLmN1cnJlbnRGaWxlfSlcclxuXHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyhcImRvY1wiLGRvYylcclxuICAgICAgbGV0IHRyaXBsZXMgPSBkb2MuZ2V0VHJpcGxlcygpXHJcbiAgICAgIGNvbnNvbGUubG9nKFwidHJpcGxlc1wiLHRyaXBsZXMpXHJcbiAgICAgIC8vICBsZXQgdmlzX25ldHdvcmsgPSB0aGlzLnN0YXRlbWVudHMydmlzKHRyaXBsZXMpXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChcIlZpc1wiLCB7YWN0aW9uOiBcInRyaXBsZXNDaGFuZ2VkXCIsIHRyaXBsZXM6IHRyaXBsZXN9KVxyXG5cclxuICAgIH1cclxuICAgIGNhdGNoKGUpe1xyXG4gICAgICBjb25zb2xlLmxvZyhlKVxyXG4gICAgICBhbGVydChcIk9oIGkndmUgZ290IGEgcHJvYmxlbSB0byByZWFkIHRoaXMgZmlsZSA6LShcIilcclxuICAgIH1cclxuICAgIGNvbnNvbGUubG9nKFwiY3VycmVudEZpbGVcIiwgdGhpcy5jdXJyZW50RmlsZSlcclxuICB9XHJcblxyXG5cclxuICBzdGF0ZW1lbnRzMnZpcyhzdGF0ZW1lbnRzKXtcclxuICAgIGNvbnNvbGUubG9nKFwic3RhdGVtZW50czJ2aXNcIilcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdmFyIGRhdGEgPSB7bm9kZXM6W10sIGVkZ2VzOltdfTtcclxuICAgIC8vICB2YXIgaSA9IDA7XHJcbiAgICBzdGF0ZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlbWVudCl7XHJcbiAgICAgIC8vY29uc29sZS5sb2coc3RhdGVtZW50KVxyXG4gICAgICAvLyAgaSsrO1xyXG4gICAgICAvLyAgYXBwLmFnZW50SW1wb3J0LnNlbmQoJ2FnZW50QXBwJywge3R5cGU6ICdtZXNzYWdlJywgZGF0YTogc3RhdGVtZW50cy5sZW5ndGgtaX0pO1xyXG4gICAgICAvLyAgY29uc29sZS5sb2coXCJTVEFURU1FTlQyVklTXCIsIHN0YXRlbWVudClcclxuICAgICAgdmFyIGVkZ2VzID0gW107XHJcbiAgICAgIHZhciBzID0gc3RhdGVtZW50LnN1YmplY3Q7XHJcbiAgICAgIHZhciBwID0gc3RhdGVtZW50LnByZWRpY2F0ZTtcclxuICAgICAgdmFyIG8gPSBzdGF0ZW1lbnQub2JqZWN0O1xyXG4gICAgICB2YXIgdyA9IHN0YXRlbWVudC53aHk7XHJcblxyXG4gICAgICBzd2l0Y2gocC52YWx1ZSkge1xyXG4gICAgICAgIGNhc2UgXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjbGFiZWxcIjpcclxuICAgICAgICBjYXNlIFwiaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9sYWJlbFwiOlxyXG4gICAgICAgIHZhciBub2RlQW5kTGFiZWwgPSB7XHJcbiAgICAgICAgICBpZDogcy52YWx1ZSxcclxuICAgICAgICAgIHRpdGxlOiBvLnZhbHVlLFxyXG4gICAgICAgICAgbGFiZWw6IG8udmFsdWUsXHJcbiAgICAgICAgICB3aHk6IHcudmFsdWUsXHJcbiAgICAgICAgICB5OjIqTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgIHR5cGU6IFwibm9kZVwiXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zb2xlLmxvZyhcInB1c2hcIixzLnZhbHVlLFwibGFiZWxcIixvLnZhbHVlKVxyXG4gICAgICAgIC8vYXBwLmFkZE5vZGVJZk5vdEV4aXN0KGFwcC5uZXR3b3JrLCBub2RlQW5kTGFiZWwpXHJcbiAgICAgICAgZGF0YS5ub2Rlcy5wdXNoKG5vZGVBbmRMYWJlbClcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIC8vY29uc29sZS5sb2coXCJOT04gTEFCRUwgXCIscC52YWx1ZSk7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCIjIyNcXG5cIixzLnZhbHVlLFwiXFxuXCIscC52YWx1ZSxcIlxcblwiLG8udmFsdWUpXHJcbiAgICAgICAgdmFyIGVkZ2VzID0gW107XHJcbiAgICAgICAgdmFyIG5vZGVTdWpldFRlbXAgPSBhcHAuZGV0YWlsTm9ldWQocyx3KTtcclxuICAgICAgICB2YXIgbm9kZU9iamV0VGVtcCA9IGFwcC5kZXRhaWxOb2V1ZChvLHcpO1xyXG4gICAgICAgIGRhdGEubm9kZXMucHVzaChub2RlU3VqZXRUZW1wKVxyXG4gICAgICAgIGRhdGEubm9kZXMucHVzaChub2RlT2JqZXRUZW1wKVxyXG5cclxuXHJcbiAgICAgICAgZGF0YS5lZGdlcy5wdXNoKHtmcm9tOnMudmFsdWUsIHRvOiBvLnZhbHVlLCBhcnJvd3M6ICd0bycsIGxhYmVsOiBhcHAubG9jYWxuYW1lKHApLCB1cmk6IHAudmFsdWV9KTtcclxuICAgICAgICAvLyAgYXBwLmFkZEVkZ2VJZk5vdEV4aXN0KGFwcC5uZXR3b3JrLHtmcm9tOnMuc3ViamVjdC52YWx1ZSwgdG86IHMub2JqZWN0LnZhbHVlLCBhcnJvd3M6ICd0bycsIGxhYmVsOnMucHJlZGljYXRlLnZhbHVlfSk7XHJcblxyXG4gICAgICAgIC8vYXBwLm5ldHdvcmsuYm9keS5kYXRhLmVkZ2VzLnVwZGF0ZShlZGdlcylcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBjb25zb2xlLmxvZyhkYXRhKVxyXG5cclxuICAgIHJldHVybiBkYXRhO1xyXG4gIH1cclxuXHJcblxyXG4gIGRldGFpbE5vZXVkKG4sdyl7XHJcbiAgICB2YXIgbm9kZSA9IHt9XHJcbiAgICBjb25zb2xlLmxvZyhuKVxyXG4gICAgc3dpdGNoIChuLnRlcm1UeXBlKSB7XHJcblxyXG4gICAgICBjYXNlICdCbGFua05vZGUnOlxyXG4gICAgICB2YXIgbCA9IHRoaXMubG9jYWxuYW1lKG4pO1xyXG4gICAgICBub2RlID0ge1xyXG4gICAgICAgIGlkOiBuLnZhbHVlLFxyXG4gICAgICAgIHdoeTogdy52YWx1ZSxcclxuICAgICAgICAvLyAgeToyKk1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgdHlwZTogXCJub2RlXCJcclxuICAgICAgfTtcclxuICAgICAgaWYgKG4udmFsdWUgIT0gbCl7XHJcbiAgICAgICAgbm9kZS50aXRsZT0gbDtcclxuICAgICAgICBub2RlLmxhYmVsID0gbDtcclxuICAgICAgfVxyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSAnQ29sbGVjdGlvbic6XHJcbiAgICAgIG4uZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihlbGVtKXtcclxuICAgICAgICBjb25zb2xlLmxvZyhcImVsZW1cIixlbGVtKVxyXG4gICAgICAgIHRoaXMuZGV0YWlsTm9ldWQoZWxlbSx3KVxyXG4gICAgICB9KVxyXG4gICAgICBicmVhaztcclxuICAgICAgY2FzZSAnTGl0ZXJhbCc6XHJcbiAgICAgIHZhciBsID0gdGhpcy5sb2NhbG5hbWUobikubGVuZ3RoPjM3PyB0aGlzLmxvY2FsbmFtZShuKS5zdWJzdHJpbmcoMCw0MCkrXCIuLi5cIiA6IHRoaXMubG9jYWxuYW1lKG4pO1xyXG4gICAgICBub2RlID0ge1xyXG4gICAgICAgIGlkOiBuLnZhbHVlLFxyXG4gICAgICAgIHRpdGxlOiBuLnZhbHVlLFxyXG4gICAgICAgIGxhYmVsOiBsLFxyXG4gICAgICAgIHdoeTogdy52YWx1ZSxcclxuICAgICAgICAvLyAgeToyKk1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgdHlwZTogXCJub2RlXCIsXHJcbiAgICAgICAgc2hhcGU6IFwiYm94XCIsXHJcbiAgICAgICAgY29sb3I6IFwicmdiKDI0MCwyMjAsMTEwKVwiXHJcbiAgICAgIH07XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBjYXNlICdOYW1lZE5vZGUnOlxyXG4gICAgICB2YXIgbCA9IHRoaXMubG9jYWxuYW1lKG4pO1xyXG4gICAgICBub2RlID0ge1xyXG4gICAgICAgIGlkOiBuLnZhbHVlLFxyXG4gICAgICAgIHRpdGxlOiBuLnZhbHVlLFxyXG4gICAgICAgIGxhYmVsOiBsLFxyXG4gICAgICAgIHdoeTogdy52YWx1ZSxcclxuICAgICAgICAvLyAgeToyKk1hdGgucmFuZG9tKCksXHJcbiAgICAgICAgdHlwZTogXCJub2RlXCJcclxuICAgICAgfTtcclxuICAgICAgaWYobCA9PSBcIm1lXCIpe1xyXG4gICAgICAgIG5vZGUubGFiZWwgPSAgbm9kZS50aXRsZTtcclxuICAgICAgICBub2RlLnNoYXBlID0gXCJpbWFnZVwiO1xyXG4gICAgICAgIG5vZGUuaW1hZ2UgPSBcIi4vYXNzZXRzL3Byb2ZpbGUuc3ZnXCI7XHJcbiAgICAgICAgbm9kZS50eXBlID0gXCJ3ZWJJZFwiO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICBjb25zb2xlLmxvZygnU29ycnksIGplIG5lIHRyYWl0ZSBwYXMgZW5jb3JlICcgKyBuLnRlcm1UeXBlICsgJy4nKTtcclxuICAgICAgbm9kZSA9IHtcclxuICAgICAgICBpZDogbi52YWx1ZSxcclxuICAgICAgICB0aXRsZTogbi52YWx1ZSxcclxuICAgICAgICBsYWJlbDogbi52YWx1ZSxcclxuICAgICAgICB3aHk6IHcudmFsdWUsXHJcbiAgICAgICAgLy8gIHk6MipNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgIHR5cGU6IFwibm9kZVwiXHJcbiAgICAgIH07XHJcblxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2cobm9kZSlcclxuICAgIC8vXHJcbiAgICByZXR1cm4gbm9kZTtcclxuICB9XHJcblxyXG5cclxuICBsb2NhbG5hbWUobm9kZSl7XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJMT0NBTE5BTUUgT0YgXCIsbm9kZSlcclxuICAgIGlmIChub2RlLnZhbHVlICE9IHVuZGVmaW5lZCl7XHJcbiAgICAgIHZhciB2YWx1ZSA9IG5vZGUudmFsdWU7XHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyh2YWx1ZSlcclxuICAgICAgaWYgKHZhbHVlLmVuZHNXaXRoKCcvJykgfHwgdmFsdWUuZW5kc1dpdGgoJyMnKSl7XHJcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCx2YWx1ZS5sZW5ndGgtMSk7XHJcbiAgICAgIH1cclxuICAgICAgdmFyIGxhYmVsVSA9IHZhbHVlO1xyXG4gICAgICBpZiAobm9kZS50ZXJtVHlwZSA9PSBcIk5hbWVkTm9kZVwiKXtcclxuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJuYW1lbm9kZVwiKVxyXG4gICAgICAgIHZhciB1TGFiZWwgPSB2YWx1ZS5zcGxpdChcIiNcIik7XHJcbiAgICAgICAgdmFyIGxhYmVsVSA9IHVMYWJlbFt1TGFiZWwubGVuZ3RoLTFdO1xyXG4gICAgICAgIGlmIChsYWJlbFUgPT0gdUxhYmVsKXtcclxuICAgICAgICAgIHVMYWJlbCA9IHZhbHVlLnNwbGl0KFwiL1wiKTtcclxuICAgICAgICAgIGxhYmVsVSA9IHVMYWJlbFt1TGFiZWwubGVuZ3RoLTFdO1xyXG4gICAgICAgIH1cclxuICAgICAgfWVsc2V7XHJcbiAgICAgICAgY29uc29sZS5sb2coXCJUT0RPIDogbGl0ZXJhbCBvciBibGFua25vZGUgPz8/XCIsIG5vZGUpXHJcbiAgICAgIH1cclxuICAgICAgLy8gIGNvbnNvbGUubG9nKGxhYmVsVSlcclxuICAgICAgcmV0dXJuIGxhYmVsVTtcclxuICAgIH1lbHNle1xyXG4gICAgICBjb25zb2xlLmxvZyhcIlRPRE8gbm9kZS52YWx1ZSA9IHVuZGVmaW5lZCwgaWwgZmF1dCBtYWludGVuYW50IHRyYWl0ZXIgbGUgdGFibGVhdVwiLG5vZGUuZWxlbWVudHMpXHJcbiAgICB9XHJcblxyXG4gIH1cclxuXHJcblxyXG5cclxuICBhc3luYyB3ZWJJZENoYW5nZWQod2ViSWQpe1xyXG4gICAgdGhpcy53ZWJJZCA9IHdlYklkXHJcbiAgICBpZiAod2ViSWQgIT0gbnVsbCl7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMud2ViSWQpXHJcbiAgICAgIGxldCBzdG9yYWdlID0gYXdhaXQgc29saWQuZGF0YVt3ZWJJZF0uc3RvcmFnZVxyXG4gICAgICB0aGlzLnN0b3JhZ2UgPSBgJHtzdG9yYWdlfWBcclxuICAgICAgLy8gICAgY29uc29sZS5sb2codGhpcy5zdG9yYWdlKVxyXG4gICAgICB0aGlzLnBhdGggPSB0aGlzLnN0b3JhZ2UrXCJwdWJsaWMvc3BvZ2d5L1wiXHJcbiAgICAgIGlmKCAhKGF3YWl0IHRoaXMuZmMuaXRlbUV4aXN0cyh0aGlzLnBhdGgpKSApIHtcclxuICAgICAgICBhd2FpdCB0aGlzLmZjLmNyZWF0ZUZvbGRlcih0aGlzLnBhdGgpIC8vIG9ubHkgY3JlYXRlIGlmIGl0IGRvZXNuJ3QgYWxyZWFkeSBleGlzdFxyXG4gICAgICB9XHJcbiAgICAgIGxldCBuZXdmaWxlbmFtZSA9IChuZXcgRGF0ZSkudG9JU09TdHJpbmcoKS5yZXBsYWNlKC86L2dpLCctJykucmVwbGFjZSgvdC9naSwnXycpLnJlcGxhY2UoL3ovZ2ksJycpLnRyaW0oKStcIi50dGxcIlxyXG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJjcmVhdGVfaW5wdXRcIikudmFsdWUgPSBuZXdmaWxlbmFtZVxyXG4gICAgICB0aGlzLnNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoXCJjcmVhdGVfaW5wdXRcIikuc2V0QXR0cmlidXRlKFwiaW5wdXRfdHlwZVwiLCBcImZpbGVuYW1lXCIpXHJcbiAgICAgIHRoaXMuY3JlYXRlSGlkZGVuID0gZmFsc2VcclxuICAgICAgdGhpcy5jdXJyZW50RmlsZSA9IHRoaXMucGF0aCtuZXdmaWxlbmFtZVxyXG4gICAgICB0aGlzLmFnZW50LnNlbmQoXCJWaXNcIiwge2FjdGlvbjogXCJjbGVhclwifSlcclxuICAgICAgdGhpcy5hZ2VudC5zZW5kKFwiVmlzXCIsIHthY3Rpb246IFwiY3VycmVudEZpbGVDaGFuZ2VkXCIsIGN1cnJlbnRGaWxlOiB0aGlzLmN1cnJlbnRGaWxlfSlcclxuICAgICAgdGhpcy51cGRhdGVGb2xkZXIoKVxyXG4gICAgfWVsc2V7XHJcbiAgICAgIHRoaXMuc3RvcmFnZSA9IFwiXCJcclxuICAgICAgdGhpcy5wYXRoID0gXCJcIlxyXG4gICAgICB0aGlzLmZvbGRlciA9IHtmb2xkZXJzOltdLCBmaWxlczogW119XHJcbiAgICAgIHRoaXMuY3VycmVudEZpbGUgPSBudWxsXHJcbiAgICAgIHRoaXMuYWdlbnQuc2VuZChcIlZpc1wiLCB7YWN0aW9uOiBcImN1cnJlbnRGaWxlQ2hhbmdlZFwiLCBjdXJyZW50RmlsZTogdGhpcy5jdXJyZW50RmlsZX0pXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyB1cGRhdGVGb2xkZXIoKXtcclxuICAgIC8vICBjb25zb2xlLmxvZyh0aGlzLnBhdGgpXHJcbiAgICB0aGlzLmZvbGRlciA9IGF3YWl0IHRoaXMuZmMucmVhZEZvbGRlcih0aGlzLnBhdGgpXHJcbiAgICBjb25zb2xlLmxvZyhcImZvbGRlclwiLHRoaXMuZm9sZGVyKVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgYWRkVHJpcGxlKHQpe1xyXG4gICAgbGV0IHN1YmplY3QgPSB0LnN1YmplY3RcclxuICAgIGxldCBwcmVkaWNhdGUgPSB0LnByZWRpY2F0ZVxyXG4gICAgbGV0IG9iamVjdCA9IHQub2JqZWN0XHJcbiAgICBpZiAodGhpcy5jdXJyZW50RmlsZSA9PSBudWxsKXtcclxuICAgICAgYWxlcnQoXCJIZXkgISBZb3UgbXVzdCBsb2dpbiB0byB5b3VyIFBPRCB0byB1c2UgbWUgISBObyBuZWVkIHRvIGdpdmUgbWUgJ0Z1bGwgQ29udHJvbCcsIGp1c3QgdGhlIGJhc2ljIHNldHRpbmdzLCBhICcvcHVibGljL3Nwb2dneScgZm9sZGVyIHdpbGwgYmUgY3JlYXRlZC5cIilcclxuICAgIH1lbHNle1xyXG4gICAgICBjb25zb2xlLmxvZyh0aGlzLmN1cnJlbnRGaWxlKVxyXG4gICAgICBzdWJqZWN0ID0gdGhpcy5jdXJyZW50RmlsZStcIiNcIit0LnN1YmplY3RcclxuICAgICAgcHJlZGljYXRlID0gdGhpcy5jdXJyZW50RmlsZStcIiNcIit0LnByZWRpY2F0ZVxyXG4gICAgICBvYmplY3QgPSB0aGlzLmN1cnJlbnRGaWxlK1wiI1wiK3Qub2JqZWN0XHJcbiAgICAgIGF3YWl0IHNvbGlkLmRhdGFbc3ViamVjdF1bcHJlZGljYXRlXS5hZGQobmFtZWROb2RlKG9iamVjdCkpXHJcbiAgICAgIHRoaXMudXBkYXRlRm9sZGVyKClcclxuICAgICAgdGhpcy5jcmVhdGVIaWRkZW4gPSB0cnVlXHJcbiAgICB9XHJcbiAgICB0aGlzLmFnZW50LnNlbmQoXCJWaXNcIiwge2FjdGlvbjogXCJhZGRUcmlwbGVcIiwgdHJpcGxlOiB7c3ViamVjdDogc3ViamVjdCwgcHJlZGljYXRlOiBwcmVkaWNhdGUsIG9iamVjdDogb2JqZWN0fSB9KVxyXG4gIH1cclxuXHJcbiAgdXAoKXtcclxuICAgIHRoaXMucGF0aCA9IHRoaXMuZm9sZGVyLnBhcmVudFxyXG4gICAgdGhpcy51cGRhdGVGb2xkZXIoKVxyXG4gIH1cclxuXHJcbiAgcHJlYygpe1xyXG4gICAgLy8gVE9ETyBtYW5hZ2UgYW4gaGlzdG9yeVxyXG4gICAgdGhpcy5wYXRoID0gdGhpcy5sYXN0XHJcbiAgICB0aGlzLnVwZGF0ZUZvbGRlcigpXHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFnZW50KVxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwid2ViSWRDaGFuZ2VkXCI6XHJcbiAgICAgICAgICBhcHAud2ViSWRDaGFuZ2VkKG1lc3NhZ2Uud2ViSWQpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgXCJhZGRUcmlwbGVcIjpcclxuICAgICAgICAgIGFwcC5hZGRUcmlwbGUobWVzc2FnZS50cmlwbGUpXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbn1cclxuXHJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnYnJvd3Nlci12aWV3JywgQnJvd3NlclZpZXcpO1xyXG4iLCJpbXBvcnQgeyBMaXRFbGVtZW50LCBodG1sIH0gZnJvbSAnbGl0LWVsZW1lbnQnO1xyXG5pbXBvcnQgeyBIZWxsb0FnZW50IH0gZnJvbSAnLi4vYWdlbnRzL2hlbGxvLWFnZW50LmpzJztcclxuXHJcbmNsYXNzIElucHV0VmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZGVidWc6IHt0eXBlOiBCb29sZWFufSxcclxuICAgICAgd2ViSWQ6IHt0eXBlOiBTdHJpbmd9LFxyXG4gICAgICB0cmlwbGVzOiB7dHlwZTogQXJyYXl9LFxyXG5cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIklucHV0XCJcclxuICAgIHRoaXMuZGVidWcgPSBmYWxzZVxyXG4gICAgdGhpcy53ZWJJZCA9IG51bGxcclxuICAgIHRoaXMudHJpcGxlcyA9IFtdXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuXHJcbiAgICBjb25zdCB0cmlwbGVzTGlzdCA9ICh0cmlwbGVzKSA9PiBodG1sYFxyXG4gICAgPHVsIGNsYXNzPVwibGlzdC1ncm91cCBsaXN0LWdyb3VwLWZsdXNoXCIgc3R5bGU9XCJoZWlnaHQ6IDMwdmg7IHdpZHRoOjEwMCU7IG92ZXJmbG93OiBhdXRvXCI+XHJcbiAgICAke3RyaXBsZXMubWFwKCh0KSA9PiBodG1sYFxyXG4gICAgICA8bGkgY2xhc3M9XCJsaXN0LWdyb3VwLWl0ZW1cIj5cclxuICAgICAgPGRpdiBjbGFzcz1cInJvd1wiPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIiB0eXBlPVwiYnV0dG9uXCI+JHt0LnN1YmplY3R9PC9idXR0b24+XHJcbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtc2Vjb25kYXJ5IGJ0bi1zbVwiIHR5cGU9XCJidXR0b25cIj4ke3QucHJlZGljYXRlfTwvYnV0dG9uPlxyXG4gICAgICA8YnV0dG9uIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeSBidG4tc21cIiB0eXBlPVwiYnV0dG9uXCI+JHt0Lm9iamVjdH08L2J1dHRvbj5cclxuICAgICAgPCEtLVtlZGl0XSBbZGVsZXRlXS0tPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9saT5cclxuICAgICAgYCl9XHJcbiAgICAgIDwvdWw+XHJcbiAgICAgIGA7XHJcblxyXG5cclxuICAgICAgcmV0dXJuIGh0bWxgXHJcbiAgICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgICA8bGluayBocmVmPVwiY3NzL2ZvbnRhd2Vzb21lL2Nzcy9hbGwuY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG5cclxuICAgICAgPCEtLSAgPGRpdiA/aGlkZGVuPVwiJHt0aGlzLndlYklkID09IG51bGx9XCI+IC0tPlxyXG4gICAgICA8ZGl2ICBjbGFzcz1cInJvd1wiPlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zXCI+XHJcbiAgICAgIDwhLS08ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtcHJlcGVuZFwiPlxyXG4gICAgICA8c3BhbiBjbGFzcz1cImlucHV0LWdyb3VwLXRleHRcIiBpZD1cImlucHV0LWxhYmVsXCI+Pzwvc3Bhbj5cclxuICAgICAgPC9kaXY+LS0+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sXCJcclxuICAgICAgaWQ9XCJ0cmlwbGVJbnB1dFwiXHJcbiAgICAgIHBsYWNlaG9sZGVyPVwiJ1N1YmplY3QgcHJlZGljYXRlIE9iamVjdCwnIGVuZGluZyB3aXRoICwgOyAuIG9yIC0gb3IgY29tbWFuZCBzdGFydGluZyBieSAnLydcIlxyXG4gICAgICBhcmlhLWxhYmVsPVwiJ1N1YmplY3QgcHJlZGljYXRlIE9iamVjdCwnIGVuZGluZyB3aXRoICwgOyAuIG9yIC0gb3IgY29tbWFuZCBzdGFydGluZyBieSAnLydcIlxyXG4gICAgICB0aXRsZT1cIidTdWJqZWN0IHByZWRpY2F0ZSBPYmplY3QsJyBlbmRpbmcgd2l0aCAsIDsgLiBvciAtIG9yIGNvbW1hbmQgc3RhcnRpbmcgYnkgJy8nXCJcclxuICAgICAgYXJpYS1kZXNjcmliZWRieT1cImlucHV0LWxhYmVsXCJcclxuICAgICAgQGtleWRvd249JHt0aGlzLmtleWRvd259PlxyXG4gICAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtZ3JvdXAtYXBwZW5kXCI+XHJcbiAgICAgIDxidXR0b24gY2xhc3M9XCJidG4gYnRuLW91dGxpbmUtcHJpbWFyeVwiIEBjbGljaz1cIiR7dGhpcy5hZGRfdHJpcGxlfVwiIHR5cGU9XCJidXR0b25cIj5BZGQ8L2J1dHRvbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPC9kaXY+XHJcblxyXG5cclxuXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJyb3dcIj5cclxuICAgICAgJHt0aGlzLnRyaXBsZXMubGVuZ3RoID4gMCA/XHJcbiAgICAgICAgaHRtbCBgICAke3RyaXBsZXNMaXN0KHRoaXMudHJpcGxlcyl9YFxyXG4gICAgICAgIDpodG1sIGBcclxuICAgICAgICA8c21hbGw+XHJcbiAgICAgICAgWW91IGNhbiBhZGQgdHJpcGxlcyB0byB5b3VyIFNwb2cuPGJyPlxyXG4gICAgICAgIFRvIGRvIHNvLCBqdXN0IHR5cGUgMyB3b3JkcyBpbiB0aGUgYWJvdmUgaW5wdXQgYW5kIGVuZHMgd2l0aCBhIDpcclxuICAgICAgICA8dWw+XHJcbiAgICAgICAgPGxpPmNvbW1hICgsKSBpZiB5b3Ugd2FudCB0byBrZWVwIHN1YmplY3QgJiBwcmVkaWNhdGUsIDwvbGk+XHJcbiAgICAgICAgPGxpPnNlbWljb2xvbiAoOykgaWYgeW91IHdhbnQgdG8ga2VlcCBqdXN0IHRoZSBzdWJqZWN0LDwvbGk+XHJcbiAgICAgICAgPGxpPmRvdCAoLikgaWYgeW91IGRvbid0IHdhbnQgdG8ga2VlcCBhbnl0aGluZyw8L2xpPlxyXG4gICAgICAgIDxsaT5kYXNoICgtKSBpZiB5b3Ugd2FudCB0aGF0IHRoZSBvYmplY3QgYmVjb21lIHRoZSBzdWJqZWN0IG9mIHRoZSBuZXh0IHRyaXBsZS48L2xpPlxyXG4gICAgICAgIDwvdWw+XHJcbiAgICAgICAgZXg6IERhdiBhIE1hbixcclxuICAgICAgICA8L3NtYWxsPlxyXG4gICAgICAgIGBcclxuICAgICAgfVxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPCEtLSAgICAgIDwvZGl2PiAtLT5cclxuICAgICAgYDtcclxuICAgIH1cclxuXHJcbiAgICBhZGRfdHJpcGxlKCl7XHJcbiAgICAgIHZhciBuZXdfdHJpcGxlID0gdGhpcy5zaGFkb3dSb290LmdldEVsZW1lbnRCeUlkKCd0cmlwbGVJbnB1dCcpLnZhbHVlLnRyaW0oKVxyXG4gICAgICBpZiAobmV3X3RyaXBsZS5sZW5ndGggPT0gMCl7XHJcbiAgICAgICAgYWxlcnQoXCJ5b3UgY2FuJ3QgYWRkIGFuIGVtcHR5IFRyaXBsZVwiKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcbiAgICAgIGNvbnNvbGUubG9nKG5ld190cmlwbGUpXHJcbiAgICAgIHZhciByZXMgPSB0aGlzLmNhdGNoQ29tbWFuZChuZXdfdHJpcGxlKVxyXG4gICAgfVxyXG5cclxuICAgIGNhdGNoQ29tbWFuZChtZXNzYWdlKXtcclxuICAgICAgaWYgKG1lc3NhZ2Uuc3RhcnRzV2l0aCgnLycpKXtcclxuICAgICAgICBsZXQgY29tbWFuZCA9IG1lc3NhZ2Uuc2xpY2UoMSlcclxuICAgICAgICBjb25zb2xlLmxvZyhcImNvbW1hbmRcIixjb21tYW5kKVxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICB0aGlzLnVwZGF0ZUlucHV0KG1lc3NhZ2UpXHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG4gICAgdXBkYXRlSW5wdXQobWVzc2FnZSl7XHJcbiAgICAgIHZhciByZXN1bHQgPSB7fVxyXG4gICAgICB2YXIgaW5wdXROZXcgPSBcIlwiO1xyXG4gICAgICBsZXQgbGFzdENoYXIgPSBtZXNzYWdlLnNsaWNlKC0xKTtcclxuICAgICAgbGV0IG1lc3NhZ2VDdXQgPSBtZXNzYWdlLnNsaWNlKDAsLTEpLnNwbGl0KFwiIFwiKTtcclxuICAgICAgbGV0IGlzVHJpcGxldCA9IHRydWU7XHJcbiAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2VDdXQpO1xyXG5cclxuICAgICAgbGV0IGRldGVjdExpdGVyYWwgPSBcIlwiO1xyXG4gICAgICBsZXQgbWVzc2FnZUN1dFRlbXAgPSBbXTtcclxuICAgICAgbWVzc2FnZUN1dC5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpe1xyXG4gICAgICAgIHBhcnQgPSBwYXJ0LnRyaW0oKTtcclxuICAgICAgICAvLyAgY29uc29sZS5sb2cocGFydCk7XHJcbiAgICAgICAgaWYgKHBhcnQuc3RhcnRzV2l0aCgnXCInKSl7XHJcbiAgICAgICAgICBkZXRlY3RMaXRlcmFsID1cImRlYnV0XCI7XHJcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coZGV0ZWN0TGl0ZXJhbCk7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKHBhcnQuc3Vic3RyKDEpKTtcclxuICAgICAgICB9ZWxzZSBpZiAocGFydC5lbmRzV2l0aCgnXCInKSl7XHJcbiAgICAgICAgICBkZXRlY3RMaXRlcmFsID0gXCJmaW5cIjtcclxuICAgICAgICAgIC8vY29uc29sZS5sb2coZGV0ZWN0TGl0ZXJhbCk7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKG1lc3NhZ2VDdXRUZW1wLnBvcCgpK1wiIFwiK3BhcnQuc2xpY2UoMCwtMSkpO1xyXG4gICAgICAgIH1lbHNlIGlmIChkZXRlY3RMaXRlcmFsID09IFwiZGVidXRcIil7XHJcbiAgICAgICAgICAvLyAgY29uc29sZS5sb2coXCJyZWN1cGVyZSBsZSBkZXJuaWVyIGV0IGx1aSBham91dGUgcGFydFwiIClcclxuICAgICAgICAgIG1lc3NhZ2VDdXRUZW1wLnB1c2gobWVzc2FnZUN1dFRlbXAucG9wKCkrXCIgXCIrcGFydClcclxuICAgICAgICB9ZWxzZSB7XHJcbiAgICAgICAgICBtZXNzYWdlQ3V0VGVtcC5wdXNoKHBhcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChtZXNzYWdlQ3V0VGVtcC5sZW5ndGggPiAwKXtcclxuICAgICAgICBtZXNzYWdlQ3V0ID0gbWVzc2FnZUN1dFRlbXA7XHJcbiAgICAgIH1cclxuICAgICAgc3dpdGNoKGxhc3RDaGFyKXtcclxuICAgICAgICBjYXNlICcuJzpcclxuICAgICAgICBpbnB1dE5ldyA9IFwiXCI7XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAnOyc6XHJcbiAgICAgICAgaWYgKG1lc3NhZ2VDdXRbMF0uaW5kZXhPZihcIiBcIikgPiAtMSl7XHJcbiAgICAgICAgICBpbnB1dE5ldyA9ICdcIicrbWVzc2FnZUN1dFswXSsnXCInKycgJztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGlucHV0TmV3ID0gbWVzc2FnZUN1dFswXSsnICc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgJywnOlxyXG4gICAgICAgIGlmIChtZXNzYWdlQ3V0WzBdLmluZGV4T2YoXCIgXCIpID4gLTEpe1xyXG4gICAgICAgICAgaW5wdXROZXcgPSAnXCInK21lc3NhZ2VDdXRbMF0rJ1wiICc7XHJcbiAgICAgICAgfWVsc2V7XHJcbiAgICAgICAgICBpbnB1dE5ldyA9IG1lc3NhZ2VDdXRbMF0rJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobWVzc2FnZUN1dFsxXS5pbmRleE9mKFwiIFwiKSA+IC0xKXtcclxuICAgICAgICAgIGlucHV0TmV3ICs9ICdcIicrbWVzc2FnZUN1dFsxXSsnXCIgJztcclxuICAgICAgICB9ZWxzZXtcclxuICAgICAgICAgIGlucHV0TmV3ICs9IG1lc3NhZ2VDdXRbMV0rJyAnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlICctJzpcclxuICAgICAgICBpZiAobWVzc2FnZUN1dFsyXS5pbmRleE9mKFwiIFwiKSA+IC0xKXtcclxuICAgICAgICAgIGlucHV0TmV3ID0gJ1wiJyttZXNzYWdlQ3V0WzJdKydcIicrJyAnO1xyXG4gICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgaW5wdXROZXcgPSBtZXNzYWdlQ3V0WzJdKycgJztcclxuICAgICAgICB9XHJcbiAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICBjb25zb2xlLmxvZyhcIm1lc3NhZ2UgdG8gY2hhdCBcIittZXNzYWdlKVxyXG4gICAgICAgIC8vdGhpcy5zZW5kTWVzc2FnZShtZXNzYWdlKTtcclxuICAgICAgICAvLyAgdGhpcy5hZ2VudElucHV0LnNlbmQoJ2FnZW50U29ja2V0Jywge3R5cGU6IFwic2VuZE1lc3NhZ2VcIiwgbWVzc2FnZTptZXNzYWdlfSk7XHJcbiAgICAgICAgLy8gIHRoaXMuY2F0Y2hUcmlwbGV0KG1lc3NhZ2Uuc2xpY2UoMCwtMSksIHRoaXMubmV0d29yayk7IC8vIEEgUkVNUExBQ0VSIFBBUiBDQVRDSFRSSVBMRVRTIFYyXHJcbiAgICAgICAgaW5wdXROZXcgPSBcIlwiO1xyXG4gICAgICAgIGlzVHJpcGxldCA9IGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc1RyaXBsZXQpe1xyXG4gICAgICAgIC8vICBjb25zb2xlLmxvZyhcImVzdCBUcmlwbGV0XCIsbWVzc2FnZUN1dClcclxuICAgICAgICByZXN1bHQudHlwZSA9IFwidHJpcGxldFwiO1xyXG4gICAgICAgIHZhciB0cmlwbGV0dmFsdWUgPSB7fTtcclxuICAgICAgICB0cmlwbGV0dmFsdWUuc3ViamVjdCA9IG1lc3NhZ2VDdXRbMF07XHJcbiAgICAgICAgdHJpcGxldHZhbHVlLnByZWRpY2F0ZSA9IG1lc3NhZ2VDdXRbMV07XHJcbiAgICAgICAgdHJpcGxldHZhbHVlLm9iamVjdCA9IG1lc3NhZ2VDdXRbMl07XHJcbiAgICAgICAgcmVzdWx0LnZhbHVlID0gdHJpcGxldHZhbHVlO1xyXG4gICAgICAgIHJlc3VsdC5pbnB1dE5ldyA9IGlucHV0TmV3O1xyXG4gICAgICB9ZWxzZSB7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKFwibidlc3QgcGFzIHRyaXBsZXRcIilcclxuICAgICAgICByZXN1bHQudHlwZSA9IFwibWVzc2FnZVwiO1xyXG4gICAgICAgIHJlc3VsdC52YWx1ZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgcmVzdWx0LmlucHV0TmV3ID0gaW5wdXROZXc7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vICBjb25zb2xlLmxvZyhyZXMpXHJcbiAgICAgIHRoaXMuc2hhZG93Um9vdC5nZXRFbGVtZW50QnlJZCgndHJpcGxlSW5wdXQnKS52YWx1ZSA9IHJlc3VsdC5pbnB1dE5ld1xyXG4gICAgICBpZiAocmVzdWx0LnR5cGUgPT0gXCJ0cmlwbGV0XCIpe1xyXG4gICAgICAgIC8vICB2YXIgdHJpcGxlID0gcmVzdWx0LnZhbHVlXHJcbiAgICAgICAgLy8gIHRoaXMudHJpcGxlcy5yZXZlcnNlKClcclxuICAgICAgICB0aGlzLnRyaXBsZXMgPSBbcmVzdWx0LnZhbHVlLCAuLi50aGlzLnRyaXBsZXNdXHJcbiAgICAgICAgLy8gIHRoaXMudHJpcGxlcy5yZXZlcnNlKClcclxuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnRyaXBsZXMpXHJcbiAgICAgICAgY29uc29sZS5sb2cocmVzdWx0KVxyXG4gICAgICAgIHRoaXMuYWdlbnQuc2VuZChcIkJyb3dzZXJcIiwge2FjdGlvbjogXCJhZGRUcmlwbGVcIiwgdHJpcGxlOiByZXN1bHQudmFsdWV9KVxyXG4gICAgICB9ZWxzZXtcclxuICAgICAgICBhbGVydCAoXCJUcmlwbGUgaXMgYW4gYXNzb2NpYXRpb24gb2YgdGhyZWUgd29yZHMgKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0KSAmIG11c3QgZW5kIHdpdGggJywnIG9yICc7JyBvciAnLicgb3IgJy0nIFwiKVxyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGtleWRvd24oZSl7XHJcbiAgICAgIGlmICggZS53aGljaCA9PT0gMTMgKSB7XHJcbiAgICAgICAgdGhpcy5hZGRfdHJpcGxlKClcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG5cclxuICAgIGZpcnN0VXBkYXRlZCgpe1xyXG4gICAgICB2YXIgYXBwID0gdGhpcztcclxuICAgICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuYWdlbnQpXHJcbiAgICAgIHRoaXMuYWdlbnQucmVjZWl2ZSA9IGZ1bmN0aW9uKGZyb20sIG1lc3NhZ2UpIHtcclxuICAgICAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgICAgIGlmIChtZXNzYWdlLmhhc093blByb3BlcnR5KFwiYWN0aW9uXCIpKXtcclxuICAgICAgICAgIC8vICBjb25zb2xlLmxvZyhtZXNzYWdlKVxyXG4gICAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICAgIGNhc2UgXCJ3ZWJJZENoYW5nZWRcIjpcclxuICAgICAgICAgICAgYXBwLndlYklkID0gbWVzc2FnZS53ZWJJZFxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJVbmtub3duIGFjdGlvbiBcIixtZXNzYWdlKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuICAgIH1cclxuXHJcblxyXG5cclxuICB9XHJcblxyXG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZSgnaW5wdXQtdmlldycsIElucHV0Vmlldyk7XHJcbiIsImltcG9ydCB7IExpdEVsZW1lbnQsIGh0bWwgfSBmcm9tICdsaXQtZWxlbWVudCc7XHJcbmltcG9ydCB7IEhlbGxvQWdlbnQgfSBmcm9tICcuLi9hZ2VudHMvaGVsbG8tYWdlbnQuanMnO1xyXG5cclxuY2xhc3MgTm9kZVZpZXcgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIGRlYnVnOiB7dHlwZTogQm9vbGVhbn0sXHJcbiAgICAgIG5vZGU6IHt0eXBlOiBPYmplY3R9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBzdXBlcigpO1xyXG4gICAgdGhpcy5uYW1lID0gXCJNb2RlbGVcIlxyXG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlXHJcbiAgICB0aGlzLm5vZGUgPSB7fVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XHJcbiAgICAke09iamVjdC5lbnRyaWVzKHRoaXMubm9kZSkubWFwKChba2V5LCB2YWx1ZV0sIGkpID0+XHJcbiAgICAgIGh0bWxgXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XHJcbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dCB0ZXh0LXByaW1hcnlcIiBpZD1cIiR7a2V5fVwiPiR7a2V5fTwvc3Bhbj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiICAgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiBwbGFjZWhvbGRlcj1cIiR7a2V5fVwiIGFyaWEtbGFiZWw9XCIke2tleX1cIlxyXG4gICAgICBhcmlhLWRlc2NyaWJlZGJ5PVwiJHtrZXl9XCJcclxuICAgICAga2V5PVwiJHtrZXl9XCJcclxuICAgICAgLnZhbHVlPVwiJHt2YWx1ZX1cIlxyXG4gICAgICBAY2hhbmdlPVwiJHt0aGlzLmNoYW5nZX1cIj5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIGBcclxuICAgICl9XHJcblxyXG4gICAgPGhyPlxyXG4gICAgPC9kaXY+XHJcblxyXG5cclxuICAgIDxkaXYgP2hpZGRlbiA9IFwiJHshdGhpcy5kZWJ1Z31cIj5cclxuICAgIDxocj5cclxuICAgIEhlbGxvIGZyb208Yj4ke3RoaXMubmFtZX08L2I+PGJyPlxyXG4gICAgZGVidWcgOiAke3RoaXMuZGVidWd9PGJyPlxyXG4gICAgbm9kZSA6XHJcbiAgICA8cHJlPiAke0pTT04uc3RyaW5naWZ5KHRoaXMubm9kZSwgdW5kZWZpbmVkLCAyKX08L3ByZT48YnI+XHJcbiAgICA8L2Rpdj5cclxuXHJcblxyXG4gICAgYDtcclxuICB9XHJcblxyXG4gIGNoYW5nZShlKXtcclxuICAgIGxldCBrZXkgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJrZXlcIilcclxuICAgIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlLnRyaW0oKVxyXG4gIC8vICBjb25zb2xlLmxvZyhcImNoYW5nZVwiLGtleSwgdmFsdWUpXHJcbiAgICB0aGlzLm5vZGVba2V5XSA9IHZhbHVlXHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLm5vZGUpXHJcbiAgICB0aGlzLmFnZW50LnNlbmQoXCJWaXNcIiwge2FjdGlvbjogXCJub2RlVXBkYXRlXCIsIG5vZGU6IHRoaXMubm9kZX0pXHJcbiAgfVxyXG5cclxuICAvKiAgaW5wdXQoZSl7XHJcbiAgPCEtLSAgQGlucHV0PVwiJHt0aGlzLmlucHV0fVwiLS0+XHJcbiAgbGV0IGtleSA9IGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImtleVwiKVxyXG4gIGxldCB2YWx1ZSA9IGUudGFyZ2V0LnZhbHVlLnRyaW0oKVxyXG4gIGNvbnNvbGUubG9nKFwiaW5wdXRcIixrZXksIHZhbHVlKVxyXG4gIGNvbnNvbGUubG9nKHRoaXMubm9kZSlcclxufSovXHJcblxyXG5maXJzdFVwZGF0ZWQoKXtcclxuICB2YXIgYXBwID0gdGhpcztcclxuICB0aGlzLmFnZW50ID0gbmV3IEhlbGxvQWdlbnQodGhpcy5uYW1lKTtcclxuICAvLyAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAvLyAgY29uc29sZS5sb2cobWVzc2FnZSlcclxuICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcImNvbmZpZ0NoYW5nZWRcIjpcclxuICAgICAgICBhcHAuY29uZmlnQ2hhbmdlZChtZXNzYWdlLmNvbmZpZylcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbmZpZ0NoYW5nZWQoY29uZmlnKXtcclxuICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xyXG4gIGNvbnNvbGUubG9nKHRoaXMuY29uZmlnKVxyXG59XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ25vZGUtdmlldycsIE5vZGVWaWV3KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5jbGFzcyBFZGdlVmlldyBleHRlbmRzIExpdEVsZW1lbnQge1xyXG5cclxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBuYW1lOiB7dHlwZTogU3RyaW5nfSxcclxuICAgICAgZGVidWc6IHt0eXBlOiBCb29sZWFufSxcclxuICAgICAgZWRnZToge3R5cGU6IE9iamVjdH1cclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIkVkZ2VcIlxyXG4gICAgdGhpcy5kZWJ1ZyA9IGZhbHNlXHJcbiAgICB0aGlzLmVkZ2UgPSB7fVxyXG4gIH1cclxuXHJcbiAgcmVuZGVyKCl7XHJcbiAgICByZXR1cm4gaHRtbGBcclxuICAgIDxsaW5rIGhyZWY9XCJjc3MvYm9vdHN0cmFwL2Jvb3RzdHJhcC5taW4uY3NzXCIgcmVsPVwic3R5bGVzaGVldFwiPlxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9mb250YXdlc29tZS9jc3MvYWxsLmNzc1wiIHJlbD1cInN0eWxlc2hlZXRcIj5cclxuXHJcbiAgICA8ZGl2IGNsYXNzPVwiY29udGFpbmVyLWZsdWlkXCI+XHJcbiAgICAke09iamVjdC5lbnRyaWVzKHRoaXMuZWRnZSkubWFwKChba2V5LCB2YWx1ZV0sIGkpID0+XHJcbiAgICAgIGh0bWxgXHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cCBtYi0zXCI+XHJcbiAgICAgIDxkaXYgY2xhc3M9XCJpbnB1dC1ncm91cC1wcmVwZW5kXCI+XHJcbiAgICAgIDxzcGFuIGNsYXNzPVwiaW5wdXQtZ3JvdXAtdGV4dFwiIGlkPVwiJHtrZXl9XCI+JHtrZXl9PC9zcGFuPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgICBjbGFzcz1cImZvcm0tY29udHJvbFwiIHBsYWNlaG9sZGVyPVwiJHtrZXl9XCIgYXJpYS1sYWJlbD1cIiR7a2V5fVwiXHJcbiAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCIke2tleX1cIlxyXG4gICAgICBrZXk9XCIke2tleX1cIlxyXG4gICAgICAudmFsdWU9XCIke3ZhbHVlfVwiXHJcbiAgICAgIEBjaGFuZ2U9XCIke3RoaXMuY2hhbmdlfVwiPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICAgYFxyXG4gICAgKX1cclxuICAgIDxocj5cclxuICAgIDwvZGl2PlxyXG5cclxuXHJcbiAgICA8ZGl2ID9oaWRkZW4gPSBcIiR7IXRoaXMuZGVidWd9XCI+XHJcbiAgICA8aHI+XHJcbiAgICBIZWxsbyBmcm9tPGI+JHt0aGlzLm5hbWV9PC9iPjxicj5cclxuICAgIGRlYnVnIDogJHt0aGlzLmRlYnVnfTxicj5cclxuICAgIGVkZ2UgOlxyXG4gICAgPHByZT4gJHtKU09OLnN0cmluZ2lmeSh0aGlzLmVkZ2UsIHVuZGVmaW5lZCwgMil9PC9wcmU+PGJyPlxyXG4gICAgPC9kaXY+XHJcblxyXG5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICBjaGFuZ2UoZSl7XHJcbiAgICBsZXQga2V5ID0gZS50YXJnZXQuZ2V0QXR0cmlidXRlKFwia2V5XCIpXHJcbiAgICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZS50cmltKClcclxuICAvLyAgY29uc29sZS5sb2coXCJjaGFuZ2VcIixrZXksIHZhbHVlKVxyXG4gICAgdGhpcy5lZGdlW2tleV0gPSB2YWx1ZVxyXG4gICAgY29uc29sZS5sb2codGhpcy5lZGdlKVxyXG4gICAgdGhpcy5hZ2VudC5zZW5kKFwiVmlzXCIsIHthY3Rpb246IFwiZWRnZVVwZGF0ZVwiLCBlZGdlOiB0aGlzLmVkZ2V9KVxyXG4gIH1cclxuXHJcbiAgLyogIGlucHV0KGUpe1xyXG4gIDwhLS0gIEBpbnB1dD1cIiR7dGhpcy5pbnB1dH1cIi0tPlxyXG4gIGxldCBrZXkgPSBlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJrZXlcIilcclxuICBsZXQgdmFsdWUgPSBlLnRhcmdldC52YWx1ZS50cmltKClcclxuICBjb25zb2xlLmxvZyhcImlucHV0XCIsa2V5LCB2YWx1ZSlcclxuICBjb25zb2xlLmxvZyh0aGlzLm5vZGUpXHJcbn0qL1xyXG5cclxuZmlyc3RVcGRhdGVkKCl7XHJcbiAgdmFyIGFwcCA9IHRoaXM7XHJcbiAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgY29uc29sZS5sb2codGhpcy5hZ2VudClcclxuICB0aGlzLmFnZW50LnJlY2VpdmUgPSBmdW5jdGlvbihmcm9tLCBtZXNzYWdlKSB7XHJcbiAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgaWYgKG1lc3NhZ2UuaGFzT3duUHJvcGVydHkoXCJhY3Rpb25cIikpe1xyXG4gICAgICAvLyAgY29uc29sZS5sb2cobWVzc2FnZSlcclxuICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBcImNvbmZpZ0NoYW5nZWRcIjpcclxuICAgICAgICBhcHAuY29uZmlnQ2hhbmdlZChtZXNzYWdlLmNvbmZpZylcclxuICAgICAgICBicmVhaztcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGNvbnNvbGUubG9nKFwiVW5rbm93biBhY3Rpb24gXCIsbWVzc2FnZSlcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH07XHJcbn1cclxuXHJcbmNvbmZpZ0NoYW5nZWQoY29uZmlnKXtcclxuICB0aGlzLmNvbmZpZyA9IGNvbmZpZ1xyXG4gIGNvbnNvbGUubG9nKHRoaXMuY29uZmlnKVxyXG59XHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2VkZ2UtdmlldycsIEVkZ2VWaWV3KTtcclxuIiwiaW1wb3J0IHsgTGl0RWxlbWVudCwgaHRtbCB9IGZyb20gJ2xpdC1lbGVtZW50JztcclxuaW1wb3J0IHsgSGVsbG9BZ2VudCB9IGZyb20gJy4uL2FnZW50cy9oZWxsby1hZ2VudC5qcyc7XHJcblxyXG5jbGFzcyBTZWxlY3RlZFZpZXcgZXh0ZW5kcyBMaXRFbGVtZW50IHtcclxuXHJcbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmFtZToge3R5cGU6IFN0cmluZ30sXHJcbiAgICAgIHNlbGVjdGVkX25vZGVzOiB7dHlwZTogQXJyYXl9LFxyXG4gICAgICBzZWxlY3RlZF9lZGdlczoge3R5cGU6IEFycmF5fSxcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBjb25zdHJ1Y3RvcigpIHtcclxuICAgIHN1cGVyKCk7XHJcbiAgICB0aGlzLm5hbWUgPSBcIlNlbGVjdGVkXCJcclxuICAgIHRoaXMuc2VsZWN0ZWRfbm9kZXMgPSBbXVxyXG4gICAgdGhpcy5zZWxlY3RlZF9lZGdlcyA9IFtdXHJcbiAgfVxyXG5cclxuICByZW5kZXIoKXtcclxuICAgIHJldHVybiBodG1sYFxyXG4gICAgPGxpbmsgaHJlZj1cImNzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3NcIiByZWw9XCJzdHlsZXNoZWV0XCI+XHJcblxyXG4gICAgPGRpdiA/aGlkZGVuPVwiJHt0aGlzLnNlbGVjdGVkX25vZGVzLmxlbmd0aCA9PSAwfVwiPlxyXG4gICAgPGhyPlxyXG4gICAgPGI+JHt0aGlzLnNlbGVjdGVkX25vZGVzLmxlbmd0aH0gbm9kZXMuPC9iPlxyXG4gICAgPGhyPlxyXG4gICAgJHt0aGlzLnNlbGVjdGVkX25vZGVzLm1hcCgobiwgaSkgPT5cclxuICAgICAgaHRtbGBcclxuICAgICAgPG5vZGUtdmlldyBuYW1lPVwiJHsnTm9kZV8nK2l9XCIgLm5vZGU9XCIke259XCI+PC9ub2RlLXZpZXc+XHJcbiAgICAgIGBcclxuICAgICl9XHJcbiAgICA8L2Rpdj5cclxuXHJcbiAgICA8ZGl2ID9oaWRkZW49XCIke3RoaXMuc2VsZWN0ZWRfZWRnZXMubGVuZ3RoID09IDB9XCI+XHJcbiAgICA8aHI+XHJcbiAgICA8Yj4ke3RoaXMuc2VsZWN0ZWRfZWRnZXMubGVuZ3RofSBlZGdlcy48L2I+XHJcbiAgICA8aHI+XHJcbiAgICAke3RoaXMuc2VsZWN0ZWRfZWRnZXMubWFwKChlLCBpKSA9PlxyXG4gICAgICBodG1sYFxyXG4gICAgICA8ZWRnZS12aWV3IG5hbWU9XCIkeydFZGdlXycraX1cIiAuZWRnZT1cIiR7ZX1cIj48L2VkZ2Utdmlldz5cclxuICAgICAgYFxyXG4gICAgKX1cclxuICAgIDwvZGl2PlxyXG5cclxuICAgIGA7XHJcbiAgfVxyXG5cclxuICBmaXJzdFVwZGF0ZWQoKXtcclxuICAgIHZhciBhcHAgPSB0aGlzO1xyXG4gICAgdGhpcy5hZ2VudCA9IG5ldyBIZWxsb0FnZW50KHRoaXMubmFtZSk7XHJcbiAgICBjb25zb2xlLmxvZyh0aGlzLmFnZW50KVxyXG4gICAgdGhpcy5hZ2VudC5yZWNlaXZlID0gZnVuY3Rpb24oZnJvbSwgbWVzc2FnZSkge1xyXG4gICAgICAvLyAgY29uc29sZS5sb2coXCJtZXNzYWhcIixtZXNzYWdlKVxyXG4gICAgICBpZiAobWVzc2FnZS5oYXNPd25Qcm9wZXJ0eShcImFjdGlvblwiKSl7XHJcbiAgICAgICAgLy8gIGNvbnNvbGUubG9nKG1lc3NhZ2UpXHJcbiAgICAgICAgc3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcbiAgICAgICAgICBjYXNlIFwic2VsZWN0ZWRDaGFuZ2VkXCI6XHJcbiAgICAgICAgICBhcHAuc2VsZWN0ZWRfbm9kZXMgPSBtZXNzYWdlLm5vZGVzXHJcbiAgICAgICAgICBhcHAuc2VsZWN0ZWRfZWRnZXMgPSBtZXNzYWdlLmVkZ2VzXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gYWN0aW9uIFwiLG1lc3NhZ2UpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcblxyXG59XHJcblxyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3NlbGVjdGVkLXZpZXcnLCBTZWxlY3RlZFZpZXcpO1xyXG4iLCIvL0dFTkVSQUxcclxuaW1wb3J0ICcuL2Nzcy9ib290c3RyYXAvYm9vdHN0cmFwLm1pbi5jc3MnO1xyXG5pbXBvcnQgJy4vc3R5bGVzLmNzcyc7XHJcblxyXG4vL0FQUFxyXG5pbXBvcnQgJy4vdmlld3MvYXBwLXZpZXcuanMnO1xyXG5pbXBvcnQgJy4vdmlld3MvbG9naW4tZWxlbWVudC5qcyc7XHJcblxyXG4vL1ZJU1xyXG5pbXBvcnQgJy4vdmlld3MvdmlzLXZpZXcuanMnO1xyXG5pbXBvcnQgJy4vdmlld3MvYnJvd3Nlci12aWV3LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL2lucHV0LXZpZXcuanMnO1xyXG5pbXBvcnQgJy4vdmlld3Mvbm9kZS12aWV3LmpzJztcclxuaW1wb3J0ICcuL3ZpZXdzL2VkZ2Utdmlldy5qcyc7XHJcbmltcG9ydCAnLi92aWV3cy9zZWxlY3RlZC12aWV3LmpzJztcclxuXHJcbi8vaW1wb3J0ICcuL3ZpZXdzL3Zpcy10b29sLXZpZXcuanMnO1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///107\n")}]);